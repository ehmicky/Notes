
                                  ┏━━━━━━━━━━━━━━━━━━━┓
                                  ┃   BASH_SYNTHESE   ┃
                                  ┗━━━━━━━━━━━━━━━━━━━┛

                                  ┌─────────────────┐
                                  │   GENERALITES   │
                                  └─────────────────┘

[VAR=VAL[ VAR=VAL]...]  #Exécute FILE comme un script, bash s'il y a le shabang
bash FILE               #bash au début. Si FILE est dans le répertoire courant,
[VAR=VAL[ VAR=VAL]...]  #et que le répertoire courant n'est pas dans $PATH, FILE
FILE                    #ne peut être invoquée sous la seconde forme que précédé
                        #de ./
                        #FILE doit être exécutable sous la seconde forme, et
                        #lisible sous la première.
                        #Toute VAR déclarées en préfixant VAR=VAL fait partie de
                        #de l'environment de FILE.
                        #Marche aussi sur une commande externe.
bash -c STRING          #Exécute STRING.
bash -s                 #Exécute stdin

BASH UTILISE ==>        #Le Bash utilisé par chaque user est défini dans
                        #/etc/passwd. bash, sh, etc. tapé dans un terminal
                        #bascule le shell utilisé.

BUILTINS OU COMMANDE    #Bash est composé de mots-clef comme { }, etc. et de
EXTERNE  ==>            #commandes builtins (ou primitives), comme echo ou test.
                        #Tout est stocké dans /bin/bash.
                        #Il est cependant possible de faire appel à des
                        #commandes externes, comme cp ou find, qui seront alors
                        #stockées n'importe où (exemple : /usr/bin/locale).
                        #Les builtins, contrairement aux commandes externes, ne
                        #forkent pas. Elles sont ainsi plus rapides
                        #L'utilisation de built-ins aux dépens de commandes
                        #externes, même aux dépens de la longueur ou simplicité
                        #du code, améliore souvent beaucoup les performances,
                        #parfois jusqu'à un facteur 100, donc essayer de faire
                        #du full-bash autant que possible !
                        #De nombreux builtins sont disponibles néanmoins en
                        #tant que commandes externes dans /bin
                        #Ce document ne fait jamais intervenir de commandes
                        #externes (ou le précise) : il est full-bash
                        #Voir la doc pour les builtins restants

SHELL INTERACTIF        #Un shell est interactif lorsque tout son input
     OU NON ==>         #provient de l'utilisateur (le cas d'une console)

#!/bin/bash             #"Shebang" En debut de script, indique le bash utilise.
#! /bin/bash            #Préférer la première version.
# COMMENTS              #Commentaires (#doit etre precede d'un whiteline)
: <<STRING
COMMENTS                #Commentaires places grace a un here document
STRING                  #redirigeant vers true. Evite de retaper le #.

; ET NEWLINE ==>        #Une ligne de commande se termine par une newline ou un
                        #point-virgule. Il est donc necessaire quand un script
                        #tient sur une seule ligne (par exemple dans une
                        #console ) de separer avec un ; ou d'echapper la
                        #newline en tapant \ puis entree.

IFS ==>                 #La variable IFS exécute le "word splitting". Ce dernier
                        #divise en plusieurs tokens le résultat :
                        #  - d'une parameter expansion (dont $VAR)
                        #  - d'une arithmétique expansion $(( )) et $[ ]
                        #  - d'une commande substitution $( ) et ` `
                        #et ce en fonction des diviseurs présent, caractère par
                        #caractère, au sein d'$IFS (par défaut $' \t\n')
                        #Pour le changer, ne pas oublier de le sauvegarder et
                        #de le remettre.

\                       #echappe le caractère suivant
''                      #echappe tout sauf ' (l'échapper avec '\''). Les
                        #trailing backslashs deviennent des backslashs littéraux
""                      #echappe tout, dont :
                        #  - globbing
                        #  - les whitespaces
                        #  - '
                        #  - <(COMMANDES) et >(COMMANDES)
                        #  - ~
                        #  - {0..9} et {1,2}
                        #sauf :
                        #  - `COMMANDES`
                        #  - toute expansion commençant par $ :
                        #    - $VAR
                        #    - $1
                        #    - ${ARR[@]}
                        #    - ${#VAR}
                        #    - ${VARPATTERN}
                        #    - ${VAR:-STRING}
                        #    - $(( ))
                        #    - $[ ]
                        #    - $(COMMANDES)
                        #    - etc.
                        #  - "
                        #  - ! non suivi d'un whitespace
                        #  - \ suivi de ` $ \ " ou newline (trailing backslash
                        #    supprimé)
                        #Des doubles guillemets au sein d'un ${ } ou d'un $( )
                        #ne referment pas les guillemets précédentes (s'il y en
                        #a), mais en ouvrent d'autres, nested.

$'MESSAGE'              #permet d'utiliser toutes les sequences d'echappement
                        #(voir doc). \c est interprété comme \cCHAR ou, seul,
                        #comme un backslash n'échappant pas les newlines. Null
                        #Arrête la string.
                        #Les guillemets sont simples, non doubles
$"STR"                  #Equivaut à "$(gettext "STR")" : cf gettext

$RANDOM                 #renvoie un nombre pseudo-aleatoire (entre 0 et 32767)

command_not_found_      #Fonction exécutée lors de l'invocation d'un programme inconnue. Peut être redéfini.
handle                  #Par défaut : sleep 2; echo "$1: command not found"

LIMITE DU NOMBRE        #Attention, car une ligne de commande ne peut pas
D'ARGUMENTS SUR UNE     #excéder un certain nombre d'octets. Celui-ci peut être
LIGNE DE COMMANDE ==>   #retrouvé grâce à getconf ARG_MAX. Cette limite est
                        #propre au noyau, et est de 128 Ko la plupart du temps.
                        #C'est la seule limite existante.
                        #Ainsi, un * peut faire référence à une myriade de
                        #fichiers et faire planter une commande par exemple :
                        #préférer donc faire une exécution par fichier dans
                        #une boucle, qu'une exécution pour plusieurs fichiers.

FORMAT DES NOMBRES ==>  #Ils sont comme des signed long long int :
                        #  - entiers : les floats sont tronqués
                        #  - avec overflow, deviennent 0
                        #  - peuvent être négatifs

                                  ┌───────────────────────────────────────────────┐
                                  │   DECLARATION ET DEFERENCEMENT DE VARIABLES   │
                                  └───────────────────────────────────────────────┘

VAR="2"                 #Declaration de variable. Jamais d'espace autour de =
declare VAR1="VALEUR1"  #sauf entre (( )) et avec let. Les variables (a moins
"VAR2=VAL2" "VAR3=VAL3" #d'utiliser declare) sont toutes des strings utilisees
set VAR="VALEUR"        #differemment selon le contexte. Par convention mettre
                        #les variables globales en majuscule, et locales en
                        #minuscule. Seules les lettres, chiffres (pas en debut
                        #de nom) et _ sont autorises dans les noms de variables
VAR_PATH="/home/user/"  #utile pour ne pas avoir a retaper un chemin partiel
                        #ou un fichier et son chemin
VAR=VAL[, VAR2=VAL2]... #Il est possible de mettre plusieurs déclarations à la
VAR=VAL[ VAR2=VAL2]...  #suite sur la même ligne ainsi.

typeset
set                     #Affiches toutes les variables declarees (dont
declare                 #environment variables)
declare -p              #Même chose, mais imprime le type avec.
declare -f              #Même chose, mais seulement pour les fonctions et leur
                        #définition.
declare -f              #Même chose, mais seulement pour les fonctions, sans
                        #leur définition.
declare -p VAR          #Affiche le type et la valeur de la variable (sauf s'il
                        #s'agit d'une fonction)
declare -F FONC_VAR     #Imprime FONC_VAR si FONC_VAR a été déclaré.

typeset                 #synonyme de declare, mais déprécié
declare -a VAR          #type une variable en tant qu'array non-associative
declare -A VAR          #type une variable en tant qu'array associative

declare -f VAR          #type une variable en tant que fonction. Si elle existe
                        #déjà, affiche cette fonction et sa définition.
declare -i VAR          #type une variable en tant qu'integer. Les valeurs qui
                        #lui seront assignées seront toujours évaluées
                        #arithmétiquement

declare -r VAR
readonly VAR            #rend une variable read-only
readonly -a VAR         #Type une variable comme array non-associative read-only
readonly -A VAR         #Type une variable comme array associative read-only
readonly -f VAR         #Type une variable comme fonction read-only
readonly -p             #Imprime une liste de toutes les read-only variables

declare -t FUNC         #La fonction héritera des traps RETURN et DEBUG du shell
                        #parent.

declare -l VAR          #la variable ne pourra contenir que des caractères
                        #lowercase (il est possible de lui assigner des
                        #uppercase mais ils sont automatiquement convertis)
declare -u VAR          #Même chose, mais en uppercase
declare -c VAR          #le premier caractère de la variable sera toujours
                        #uppercase et les suivants lowercase (même remarque que
                        #précédemment pour la conversion et l'assignation)

declare +a VAR          #enleve le typage Array. Meme chose pour +f,+i,+p,etc.
declare -a VAR="VALEUR" #il est possible d'assigner une valeur avec declare
                        #mais reduit la portee d'une variable a l'interieur
                        #d'une fonction

$VAR                    #utiliser la valeur d'une variable. ne pas oublier $
${VAR}                  #meme chose. parfois pour eviter une ambiguite. Ex :
                        #VAR=${VAR}2 pour ajouter un 2 a la fin de $VAR. $VAR2
                        #echouerait
"$VAR"                  #cette version doesn't squeeze multiple whitespaces
                        #into single ones as $VAR does. De plus, contrairement à
                        #$VAR, les nulls sont conservés. Ainsi echo -e "\0"
                        #imprime un null contrairement à echo -e \0 ou à echo -e
                        #$'\0'

POINTEUR="VALEUR"       #reference indirect : fait reference a la valeur de la
VAR="POINTEUR"          #valeur d'une VAR. Ici, \$$VAR signifie $POINTEUR soit
eval "VAR=\$$VAR"       #VALEUR. $$VAR est une erreur de syntaxe. Sans eval,
(ou eval eval "VR=$VR") #VAR deviendrait "$POINTEUR" et non "VALEUR".
${!VAR}                 #Est equivalent a \$$VAR mais mieux car il n'a pas
                        #besoin d'eval pour eviter de renvoyer "$POINTEUR" :
                        #il renvoie toujours "VALEUR"
POINTEUR2="VALEUR"
POINTEUR1="POINTEUR2"
VAR="POINTEUR1"
eval "VAR=\$$VAR"
eval "VAR=\$$VAR"       #On peut multiplier les references indirectes

$_                      #dernier argument utilise

NULL ==>                #Null et "" sont la meme chose

unset VAR               #Remplace la valeur de VAR par une chaine vide.
VAR=""                  #Most of time, une variable qui n'existe pas, egal a
VAR=                    #"" ou a null are the same (exception pour les arrays)
                        #La variable reste declaree
unset -f VAR            #Ne marche que sur les fonctions.
unset -v VAR            #Ne marche que sur les variables.

                                  ┌────────────┐
                                  │   ARRAYS   │
                                  └────────────┘

NULL ET ARRAYS ==>      #Un null dans une array est tout de meme un element

ASSOCIATIVE ARRAYS ==>  #Il est possible d'utiliser des STRINGS comme index : on
declare -A ARR  ==>     #parle alors d'associative arrays.
                        #Il faut auparavant obligatoirement les déclarer avec
                        #declare -A ARR
                        #Elles s'utilisent de la même manière, sauf que la forme
                        #ARR=( ... ) est prohibée. Seul ARR[INDEX]="VALEUR" est
                        #possible pour modifier ou ajouter des valeurs.
                        #Le reste est identique
                        #Il s'agit d'une fonction de Bash 4

ARR=( "VALEUR" ... )    #declaration d'array. Ce qui sépare les différentes
                        #VALEUR d'une array lors de l'affectation est un espace
                        #non échappé (guillemets ou backslash)
ARR=( [N1]="VAL1"... )  #permet d'assigner un index customisé a chaque variable
ARR=( $VAR )            #Si $VAR est une chaine de mots separes par des espaces
                        #(par exemple "$@"), transforme cette chaine en array
                        #ARR. Attention : pas de guillemets
ARR1=( ${ARR2[@]} )     #Il est possible de copier une array ainsi
ARRAY1=( ${ARRAY2[@]}
${ARRAY3[@]} )          #concatene deux arrays
ARR+=( VAL )            #ajoute une valeur a la fin de l'array. Ne marche pas
                        #avec les arrays associatives. VAL peut être une suite
                        #de VAL ou de ${arr[@]}, etc.

ARR[INDEX]="VALEUR"     #modification d'une valeur. L'index commence a 0. Il est
                        #possible de creer une array ainsi quel que soit INDEX
                        #(comble les valeurs precedentes par des null).
unset ARR[INDEX]        #supprime complètement une valeur de l'array

${ARR[INDEX]}           #renvoit la valeur de l'array a tel index. $ARR[INDEX]
                        #ne marche pas.
${${ARR[* ou INDEX]}}
    ==> ERREUR          #mauvaise syntaxe. utiliser ${VAR[* ou INDEX]}

"${ARR[@]}"             #renvoit l'ensemble des valeurs de ARR, séparés les
                        #unes des autres par un espace non échappé (il s'agit
                        #donc d'une suite de STRINGS et non d'une seule
                        #STRING). Les valeurs ne sont pas splittées.
                        #$ARR et ${ARR} équivalent à ${ARR[0]}
                        #Utile dans les boucles for : for VAR in "${ARR[@]}"
"${ARR[*]}"
${ARR[*]}               #Comme ce qui précède, mais avec les mêmes différences
${ARR[@]}               #que celles entre "$*", $* et $@ (voir ces derniers)

"${!ARR[@]}"
"${!ARR[*]}"
${!ARR[*]}              #même chose mais renvoie l'ensemble des indexs, et non
${!ARR[@]}              #des valeurs

${#ARR[*]}
${#ARR[@]}              #renvoie le nombre de valeurs de l'array

VARIABLES UTILISEES     #Si une variable est utilisee dans une operation prevue
COMME ARRAYS ==>        #pour les arrays, elle ne renvoie pas d'erreur et est
                        #consideree comme une array a un seul element. Ex :
                        #"${#VAR[@]}" renvoie "1".

ARR[INDX]="VAL" || echo #certains shells bashs ne supportent pas les arrays.
"Array non supporte"    #ceci est un test de validation.

MULTIDIMENSIONNAL ARRAYS#Pas supportées, mais on peut utiliser des arrays associatives pour simuler :
 ==>                    #  - declare -A Matrice
                        #    Matrice[3;5]=VAL
                        #    echo ${Matrice[$a;$b]}

                                  ┌────────────────────────────┐
                                  │   ARGUMENTS POSITIONNELS   │
                                  └────────────────────────────┘

ARGUMENTS NULL ==>      #Il est possible de passer des arguments null

$0                      #nom/chemin du script lui-meme (ex: "./scrip.sh") tel
                        #qu'il a été invoqué. Renvoie "bash" dans un login
                        #ou interactive shell. Plus user-friendly :
                        #  - $(basename $0) ou $(basename $0 .sh)
$1, $2, etc.            #arguments utilisés.
${10},${11},etc.        #correcte notation apres $9 mais fonctionne aussi avant

$#
${#*}
${#@}                   #nombre d'arguments (sauf $0)
${!#}                   #dernier argument positionnel

"$*"                    #renvoie l'ensemble des arguments en échappant tous les
                        #les IFS, l'ensemble étant alors considéré comme une
                        #seule STRING
$*                      #Renvoie l'ensemble des arguments en n'échappant aucun
$@                      #IFS, que ce soit entre les arguments ou en leur sein.
                        #Les arguments sont ainsi considérés comme des STRINGS
                        #séparés, mais les arguments contenant en leur sein un
                        #IFS seront splittés.
"$@"                    #Renvoie l'ensemble des arguments en échappant les IFS
                        #au sein des arguments, mais pas entre eux. Ainsi, ils
                        #ne sont pas splittés, mais sont considérés comme des
                        #STRINGS séparés
                        #Préférer cette syntaxe

${$* etc.
${$@ etc.               #Cette structure est erronee, il faut utiliser ${*, ${@
${$1, ${$2 etc. ==> ERR #et ${index etc. a la place

shift N                 #shift la liste d'arguments de N vers la gauche. Utile
                        #par exemple dans une boucle while (( $# )) qui est
                        #Renvoie true si $# != 0

set -- [STRING...]      #Les arguments sont remplacés par STRING...
                        #Penser a les sauvegarder donc si l'on veut les
                        #reutiliser.
                        #Si STRING est absent, supprime donc les arguments.

COMMANDE -- ...         #End of options flag : tout ce qui suit -- est un
                        #argument et non une option, même s'il commence par un
                        #tiret. Ne marche pas avec toutes les commandes (par
                        #exemple echo)

while getopts ...       #Utiliser getopts pour procéder les options (voir doc)

                                  ┌───────────────┐
                                  │   FONCTIONS   │
                                  └───────────────┘

NOM () {                #declare une fonction. $1 $2 etc. sont updates en
  COMMANDES             #fonction des parametres passes en appelant la
}                       #$0 reste inchange cependant. ${FUNCNAME[0]} (ou
function NOM {          #$FUNCNAME) enregistre le nom de la fonction courante,
  COMMANDES             #${FUNCNAME[1]} celui de la fonction ayant appelé cette
}                       #fonction, etc. Il est possible de passer des arguments
function NOM () {       #null.
  COMMANDES             #Preferer la première syntaxe. Il peut etre interessant
}                       #de redefinir une fonction ou de la definir
                        #differemment en fonction d'une condition. Une fonction
                        #peut etre récursive. Les arguments positionnels restent
                        #locaux, mais pas les variables, auquel il faut donc
                        #penser à apposer le keyword "local"
                        #Une fonction peut aussi être une collapsing function,
                        #c'est-à-dire qu'elle refait une définition
                        #(déclaration) d'elle-même, au sein d'elle-même. La
                        #nouvelle définition de la fonction ne sera lue qu'à
                        #la prochaîne exécution de la fonction
                        #Les noms de fonctions ne sont pas techniquement des
                        #variables : il est possible d'assigner une variable et
                        #une fonction avec le même nom.
                        #{ COMMANDES } peut aussi être non un bloc { } mais
                        #une structure ou boucle (mais pas une commande simple)
function NOM () {       #Mettre un ; avant et après le second crochet si le tout
COMMANDES ; } ;         #tient sur une seule ligne
return [NOMBRE]         #return est l'"exit" des fonctions et des fichiers
                        #sources. NOMBRE est 0 par défaut. Une fonction fait un
                        #return 0 à la fin de son exécution.

local VAR               #rend locale la portee d'une VAR. Utilisee dans les
local VAR=VALEUR        #fonctions uniquement, notamment les recursions, pour
typeset VAR             #que chaque boucle recursive n'ecrase pas la VAR de la
typeset VAR=VALEUR      #boucle precedente (principalement si des COMMANDES
declare VAR             #sont effectues apres la fin de chaque boucle recursive
declare VAR=VALEUR      #a l'aide de la VAR conservee et propre a cette boucle

caller [NOMBRE]         #A l'intérieur d'une fonction ou d'un fichier sourcé,
                        #affiche :
                        #  - le numéro de ligne
                        #  - le nom de la fonction (ou "main" s'il ne s'agit
                        #    pas d'une fonction)
                        #  - le nom du fichier
                        #depuis laquelle a été lancée cette fonction, ou sourcé
                        #ce fichier, en remontant dans l'arborescence NOMBRE
                        #fois (par défaut 0)
                        #Si NOMBRE n'est pas précisé, n'affiche pas le nom de
                        #la fonction (ou "main")

{                       #"fonction" anonyme. Permet les redirections du bloc
  COMMANDES             #entier et son utilisation comme une seule COMMANDES
}                       #(pipeline).
                        #Les COMMANDES sont exécutées immédiatement. On ne peut
                        #pas rendre la portée des variables locale, ni utiliser
                        #return ou caller.
                        #Un whitespace doit séparer { de COMMANDES

                                  ┌───────────────────────────────┐
                                  │   SUBSTITUTION DE COMMANDES   │
                                  └───────────────────────────────┘

`COMMANDES`             #Renvoie le resultat d'une commande. Si des $IFS sont
                        #presents, ils coupent le resultat en plusieurs chaines
                        #COMMANDES peut meme etre un loop, etc.
                        #Remplace les newlines par des espaces.
                        #Attention : lance un sub-shell
                        #Il est possible de lancer un autre langage ainsi et
                        #d'en avoir le resultat. Ex : `python script.py`
$( COMMANDES )          #meme chose, mais meilleure syntaxe. Permet :
                        #  - des nested structures (peut être fait avec ` `,
                        #    mais ils doivent être échappés
                        #  - de mieux prendre en charge les séquences
                        #    d'échappement backslash lorsqu'entouré de double
                        #    guillemets. Ex: "`echo -e 1\\\\n2`" peut être écrit
                        #    "$(echo -e 1\\n2)"
eval "COMMANDES"        #Execute "COMMANDES" (qui peut donc venir de
                        #l'expansion d'une $VAR), sans rien renvoyer.
                        #En général obsolète, sauf quelques cas, par exemple
                        #forcer l'expansion de la valeur contenue dans les
                        #variables contenues dans COMMANDES. Exemple :
                        #  - var="'un deux'" ; echo "$var" --> 'un deux'
                        #  - var="'un deux'" ; eval 'echo "$var"' --> un deux

                                  ┌───────────┐
                                  │   TESTS   │
                                  └───────────┘

TEST ==>                #Voici les valeurs possibles de TEST :

[ OPERATION LOG. ]
test OPERATION LOG.
[[ OPERATION LOG. ]]    #Voir plus bas

let 'OPERATIONS
ARITHMETIQUES'
(( OPERATIONS
ARITHMETIQUES ))        #voir plus bas

COMMANDES               #le test execute Then si la commande reussit (exit code
                        #de 0)
FONCTION                #vrai si la fonction retourne un exit code de 0

true                    #Renvoie toujours 0. exemple : while true etc.
:                       #Ne marche qu'en dehors d'une structure de test ( [ ]
                        #[[ ]] (( )) ou autres)
                        #A noter que : > "FILE" vide un fichier a 0 bits sans
                        #pour autant le supprimer ou en changer les permissions
false                   #renvoit toujours faux
                        #Ne marche qu'en dehors d'une structure de test ( [ ]
                        #[[ ]] (( )) ou autres)
: COMMANDES             #Renvoient toujours vrai (ou faux) même si COMMANDES
true COMMANDES          #contient des erreurs (et n'affiche pas ces erreurs)
false COMMANDES         #Ainsi :
                        #  - : $(( OPER. ARI )) exécute OPER. ARI, mais n'envoie
                        #    pas de message d'erreur (car il n'y a pas de
                        #    commande à proprement parler)

OPERATIONS BOOL. ==>    #Un TEST peut aussi être la combinaison de deux TEST :

TEST && TEST            #Et logique entre deux tests
TEST || TEST            #Ou logique entre deux tests
! TEST                  #Non logique sur un test
( TEST... )             #La valeur logique des TEST... liés entre eux par des
                        #&&, || et ! est calculée prioritairement

CALCUL DE LA VALEUR     #La valeur logique se calcule de gauche à droite, en
LOGIQUE ==>             #commençant par calculer les parenthèses. Exemple :
                        #  - true && false || ! ( true && true )
                        #  --> true && false || ! ( true )
                        #  --> true && false || false
                        #  --> false || false
                        #  --> false

! && et || à l'intérieur#! && et || peuvent être placés à l'intérieur même d'un
même d'un TEST ==>     #(( )), d'un [[ ]] ou d'un [ ] sous la forme par
                        #exemple :
                        #  - (( OPERATION ARI. || OPERATION ARI. && ... ))
                        #  - [[ ! OPERATION LOG. || OPERATION LOG. ]]
                        #  - etc.
                        #Cependant, [ ] n'accepte que !, car && et || sont
                        #nommés -a et -o :
                        #  - [ OPERATION LOG. -a OPERATION LOG. -o ... ]
                        #De plus, (( )) accepte & et | comme équivalent de && et
                        #de ||, mais ceux-ci sont dépréciés
(( OPER1 , OPER2 ))     #A l'intérieur de ces structures pour opérations
$(( OPER1 , OPER2 ))    #arithmétiques, OPER2 sera exécutée quelle que soit la
$[ OPER1 , OPER2 ]      #valeur logique de OPER1, et seul la valeur logique
let'OPER1 , OPER2'      #d'OPER2 sera renvoyée

ET-CHAINES ET           #Les syntaxes suivantes permettent de se passer de
OU-CHAINES ==>          #structures et de boucles pour utiliser un TEST.

TEST... && COMMANDES    #execute COMMANDES entre parentheses si la valeur des
                        #TEST... précédents est vraie
TEST... || COMMANDES    #execute COMMANDES entre parentheses si la valeurs des
                        #TEST... précédents est fausse

CMAND && CMAND && CMAND #execute chaque COMMANDE a condition que la precedente
&& etc.                 #reussisse (quel que soit l'état de toutes celles
                        #précédant la précédente)
CMAND || CMAND || CMAND #execute chaque COMMANDE a condition que la precedente
|| etc.                 #echoue (même chose)

CMAND1 && CMAND2 ||
CMAND3 && TEST || CMND4 #Exemple de structure complexe

                                  ┌──────────────────────────────┐
                                  │   OPERATIONS ARITHMETIQUES   │
                                  └──────────────────────────────┘

$VAR DANS LES OPERATIONS#Il n'est pas necessaire d'ajouter un $ devant VAR pour
ARITHMETIQUES ==>       #la substituer, c'est même non recommandé

STRING DANS LES
OPERATIONS ARI. ==>     #Les STRINGS ont une valeur de 0

CHIFFRES DECIMAUX == >  #Bash ne comprend pas . ou , et tout nombre est
                        #directement tronqué

`expr OPERATION ARI.`   #Renvoie le resultat d'une operation arithmetique (dont
$( expr OPERATION ARI. )#comparaisons et operations booleennes). 0 = faux, 1 =
                        #vrai. Les declarations ne sont pas effectuees.
                        #Preferer (( )) et let.
                        #expr est une commande externe

$[ OPERATION ARI. ]     #Effectue et renvoie le resultat d'une operation
                        #arithmetique (ce qui inclue les comparaisons et
                        #operations booleennes). 0 = faux et 1 = vrai
                        #(ne pas confondre avec les exit codes)
                        #Les declarations de variables telles $[VAR = VAR+1] ou
                        #$[VAR++] sont opérées. Elles ne sont qu'arithmetiques,
                        #il n'est par exemple pas possible d'assigner une
                        #"STRING" à une VAR. Elles viennent en dernier dans
                        #l'ordre d'enchainement des opérations arithmétiques
                        #Respecter les espaces autour de [ ]
let 'OPERATION ARI.'    #Comme $[ ] mais a une valeur de TEST egalement.
(( OPERATION ARI.))     #Prefere a $[ ]. Exemple : if (( VAR < 5 )). Autre
                        #Même chose pour les déclarations.
                        #Respecter les espaces autour de (( ))
$(( OPERATION ARI. ))   #Seul moyen (avec let 'VAR = (( OPERATION ARI. ))') de
                        #renvoyer le resultat de (( OPERATION ARI. )). Ce
                        #résultat est celui de l'operation, de la variable
                        #déclarée ou bien 1(vrai) ou 0(faux) s'il s'agit d'une
                        #comparaison ou d'une operation booleenne)
                        #Effectue l'opération arithmétique, de même que (( ))
: $(( OPERATION ARI. )) #Equivalent de (( )) pour toutes les situations, mais
                        #plus portable

OPERATION ARI. ==>      #Voici la liste de ce que peut contenir une OPERATION
                        #ARI. :

+ - * /                 #arithmetique de base. VAR=VAR+1 concatene seulement
                        #"+1" a la fin de VAR. pour declarer une variable en
                        #utilisant des operations arithmetiques, il faut
                        #utiliser les formes : VAR=$[VAR+1], (( VAR = VAR+1 ))
                        #ou let 'VAR = VAR+1'
%                       #modulo
**                      #puissance

VAR++ VAR--             #post-incrementation. Utiliser $[ ] let ou (( ))
++VAR --VAR             #pre-incrementation.
+= -= *= /= %=          #declaration arithmetique. meme remarque.

< <= > >= ==            #comparaisons
== !=                   #egal et inegal

<<                      #bitwise left shift
<<=                     #bitwise left-shift-equal
>>                      #bitwise right shift
>>=                     #bitwise right-shift-equal
&                       #bitwise AND
&=                      #bitwise AND-equal
|                       #bitwise OR
|=                      #bitwise OR-equal
~                       #bitwise NOT
^                       #bitwise XOR
^=                      #bitwise XOR-equal

0NOMBRE                 #nombre octal (considere comme une operation
                        #arithmetique : utiliser donc les bonnes structures)
                        #Sera toujours imprimé et lu en octal
0xNOMBRE                #nombre hexadecimal. Sera toujours imprimé et lu en
                        #hexadécimal
2#NOMBRE                #nombre lu comme binaire (le $ est obligatoire même
2#$VAR                  #entre (( )) ) (mais ne pourra être affiché qu'en
                        #décimal)
N#NOMBRE                #nombre lu comme étant de base N (mais ne pourra être
N#$VAR                  #affiché qu'en décimal)
$(( N#NOMBRE ))         #renvoie NOMBRE, base N, converti en décimal

OPER1 ARI. ? OPER2 ARI. #Renvoie OPER2. ARI si OPER1 ARI. est vraie, sinon
: OPER3 ARI.            #renvoie OPER3. ARI. C'est une construction trinaire
                        #C-style

                                  ┌───────────────────────┐
                                  │   OPERATION LOGIQUE   │
                                  └───────────────────────┘

[ OPERATION LOG. ]      #Effectue un TEST en fonction de l'OPERATION LOG.
test OPERATION LOG.     #la commande test et [ ] sont equivalentes.
[[ OPERATION LOG. ]]    #La deuxième structure est à préférer. Voici ses ajouts
                        #par rapport à la structure [ ] :
                        #  - [[ ]] est plus rapide que (( )), qui est plus
                        #    rapide que [ ]
                        #  - Ne provoque pas d'erreur si une $VAR non échappée
                        #    contient une whitespace ou un control character.
                        #    $VAR n'a jamais donc besoin d'être échappé,
                        #    contrairement à [ ]
                        #    N'échapper donc que les wildcards si elles doivent
                        #    être prises dans leur sens littéral : échapper donc
                        #    les variables d'un test [[ == ]] ou !=, car elles
                        #    sont susceptibles de contenir des crochets, qui
                        #    font échouer les tests.
                        #  - Avec les OPERATION LOG. -eq, -ne, -lt, -le, -gt et
                        #    -ge, possibilité d'utiliser :
                        #         - les opérateurs arithmétiques + - * / %
                        #           et ** (à condition qu'ils soient
                        #           immédiatement suivis et précédés d'un nombre
                        #           ou de $VAR, et non d'un espace)
                        #         - les formes 0NOMBRE, 0xNOMBRE et 2#NOMBRE
                        #  - > et < ne doivent pas être échappés
                        #  - -a et -o sont remplacés par && et || (voir plus
                        #    haut)
                        #  - [[ ]] est insensible à la casse après un "shopt -s
                        #    nocasematch"
                        #  - moins portable cependant
                        #  - le globbing sur les tests de FILE est impossible,
                        #    contrairement à [ ]. Le globbing sur les tests ==
                        #    = et != est quant à lui possible
                        #  - l'opérateur =~ est disponible

OPERATION LOG. ==>      #Voici une liste des OPERATION LOG. possibles :

[[ -z $VAR ]]           #$VAR doesn't exist ou est null.
[[ $VAR ]]
[[ -n $VAR ]]           #$VAR exists et est non null

STRING DANS LES         #Les STRINGS ont une valeur de 0 dans les tests -eq, -ne
OPERATIONS ARI. ==>     #-lt, -le, -gt et -ge

[[ NOMBR1 -eq NOMBR2 ]] #NOMBR1 est arithmetiquement egal a NOMBR2. Il peut
                        #s'agir de $VAR ou de VALEUR
[[ NOMBR1 -ne NOMBR2 ]] #NOMBR1 est arithmetiquement inegal a NOMBR2.
[[ NOMBR1 -lt NOMBR2 ]] #NOMBR1 est arithmetiquement inferieur a NOMBR2.
[[ NOMBR1 -le NOMBR2 ]] #NOMBR1 est arithmetiquement inferieur ou egal a NOMBR2
[[ NOMBR1 -gt NOMBR2 ]] #NOMBR1 est arithmetiquement superieur a NOMBR2.
[[ NOMBR1 -ge NOMBR2 ]] #NOMBR1 est arithmetiquement superieur ou egal a NOMBR2

[[ STRING1 == STRING2 ]]#Strings are alphabétiquement equal. Il peut s'agir de
[[ STRING1 = STRING2 ]] #STRING ou "STRING". La seconde syntaxe est à déprécier
[[ STRING1 != STRING2 ]]#Strings are not equal alphabetiquement

[[ STRING1 < STRING2 ]] #STRING1 est alphabetiquement avant STRING2. L'ordre
[ STRING1 \< STRING2 ]  #dépend peut-être de la locale, mais pour moi, cela
                        #donne, du plus petit au plus grand :
                        #
                        #  ` ^ ~ < = > | space _ - , ; : ! ? / . ' " ( ) [ ] {
                        #  } @ $ * \ & # % +
                        #  NUL->\x1f, DEL
                        #  0123456789
                        #  aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
[[ STRING1 > STRING2 ]]
[ STRING1 \> STRING2 ]  #STRING1 est alphabetiquement apres STRING2.

[[ -a FILE ]]
[[ -e FILE ]]           #FILE exists. -a is deprecated
[[ -s FILE ]]           #FILE has a size greater than zero.

[[ -f FILE ]]           #FILE is a regular file (and exists).
[[ -d FILE ]]           #FILE is a directory (and exists).
[[ -h FILE ]]
[[ -L FILE ]]           #FILE is a symbolic link (and, etc. for all the list)
[[ -b FILE ]]           #FILE is a block-special file.
[[ -S FILE ]]           #FILE is a socket.
[[ -c FILE ]]           #FILE is a character-special file.
[[ -p FILE ]]           #FILE is a named pipe (FIFO).

[[ -r FILE ]]           #FILE is readable.
[[ -w FILE ]]           #FILE is writable.
[[ -x FILE ]]           #FILE is executable.

[[ -u FILE ]]           #SUID (set user ID) bit is set.
[[ -g FILE ]]           #SGID bit is set.
[[ -k FILE ]]           #Sticky bit is set.
[[ -O FILE ]]           #FILE is owned by the effective user ID.
[[ -G FILE ]]           #FILE is owned by the effective group ID.

[[ -N FILE ]]           #FILE has been modified since it was last read.

[[ FILE1 -nt FILE2 ]]   #FILE1 older than FILE2, or FILE1 exists and
                        #FILE2 does not
[[ FILE1 -ot FILE2 ]]   #FILE1 newer than FILE2, or FILE2 exists and
                        #FILE1 does not
[[ FILE1 -ef FIL2 ]]    #FILE1 and FILE2 are the same device and inode

[[ -o OPTION ]]         #Shell OPTION is enabled (long name d'option simple)

[[ -t NOMBRE ]]         #Filedescriptor NOMBRE existe dans le shell courant

[[ STRING =~ PATTERN ]] #Test si la premiere chaine contient PATTERN.
                        #Regexps étendues (sauf \b, \B, \<, \>, \1...), et rien
                        #dans le PATTERN ne doit être échappé (ni guillemets,
                        #ni backslash (sauf littéral))
                        #Préférer [[ STRING == *PATTERN* ]], 2 fois plus rapide,
                        #si PATTERN peut être fait en globbing sans regexps.

                                  ┌───────────────────────────┐
                                  │   BOUCLES ET STRUCTURES   │
                                  └───────────────────────────┘

if TEST ; then
    COMMANDES
elif TEST ; then
    COMMANDES           #il est plus propre de mettre then sur la meme
else                    #ligne que if ou elif, separe par un ; et else et fi
    COMMANDES           #sur des lignes isolees
fi                      #elif ... et else ... sont falcultatifs

for VAR in LIST ; do    #execute COMMANDES pour chaque element de LIST, chaque
    COMMANDES           #élément devenant a tour de rôle VAR
done                    #Si la liste est absente, il s'agit de "#@"
                        #Une LIST est une suite d'éléments séparés par un IFS
                        #non échappé (guillemets ou backslash) : généralement,
                        #un espace séparant deux STRINGS ou une newline
                        #La suite d'éléments peut être obtenue par une
                        #sustitution de variable, de commandes, etc.
                        #Exemple de LIST :
                        #  - {1..100}
                        #  - "$@"
                        #  - "${ARR[@]}"
                        #  - ./*.txt
                        #  - "VAL1" "VAL2"...
                        #  - "$VAR1" "$VAR2"...
                        #  - VAR... contenant chacune une suite de "VAL"... (et
                        #    non "VAR" qui échapperait les espaces entre ces
                        #    "VAL")
                        #Jamais de guillemets autour de VAR

for (( OPER1 ; OPER2 ;  #  1) OPER1 s'exécute initialement
OPER3 )) ; do           #  2) Ensuite, si OPER2 renvoie vrai, COMMANDES
    COMMANDES           #     puis OPER3 s'exécute. Itération de l'étape 2
done                    #  3) Si OPER2 renvoie faux, la boucle s'arrête
                        #OPER sont des opérations arithmetiques.
                        #Attention, 2 fois moins rapide que la syntaxe
                        #précédente : utiliser de préférence for VAR in {1..8}

for (( OPER1
[ , OPER1]... ; OPER2
[ , OPER2]... ; OPER3   #Il est impossible d'avoir plusieurs OPER1, OPER2 ou
[ , OPER3]... )) ; do   #OPER3 en les séparant par des virgules.

break                   #Dans une boucle for, while ou until, clot la boucle.
break CHIFFRE           #Même chose, mais clot N-1 boucles superieures
                        #egalement (if loops are nested)
continue                #Dans une boucle for, while ou until, effectue une
                        #nouvelle iteration sans aller jusqu'au bout de celle
                        #en cours
continue CHIFFRE        #Effectue un continue au niveau N-1 superieur, fermant
                        #les boucles inferieures demarrees

while TEST ; do         #Execute tant que le test est vrai ou break ou
  COMMANDES             #continue (optionnels) Ex : while [ "$a" -lt 3 ].
done                    #Autre ex : ou while (( a < 3 ))

while true ; do ...     #dure toujours jusqu'a interruption ou break
while read VAR ; do ... #Avec une redirection de l'input de read, dure jusqu'a
                        #la fin de l'input. Ex : while read VAR... < FILE
                        #lira une ligne de FILE a chaque iteration de la boucle
                        #Voir plus loin sur les risques de piper l'input d'un
                        #while read
                        #De plus, un read embedded dans une telle structure ne
                        #lira plus l'entrée standard mais FILE. Il faut alors
                        #inclure un read -u N (qui lira le fdN et non fd0) et
                        #faire en sorte que fdN pointe vers le terminal et soit
                        #un input fd : while read VAR... N<&0 < FILE

until TEST; do
  COMMANDES
  break
  continue              #execute tant que le test est faux ou break (optionnel)
done                    #il s'agit d'un while inverse

case "$VAR" in          #Exécute les COMMANDES associées au premier PATTERN
    PATTERN)            #matchant $VAR, puis exécute TERM.
        COMMANDES TERM  #TERM peut être :
    ...                 #  - ;;  interrompt la structure case
    *)                  #  - ;;& continue de rechercher le prochain PATTERN
        COMMANDES ;;    #        parmi tous les PATTERN restants
esac                    #  - ;&  exécute les COMMANDES et le TERM du PATTERN qui
                        #        suit immédiatement le PATTERN courant
                        #;;& et ;& sont des ajouts de Bash 4
                        #PATTERN utilise le globbing, ainsi que
                        #PATTERN1|PATTERN2
                        #PATTERN) peut être sous la forme (PATTERN) : les ( et )
                        #doivent donc être échappées
                        #Pour le globbing, pas de guillemets bien sûr
                        #PATTERN est insensible à la casse après un "shopt -s
                        #nocasematch"
                        #Ne pas oublier d'inclure le PATTERN * à la fin, pour
                        #donner une réponse par défaut.
                        #Utile pour traiter les options passees par
                        #l'utilisateur.

select VAR in LIST ; do #Imprime une LIST (même sens que pour for), avec un
  COMMANDES             #nombre s'incrémentant en face de chaque element, sur
  break                 #stderr.
done                    #La valeur choisie par l'utilisateur remplace VAR, et
                        #les commandes sont exécutées.
                        #La variable REPLY enregistre le nombre tape.
                        #Si la liste est absente, il s'agit de #@. Si autre
                        #chose est tape, null remplace VAR.
                        #PS3 est une variable que l'on peut modifier pour
                        #changer le texte du prompt.
                        #Si aucun break n'est rencontre, la boucle se repete.

                                  ┌──────────────────┐
                                  │   REDIRECTIONS   │
                                  └──────────────────┘

FILE DESCRIPTORS ==>    #Un file descriptor (fd) est un lien symbolique vers un
                        #fichier. Tout fichier ouvert a un file descriptor lié
                        #à lui.
                        #Les file descriptors sont listés dans /proc/PROC_NUM/fd
                        #(PROC_NUM pouvant être "self"). Un nombre leur est
                        #attribué.
                        #Un fd peut être :
                        #  - un input fd (recevoir son input du file)
                        #  - un output fd (envoyer son output vers file)
                        #  - un input/output fd (recevoir son input du file, et
                        #    recevoir son output de file)
                        #D'un point de vue strictement technique, les choses
                        #sont en fait que tout fd pointe vers un fichier dans le
                        #même sens : FD --> FICHIER. Seulement la différence est
                        #au niveau des droits d'accès pour l'user courant :
                        #  - un input fd peut être lu (et donc lire le fichier
                        #    qu'il pointe)
                        #  - un output fd peut être écrit (et donc écrire le
                        #    fichier qu'il pointe)
                        #  - un input/output fd peut être lu et écrit.
                        #Dans tous les cas, tout fd peut être exécuté
                        #
LES FD STANDARD ==>     #Tout subshell initialise au moins trois fd :
                        #  - /dev/stdin, l'entrée standard, fd 0, input/output
                        #    fd vers le terminal courant (/dev/pts/TERM_NUM),
                        #    mais utilisé par les processus comme un input fd
                        #  - /dev/stdout, la sortie standard, fd 1, input/output
                        #    fd vers le terminal courant (/dev/pts/TERM_NUM),
                        #    mais utilisé par les processus comme un output fd
                        #  - /dev/stderr, l'erreur standard, fd 2, input/output
                        #    fd vers le terminal courant (/dev/pts/TERM_NUM),
                        #    mais utilisé par les processus comme un output fd
                        #Ainsi, ces trois référence font référence au même
                        #fichier, en lecture et en écriture. Ce sont les seuls
                        #fd utilisés par les commandes builtins et externes.
                        #Pour faire utiliser un fdN à un des fd standards, il
                        #faut donc le faire indirectement en réassignant leur
                        #valeurs :
                        #  - N< FICHIER, puis <&N pour fd0 (et non N< FILE, qui
                        #    va modifier le fichier pointé par fdN, mais pas
                        #    celui utilisé par fd0, qui est le fd utilisé par
                        #    les commandes.
                        #  - N> FICHIER, puis >&N pour fd1
                        #  - N> FICHIER, puis 2>&N pour fd2
                        #Sans les fd standards, elles n'ont pas d'input ou ne
                        #produisent pas d'output (normal ou flux d'erreurs).
                        #Supprimer l'un d'eux, ou le modifier d'une mauvaise
                        #manière peut donc produire une erreur (par exemple,
                        #si fd0 devient un output fd, il ne pourra plus être lu,
                        #et si fd1 ou fd2 devient un input fd, il ne pourra
                        #plus écrire)
                        #
HERITAGE ==>            #Chaque subshell a ses propres fd, qu'il hérite de ses
                        #parents. Ainsi :
                        #  - ( COMMANDES ) 2>&1 : COMMANDES hérite de 2>&1, mais
                        #    ses fd restent distincts de ceux de son parent
                        #  - ( COMMANDES1 ) 2>&1 | COMMANDES2 : COMMANDES1
                        #    hérite seulement de 2>&1, car pipe et COMANDES2
                        #    est un autre subshell, qui ne lui est pas parent
                        #    (il est en fait enfant du même parent)
                        #
PORTEE DES              #Ainsi une redirection est propre au seul subshell.
REDIRECTIONS ==>        #Tout N>, N<, N>&M, |... affectera seulement le subshell
                        #c'est-à-dire COMMANDES en général.
                        #En effet, COMMANDES N> FILE ne redirige l'output que du
                        #subshell créé par COMMANDES
                        #Pour faire des redirections sur le subshell courant,
                        #remplacer COMMANDES par exec
                        #Ainsi, après :
                        #  - exec N>&M ; COMMANDES...
                        #COMMANDES... est encore affecté par N>&M car c'est le
                        #subshell qui lance COMMANDES qui a N>&M, dont le
                        #subshell lancé par COMMANDES hérite donc
                        #
ORDRE D'EXECUTION ==>   #L'ordre d'exécution des redirections est celui-ci :
                        #  - Les fd hérités, du plus haut au plus bas parent
                        #  - Puis la pipe si le subshell est pipé (qu'il
                        #    s'agisse d'une pipe redirigeant son entrée ou sa
                        #    sortie)
                        #  - Enfin les redirections de gauche à droite
                        #Exemple (redirige stdout et stderr de COMMANDES1 vers
                        #COMMANDES2 et COMMANDES3 séparément) :
                        #  {
                        #    {
                        #      COMMANDES1 | COMMANDES2
                        #    } 2>&1 1>&4 | COMMANDES3
                        #  } 4>&1
                        #Ordre d'exécution de :
                        #  - COMMANDES1 : 4>&1 2>&1 1>&4 Pipe_intérieur_ouput
                        #  - COMMANDES2 : 4>&1 2>&1 1<&4 Pipe_intérieur_input
                        #  - COMMANDES3 : 4>&1 Pipe_extérieur_ouput 2>&1 1>&4
                        #                 Pipe_extérieur_input (à partir de ce
                        #                 point, fd 1 et 2 ne sont plus hérités,
                        #                 mais fd 0 et 4 le sont)
                        #Seul l'ordre de succession des redirections entre elles
                        #importent, mais leur place dans le subshell est libre,
                        #sauf  :
                        #  - |, |& et <<HEREDOC qui doivent être à la fin du
                        #    subshell
                        #  - les structures, fonctions et blocs (voir ci-
                        #    dessous) doivent précéder les redirections (sauf
                        #    pour un pipe redirigeant leur input)
                        #Ainsi < FILE COMMANDES équivaut à COMMANDES < FILE
                        #
OFFSET DES INPUT FD ==> #Un fd a un offset (0 au début). Lorsque des octets sont
                        #lus ou écrit, ils sont lus à partir de cet offset et
                        #font avancer cet offset d'autant d'octets.
                        #Par exemple un read normal fera avancer l'offset du
                        #nombre d'octets de la ligne lue ou de NOMBRE
                        #caractères si read a été invoqué avec l'option -n
                        #NOMBRE

if ... fi       > ...   #Il est possible de rediriger les fd de tout subshell.
for ... done    > ...   #Cependant, ces structures :
while ... done  | ...   #  - bloc conditionnel if, case ou select
...  | until ... done   #  - fonction (anonyme ou non)
select ... done  2>&1   #  - bloc de commandes
case ... esac   > ...   #  - boucle for, while ou until
[FNCTON] { .. } > ...   #Agissent comme si elles étaient des subshells (bien que
( COMMANDES )   > ...   #ce soit faux) pour les redirections. Il est donc
                        #possible de rediriger leurs fd.
                        #Voir ci-dessous pour les risques de piper leur input

COMMANDES DONT L'INPUT  #Il est possible de rediriger l'input de certaines
PEUT ETRE REDIRIGE      #commandes, et non d'autres. Celles le pouvant sont
  ==>                   #celles :
                        #  - n'acceptant pas d'argument et utilisant par défaut
                        #    stdin (par exemple tr)
                        #  - acceptant stdin par défaut si aucun argument n'est
                        #    attribué
                        #Dans les deux cas, stdin est lue comme une string, en
                        #aucun cas comme un nom de fichier. Ainsi :
                        #  - cat FILE | head
                        #et non :
                        #  - echo FILE | head
                        #est l'équivalent de :
                        #  - head FILE
                        #stdin ne sera pas toujours traité exactement de la même
                        #manière qu'un argument spécifié normalement. Par
                        #exemple wc FILE affiche le nom de fichier,
                        #contrairement à wc < FILE

COMMANDES DONT L'INPUT  #Pour les autres, il existe des alternatives : à la
NE PEUT PAS ETRE        #place de COMNDE1 | COMNDE_NO_INPUT, faire un :
REDIRIGE ==>            #  - COMNDE1 | xargs COMNDE_NO_INPUT. xargs place stdin
                        #    comme un argument supplémentaire à la fin de la
                        #    liste d'arguments actuelle de CMNDE_NO_INPUT
                        #    COMNDE_NO_INPUT doit être une commande externe, ou
                        #    un builtin ayant une équivalence sous forme de
                        #    commande externe
                        #  - COMNDE_NO_INPUT $(COMNDE1) si CMNDE_NO_INPUT prend
                        #    comme argument une STRING
                        #  - COMNDE_NO_INPUT <(COMNDE1) si CMNDE_NO_INPUT prend
                        #    comme argument un FILE

INPUT ET OUTPUT VERS    #Si un input fd et un ouput fd pointent vers le même
LE MÊME FICHIER ==>      #fichier régulier (donc cela ne marche pas pour
                        #/dev/pts), ce fichier régulier sera vide à la fin de
                        #l'opération. Ainsi :
                        #  - COMMANDE < FILE > FILE
                        #utilisant le même FILE vide ce fichier, ce qui est
                        #rarement souhaité. (car > FILE tronque d'abord FILE,
                        #puis < FILE prend comme input le FILE tronqué)
                        #Alternatives pour modifier un fichier entrée en input :
                        #  - COMMANDE <<<"$(<FILE)" > FILE
                        #  - COMMANDE < FILE 1<>FILE (semble mal fonctionner)
                        #  - faire en deux étapes en utilisant des fichiers
                        #    temporaires (notamment avec mktemp, plus sûr)
                        #  - utiliser une named pipe
                        #Enfin, pour avoir le même effet que :
                        #  - COMMANDE < FILE >> FILE
                        #Faire :
                        #  - COMMANDE <>FILE >&0

VIDER UN FICHIER ==>    #Il arrivera la même chose si :
                        #  - un fd n'étant pas fd0, 1 ou 2 pointe en écriture
                        #    vers FILE, et que fd1 ou fd2 ne pointe pas pas
                        #    vers ce même FILE. Exemple :
                        #      - echo "oh" 3> FILE (vide FILE)
                        #      - echo "oh" 3> FILE >&3 (ne vide pas FILE)
                        #  - > FILE est utilisé dans une ligne de commandes
                        #    (hors pipe) ne contenant que true, : ou false (ou
                        #    d'autres redirections). Exemple :
                        #      - : > FILE

SUBSHELL1 | SUBSHELL2   #redirige l'output du fd1 de SUBSHELL1 vers une
                        #anonymous pipe (créée pour l'occasion) et l'input de
                        #fd0 de SUBSHELL2 depuis la même anonymous pipe, ces
                        #deux derniers fd devenant respectivement un output fd
                        #et un input fd.
                        #
                        #Piper crée en fait un subshell. Attention donc, car
                        #la portée des variables créées dans SUBSHELL2 est
                        #donc locale.
                        #Ainsi, piper l'input d'une boucle ou structure fait
                        #que les variables à l'intérieur d'elle sont locales.
                        #Utiliser donc < <(COMMANDES), < FILE, <<HEREDOC ou
                        #<<<STRING pour piper l'input de ces dernières sans
                        #forker
SUBSHELL1 |& SUBSHELL2  #Raccourci pour 2>&1 | S'il n'y a pas d'autres
                        #redirections, équivaut à dire que fd1 et fd2 de
                        #SUBSHELL1 pointent vers l'anonymous pipe, laquelle est
                        #l'input de fd0 de SUBSHELL2. (Bash 4)
                        #Cependant par exemple :
                        #  - SUBSHELL1 > /dev/null |& SUBSHELL2
                        #équivaut à :
                        #  - SUBSHELL1 > /dev/null 2>&1 | SUBSHELL2
                        #donc l'ordre d'exécution est | > /dev/null puis 2>&1,
                        #du coup, à la fin fd1 et fd2 pointent vers /dev/null

N> FILE                 #redirige l'output de fdN (1 par défaut) vers FILE (le
                        #crée ou l'écrase) pour le subshell courant. fdN devient
                        #un output fd
N>> FILE                #Même chose, mais n'ecrase pas FILE, rajoute seulement
                        #a la fin.
N>| FILE                #Comme N> FILE, mais fonctionne meme si l'option
                        #noclobber est activee
>& FILE
&> FILE                 #équivaut à > FILE 2> FILE (deprecated)
&>> FILE                #équivaut à >> FILE 2>> FILE (Bash 4)

N< FILE                 #redirige l'input de fdN (0 par défaut) depuis FILE pour
                        #le subshell courant. fdN devient un input fd
                        #A noter que VAR="$(cat FILE)" peut être noté :
                        #  - VAR="$(< FILE)"

N<<<STRING              #Here string. Redirige l'input de fdN (0 par défaut)
                        #depuis STRING + '$\n' pour le subshell courant. fdN devient un
                        #input fd. Préférer un Here document dans les scripts
                        #devant être portables.
                        #Pour inclure une séquence d'échappement backslash,
                        #utiliser $' '
                        #Ce n'est pas STRING qui est en fait pointée, mais un
                        #fichier temporaire créé dans /tmp/ qui contient
                        #seulement STRING

SUBSHELL N<<STRING_DELIM#Here document. Les deux STRING_DELIM doivent etre le
STRING                  #même mot (generalement en lettres capitales). Une
STRING_DELIM            #newline doit précéder et succéder le deuxième
                        #STRING_DELIM (pas même un ;)
                        #Rajouter un caractère non blank après le premier
                        #STRING_DELIM fait que le Here document (mais pas les
                        #caractères ajoutés après) est ignoré.
                        #Ainsi le subshell auquel s'applique un Here document
                        #doit être à gauche de <<STRING_DELIM
                        #STRING commence au premier newline suivant le premier
                        #STRING_DELIM, et peut lui-même contenir des newlines
                        #(être sur plusieurs lignes)
                        #Echapper le premier STRING_DELIM fait que STRING ne
                        #fait pas de parameter expansion.
                        #Faire précéder STRING_DELIM ou 'STRING_DELIM' d'un
                        #tiret fait que les blanks en début de ligne sont
                        #ignorés
                        #L'effet : redirige l'input de fdN (0 par défaut)
                        #depuis STRING pour le SUBSHELL. fdN devient un input fd
                        #Pour inclure une séquence d'échappement backslash,
                        #utiliser $' '
                        #Ce n'est pas STRING qui est en fait pointée, mais un
                        #fichier temporaire créé dans /tmp/ qui contient
                        #seulement STRING
                        #Exemple pour taper automatiquement y :
                        #apt-get install $1 <<CONF
                        #y
                        #CONF

N<> FILE                #redirige l'input de fdN (0 par défaut) depuis FILE, et
                        #son output également vers FILE. fdN devient un input/
                        #output fd : il peut donc être utilisé dans les deux
                        #occasions. Par exemple :
                        #  - >&N redirigera fd1 vers FILE
                        #  - <&N redirigera fd0 depuis FILE
                        #L'ouput vers FILE n'écrasera pas FILE mais insèrera
                        #les octets désignés à l'offset de fdN.
                        #L'input depuis FILE fera avancer cet offset.

N> /dev/fd/M            #redirige l'output de fdN vers le fichier pointé par fdM
                        #pour le shell courant. fdN devient un output fd.
                        #N est par défaut 1.
N< /dev/fd/M            #redirige l'input de fdN depuis le fichier pointé par
                        #fdM pour le shell courant. fdN devient un input fd.
                        #N est par défaut 0.
N>&M                    #redirige l'input et/ou l'output de fdN depuis/vers le
N<&M                    #fichier pointé par fdM, pour le shell courant, en
                        #fonction que fdM est un input, ouput ou input/output
                        #fd. fdN devient un fd du même type que fdM. En gros,
                        #fdN devient une copie de fdM
                        #Ainsi COMMANDES > FILE 2>&1, puisque fd1 pointe vers
                        #FILE, fera que fd2 pointera aussi vers FILE
                        #>&2 imprime fd1 comme un message d'erreur

N> /dev/null            #fera que fdN ne produira pas d'output pour le shell
                        #courant, mais ne fermera pas fdN. fdN devient un output
                        #fd.
                        #2> /dev/null permet ainsi de supprimer le flux d'erreur
N< /dev/null            #fera que l'input de fdN sera vide pour le shell
                        #courant, mais ne fermera pas fdN. fdN devient un input
                        #fd

N>&-                    #Fermera fdN. A faire après utilisation d'un fd créé.
N<&-                    #Différent de N> /dev/null et N< /dev/null : produira
                        #une erreur si le fd est requis par une COMMANDE.
                        #N est par défaut 1 dans le 1er cas, 0 dans le 2ème

N>&-M                   #Déplace fdM pour en faire un fdN, avec les mêmes
N<&-M                   #permissions de lecture et/ou d'écriture.
                        #N est par défaut 1 dans le 1er cas, 0 dans le 2ème

<(COMMANDES)            #A deux effets :
                        #  1) l'output de fd1 du subshell de COMMANDES est
                        #     redirigé vers le fdN du subshell parent (N est
                        #     choisi par Bash), via une anonymous pipe, ce
                        #     dernier devenant un input fd, et ce premier un
                        #     output fd
                        #  2) Pour utiliser ce fdN, "/dev/fd/N" est substitué à
                        #     <(COMMANDES)
                        #Utilité : utiliser la string résultant de l'output de
                        #COMMANDES là où un FILE est attendu en lecture
                        #Deux utilités principales :
                        #  1) Ainsi, < <(COMMANDES) permet de rediriger la
                        #     sortie standard de COMMANDES vers le fd0 du
                        #     subshell courant.
                        #     Ceci simule un < $(COMMANDES) qui ne marcherait
                        #     pas sinon, car $( ) renvoie une string et non un
                        #     file
                        #     Ceci est une alternative à |, mais sans créer de
                        #     subshell. Ainsi, par exemple :
                        #       - while read ... < <(COMMANDES)
                        #     est équivalent à :
                        #       - COMMANDES | while read ...
                        #     Sauf que while read n'est pas dans un nouveau
                        #     subshell et ses variables n'ont donc pas de
                        #     portée locale à ce subshell
                        #  2) Pour une commande COMMANDE FILE..., COMMANDE
                        #     <(COMMANDES2)... permet de simuler un COMMANDE
                        #     $(COMMANDES2)... qui ne marcherait pas sinon, car
                        #     $( ) renvoie une string et non un file.
                        #     Exemple : cmp <(COMAND1) <(COMAND2)
                        #     (cmp est une commande externe)
                        #Attention : est peu portable
>(COMMANDES)            #A deux effets :
                        #  1) l'input de fd0 du subshell de COMMANDES est
                        #     redirigé depuis le fdN du subshell parent (N est
                        #     choisi par Bash), via une anonymous pipe, ce
                        #     dernier devenant un output fd, et ce premier un
                        #     input fd
                        #  2) "/dev/fd/N" est substitué à >(COMMANDES)
                        #Utilité : rediriger l'input de COMMANDES là où un FILE
                        #est attendu en écriture
                        #Utilités principales :
                        #  1) > >(COMMANDES) permet de rediriger l'entrée
                        #     standard de COMMANDES depuis le fd1 du subshell
                        #     courant. Comme | COMMANDES, sauf que cela ne crée
                        #     pas de nouveau subshell.
                        #  2) tee >(COMMANDE) permet de "piper" stdin vers
                        #     COMMANDE tout en redirigeant stdin vers stdout.
                        #     Dans, tee >(COMMANDE1) | COMMANDE2, COMMANDE2 aura
                        #     comme input l'input de tee incrémenté du résultat
                        #     de COMMANDE1 (lui-même inputé par l'input de tee)

COMMANDE -              #Le tiret est un alias pour /dev/stdin, utilisable par
                        #certaines commandes demander un FILE comme argument,
                        #dont :
                        #  - cat, tac
                        #  - file
                        #  - diff
                        #  - head, tail
                        #  - split, csplit
                        #  - join
                        #  - shuf
                        #  - etc.
                        #Il peut s'agir de /dev/stdout aussi pour par exemple :
                        #  - tar
                        #  - patch -o
                        #Ainsi :
                        #  - echo "oh" | cat FILE1 - FILE2
                        #imprime "oh" au milieu des fichiers FILE1 et FILE2
                        #Ne peut être utilisé qu'une fois
                        #Cela peut permettre aussi de rediriger l'input de
                        #commandes ne le pouvant normalement pas :
                        #  - cat FILE | file -

                                  ┌───────────────────────────────────────────────┐
                                  │   MANIPULATION DE VARIABLES ET DE LEUR NOMS   │
                                  └───────────────────────────────────────────────┘

${$ ==> ERREUR          #Ne jamais doubler les $ avec { au milieu. Le premier
                        #suffit. Pour ce qui est de $*, $@, $1, $2 etc., voir
                        #la section sur les arguments
GLOBBING ==> ERREUR     #Le globbing est interdit dans les expressions
                        #suivantes pour VAR

"${VAR:-VALEUR}"        #Si $VAR est non declaree ou null, renvoie VALEUR,
                        #sinon renvoie $VAR. Utile pour mettre un parametre
                        #meme si celui-ci a ete oublie : "${1:-VALEUR}"
                        #VAR="${1:-.}" permet de désigner $1 ou, si aucun $1, le
                        #répertoire courant par défaut
"${VAR:=VALEUR}"        #Si $VAR est non declaree ou null, renvoie VALEUR et
                        #l'assigne a VAR, sinon renvoie $VAR.
"${VAR:+VALEUR}"        #A moins que $VAR soit non declaree ou null, renvoie
                        #VALEUR, sinon renvoie null
"${VAR:?MESSAGE}"       #Si $VAR est non declaree ou null, renvoie un MESSAGE
                        #d'erreur sur stderr et arrete le script, sinon renvoie
                        #$VAR

"${VAR-VALEUR}"
"${VAR=VALEUR}"
"${VAR+VALEUR}"         #meme chose que ci-dessus mais ne prend en compte que
"${VAR?MESSAGE}"        #les $VAR non declarees

VAR+="STRING"           #concatene "STRING" a la fin de VAR

${!PATTERN*}            #PATTERN n'est pas une regexp mais une suite de
                        #lettres, chiffres et quelques caracteres speciaux.
                        #Renvoie la liste concatenee du nom de toutes les
                        #variables commencant par PATTERN.
${!PATTERN@}            #Meme chose mais la liste n'est pas concatenee

CHAINE{UN,DEUX,TROIS}   #Renvoie CHAINEUN CHAINEDEUX CHAINETROIS. attention :
                        #echapper les espaces a l'interieur
{UN,DEUX,TROIS}CHAINE   #Renvoie UNCHAINE DEUXCHAINE TROISCHAINE
echo /{,usr/}bin        #Exemple d'utilisation : signifie echo /bin /usr/bin
cp file{,.bak}          #Autre exemple. cp est une commande externe

[STR1]{DEBUT..FIN       #renvoie l'ensemble des éléments compris entre DEBUT et
[..STEP]}[STR2]         #FIN, à STEP pas, séparés les uns des autres par des
                        #espaces non échappés, avec STR1 les précédant, et STR2
                        #après eux.
                        #DEBUT et FIN peuvent être des nombres ou des lettres
                        #isolées (plusieurs lettres ne fonctionnent pas)
                        #Il ne peut pas s'agir d'une $VAR.
                        #Si un ou plusieurs 0 sont rajoutés devant DEBUT ou FIN
                        #et qu'il s'agit d'un nombre, des 0 sont ajoutés à
                        #chaque nombre pour garder le padding du nombre (entre
                        #DEBUT et FIN) ayant le plus de chiffres
                        #Rajouter ou non un - devant STEP ne change rien au
                        #résultat
                        #Utile dans une boucle for.
                        #Voici des exemples :
{1..4}                  #renvoie 1 2 3 4
{11..4}                 #renvoie 11 10 9 8 7 6 5 4
{1..10..2}              #renvoie 1 3 5 7 9
{01..100}               #renvoie 001 002 ... 100
{0001..3}               #renvoie 0001 0002 0003
{a..e}                  #renvoie a b c d e
{Y..V}                  #renvoie Y X W V
_{{0..2},{a..c}}        #renvoie _0 _1 _2 _a _b _c
{a..n..2}               #renvoie a c e g i k m
_{1..3}#                #renvoie _1# _2# _3#
{A..C}{1..3}            #renvoie A1 A2 A3 B1 B2 B3 C1 C2 C3
{{0..9},{a..f}}{{0..9},
{a..f}}                 #Renvoie 00 01 .. fe ff

~                       #$HOME
~USER                   #$HOME de USER
~+                      #$PWD
~-                      #OLDPWD

                                  ┌─────────────────────────────┐
                                  │   MANIPULATION DE STRINGS   │
                                  └─────────────────────────────┘

${$VAR} ==> ERREUR      #ne jamais mettre cette syntaxe, incorrecte.
                        #$*, $@, $1, $2 doivent être notés ${* ${@ ${1 ${2...
"STR"                   #STR ou PATTERN peuvent contenir une $VAR, il faut alors
"PATTERN"               #noter "$VAR" (sauf globbing)

${ARR[@] etc.           #les variables arrays doivent de meme etre notees ainsi
                        #et non ${ARR etc. qui ne renvoie que le premier
                        #element de l'array

RENVOIE MAIS NE         #Les operations suivantes renvoie une valeur mais ne
MODIFIE PAS ==>         #modifie pas les variables en elles-meme

EXPR  ==>               #expr est une commande externe, non un built-in.
                        #Les commandes qui suivent ne conviennent pas pour un
                        #array. Utilise les regexps basiques.

expr "STR" : "PATTERN"  #Si PATTERN contient un \(SUBPATTERN\), imprime les
expr match "STR" "PATRN"#caractères de STR matchant SUBPATTERN.
                        #Sinon, imprime le nombre de caractères de STR matchant
                        #PATTERN. Il s'agit bien d'une impression.
                        #Dans tous les cas PATTERN (incluant ou non un
                        #SUBPATTERN) doit matcher STR depuis son début.
expr length "STR"       #Equivaut à expr "STR" : ".*", imprimant donc le nombre
                        #de caractères de STR.
expr index "STR" "PATRN"#Equivaut à expr "STR" : ".*PATTERN", imprimant donc la
                        #position de la première occurence de PATTERN.

ARRAY ==>               #pour les operations suivantes, les mots entiers
                        #des arrays sont considerees comme leurs "caracteres"
                        #Le globbing est utilisé à partir de maintenant.
${#VAR}                 #renvoie le nombre de caracteres (ou de valeurs pour
                        #un array) de VAR
"${STR:OFFSET[:LENGTH]}"#renvoie LENGTH caracteres (par défaut tous jusqu'à la
expr substr "STR" OFFSET#fin), de STR, à partir de l'OFFSET.
LENGTH                  #${@:0:1} désigne $0 et non $1 pour Bash 4
                        #Cependant pour Bash 3, il désigne $1
                        #OFFSET et LENGTH sont des opérations arithmétiques, pas
                        #besoin de faire $(( ))
                        #OFFSET peut être négatif désignant alors le OFFSET
                        #dernier caractère (un espace doit séparer alors OFFSET
                        #et :)

ARRAY ==>               #pour les commandes suivantes, pour les arrays, la
                        #recherche/substitution s'effectue pour chaque element
                        #de l'array
"${VAR#PATTERN}"        #renvoie $VAR, a l'exception du PATTERN dans $VAR si
                        #celui-ci est present depuis le debut de $VAR (peut
                        #donc inclure la totalite de $VAR).
"${VAR##PATTERN}"       #meme chose, mais si le pattern inclus des * ? + etc.,
                        #le pattern le plus long possible sera choisi pour
                        #supprimer, et non le plus court
"${VAR%PATTERN}"        #comme ${VAR#PATTERN} mais supprime depuis la fin
"${VAR%%PATTERN}"       #comme ${VAR##PATTERN} mais supprime depuis la fin
"${VAR/PATRN[/VARING]}" #renvoie $VAR supprimant la premiere occurence de
                        #PATTERN et en la remplaçant par VARING, si présent
"${VAR//PTRN[/VARING]}" #meme chose mais supprime ou remplace toutes les
                        #occurences
"${VAR/#PTRN[/VARING]}" #renvoie $VAR en supprimant la premiere occurence du
                        #PATRN, et si elle est au debut de VARING, et en la
                        #remplaçant par VARING si présent
"${VAR/%PTRN[/VARING]}" #meme chose mais pour la fin

"${VAR^[CHAR]}"         #Renvoie $VAR en mettant sa première lettre en uppercase
                        #si elle matche CHAR (qui peut être une wildcard)
                        #Bash 4 uniquement
                        #PATTERN par défaut est *
"${VAR^^[CHAR]}"        #Même chose mais met chaque lettre matchant CHAR en
                        #uppercase.
"${VAR,[CHAR]}"         #Même chose mais lowercase
"${VAR,,[CHAR]}"        #Même chose mais lowercase
"${VAR~[CHAR]}"         #Même chose mais inversion de casse
"${VAR~~[CHAR]}"        #Même chose mais inversion de casse

                                  ┌────────────────────────┐
                                  │   REGEXP ET GLOBBING   │
                                  └────────────────────────┘

REGEXPS ==>             #Only used with [[ =~ ]]

GLOBBING ==>            #Can be used in:
                        #  - [ ... ] tests
                        #  - [[ ... ]] tests, only right-side and == != =
                        #  - PATTERNs, e.g. in ${VAR/PATTERN/STR}
                        #  - command arguments
                        #File expansion with * ** only happens in last case
                        #  - matches regular files + directories
                        #  - does not follow symlinks

shopt -s nocaseglob     #Case-insensitive globbing
shopt -s nullglob       #Enable nullglob, i.e. non-matching globbing becomes "" instead of kept as is
shopt -s dotglob        #Enable dotglob for *
shopt -s globstar       #Enable **
shopt -s extglob        #Enable extended globbing

*
**
?
[CHAR...]
[!CHAR...]
[^CHAR...]
[...[:CLASS:]...]       #Globbing
@(...|...)
!(...|...)
?(...|...)
*(...|...)
+(...|...)              #Extended globbing

                                  ┌───────────┐
                                  │   FORKS   │
                                  └───────────┘

FORKS   ==>             #Le processus de fork se déroule ainsi :
                        #  1) le shell lanceur (bash) est dupliqué, avec tout
                        #    son environment
                        #  2) il est remplacé par la commande (COMMANDE, ( ),
                        #     etc., qui se ferme lorsqu'arrivée au bout
                        #
                        #Un shell produit par un fork :
                        #  - hérite de l'execution environment (étendu ou
                        #    restreint) de son parent, mais cet environment est
                        #    distinct de celui de son parent. Une fois le fork
                        #    procédé, les deux environments n'interagissent plus
                        #    Il est donc impossible pour un shell enfant de
                        #    modifier l'environment de son parent (et
                        #    inversement, sauf lors de la création de l'enfant)
                        #    Les variables ont donc une portée locale
                        #    Il est possible cependant de renvoyer des variables
                        #    en creant des fichiers temporaires pour les
                        #    sauvegarder
                        #  - initialise ou non ensuite les builtins variables
                        #  - renvoie cependant un exit code à son parent
                        #
                        #Par execution environment restreint, on entend :
                        #  - ensemble des variables exportées (hérite également
                        #    des modifications des variables exportées même sans
                        #    nouvelle exportation) : "environnement"
                        #  - variables Bash par défaut, non modifiées puis
                        #    exportées
                        #  - répertoire courant
                        #  - umask
                        #  - redirections produites par un exec
                        #Par execution environnement étendu, on entend
                        #également :
                        #  - ensemble des variables, exportées ou non
                        #  - ensemble des trap
                        #  - options de bash (simple et complexes)
                        #  - aliases
                        #
                        #Ne forkent pas :
                        #  - les fonctions
                        #  - les boucles et structures
                        #  - les built-in commandes
                        #  - les commandes lancees avec exec (mais l'étape 2 a
                        #    lieu)
                        #
                        #Il y a deux manieres de forker :
                        #  - en lancant un nouveau subprocess :
                        #     - lancer un script ou une commande externe, avec
                        #       ou sans &
                        #  - en lançant un subshell :
                        #     - ( COMMANDES )
                        #     - $( ) ou ` `
                        #     - avec | (mais le parent n'est pas la commande à
                        #       gauche de |, mais le shell lui-même. En effet,
                        #       la commande à gauche de | est elle aussi lancée
                        #       dans un nouveau subshell)
                        #
                        #Une commande externe entouree de parentheses par
                        #exemple lancera un subshell, qui lancera lui-même un
                        #nouveau subprocess
                        #Une commande peut lancer un processus puis se terminer
                        #le processus enfant lance continuera a s'executer
                        #(connu sous le nom de "fork and die")
                        #
                        #Les differences entre lancer un subshell et un
                        #subprocess sont les suivantes :
                        #
                        #          SUBPROCESS                   SUBSHELL
                        #
                        #  Execution environnement          Execution
                        #  restreint                        environnement étendu
                        #  Initialise les builtins          N'initialise pas les
                        #  variables                        builtins variables
                        #  $$ change                        $$ ne change pas
                        #  Le PPID change                   Le PPID ne change
                        #                                   pas
                        #  $SHLVL s'incremente              $SHLVL ne change
                        #                                   pas
                        #  $BASH_SUBSHELL == 0              $BASH_SUBSHELL
                        #                                   s'incremente
                        #                                   (sauf |)
                        #  BASHPID change et == $$          BASHPID change et
                        #                                   != $$

source FILE             #Execute FILE sans forker. FILE n'a pas besoin d'avoir
. FILE                  #les droits d'exécution, ni de shebang. FILE est souvent
                        #un fichier de configuration présent dans /etc ou ~/
                        #définissant des variables.
                        #Possibilite donc de passer des arguments, mais $0
                        #reste le meme. Utilise souvent en debut de fichier
                        #pour lancer des scipts de configuration declarant des
                        #variables utilisees par le script lanceur.
                        #La deuxième syntaxe est plus portable.

exec [COMMANDE]         #Exécute COMMANDE sans forker : ainsi COMMANDE remplace
                        #le shell courant (qui se ferme donc à la fin de
                        #COMMANDE).
                        #  - exec $0
                        #permet donc une "récursion" d'un script sans multiplier
                        #ses instances de lui-même
                        #exec sans argument ne fait rien, mais le fait dans le
                        #shell courant sans forker, ainsi toute redirection
                        #qui lui appliquée est appliquée au shell courant (voir
                        #ci-dessus)

export VAR
export VAR="VALEUR"     #Permet aux subprocesses d'hériter de VAR. D'abord
declare -x VAR          #exporter, puis assigner VALEUR à VAR est plus portable
export -f FONCTION      #permet d'exporter une fonction
export -n VAR           #Fait qu'une variable n'est pas exportée aux
                        #subprocesses enfants
export -n VAR=VALEUR    #Même chose, mais réaffecte aussi sa valeur
export -p               #Imprime la liste de toutes les variables exportées

(
  COMMANDES             #bloc de commandes. Lance les COMMANDES dans un sub-
)                       #shell sans lancer une nouvelle instance de Bash

exit [NOMBRE]           #Quitte le sub-shell courant et renvoie le code d'exit
                        #NOMBRE (par défaut 0) au shell parent dans la variable
                        #$?.
                        #Toute commande renvoie un code d'exit : 0 en cas de
                        #succes, 1 en cas d'echec, 2 en cas d'erreur. NOMBRE
                        #doit etre compris entre 0 et 255.
logout NOMBRE           #Même chose mais ne marche que pour les logins shells
if [[ ERREUR ]] ; then
    exit NOMBRE
fi                      #construction pour envoyer un code d'erreur NOMBRE

$?                      #retourne le dernier code d'exit

$$                      #renvoie le PID du shell ou sub-shell. Souvent utile
                        #pour creer un fichier temporaire unique. Ex : a.$$.tmp

                                  ┌─────────────────┐
                                  │   JOB CONTROL   │
                                  └─────────────────┘

set -m                  #Cette option doit être activée pour utiliser le job
                        #control. Elle l'est par défaut en shell interactif,
                        #mais non en shell non-interactif. Le job control est
                        #surtout convénient en console, dans un script, il vaut
                        #mieux manipuler directement les PID.

shopt -s checkjobs      #Cette option a pour effet d'interrompre un premier
                        #exit d'un shell comportant des jobs running (mais non
                        #le second exit)

COMMANDE &              #lance une commande en background. Permet de continuer
                        #le script pendant que la commande procede en même
                        #temps. Permet donc de lancer plusieurs processus en
                        #meme temps, et de stopper/continuer les tâches lancées
                        #en background (job control).
                        #Un processus en background ne lit pas l'entrée standard
                        #du terminal (et donc également les interruptions
                        #clavier)
                        #Une même ligne de commande en background ou en
                        #foreground a le même PGID.
                        #Dans les lignes et commandes qui suivent :
                        #  - une job spécification suivie d'un + signifie qu'il
                        #    s'agit du current job ou last job
                        #  - une job spécification suivie d'un - signifie qu'il
                        #    s'agit du last job
                        #Imprime également une ligne avec :
                        #  - la job specification, un id associé à tous les
                        #    jobs, commençant à 1.
                        #  - le PID du job.
                        #Si set -b est activé, lorsque le job se termine, sont
                        #imprimés :
                        #  - la job spécification
                        #  - "Done"
                        #  - la ligne de commande
                        #De plus, toute trap sur SIGCHLD sera exécutée.
                        #Dans un shell non-interactif, le script s'interrompera
                        #avec un COMMANDE &, si un "wait" ne suit pas derrière.
                        #Les jobs sont l'ensemble des lignes de commande lancées
                        #avec COMMANDES &, ils ont à la fois un PID et un job
                        #spécification, associé à un sub-shell.
                        #Il est possible de mettre une nouvelle ligne de
                        #commande après &, comme s'il s'agissait d'un ";" :
                        #  - COMMANDE & COMMANDE2
                        #équivaut à :
                        #  - COMMANDE & ; COMMANDE2
                        #Dans plusieurs commandes qui vont suivre, JOB_SPEC
                        #fait référence à :

%NOMBRE                 #Job dont la job spécification est NOMBRE (la deuxième
NOMBRE                  #syntaxe ne marche que pour bg, fg et jobs)
%STRING                 #Job dont la ligne de commande commence par STRING
                        #(échoue s'il y a plusieurs candidats)
%?STRING                #Job dont la ligne de commande contient STRING (échoue
                        #s'il y a plusieurs candidats)
%-                      #"Last job" : dernier job (ayant la job spécification
                        #la plus grande)
%%                      #"Current job" : dernier job stoppé en foreground, ou
%+                      #lancé en arrière-plan.

                        #Il est possible aussi de renvoyer les PID des jobs.
                        #D'une part imprimer une JOB_SPEC (par exemple echo %%)
                        #imprime son PID. D'autre part :
$!                      #Renvoie le PID du dernier process lance en background

jobs [JOB_SPEC]         #Imprime pour chaque JOB_SPEC (par défaut tous) du sub-
                        #shell courant :
                        #  - la job spécification
                        #  - le statut : "Running" ou "Stopped"
                        #  - la ligne de commande

-l                      #Imprime également le PID des jobs.
-p                      #N'imprime que les PID des jobs.
-r                      #N'imprime que les running jobs
-s                      #N'imprime que les stopped jobs
-n                      #N'imprime que les jobs dont le statut a changé sans
                        #qu'une ligne avec le statut du job n'ait été imprimée
                        #(par exemple en relançant un job avec bg)

fg [JOB_SPEC]           #  - Place un job en foreground (si ce n'est pas déjà le
JOB_SPEC                #    cas)
                        #  - Relance un job stoppé (si c'est le cas) avec un
                        #    SIGCONT
                        #Imprime également une ligne avec :
                        #  - la job spécification
                        #  - la ligne de commande du job, suivie de &
                        #JOB_SPEC est %% par défaut.
bg [JOB_SPEC]           #Même chose, mais place en background, et le message
JOB_SPEC &              #n'est pas imprimé.

disown [JOB_SPEC]       #Supprime JOB_SPEC (%% par défaut). Un message avec le
                        #PID du job et sa job specification est imprimé.
                        #Envoie en fait SIGHUP
-a                      #Supprime tous les jobs. Les messages comme ci-dessus
                        #sont imprimés pour chaque job
-r                      #Supprime tous les running jobs. Les messages comme
                        #indiquées ci-dessus ne sont pas imprimés
-h                      #Fait que si le shell contrôlant les jobs JOB_SPEC est
                        #éteint (SIGHUP), un signal SIGHUP n'est pas envoyé à
                        #ces derniers JOB_SPEC.

wait [JOB_SPEC]         #Attend jusqu'à ce que JOB_SPEC se soit achevé (tous
                        #les jobs par défaut). Permet d'être sûr qu'un job se
                        #soit complété pour continuer.

suspend                 #Stoppe le sub-shell courant qui peut être un script
CTRL-Z                  #non-interactif, une ligne de commande, etc.), qui
                        #devient un stopped job de son shell parent (par exemple
                        #la console pour une ligne de commande), jusqu'à ce
                        #qu'il reçoive un SIGCONT. Un jobs sur ce job est
                        #effectué. Envoie en fait un SIGTSTP
                        #Stopper une commande via CTRL-Z est la base du job
                        #control en console (sinon les autres commandes seraient
                        #bien moins utiles)

coproc [VAR] COMMANDE   #Exécute COMMANDE en background, en connectant son input
                        #et son output au shell courant via une pipe disponible
                        #via ${VAR[@]}. VAR est par défaut COPROC, et ne peut
                        #être nommé explicitement que si COMMANDE est une
                        #structure, boucle ou bloc.
                        #L'input de COMMANDE est redirigé depuis les file
                        #descriptors (seulement le nombre du fd, pas son chemin)
                        #${VAR[1]} et son output rediriger vers ${VAR[0]}.
                        #Ainsi, le shell courant peut utiliser par exemple :
                        #  - >&${VAR[1]}
                        #  - read -u ${VAR[0]}
                        #La redirection a lieu avant toute autre redirection
                        #dans COMMANDE. Par exemple, si COMMANDE est sous la
                        #forme COMMANDE 2>&1, stderr pointera vers ${VAR[0]}.
                        #VAR est détruit après la fin de COMMANDE.
                        #Attention :
                        #  - on ne peut lancer qu'un coproc à la fois.
                        #  - si COMMANDE s'achève avant que l'on lise son input,
                        #    VAR ne sera plus disponible. On peut faire
                        #    coproc { COMMANDE ; read ; } pour pallier à cela
                        #    par exemple.
                        #  - si COMMANDE utilise stdin pour son exécution, elle
                        #    ne s'arrêtera jamais, un peu comme une named pipe,
                        #    avant d'être tuée via un signal en général, et
                        #    gardera son output en attente d'être lu, agissant
                        #    donc un peu comme une named pipe.
                        #  - cependant, si son ouput est buffered, il ne sera
                        #    que rarement disponible : il faut alors flusher
                        #    l'output (par exemple fflush() de awk) ou faire en
                        #    sorte que l'output ne soit pas full-buffered
                        #    (options spécifiques, stdbuf, etc., cf doc)
                        #  - de même si son input est buffered, COMMANDE n'aura
                        #    pas lieu. Même chose.
                        #  - les backgrounds process n'héritent pas de ${VAR[@]}
