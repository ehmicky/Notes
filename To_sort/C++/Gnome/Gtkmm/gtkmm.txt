
           
   GTKMM   
           

                                  ┌─────────────┐
                                  │   GENERAL   │
                                  └─────────────┘

LIBRAIRIE ET HEADERS ==>#libgtkmm (en C : libgtk)
                        #  - <gtkmm.h>               : header général comprenant tout
                        #  - <gtkmm/accelmap.h>      : AccelMap
                        #  - <gtkmm/volumebutton.h>  : ScaleButton et VolumeButton
                        #  - <gdkmm/devicemanager.h> : DeviceManager et Device
                        #  - <gdkmm/plug.h>          : Plug
                        #  - <gdkmm/socket.h>        : Socket
                        #En C : <gtk.h>, <gtk/gtkaccelmap.h>, etc.
                        #Wrapper c++ de GTK+.
                        #Utilise libsigc++, cairomm, pangomm, atkmm, glibmm.
                        #Compiler avec $(pkg-config gtkmm-VERSION --cflags --libs) (en C : gtk+-VERSION)
NAMESPACE ==>           #Gtk::

IDEE PRINCIPALE ==>     #  - initialiser Gtkmm avec Gtk::Main VAR( argc, argv )
                        #  - instantier une WINDOW, et la lancer via Gtk::Main::run( WINDOW_VAR )
                        #  - WINDOW :
                        #     - CONTAINER (WIDGET pouvant contenir d'autres WIDGET via add() ou pack_*())
                        #     - une fois WIDGET placés, les afficher via WINDOW.show_all()
                        #     - mettre des callbacks aux WIDGET via les signaux

Principales classes :
  - Principal : Main, Object, Widget, Container
  - Window : Window, Dialog, MessageDialog, AboutDialog, Assistant, Plug, Socket
  - Button : Button, ToggleButton, CheckButton, RadioButtonGroup, RadioButton, LinkButton, ScaleButton, VolumeButton
  - Bin : Bin, Frame, AspectFrame, ScrolledWindow, Viewport, Alignment, Expander, EventBox
  - Box : [H|V]Box, [H|V]ButtonBox, Statusbar, InfoBar
  - Container : Layout, Fixed, [H|V]Paned, Table, Grid, Notebook
  - Menu : MenuShell, MenuBar, Menu, MenuItem, CheckMenuItem, RadioMenuItem, SeparatorMenuItem, ImageMenuItem, UIManager
  - Toolbar : ToolShell, Toolbar, ToolPalette, ToolItemGroup, ToolItem, SeparatorToolItem, ToolButton,
    ToggleToolButton, RadioToolButton, RadioToolButton, MenuToolButton
  - Widgets non-container : Switch, [H|V]Separator, Range, [H|V]Scale, [H|V]Scrollbar, Misc, Label, AccelLabel, Image, Arrow,
    Calendar, ProgressBar, Spinner, DrawingArea
  - Non-widgets : Orientable, SizeGroup, Editable, Adjustment, Border, Tooltip, 
  - Entry : Entry, EntryBuffer, SpinButton
  - TreeView : 
  - Action&Accelerators : Activatable, Action, ToggleAction, RadioAction, ActionGroup, AccelGroup, AccelMap, AccelKey
  - Chooser : FontChooser, FontChooserWidget, FontChooserDialog, FontButton, FontSelection, FontSelectionDialog,
    ColorSelection, ColorSelectionDialog, ColorButton, FileChooser, FileFilter, FileChooserWidget, FileChooserDialog,
    FileChooserButton, RecentChooser, RecentFilter, RecentChooserWidget, RecentManager, RecentInfo, RecentChooserMenu,
    RecentAction, AppChooser
  - Icônes : StockID, StockItem, IconSet, IconSource, IconSize
  - TextView : TextView, TextBuffer, TextIter, TagTable, Tag, TextChildAnchor, Mark
  - Drag&Drop : SelectionData, DragContext, TargetEntry, TargetList, Clipboard
  - Builder&Settings : Builder, Buildable, Settings

Plusieurs classes ne sont pas CopyConstructible, ni instantiable :
  - On ne peut donc pas les passer par référence, il faut les passer par adresse.
  - Elles sont créées via une static fonction create(), mais des constructors protected avec les mêmes arguments existent si l'on veut dériver cette classe
  - Utiliser boost::[c]ref( ) si utilisation avec boost::bind

Définitions :
  - PROP :
    - désigne Glib::PropertyProxy<T>. PROPW désigne Glib::PropertyProxy_WriteOnly<T> et PROPR Glib::PropertyProxy_ReadOnly<T>
      - PROP.set_value( T_VAL ), PROP.reset_value(), PROP.get_value() (Si WriteOnly, pas le dernier ; si ReadOnly, seulement le dernier). reset_value() remet à la valeur initiale. Mais il existe un cast operatorT, donc on peut faire PROP = T_VAL directement ou utiliser PROP comme une T_VAL.
    - la plupart des classes définissent des fonctions property_* renvoyant des PROP<T> pour accéder à un membre T de la classe, mais c'est en général redondant avec les setters/getters déjà disponibles. Si ce n'est pas le cas, le property_* est spécifié.
    - Cependant quelque utilité possible :
      - PROP.signal_changed(), signal <void> émit lors d'une modification.
  - USTRING est GLIB::USTRING
  - REFPTR : signifie GLIB::REFPTR
  - {s,g}et signifie que :
    - une fonction set* existe aussi, prenant en argument le type renvoyé par get*. 
    - Si plusieurs arguments, le get* gardera les mêmes arguments, moins celui renvoyé. 
    - Si set* prend un *_VAR, get* renverra un *_ADR
  - Par ailleurs :
    - {g,s}et est l'inverse
    - {[un]s,g}et signifie qu'il y a une fonction unset() qui fait un set() mettant à zero

MVC PATTERN ==>         #Model-view-controller pattern (architectural pattern)
                        #Sépare ("Separation de SOLID"):
                        #  - model : data. Modifier le model peut parfois déclencher des signaux modifiant la view.
                        #  - view : ce que l'user voit et interagit avec. Contient aussi le state, qui lors de sa modification,
                        #    peut déclencher des signaux modifiant comportement du controller. 
                        #  - controller : modifie model et view en fonction de l'input (donné par la view)
                        #Utilisation de Glade sépare view des deux autres (sauf les widgets personnalisés à coder)
                        #Pour séparer ensuite model du controller : avoir une database ou fichier XML avec interface
                        #indépendante. 
                        #Controller désigne alors ensuite les callbacks dans le code.

                                  ┌─────────────┐
                                  │   SIGNAUX   │
                                  └─────────────┘

PREDIC ==>              #Souvent les PREDIC sont en fait des SIGC::SLOT

SIGNAUX ==>             #Plusieurs classes définissent les méthodes suivantes :
....signal_*()          #Lors de l'évévement *, un callback est déclenchée de manière async (event-driven programming) :
                        #renvoie ce callback sous forme de Glib::SignalProxyN<...>. Tout événement à un callback par défaut,
                        #mais celui-ci souvent ne fait rien.
                        #Glib::SignalProxyN<...> est comme sigc::signal<...>, mais avec comme seuls membres SlotType et
                        #connect( SLOTTYPE ). Cf libsigc++.
                        #Le return type du signal est en général void ou bool, et il peut avoir différents arguments (ou pas
                        #d'arguments), cela dépend du signal : on voit cela dans le template <...>.

EQUIVALENT C ==>        #  g_signal_connect( GOBJECT_ADR, "signal", G_CALLBACK( FONC_ADR ), NULL );

PROBLEME AVEC FONCTORS  #Pour faire un connect( FONCTOR ) d'un FONCTOR retournant une valeur, et n'étant pas un des fonctors
NON LIBSIGC++ ==>       #de libsigc++, définir :
                        #  - namespace sigc { SIGC_FUNCTORS_HAVE_RESULT_TYPE }
                        #Préférer utiliser sigc::mem_fun( ), sigc::ptr_fun( ) ou sigc::bind( ) plutôt que leur version boost::
                        #quand c'est possible.
....on_*( [ARGS] )      #Tout signal_*() a une fonction correspondante on_*() prenant en argument ceux pris par le callback.
                        #Il s'agit d'une virtual function protected de type void : la redéfinir modifie le callback par défaut 
                        #pour le signal *
                        #Pour pouvoir le faire, il faut donc être dans la classe même recevant ce signal.

X EVENTS ==>            #  - Il s'agit des signaux _event() de WIDGET.
                        #  - Ils donnent des infos précises sur l'events (par exemple position de la souris) via des Gdk*Event
                        #  - Callback renvoient bool : si true, mettre un callback fait que le callback par défaut ne se 
                        #    produit pas (sauf event_after()). Par exemple, focus_out n'enlevera plus le focus. 
                        #  - parfois impossible d'override le callback par défaut et d'intercepter l'event pour un widget
                        #    donné : par exemple, signal clicked de Button empêche interception du signal button_pressed_event.
                        #    Solution : mettre "false" comme dernier argument à connect(). Cependant, cela peut provoquer 
                        #    effets inattendus.
                        #  - plupart des containers, Separator, enfant de Misc ne peuvent pas recevoir des X Events : les 
                        #    mettre dans une EventBox, et attacher le signal à l'EventBox (non à son enfant)
                        #  - set_events et add_events modifient X events possibles, mais semble-t-il pas besoin (sauf pour
                        #    limiter les X events possibles pour questions de performance)

Ensemble des signaux (si pas de <...>, <void> par défaut) (en général const&, sauf type fondamental et sauf précisé) :
  - PRINCIPAL :
    - WIDGET :
        - show : show()
        - hide : hide()
        - [un]realize : quand le WIDGET a fini d'être instantié
        - [un]map : quand le WIDGET a fini d'être dessiné à l'écran
        - draw <bool, CAIRO::REFPTR<CAIRO::CONTEXT> > : à chaque fois que WIDGET est dessiné à l'écran, c'est-à-dire à chaque
          changement d'apparence. Permet de dessiner dessus. Doit renvoyer false si REFPTR est un smart pointer vide.
        - size_allocate <void,Gdk::Rectangle&> : émit lors du calcul de la taille requise pour le Widget. Modifier Rectangle 
          pour désigner cette taille via appel à WIDGET.set_allocation( GDK::RECTANGLE ). 
          A ne redéfinir que lors d'un Widget personnalisé.
        - delete_event <void,GdkEventAny*> : quand le WIDGET est supprimé. Utile pour une toplevel fenêtre (ex : "Voulez-vous
          sauvegarder ?"). Penser à faire hide() à la fin.
        - state_changed <void, StateType> : quand le state change (focus, survol, désélection, etc.)
        - focus <bool,DirectionType>
        - grab_focus <void>
        - {parent,hierarchy}_changed <void,Widget*>
        - direction_changed <void,TextDirection>
        - screen_changed <void,RefPtr<Gdk::Screen> >
        - popup_menu : popmenu (clic droit par exemple)
        - quiery_tooltip <bool,int,int,bool,RefPtr<Tooltip> > : les deux int sont les coordonnées du pointeur, locales à 
          WIDGET.
          Tooltip est à modifier, et est affiché si l'on renvoie true. Le bool argument indique que le tooltip vient d'un
          mouvementent initié par le clavier, non la souris. Il faut que WIDGET ait indiqué set_has_tooltip() auparavant.
        - X Events (cf plus haut) :
          - event <bool,GdkEvent*> : tout event
          - event_after <void,GdkEvent*> : tout event
          - button_{press,release}_event <bool,GdkEventButton*>
          - scroll_event <bool,GdkEventScroll*>
          - {enter,leave}_notify_event <bool,GdkEventCrossing*> : entrée/sortie du survol
          - key_{press,release}_event <bool,GdkEventKey*>
          - focus_{in,out}_event <bool,GdkEventFocus*>
          - visibility_notify_event <bool,GdkEventVisibility*>
          - configure_event <bool,GdkEventConfigure*> : redimensionnement de la fenêtre (ne marche que sur une WINDOW)
          - motion_notify_event <bool,GdkEventMotion*> : déplacement en survol (ne marche que sur Entry et TextView)
          - [un]map_event <bool,GdkEventAny*> (ne marche que sur WINDOW ?)
          - selection_{clear,request,notify}_event <bool,GdkEventSelection*> (ne parvient pas à faire marcher)
          - property_notify_event <bool,GdkEventProperty*> : ajout ou suppression (ne parvient pas à faire marcher)
      - WIDGET->DRAGNDROP-RELATED :
          - drag_begin <void,RefPtr<Gdk::DragContext> > : début du drag. Cf plus bas.
          - drag_data_get <void,RefPtr<Gdk::DragContext>,SelectionData&,uint,uint> : fin du drag, successful. Cf plus bas.
          - drag_failed <bool,RefPtr<Gdk::DragContext>,DragResult> : fin du drag, si non successful. Cf plus bas.
          - drag_data_delete <void,RefPtr<Gdk::DragContext> > : fin du drag, si successful et ACTION_MOVE. Cf plus bas.
          - drag_end <void,RefPtr<Gdk::DragContext> > : fin du drag, successful ou non. Cf plus bas.
          - drag_motion <bool,RefPtr<Gdk::DragContext>,int,int,uint> : drag bouge d'un pixel dans la zone du drop. Cf plus bas.
          - drag_leave <void,RefPtr<Gdk::DragContext>,uint> : drag quitte la zone du widget après l'avoir survoler. Cf plus 
            bas.
          - drag_data_received <void,RefPtr<Gdk::DragContext>,int,int,SelectionData&,uint,uint> : drop. Cf plus bas.
          - drag_drop <bool,RefPtr<Gdk::DragContext>,int,int,uint> : drop. Cf plus bas.
    - CONTAINER :
        - add <Widget*> : add()
        - remove <Widget*> : remove()
  - WINDOW :
    - WINDOW :
        - set_focus <vois,Widget*> : lorsque le focus est donné à un nouveau WIDGET
    - DIALOG : response <void,GtkResponseType> : clic sur un BUTTON ajouté via add_button()
    - ASSISTANT :
        - apply : clic sur un bouton "Apply"
        - cancel : clic sur un bouton "Cancel"
        - close : clic sur un bouton "Close"
        - prepare <void,Widget*> : changement de page. WIDGET_ADR est le widget principal de la page.
    - PLUG :
        - embedded : lors d'une connection de SOCKET
    - SOCKET : 
        - plug_added
        - plug_removed <bool>
  - BUTTON :
    - BUTTON : 
        - clicked, pressed
        - released
        - enter : mouse over
        - leave : mouse out
        - activate : déclenché par clicked
    - TOGGLEBUTTON : toggled
    - RADIOBUTTON : group_changed
    - LINKBUTTON : activate_link <bool>
    - SCALEBUTTON : value_changed <void,double>
  - BOX :
    - STATUSBAR : 
        - text_pushed <uint,ustring> : uint est le stack id
        - text_popped <uint,ustring>
    - INFOBAR : response <void,GtkResponseType> : clic sur un BUTTON ajouté via add_button()
  - CONTAINER :
    - NOTEBOOK :
        - switch_page <WIDGET*, UINT> : chaque changement de tab (dont tout début)(UINT est le numéro du nouvel onglet, WIDGET son WIDGET)
        - page_added <WIDGET*, UINT>
        - page_removed <WIDGET*, UINT>
        - page_reordered <WIDGET*, UINT>
  - WIDGETS NON-CONTAINERS :
    - CALENDAR :
        - month_changed
        - {prev,next}_{month,year}
        - day_selected
        - day_selected_double_click
  - MENU :
    - MENUSHELL :
        - deactivate : deactivate()
        - selection_done : choix + validation d'un MenuItem sans submenus
    - UIMANAGER :
        - add_widget <void,Widget*>
        - actions_changed
        - pre_activate <void,RefPtr<Action> > : avant l'émission d'un signal activate
        - post_activate <void,RefPtr<Action> > 
  - TOOLBAR :
    - TOOLSHELL :
        - orientation_changed <void,Orientation>
        - toolbar_style_changed <void,ToolbarStyle>
  - ENTRY :
    - ENTRY :
        - activate : touche entrée
        - icon_{press,release} <void,EntryIconPosition,GdkEventButton const*> : clic sur l'un des icônes
    - ENTRYBUFFER :
        - inserted_text <uint, STR, uint> : comme signal insert_text, sauf que premier UINT est position du premier 
          caractère
        - deleted_text <void,uint,uint> : comme signal delete_text
    - SPINBUTTON :
        - value_changed
        - wrapped : dépasse une limite, si get_wrap()
  - TREEVIEW :
    - TREEVIEW :
        - cursor_changed : changement de la sélection courante
    - TREEVIEWCOLUMN :
        - clicked : clic sur colonne (si set_headers_clickable())
    - CELLRENDERER :
        - editing_started <void,CellEditable*,ustring>
        - editing_canceled
    - TREESELECTION :
        - changed
    - TREESORTABLE :
        - sort_column_changed
    - TREEMODEL :
        - row_changed <void, TreePath, TreeIter>
        - row_inserted <void, TreePath, TreeIter>
        - row_deleted <void, TreePath>
        - row_has_child_toggled <void, TreePath, TreeIter>
        - row_reordered <void, TreePath, TreeIter, int*>
  - NON-WIDGET :
    - EDITABLE :
        - changed : chaque insertion ou suppression (dont multicaractère, via sélection, copier/coller, etc.)
        - insert_text <void, ustring, int*> : chaque insertion (USTRING : texte inséré, INT_ADR : position du dernier
          caractère inséré)
        - delete_text <void,int,int> : chaque suppression (INT1 : position du premier caractère supprimé - 1, INT2 : 
          position du dernier caractère supprimé)
    - ADJUSTMENT :
        - value_changed : value modifiée
        - changed : modification (autre que valeur)
    - RANGE :
        - value_changed : value modifiée
    - LABEL :
        - activate_link <bool,ustring>
  - ACTION&ACCELERATOR-RELATED :
    - ACCELGROUP :
        - accel_activate <bool, RefPtr<Glib::Object>, uint, Gdk::ModifierType> : activation de l'un des accelerators
          de l'AccelGroup. guint et ModifierType est la touche, Object l'objet activated. Ne semble pas marcher.
        - accel_changed <void, uint, Gdk::ModifierType, GClosure*> : changement de l'AccelGroup
    - ACTION :
        - activate : activate() de l'ACTIVATABLE associé
    - TOGGLEACTION :
        - toggled : toggled() de l'ACTIVATABLE associé
    - RADIOACTION :
        - changed
  - CHOOSER :
    - FONTBUTTON : font_set : quand une police est sélectionnée
    - COLORSELECTION : color_changed : nouvelle couleur sélectionnée (clic pressed, clic maintenu en bougeant la souris, et clic released)
    - COLORBUTTON : color_set : quand une couleur est sélectionnée
    - FILECHOOSER : 
        - file_activated : choix d'un fichier non-répertoire + validation (touche Entrée, double clic)
        - current_folder_changer : changement de répertoire courante (le déclenche parfois plusieurs fois)
        - selection_changed : current_folder_changer ou clic sur un nouveau fichier (dont fichier régulier)
        - confirm_overwrite : confirmation d'un overwrite
        - update_preview : émis quand le preview widget devrait être updaté
    - FILECHOOSERBUTTON : file_set : quand un fichier est sélectionné
    - RECENTCHOOSER :
        - item_activated : choix d'un fichier + validation (touche Entrée, double clic)
        - selection_changed : changement de sélection
    - RECENTMANAGER :
        - changed : toute modification
        - MENUITEM : activate : lors de la validation (ouverture du submenu si MenuItem avec submenu)
        - CHECKMENUITEM : toggled
        - TOOLBUTTON : clicked
        - TOGGLETOOLBUTTON : toggled
        - MENUTOOLBUTTON : show_menu
  - TEXTVIEW
    - TEXTVIEW :
        - set_anchor : add_child_at_anchor()
    - TEXTBUFFER :
        - {begin,end}_user_action : cf begin_user_action(). Utile pour mettre un undo-historique.
        - insert <void,TextIter,ustring,int> : INT_VAL est le nombre de caractères insérés
        - erase <void,TextIter,TextIter>
        - changed : insert ou erase
        - modified_changed : premier changed
        - apply_tag <void,RefPtr<Tag>,TextIter,TextIter>
        - remove_tag <void,RefPtr<Tag>,TextIter,TextIter>
        - insert_pixbuf <void,TextIter,RefPtr<Gdk::Pixbuf> >
        - insert_child_anchor <void,TextIter,RefPtr<TextChildAnchor> >
        - mark_set <void,TextIter,RefPtr<TextBuffer::Mark> >
        - mark_deleted <void,RefPtr<TextBuffer::Mark> >
    - TAGTABLE : 
        - tag_changed <void, REFPTR<TAG>, bool> : bool est ... ?
        - tag_added <void, REFPTR<TAG> >
        - tag_removed <void, REFPTR<TAG> >

                                  ┌───────────────────────┐
                                  │   MEMORY MANAGEMENT   │
                                  └───────────────────────┘

GENERAL ==>             #Il est préférable de déclarer les WIDGET contenus par une CLASS comme CLASSDT.
                        #Cependant, on a parfois besoin de pointeurs : notamment dans un handler si l'on veut créer des
                        #WIDGET runtime.
                        #On ne peut pas déclarer des WIDGET non-pointeurs dans le scope d'une fonction (dont constructor), si 
                        #ces WIDGET doivent survivre au-delà de cette fonction. En effet, si le WIDGET doit survivre, réduire 
                        #sa lifetime à une fonction provoque des crashs.
                        #Solution : utiliser des pointeurs, mais sans problème de leak memory :
                        #  - CLASS( void )
                        #    {
                        #      WIDGET* WIDGET_ADR( Gtk::manage( new WIDGET( ARGS ) ) );
                        #      add( *WIDGET_ADR );
                        #    }
                        #Problème : les fonctions de la classe ne peuvent pas référer à ce pointeur sans le passer comme
                        #argument.
                        #Grâce à manage, dès que WIDGET_ADR est attaché à un container via add(), pack*, etc., il sera détruit
                        #lors de la destruction de ce container. Et comme il s'agit d'un pointeur : la lifetime de ce
                        #qu'il pointe dépasse celle de la fonction où le pointeur a été déclaré.
                        #Pour les non-WIDGET, souvent :
                        #  - ou ils peuvent être temporaires (ex : StockID)
                        #  - ou il s'agit de base classe qu'on manipule via leur enfant (ex : Editable)
                        #  - ou il faut les instantier via des factory methods et RefPtr : dès que ce RefPtr est assigné à un 
                        #    WIDGET du container, ce WIDGET extend la lifetime de ce REFPTR.

                                  ┌───────────────┐
                                  │   PRINCIPAL   │
                                  └───────────────┘

ObjectBase              #Parent d'Object et Interface. Enfant de sigc::trackable
Glib::Object            #Wrapper autour de GObject (hors interfaces), parent direct de toutes les classes n'étant pas enfant
                        #d'Interface ou de Gtk::Object (donc essentiellement n'étant pas un Widget ni une Interface), à
                        #l'exception de Main, qui n'est enfant que de sigc::trackable.
Object                  #Enfant de Glib::Object.
                        #Parent de Widget, CellRenderer et TreeViewColumn.
Interface               #Wrapper autour d'un parent GObject interface. Parent d'Activatable, AppChooser, Buildable, 
                        #CellEditable, CellLayout, Editable, FileChooser, FontChooser, Orientable, PrintOperationPreview, 
                        #RecentChooser, Scrollable, StyleProvider, ToolShell, TreeDragDest, TreeDragSource, TreeModel, 
                        #TreeSortable.

Main                    #Enfant de sigc::trackable. Son instantiation effectue un init(). L'instantier avant toute autre 
                        #opération. Singleton.
MAIN( argc, argv        #  - effectue un init()
[, BOOL_VAL] )          #  - parse les command-line arguments relatifs à GTK et les enlève d'argv
                        #  - si true (défaut true), effectue un setlocale( LC_ALL, "" ). Cependant, pour le C++, il faut faire
                        #    soi-même aussi un std::locale::global( std::locale( "" ) ) *après* MAIN().
                        #En C : gtk_init( &argc, &argv )
Main::run( WINDOW )     #Lance la main loop en instantiant WINDOW et tous ses membres (mais ne les montre pas : il faut faire 
MAIN.run( WINDOW )      #un show_all() pour les non-WINDOW et un WINDOW.show() pour les WINDOW membres.
                        #On peut invoquer Main::run() à l'intérieur d'une GTK main loop, faisant une main loop récursive.
                        #En C : gtk_main()
Main::quit()            #Quitte la main loop.
                        #En C : doit le lier au signal "delete-event" de la main Window.
Main::level()           #Renvoie le nombre de main loops récursives sous forme d'UINT_VAL.

Widget                  #Enfant de Buildable et Object. Base classe abstraite pour tous les widgets.
WIDGET.show()           #Montre le WIDGET. Tout WIDGET est construit à l'instantiation, mais pas montré : faire show().
                        #Un WIDGET n'est pas montré si son container parent ne l'est pas.
WIDGET.show_all()       #Montre le WIDGET et ses enfants.
WIDGET.hide()           #Contraire de show()
WIDGET.set_visible      #
( [BOOL_VAL] )          #Si true (défaut true), effectue show(), sinon effectue hide().
WIDGET.get_visible()    #Renvoie true si show() a été appelé, et qu'aucun hide() n'a eu lieu entre temps.

WIDGET.grab_focus()     #WIDGET prend le focus. Certains WIDGET ne peuvent pas avoir le focus (par exemple Label)
WIDGET.is_focus()       #Renvoie true si WIDGET a le focus dans sa fenêtre.
WIDGET.has_focus()      #Pareil, mais en plus la fenêtre doit elle-même avoir le focus.
WIDGET.{g,s}et_can_focus#Si false (défaut true), WIDGET ne peut plus avoir le focus (et donc on ne peut plus non plus agir 
( [BOOL_VAL] )          #avec)
WIDGET.grab_default()   #Fait que WIDGET emettra signal activate (clicked pour un Button) à toute pression de Entrée sur cette
                        #fenêtre. Si focus est dans une ENTRY, set_activates_default() doit être à true (défaut false) en plus.
                        #Pour pouvoir faire grab_default(), il faut avoir fait un set_can_default avant.
                        #Par défaut, aucun WIDGET n'est default.
WIDGET.hash_default()   #
WDGT.{g,s}et_can_default#
( [BOOL_VAL] )          #(défaut true) (sinon false)
WIDGET.{g,s}et_receives_#
default( [BOOL_VAL] )   #Fait que grab_default() est appelé tant que WIDGET a le focus (défaut true) (sinon false)
WIDGET.{add,remove}_
modal_grab()            #Fait que WIDGET et ses enfants deviennent seules WIDGETS avec lesquels on peut interagir.
WIDGET.{g,s}et_state    #Parmi (or'd) :
( STATETYPE )           #  - STATE_NORMAL       : non-sélectionné, aucun des autres
                        #  - STATE_ACTIVE       : effectue une action
                        #  - STATE_PRELIGHT     : survol du widget, avec un clic pouvant faire action
                        #  - STATE_SELECTED     : sélectionné 
                        #  - STATE_INSENSITIVE  : non-sensitive
                        #  - STATE_INCONSISTENT : problème
                        #  - STATE_FOCUSED      : a le focus
WIDGET.                 #STATEFLAG : comme STATETYPE, mais STATE_FLAG_*
{g,s}et_state_flags     #Fait que ce STATE est ajouté aux STATE courants du WIDGET. Si true, clear les anciens STATE. 
( STATEFLAG[, BOOL_VAL])#A ne faire que sur des WIDGET dérivés user-defined, pour permettre bon fonctionnement d'autres
                        #fonctions.
WIDGET.{g,s}et_sensitive#Si false (défaut true) (sinon true), WIDGET est visible, mais mis en gris et pas d'interaction
( [BOOL_VAL] )          #possible.
WIDGET.is_sensitive()   #Comme get_sensitive, mais en prenant en compte les parents.

WIDGET.
get_preferred_height    #Renvoie dans les références : dans INT_VAR1 la taille minimale, même après redimensionnement, dans
( 2 INT_VAR )           #INT_VAR2 la taille que GTK choisira, en dehors de toute autre contrainte.
WIDGET.get_preferred_   #
width( 2 INT_VAR )      #Même chose pour largeur.
WIDGET.
get_preferred_*_for_*   #* est "height" si le second est "width", et inversement. Comme get_preferred_*, mais choisit une 
( INT_VAL, ... )        #taille INT_VAL pour le premier *, et calcule le résultat pour le second *
WIDGT.get_request_mode()#Renvoie le SIZEREQUESTMODE parmi : SIZE_REQUEST_{HEIGHT_FOR_WIDTH,WIDTH_FOR_HEIGHT,CONSTANT_SIZE}
                        #décidant si l'on utiliser get_preferred_height_for_width() ou le contraire.
WIDGET.{g,s}et_size_
request( 2 INT_VAL )    #Cf WINDOW.set_size_request()
WIDGET.get_width()      #
WIDGET.get_height()     #
WIDGET.get_allocated_*  #Comme get_*, ne voit pas la différence.   
WIDGT.{g,s}et_allocation# 
( GDK::RECTANGLE )      #Modifie coordonnées locales par rapport à la toplevel WINDOW.
WIDGET.{g,s}et_
{h,v}expand( [BOOL_VAL])#Modifie le fait que le WIDGET prend tout l'espace disponible horizontalement/verticalement.
WIDGET.{g,s}et_{h,v}
expand_set( [BOOL_VAL] )#Modifie le fait que {h,v}expand() sera utilisé
WIDGT.{g,s}et_{h,v}align#
( ALIGN )               #Modifie l'alignement.
WIDGET.{g,s}et_margin_
{top,bottom,left,right} #
( INT_VAL )             #Modifie le padding interne.

WIDGET.get_window()     #Renvoie la GDK::WINDOW sous-jacente à WIDGET, sous forme de REFPTR<GDK::WINDOW>.
                        #Renvoie smart pointer null si WIDGET n'est pas realized : à mettre donc dans un handler du signal
                        #realize de WIDGET (et non d'un de ses parents, sinon c'est la WINDOW de ce parent qui est renvoyée
                        #si WIDGET pas encore realized).
WIDGET.get_parent()     #Renvoie le CONTAINER parent, sous forme de CONTAINER_ADR (NULL si pas de parent)
WIDGET.{g,s}et_
parent_window()         #Equivaut à WIDGET.get_parent()->get_window(), sauf qu'il y a un set*
WIDGET.reparent         #
( WIDGET2_VAR )         #WIDGET2 devient le nouveau parent de WIDGET.
WIDGET.set_parent       #
( WIDGET_VAR )          #A faire seulement lorsque l'on définit son propre Container
WIDGET.unparent()       #Pareil.
WIDGET.is_ancestor      #
( WIDGET2_VAR )         #Renvoie true s'il est son enfant ou dans sa descendance.
WIDGET.get_toplevel()   #Renvoie le toplevel CONTAINER_ADR
WIDGET.get_root_window()#Renvoie la root REFPTR<GDk::WINDOW>
WIDGET.get_is_toplevel()#Renvoie true si WINDOW, INVISIBLE ou PLUGS.
WINDOW.get_visual()     #Renvoie REFPTR<VISUAL>
WINDW.{get,has}_screen()#Sous REFPTR<SCREEN>
WINDOW.get_display()    #Renvoie REFPTR<DISPLAY>

WIDGET.
translate_coordinates   #
( WIDGET2_VAR, 2 INTVAL,#Traduit les coordonnées INT_VAL1,INT_VAL2 locaux à WIDGET en coordonnées INT_VAR1,INT_VAR2 locaux à
2 INT_VAR )             #WIDGET2.
WIDGET.intersect        #
( GDK::RECTANGLE1       #Si GDK::RECTANGLE2, renvoie l'intersection (coordonnées locales selon window principale ?) de 
[, GDK::RECTANGLE2_VAR])#WIDGET et de GDK::RECTANGLE1. Si intersection, renvoie true.
WIDGET.region_intersect #
(REFPTR<CAIRO::REGION> )#Même chose, mais avec une CAIRO::REGION
WIDGET.get_pointer      #
( 2 INT_VAR )           #Cf GDK::WINDOW
WIDGET.{input_,}shape_
combine_region( CAIRO:: #
REFPTR<CAIRO::REGION> ) #Cf GDK::WINDOW.

WIDGET.is_composited()  #Renvoie true si l'on peut utiliser l'alpha channel (true sous Windows en général, true sous Linux si
                        #Compiz ou autre)
WIDGET.get_is_drawable()#
WIDGET.get_realized()   #
WIDGET.get_mapped()     #
WIDGET.{g,s}et_app_
paintable( [BOOL_VAL] ) #Intention de peindre sur WIDGET dans un handler du signal draw
WIDGET.{g,s}et_child_
visible( [BOOL_VAL] )   #Si true, les enfants de WIDGET sont show(), si WIDGET est show()
WIDGET.[un]map()        #A utiliser seulement par des WIDGET personnalisés.

WDGT.create_pango_layout#
( USTRING )             #Cf GDK::WINDOW. En plus, le PANGO::LAYOUT retourné doit pouvoir afficher USTRING.
WIDGET.
create_pango_context()  #Pareil mais pour un PANGO::CONTEXT et ne met pas à jour WIDGET.
WDGT.get_pango_context()#Pareil mais met à jour WIDGET.

WIDGET.{g,s}et_events
( GDK::EVENTMASK )      #Cf GDK::WINDOW
WIDGET.add_events
( GDK::EVENTMASK )      #Pareil, mais en add() (ne fait pas de clear)
WIDGET.*_device_events* #Cf GDK::WINDOW
WIDGET.{g,s}et_
device_enabled          #
( REFPTR<GDK::DEVICE>
[, BOOL_VAL] )          #Si false, DEVICE ne peut plus interagir avec WIDGET.

WIDGET.override_font    #
(PANGO::FONTDESCRIPTION)#Modifie la FONTDESCRIPTION utilisée par défaut pour ce WIDGET (non-récursif)
WIDGET.override_color
(GDK::RGBA[, STATEFLAG])#Pareil mais pour la couleur de police, et peut limiter à un STATEFLAG (par défaut tous)
WIDGET.override_
background_color
(GDK::RGBA[, STATEFLAG])#Pareil mais pour la couleur d'arrière-plan de police.
WIDGET.override_cursor
(GDK::RGBA1, GDK::RGBA2)#Pareil mais pour la couleur du curseur primaire et secondaire d'un Entry ou TextView.
WIDGET.unset_*()        #Supprime l'effet d'override_*()

WIDGET.set_accel_path   #
( USTRING, 
REFPTR<ACCELGROUP> )    #Modifie l'accel path et l'AccelGroup.
WIDGET.add_accelerator  #
( USTRING,              #Modifie l'AccelGroup et attribue un raccourci, pour activer le signal USTRING de WIDGET (sans avoir
REFPTR<ACCELGROUP>,     #à définir d'accel path). Le signal doit activer lui-même "activate", par exemple "clicked". 
UINTVAL,GDK::MODIFIRTYP,#Utiliser get_accel_group()
ACCELFLAGS )            #ACCELFLAGS parmi : ACCEL_{VISIBLE,LOCKED,MASK}
WIDGT.remove_accelerator#
( REFPTR<ACCELGROUP>,
GDk::MODIFIERTYPE )
WIDGET.activate()       #Emet le signal activate si le WIDGET enfant l'a défini.

WIDGET.{g,s}et_tooltip_ #
{text,markup}( USTRING )#Modifie le tooltip, avec ou sans markup HTML.
WDGT.{g,s}et_has_tooltip#
( [BOOL_VAL] )          
WIDGET.
{g,s}et_tooltip_window  #
( WINDOW_VAR )          #Remplace la WINDOW d'arrière-plan des tooltips par défaut (sinon WINDOW vide et jaune)

Widget::{push,pop}_     #Si on définit un Widget perso, et que celui-ci contient lui-même des WIDGET, mais qu'on ne veut pas
composite_child()       #les exposer, faire entre un push* et un pop*
WIDGET.{g,[un]s}et_
composite_name( USTRING)#Nom d'un tel WIDGET

WIDGET.{g,s}et_direction#
( TEXTDIRECTION )       #
Widget::{g,s}et_default_
direction(TEXTDIRECTION)#

WIDGET.get_accessible() #Renvoie le REFPTR<ATK::OBJECT> associé.

Container               #Enfant de Widget. Base classe abstraite pour les containers : widgets pouvant contenir d'autres 
                        #widgets. 
                        #Il est possible pour un container de contenir un WIDGET déjà contenu par un autre container.
CONTAINER.add(WIDGET)   #Ajoute WIDGET dans le CONTAINER
CONTAINER.remove(WIDGET)#Supprime WIDGET dans le CONTAINER
CONTAINER.{s,g}et_  
border_width(UINTVAL)   #Fait que CONTAINER a une inner marge de UINT_VAL pixels par rapport au widget qu'il contient
CONTAINER.
show_all_children       
([BOOL_VAL])            #Comme show_all(), sauf que si false (par défaut true), n'est pas récursif.
CONTAINER.{g,[un]s}et_
focus_chain             #
( VECTOR<WIDGET_ADR> )  #Modifie tab order.
CONTANR.property_child()#PROPW <Widget*>

                                  ┌────────────┐
                                  │   WINDOW   │
                                  └────────────┘

Window                  #Enfant de Bin. Fenêtre. Il s'agit du container "top level" en général.
                        #Ne pas oublier de faire un show_all_children() pour tout WINDOW, donc DIALOG.
                        #Pour ouvrir une WINDOW membre d'une autre WINDOW, suffit de faire un show() (non-bloquant), car déjà
                        #instantiée. Pour fermer celle-ci, faire hide().
                        #Pour mettre un handler sur la fermeture : signal delete_event().
Window::{g,s}et_
default_icon_*          #Equivaut à set_icon_*, mais agit au cas où aucun set_icon_* n'a été appelé (default taskbar icon)
Window::set_auto_
startup_notification    #Mettre false pour un splash screen, puis remettre à true quand la fenêtre principale est prête à être
( [BOOL_VAL] )          #affichée.
Window::list_toplevels()#Renvoie toutes les WINDOW toplevel, sous forme de VECTOR<WINDOW_ADR>
WINDOW( [WINDOWTYPE] )  #WINDOWTYPE est par défaut WINDOW_TOPLEVEL. Si WINDOW_POPUP, quelques changements : notamment pas de
                        #bordure, pas de prise en charge de nombreuses choses. Utilisé non pour les popups, mais pour les
                        #tooltips et MenuItem.
WINDOW.get_window_type()#Renvoie le WindowType de WINDOW : cf GDK::WINDOWTYPE

WINDOW.move( 2 INT_VAL )#Cf GDK::WINDOW
WINDOW.get_position
( INT_VAR1, INT_VAR2 )  #Cf GDK::WINDOW
WINDOW.get_size         #
( 2 INT_VAR )   
WINDOW.{g,s}et_default_ #
size(INT_VAL1, INT_VAL2)#Taille à l'ouverture (si -1 : laissé tel quel).
WINDOW.{g,s}et_geometry_
hints( WIDGET_VAR,      #Comme GDK::WINDOW.set_geometry_hints(), mais pour un WIDGET de la WINDOW (peut être la WINDOW elle-
GEOMETRY, WINDOWHINTS ) #même)
WINDOW.{g,s}et_size_    #
request( 2 INT_VAL )    #Taille minimale (si -1 : pas de minimum)
WINDOW.resize(INT_VAL1, #
INT_VAL2)               #Une valeur de -1 signifie : laisser tel quel.
WINDOW.reshow_          #
with_initial_size()     #hide(), puis show() avec la taille et position initiale.
WINDOW.{g,s}et_resizable#
( BOOL_VAL )            #Si false, impossible de Redimensionner, dont par set_default_size ou autre.
WINDOW.
{g,s}et_has_resize_grip   
( [BOOL_VAL] )          #Si false, pas de corner resize grip (mais supprime pas possibilité de redimensionner)
WINDOW.set_position     #Modifie la position de WINDOW parmi l'enum WindowPosition :
( WINDOWPOSITION )      #  - WIN_POS_NONE : position par défaut.
                        #  - WIN_POS_CENTER[, ALWAYS] : centre de l'écran
                        #  - WIN_POS_CENTER_ON_PARENT : au-dessus de la fenêtre parente, pour une popup
                        #  - WIN_POS_ON_MOUSE : endroit courant de la souris

WINDOW.activate_focus() #Emet signal activate() du WIDGET ayant le focus dans WINDOW, et renvoie true si ok.
WINDOW.{g,s}et_accept_
focus( [BOOL_VAL] )     #Cf GDK::WINDOW
WINDOW.{g,s}et_focus_
on_map( [BOOL_VAL] )    #Cf GDK::WINDOW
WINDOW.{g,[un]s}et_focus#
( WIDGET_VAR )          #WIDGET devient celui ayant le focus dans WINDOW.
WINDW.activate_default()#Comem activate_focus(), mais pour WIDGET default (cf WIDGET.is_default())
WINDOW.[un]set_default  #
( WIDGET_VAR )
WINDOW.{g,s}et_modal    #
( [BOOL_VAL] )
WINDOW.raise()          #

WINDOW.[un]stick()      #
WINDOW.[de]iconify()    #
WINDOW.[un]maximize()   #
WINDOW.[un]fullscreen() #
WINDOW.set_keep_{above,
below}( [BOOL_VAL] )    #
WINDOW.present()        #Fait deiconify(), raise(), show(), déplace WINDOW sur bureau courant et/ou focus() pour que l'user
                        #voit la WINDOW et aie le focus.

WINDOW.{s,g}et_title    #
(USTRING)               #Cf GDK::WINDOW.
WINDOW.{g,s}et_opacity  #
( DOUBLE_VAL )          #Cf GDK::WINDOW
WINDOW.{g,s}et_decorated#
( BOOL_VAL )            #Si false, pas de bordure de fenêtre.

WINDOW.{g,s}et_type_hint#
( GDK::WINDOWTYPEHINT ) #Cf GDK::WINDOW
WINDOW.{g,s}et_skip_
taskbar_hint([BOOL_VAL])#Cf GDK::WINDOW
WINDOW.{g,s}et_skip_
pager_hint( [BOOL_VAL] )#Cf GDK::WINDOW
WINDOW.{g,s}et_urgency_
hint( [BOOL_VAL] )      #Cf GDK::WINDOW

WINDW.{g,s}et_mnemonics_#
visible( [BOOL_VAL] )   #(défaut true) (sinon true)

WINDOW.{g,s}et_screen   #
( REFPTR<SCREEN> )      #Modifie le SCREEN.
WINDOW.get_group()      #Renvoie le REFPTR<WINDOWGROUP> auquel appartient WINDOW. Permet de grouper les WINDOW à des fins
                        #logiques. Un WindowGroup a seulement des fonctions {add,remove}_window( WINDOW_VAR ), et est créé
                        #via WindowGroup::create().

WINDOW.{g,s}et_icon_list
(VECTOR<REFPTR<PIXBUF>>)
WINDOW.{g,s}et_icon
( REFPTR<PIXBUF> )
WINDW.{g,s}et_icon_name
( USTRING )
WNDW.set_icon_from_file #
( STRING )              #Modifie icône de la taskbar. icon_list : choisit en fonction de la taille.

Dialog                  #Enfant de Window, désigne une pop-up window. 
                        #Est composé à l'initialisation d'une VBox vide et d'une ButtonBox, séparés par un HSeparator.
                        #Ne communique qu'un RESPONSETYPE à la fenêtre parente. Pour communiquer un autre objet, le passer
                        #par référence au constructor d'un enfant user-defined de DIALOG.
                        #Pour ouvrir un DIALOG : run() (pas bloquant mais modal), show() (pas bloquant et non modal)
                        #Pour fermer un DIALOG : hide()
DIALOG(USTRING          #Instantie un DIALOG avec le titre STRING, et désigne WINDOW (par défaut aucune) comme son parent.
[,WINDOW][, BOOL_VAL])  #Si true, fenêtre "modale" : la fenêtre parent devient bloquée tant que DIALOG est ouvert.
                        #Eviter fenêtres modales.
DIALOG.run()            #Lance DIALOG et bloque jusqu'à sa fermeture, et renvoie le RESPONSETYPE émit.
DIALOG.response         #Emet le signal "response", avec ResponseType en paramètre, parmi : 
( RESPONSETYPE )        #RESPONSE_{NONE,REJECT,ACCEPT,DELETE_EVENT,OK,CANCEL,CLOSE,YES,NO,APPLY,HELP} (namespace global)
                        #On peut aussi utiliser un autre INT_VAL.
DIALOG.add_button       #Rajoute un BUTTON dans la BUTTONBOX principale, instantié avec USTRING, et le renvoie sous forme de 
( USTRING,              #BUTTON_ADR. Une fois cliqué, ce bouton émettra un signal "response", avec RESPONSE_TYPE en 
RESPONSETYPE )          #paramètre. DIALOG sera parfois fermé, en fonction du RESPONSETYPE.
DIALOG.add_button       #
(STOCKID,RESPONSTYPE)   #Même chose, mais avec un STOCKID remplissant le BUTTON d'un label + image.
DIALOG.add_action_widget#
(WIDGET, RESPONSTYPE)   #Même chose, mais avec un WIDGET.
DIALOG.
set_default_response    #Le WIDGET avec RESPONSETYPE devient celui par défaut appelé lors d'un Entrée. Ne marche pas sur
( RESPONSETYPE )        #certains enfants prédéfinis de Dialog.
DIALOG.
get_widget_for_response #
( RESPONSETYPE )        #Renvoie le WIDGET ayant RESPONSETYPE.
DIALOG.
get_response_for_widget #
( WIDGET )              #Renvoie le RESPONSETYPE de WIDGET.
DIALOG.set_alternative_
button_order_from_array #
(VECTOR<RESPONSETYP>)   #Modifie ordre des boutons.
DIALOG.
set_response_sensitive  #
( RESPONSETYPE          #Appelle set_sensitive( BOOL_VAL ) (défaut true) (sinon true) sur les WIDGET ayant RESPONSETYPE,
[, BOOL_VAL] )          #les désactivant ou non.
DIALG.get_content_area()#Renvoie la VBOX_ADR principale.
DIALOG.get_action_area()#Renvoie la BUTTONBOX_ADR principale.

MessageDialog           #Enfant de Dialog, désigne une popup affichant un message. 
                        #La VBOX principale est composée d'un WIDGET principal (en général une image) et de deux LABEL (le 
                        #deuxième LABEL est vide par défaut). 
                        #La BUTTONBOX ainsi que la VBOX dépendent de l'instantiation.
MESSAGEDIALOG           #Instantie un MESSAGEDIALOG : le premier LABEL est USTRING, l'image dépend de GTK::MESSAGETYPE, les 
( [WINDOW_VAR, ]USTRING #  - WINDOW_VAR est le parent
[,BOOL_VAL1[,MESSAGETYPE#  - USTRING le premier LABEL
[, BUTTONSTYPE          #  - Si BOOL_VAL1 est true, on peut utiliser du Pango markup (défaut false)
[, BOOL_VAL2]]]])       #  - MESSAGETYPE change l'image, parmi MESSAGE_{INFO,WARNING,QUESTION,ERROR,OTHER}. OTHER n'a pas 
                        #    d'image. (défaut MESSAGE_INFO)
                        #  - BUTTONSTYPE change les boutons, parmi BUTTONS_{NONE,OK,CLOSE,CANCEL,YES_NO,OK_CANCEL}. Instantie
                        #    un bouton avec ce même nom, émettant un RESPONSE_* en fonction du nom. NONE : pas de bouton.
                        #    (défaut MESSAGE_OK)
                        #  - Si BOOL_VAL2 est true : fenêtre modale (défaut false)
MESSAGEDIALOG.
set_message             #
( USTRING[, BOOL_VAL] ) #Modifie le premier LABEL. BOOL_VAL est même que BOOL_VAL1 de l'instantiation.
MESSAGEDIALOG.
set_secondary_text      #
( USTRING )             #Pareil pour le second LABEL
MESSAGEDIALOG.
{s,g}et_image
(WIDGET_VAR)            #Modifie le widget principal.
MESSAGEDIALOG.
get_message_area()      #Renvoie la BOX_ADR principale.

AboutDialog             #Enfant de Dialog. About dialog : en général afficher après clic sur "About MyProgram", en bas de la 
                        #teardown list du menu "Help", à droite de la menu bar.
                        #Par défaut juste Button "Close".
                        #Définit une série de {g,s}et_*() :
                        #  - program_name       ( USTRING ) : "Stego++"
                        #  - version            ( USTRING ) : "1.0.1"
                        #  - logo               ( REFPTR<GDK::PIXBUF> )
                        #  - logo_icon_name     ( USTRING ) : utilise un icon name au lieu de PIXBUF
                        #  - comments           ( USTRING ) : "A high-quality steganographic library"
                        #  - website            ( USTRING ) : "http://www.stegopp.com"
                        #  - website_label      ( USTRING ) : "Homepage"
                        #  - copyright          ( USTRING ) : "Copyright © 2001-2006 Joaquin Abela, Paolo Borelli, et al."
                        #  - license            ( USTRING ) : "Stego++ ... texte de la LGPL". Affiché dans un bouton "License"
                        #  - wrap_license       ( BOOL_VAL ): si true, wrap le texte : le faire
                        #  - license_type       ( LICENSE ) : Parmi : LICENSE_{UNKNOWN,CUSTOM,GPL_2_0,GPL_3_0,LGPL_2_1,
                        #                                     LGPL_3_0,BSD,MIT_X11,ARTISTIC}. Annule license(). Préférer
                        #                                     license()
                        #Affiché dans un bouton "Credits" :
                        #  - authors            ( VECTOR<USTRING> )     : "Adrien Amo http://www.aamo.com" "Benabar Bono
                        #                                                 http://bbono.com"
                        #  - documenters        ( VECTOR<USTRING> )     : Pareil
                        #  - artists            ( VECTOR<USTRING> )     : Pareil
                        #  - translation_credits( USTRING )             : "Win Yi (中文)\nHans Mühlen (Deutsch)"

Assistant               #Désigne une fenêtre avec un ensemble de steps.
                        #Avant d'afficher l'ASSISTANT, ne pas oublier de :
                        #  - mettre bien toutes les pages
                        #  - faire un ASSISTANT.show_all_children()
                        #La page index est le numéro du step courant : -1 si ASSISTANT pas lancé, 0 au début, puis 1, 2, etc.
                        #Un step est composé :
                        #  - d'un WIDGET principal : cf *page(), get_nth_page()
                        #  - un titre USTRING affiché à gauche : cf *et_page_title()
                        #Chaque step a des boutons par défaut en fonction de l'ASSISTANTPAGETYPE
                        #  - "Go back"  : revient à dernière page. Bouton apparaissant automatiquement si dernière action a 
                        #                 été un "Continue"
                        #  - "Continue" : invoque next_page(), est grisé si get_page_complete() == false (défaut). Permet
                        #                 de bloquer le flow tant qu'une condition sur la page n'est pas remplise.
                        #  - "Cancel", "Apply" et "Close" : ne fait rien sans handler, mais invoque chacun un signal
                        #L'assistant garde toutes les pages en mémoire => il y a un historique en cas de retour en arrière.
                        #Les différents ASSISTANTPAGETYPE sont :
                        #  - ASSISTANT_PAGE_INTRO    : "Cancel" + "Continue" (défaut pour première page)
                        #  - ASSISTANT_PAGE_CONTENT  : "Cancel" + "Continue" (défaut pour autres pages)
                        #  - ASSISTANT_PAGE_CONFIRM  : "Cancel" + "Apply"    (pas défaut pour dernière page -> le faire)
                        #  - ASSISTANT_PAGE_SUMMARY  : "Close"               (peut aussi servir de dernière page)
                        #  - ASSISTANT_PAGE_PROGRESS : "Cancel"
                        #  - ASSISTANT_PAGE_CUSTOM   : rien
ASSISTANT.insert_page   #
( WIDGET_VAR, INT_VAL ) #Rajoute un step avant le step INT_VAL, dont le WIDGET principal est WIDGET_VAR.
ASSISTANT.append_page   #
( WIDGET_VAR )
ASSISTANT.prepend_page  #
( WIDGET_VAR )
ASSISTANT.remove_page   #
( INT_VAL )
ASSISTANT.get_n_pages() #Renvoie nombre de pages, sous forme d'INT_VAL
ASSISTANT.get_nth_page  #
( INT_VAL )             #Renvoie le WIDGET_ADR principal du step numéro INT_VAL
ASSISTANT.
{g,s}et_current_page    #
( INT_VAL )
ASISTANT.previous_page()#
ASSISTANT.next_page()   #Modifie le page index courant, et montre le step du nouveau page index.
ASSISTANT.              #Modifie le fait que le bouton principal ("Continue", "Apply" ou "Cancel" selon ASSISTANTPAGETYPE,
{g,s}et_page_complete   #mais pas "Close") soit sensitive (défaut true) (sinon false) pour la page dont le WIDGET principal 
( WIDGETVAR[, BOOL_VAL])#est WIDGET_VAR. *get prend un WIDGET_VAR en argument.

ASSISTANT.
{g,s}et_page_title      #
( WIDGET_VAR, USTRING ) #Modifie le titre de la page dont WIDGET_VAR est le widget principal.
ASSISTANT.              
{g,s}et_page_type       #
( WIDGET_VAR            #Modifie les boutons de la page dont WIDGET_VAR est le widget principal, en fonction 
[, ASSISTANTPAGETYPE] ) #d'ASSISTANTPAGETYPE.
ASSISTANT.{add,remove}_
action_widget(WIDGETVAR)#Ajoute/Supprime un WIDGETVAR (en général un bouton) dans la zone à boutons.
ASSISTANT.
set_forward_page_func   #Change la fonction invoquée par bouton "Continue" : invoque PREDIC, prenant un INT_VAL comme 
( PREDIC )              #argument (numéro de page courante), et renvoyant un INT_VAL (numéro de page où aller)

Plug                    #Enfant de Window. La WINDOW est invisible, mais si l'on instantie un SOCKET avec son window id, elle 
                        #est affichée dans SOCKET.
                        #  - Stocker window id de PLUG.
                        #  - Lancer PLUG via Gtk::Main::run( PLUG ) : cela est bloquant.
                        #  - Instantier dans un autre process une SOCKET avec le window id du PLUG, qui est alors affiché dans
                        #    SOCKET.
                        #  - lors de la fermeture de SOCKET, PLUG ferme et Gtk::main::run( PLUG ) quitte.
                        #Pas possible de mettre plus d'un PLUG par SOCKET.
                        #Les window id sont des INT_VAL stockés dans des typedefs nommés WINDOW, namespace global :
                        # ::WINDOW_VAL (différent de GTK::WINDOW et de GDK::WINDOW)
                        #A noter que Qt a le même principe avec le même protocole, ce qui permet de mettre des widgets Qt dans
                        #Gtkmm, et inversement.
PLUG( [[REFPTR<GDK::
DISPLAY>,]::WINDOW_VAL])#Instantie un PLUG dont le window id est ::WINDOW_VAL (par défaut l'id de la fenêtre courante)
PLUG.get_id()           #Renvoie le ::WINDOW_VAL
PLUG.is_embedded()      #Renvoie true si une SOCKET est actuellement connectée.
PLUG.get_socket_window()#Renvoie cette SOCKET sous forme de REFPTR<GDK::WINDOW>, ou 0 si pas connecté.

Socket                  #Enfant de Container. Affiche le contenu d'un PLUG.
SOCKET.add_id           #
( ::WINDOW_VAL )        #Connecte à la plug dont le window id est ::WINDOW_VAL
SOCKET.get_id()         #
SOCKET.get_plug_window()#Comme PLUG.get_socket_window()

                                  ┌────────────┐
                                  │   BUTTON   │
                                  └────────────┘

Button                  #Enfant de Bin et d'Activatable. Bouton.
                        #A un enfant, souvent un label, mais peut aussi avoir un WIDGET (souvent une IMAGE) en plus ou à la
                        #place.
                        #Pour avoir à la fois un label et un WIDGET, mettre gtk_button_images des default Settings à true.
BUTTON(USTRING          
[, BOOL_VAL])           #USTRING est le label. Si true (défaut false) (sinon false), mnemotechnics.
BUTTON.{g,s}et_label    #
( USTRING )             #Modifie le label.
BUTTON.{g,s}et_relief   #Modifie le relief du bouton, hors mouse over : RELIEF_NORMAL (normal), RELIEF_HALF (accentué),
( RELIEFSTYLE )         #RELIEF_NONE (pas de relief)
BUTTON.{g,s}et_image
( WIDGET )              #Modifie le WIDGET.
BUTTON.{g,s}et_use_stock#Si true, set_label() utilise StockID( USTRING ).get_label(), sans le "_", et non USTRING (sinon false)
( [BOOL_VAL] )          #pour le label, et rajoute l'icône associé à ce STOCKID comme WIDGET (défaut true)
BUTTON.set_alignment    #
( FLOAT_VAL1,FLOAT_VAL2)#Modifie l'alignement de l'enfant.
BUTON.set_image_position
( POSITIONTYPE )        #Modifie position du WIDGET par rapport au label.
BUTTON.get_alignment    #
( FLOAT_VAR1,FLOAT_VAR2)#Utilise les références.

ToggleButton            #Enfant de Button : bouton restant activé après relâchement du clic si était désactivé.
TOGGLEBUTTON.{g,s}et_
active([BOOL_VAL])      #TOGGLEBUTTON devient pressé si BOOL_VAL est true (défaut), ou non-pressé sinon.
TOGGLEBUTTON.toggled()  #Toggle le bouton.

CheckButton             #Enfant de ToggleButton, même chose, seule l'apparence change (check box)

RadioButtonGroup        #Groupe de RadioButton. Par défaut un RadioButton créé vient avec son propre groupe.
RadioButton             #Enfant de CheckButton. Cliquer sur l'un décoche les autres du même RadioButton::group
RADIOBUTTON
( RADIOBUTTONGROUP_VAR
[, USTRING[, BOOL_VAL]])#Rajoute RADIOBUTTON à RADIOBUTTONGROUP_VAR
RADIOBUTON.
{g,[re]s}et_group       #
(RADIOBUTTONGROUP_VAR)  #Rajoute RADIOBUTTON à RADIOBUTTONGROUP_VAR
RADIOBUTTON.join_group
( RADIOBUTTON2 )        #Rajoute RADIOBUTTON au GROUP_VAR de RADIOBUTTON2

LinkButton              #Enfant de Button. Bouton avec lien hypertexte + label.
LINKBUTTON( [USTRING1   
[, USTRING2]] )         #USTRING1 est l'URI du lien, USTRING2 le label.
LINKBUTTON.{g,s}et_uri  #
( USTRING )
LINKBUTTON.
{s,g}et_visited()       #Renvoie true si déjà cliqué dessus.

ScaleButton             #Bouton qui affiche une Scale avec un icône "+" en haut et un icône "-" en bas.
                        #Instantiation semble provoquer un bug avec Gtkmm. Solution : utiliser un VolumeButton, ou Glade.
SCALEBUTTON( ICONSIZE,  #ICONSIZE est celui du Bouton. Les DOUBLE_VAL sont le min, max puis step de l'ADJUSTMENT sous-jacent.
3 DOUBLE_VAL,           #Les USTRING sont les icon names de l'icône du bouton : l'icône changera en fonction de la value, de
VECTOR<USTRING> )       #manière uniforme entre le premier icon name et le dernier.
SCALEBUTTON.set_icons   #
( VECTOR<USTRING> )
SCALEBUTON.{g,s}et_value#
( DOUBLE_VAL )          #Value de l'ADJUSTMENT sous-jacent.
SCALEBUTTON.
{g,s}et_adjustment      #
( REFPTR<ADJUSTMENT> )
SCALEBUTTON.get_
{plus,minus}_button()   #Renvoie les icônes "+" ou "-" sous forme de WIDGET_ADR.
SCALEBUTTON.get_popup() #Renvoie le WIDGET_ADR contenant le SCALE.

VolumeButton            #Enfant de ScaleButton, avec un min de 0, max de 100, step de 2, et un ensemble d'icônes de volume 
                        #(je crois "audio-volume*")

                                  ┌─────────┐
                                  │   BIN   │
                                  └─────────┘

Bin                     #Enfant de Container. Base classe abstraite, désignant les containers ne pouvant contenir qu'un seul 
                        #WIDGET.
BIN.remove()            #Supprime le WIDGET du CONTAINER
BIN.get_child()         #Renvoie le WIDGET du CONTAINER, sous forme de WIDGET_ADR.

Frame                   #Enfant de Bin. Encerclant le widget qu'il contient d'un rectangle avec titre
FRAME([USTRING])        #Effectue un set_label( USTRING ) (par défaut "")
FRAME.[un]{g,s}et_label #
(USTRING)               #Modifie le titre de FRAME.
FRAME.set_label_align   #
(ALIGN1, ALIGN2)        #Modifie l'alignement horiz. et vert. du label, parmi ALIGN_{FILL,START,CENTER,END}
FRAME.set_label_align
(DOUBLE_VAL1,DOBLE_VAL2)#Même chose, avec des DOUBLE (0 à 1). Si passage par référence, possibilité de modifier après.
FRAM.{g,s}et_shadow_type
(SHADOWTYPE)            #Modifie le type d'ombre parmi : SHADOW_{NONE,IN,OUT,ETCHED_IN,ETCHED_OUT}

AspectFrame             #Enfant de Frame.
                        #Frame dont le ratio hauteur / largeur est toujours le même (par exemple pour ne pas étirer une image)
                        #Si enfants ne tiennent pas, ils sont tronqués, pas de scrollbars.
ASPECTFRAME([USTRING
[, ALIGN1[, ALIGN2      #Construit un ASPECTFRAME, avec le titre USTRING (par défaut ""), l'alignement horizontal et vertical 
[, FLOAT_VAL            #ALIGN1 et ALIGN2 et le rapport largeur / hauteur FLOAT_VAL. Le ratio est ignoré si BOOL_VAL == false.
[, BOOL_VAL]]]]])       #On peut aussi utiliser des FLOAT_VAL au lieu des ALIGN.
ASPECTFRAME.set( ARGS ) #Comme constructor, même argument, sauf pas d'USTRING.
property_*()            #PROP <float> : xalign, yalign, ratio ; PROP <bool> : obey_child

ScrolledWindow          #Enfant de Bin et de Scrollable. Ajoute des scrollbars horizontale et verticale à son enfant.
                        #Si enfant n'est pas Scrollable lui-même, il faut mettre un VIEWPORT dans SCROLLEDWINDOW, et l'enfant
                        #dans le VIEWPORT.
SCROLLEDWINDOW()        #Constructor vide
SCROLLEDWINDOW
(REFPTR<ADJUSTMENT1>, 
REFPTR<ADJUSTMENT2>)    #Constructor avec deux ADJUSTMENT pour la barre horizontale et verticale.
SCROLLEDWINDOW.
{g,s}et_*adjustment     #
( REFPTR<ADJUSTMENT> )  #Pour hadjustment ou vadjustment.
SCROLLEDWINDOW.
{g,s}et_shadow_type     #
(SHADOWTYPE)            #Modifie le type d'ombre parmi : SHADOW_{NONE,IN,OUT,ETCHED_IN,ETCHED_OUT} (défaut : NONE)
SCROLLEDWINDOW.
{g,s}et_policy
(POLICYTYPE1,POLICYTYP2)#Modifie l'apparition des Scrollbars parmi : POLICY_{NEVER,AUTOMATIC,ALWAYS} (défaut : AUTOMATIC)
SCROLLEDWINDOW.
[un]{g,s}et_placement   #Modifie l'endroit d'apparition des Scrollbars horiz. et vert. pami : CORNER_{BOTTOM,TOP}_{LEFT,RIGHT}
( CORNERTYPE )          #(défaut : BOTTOM_RIGHT)
SCROLLEDWINDOW.
{s,g}et_minimum_content_#Définie une taille minimale pour le WIDGET contenu. Le getter renvoie -1 si pas de taille minimale
{height,width}          #définie.
SCROLLEDWINDOW.
get_{v,h}scrollbar()    #Renvoie la SCROLLBAR_ADR vert. ou horiz. associée.

Viewport                #Enfant de Bin et de Scrollable. Comme un ScrolledWindow, sauf qu'il n'y a pas de scrollbars et qu'il 
                        #faut utiliser les ADJUSTMENT pour scroller.
VIEWPORT
(REFPTR<ADJUSTMENT1>, 
REFPTR<ADJUSTMENT2>)    #Constructor avec deux ADJUSTMENT pour la barre horizontale et verticale.
VIEWPORT.
{g,s}et_shadow_type     #
(SHADOWTYPE)            #Modifie le type d'ombre parmi : SHADOW_{NONE,IN,OUT,ETCHED_IN,ETCHED_OUT} (défaut : NONE)

Alignment               #Enfant de Bin, alignant, rescalant et paddant son enfant.
ALIGNMENT               #Construit un ALIGNMENT, avec un alignement horizontal de FLOAT_VAL1 (de 0 à 1, gauche à droite, par 
([[[[FLOAT_VAL1],       #défaut 0.5), un alignement vertical de FLOAT_VAL2, un fill horizontal de FLOAT_VAL3 (de 0 à 1, 1 le 
FLOAT_VAL2],FLOAT_VAL3],#widget prend toute la place, 0 il prend le moins de place possible, par défaut 1) et un fill vertical 
FLOAT_VAL4])            #de FLOAT_VAL4
ALIGNMENT([[[[ALIGN1], 
ALIGN2], FLOAT_VAL3],
FLOAT_VAL4])            #Même chose, mais en utilisant deux ALIGN
ALIGNMENT.set( ARGS )   #Mêmes arguments et effet que constructor.
ALIGNMENT.set_padding
( 4 UINT_VAL )          #Ajoute un padding aux 4 bords.
ALIGNMENT.get_padding
( 4 UINT_VAR )          #Il s'agit de références.

Expander                #Enfant de Bin. 
                        #Cache ou non son enfant via un triangle.
EXPANDER
( [USTRING[, BOOL_VAL]])#USTRING est le label. Si true (défaut false), mnemotechnics.
EXPANDER.{g,s}et_label  #
( USTRING )             
EXPANDR.
{g,s}et_use_markup      #
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), label utilise markup HTML
EXPANDR.
{g,s}et_label_widget    #
( WIDGET_VAR )          #Utilise WIDGET_VAR comme label.
EXPANDR.
{g,s}et_use_underline   #
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), mnemotechnics.
EXPANDR.{g,s}et_expanded#
( [BOOL_VAL] )          #Si true (défaut true) (sinon true), l'enfant est caché.
EXPANDER.
{g,s}et_resize_toplevel #
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), redissimuler l'enfant réduit taille de fenêtre parente.
EXPANDER.{g,s}et_spacing#
( INT_VAL )             #Modifie espace entre expander et son enfant (défaut 0)
EXPDR.{g,s}et_label_fill#
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), l'enfant a même largeur qu'EXPANDER.

EventBox                #Enfant de Bin. Permet à son enfant de recevoir des X Events (cf plus haut).
EVENTBX.{g,s}et_visible_#Modifie le fait qu'associé à une GDK::WINDOW visible, ou juste une GDK::WINDOW prenant les inputs
window( [BOOL_VAL] )    #(défaut true) (sinon true)
EVENTBOX.{g,s}et_above_
child( [BOOL_VAL] )     #Modifie le fait que sa GDK::WINDOW soit au-dessus (défaut true) (sinon false)

                                  ┌─────────┐
                                  │   BOX   │
                                  └─────────┘

Box                     #Base classe abstraite, enfant de Container et d'Orientable, désignant un container invisible, à 
                        #remplir avec des widgets (dont d'autres Box). 
                        #Il y a deux files : l'une est remplie de haut en bas (ou gauche à droite) avec pack_start(), l'autre 
                        #est remplie de bas en haut (ou droite à gauche) avec pack_end(), et la première file est toujours au-
                        #dessus (ou à gauche) de la seconde.
                        #Préférer utiliser Grid.
BOX( [ORIENTATION] )
BOX.pack_start(WIDGET   #Rajoute WIDGET dans la première file, en fonction de PACKOPTIONS (par défaut PACK_EXPAND_WIDGET),
[, PACKOPTIONS          #avec en haut et en bas de lui (ou à gauche et à droite) une marge (padding) de UINT_VAL pixels (par 
[, UINT_VAL]])          #défaut 0) (qui s'ajoute au padding déclaré à l'instantiation d'une VBOX ou HBOX, mais concerne un 
                        #padding autour, et pas seulement entre les widgets)
BOX.pack_end(WIDGT[...])#Même chose, mais pour la seconde file.
BOX.{g,s}et_spacing     #
(INT_VAL)               #Modifie la marge interne de BOX.

VBox                    #Enfant de Box, packant les widgets de haut en bas. Préférer Box.
VBOX([BOOL_VL[,INT_VL]])#Instantie une VBOX. INT_VAL est la taille (en pixels) de l'espace entre chaque WIDGET contenus par 
                        #VBOX. Pour BOOL_VAL, cf plus haut)

HBox                    #Même chose, mais se rajoute de gauche à droite, et non verticalement. Préférer Box.

ButtonBox               #Base classe abstraite, enfant de Box. Container pour boutons.
BUTTONBOX([ORIENTATION])
BUTTONBOX.{g,s}et_layout
(BUTTONBOXSTYLE)        #Change le layout de BUTTONBOX

HButtonBox              #Enfant de ButtonBox, horizontal.
HBUTTONBOX              
([BUTTONBOXSTYLE        #Instantie un HBUTTONBOX avec des espaces de INT_VAL (par défaut une constante BUTTONBOX_DEFAULT) 
[, INT_VAL]])           #pixels entre chaque widget contenu, et effectue set_layout( BUTTONBOXSTYLE )

VButtonBox              #Comme HButtonBox, mais vertical.

Statusbar               #Enfant de HBox. Contient une Box contenant un Label, lequel est mis à jour avec un stack de messages
                        #que l'on peut push et pop.
                        #Une statusbar peut avoir différents stacks, identifiés par des stack id UINT_VAL et des noms USTRING.
                        #La stack de départ a un id 0, celle qui suit 1, etc.
                        #Chaque méthode permet de de désigner la stack que l'on veut UINT_VAL, et est par défaut 0 (celle de
                        #départ), et non la dernière stack.
                        #La stack affichée est celle du dernier push. Par conséquent, les pop/remove sur autres stacks seront
                        #sur le moment invisible, et seuls ceux sur cette stack seront visible. Pour changer de stack, faire
                        #un push.
STATUSBAR.get_context_id#Renvoie sous forme d'UINT_VAL le stack id du message stack dont le nom est USTRING (le crée si pas
( USTRING )             #encore créé)
STATUSBAR.push          #
( USTRING[, UINT_VAL] ) #Push le message USTRING, et renvoie son message id sous forme d'UINT_VAL.
STATUSBAR.pop([UINTVAL])#Pop le stack de messages.
STATUSBAR.remove_message#
( UINT_VAL[, UINT_VAL] )#Supprime le message dont l'id est UINT_VAL.
STATUSBAR.
remove_all_messages     #
( [UINT_VAL] )          #Supprime tous les messages
STATUSBAR.
get_message_area()      #Renvoie la Box contenant le Label sous forme de WIDGET_ADR.

InfoBar                 #Enfant de HBox. Désigne une barre horizontale affichée temporairement en haut ou en bas d'une 
                        #fenêtre pour donner un message et demander un choix. Moins intrusif qu'un Dialog.
                        #A les mêmes méthodes que Dialog sauf :
                        #  - qu'un constructor vide
                        #  - run()
                        #  - get_widget_for_response()
                        #  - set_alternative_button_order_from_array()
                        #Et rajoute :
                        #  - {g,s}et_message_type( MESSAGETYPE ), agissant comme un MessageDialog.

                                  ┌────────────────┐
                                  │   CONTAINERS   │
                                  └────────────────┘

Layout                  #Enfant de Container et Scrollable. Comme DrawingArea, sauf qu'est Scrollable (peut être mis dans une 
                        #ScrolledWindow par exemple) et est Container : peut rajouter des enfants via add().
LAYOUT.{g,s}et_size     #
( 2 UINT_VAL )          #Modifie la taille.
LAYOUT.put              #
( WIDGET_VAR, 2 INT_VAL)#Place WIDGET à l'endroit (coordonnées locales, coin supérieur gauche) indiqué.
LAYOUT.move             #
( WIDGET_VAR, 2 INT_VAL)#Même chose, mais pour un WIDGET déjà ajouté.

Fixed                   #Enfant de Container. Comme Layout, sauf que pas de *et_size(), et pas Scrollable.

Paned                   #Enfant de Container et d'Orientable. Contient deux enfants, avec un délimiteur entre les deux, que 
                        #l'on peut bouger (dont l'user)
                        #Aucun contour n'est dessiné et il peut donc être utile de mettre les enfants dans des FRAME.
PANED( [ORIENTATION] )
PAND.add{1,2}(WIDGETVAR)#Equivaut à pack{1,2}( SHRINK ).
PANED.pack{1,2}         #Le premier/deuxième widget de PANED devient WIDGET. Si BOOL_VAL2 == true, on peut sortir le WIDGET du
( BOOL_VAL1, BOOL_VAL2 )#champs visible en bougeant au maximum le délimiteur. Si BOOL_VAL1 == false, le WIDGET n'est pas
                        #resized lorsque PANED l'est.
PANED.pack{1,2}         #
( [ATTACHOPTIONS] )     #ATTACHOPTIONS est par défaut EXPAND.
PANED.get_child{1,2}()  #Renvoie le premier/deuxième WIDGET_ADR
PANED.{s,g}et_position  #La position du délimiteur entre les deux WIDGET devient INT_VAL 
(INT_VAL)               #(mesuré en pixels depuis le début de PANED. si INT_VAL est négatif, la position par défaut est 
                        #rétablie)
HPaned                  #Enfant de Paned, horizontal. Préférer Paned.
VPaned                  #Enfant de Paned, vertical. Préférer Paned.

Table                   #Enfant de Container, désignant un tableau de widgets. Préférer Grid.
TABLE([UINT_VAL1        #Construit une TABLE, de UINT_VAL1 lignes (par défaut 1) et UINT_VAL2 colonnes (par défaut 1). Si 
[,UINTVAL2[,BOOL_VAL]]])#BOOL_VAL == true (défaut false), les cellules ont toutes la même taille.
TABL.{s,g}et_homogeneous#
( [BOOL_VAL] )          #Comme BOOL_VAL de l'instantiation.
TABLE.resize            #
( UINT_VAL1, UINT_VAL2 )#Comme UINT_VAL de l'instantiation.
TABLE.get_size          #
( UINT_VAR1, UINT_VAR2 )
TABLE.attach(WIDGET,    #
INT_VAL1, INT_VAL2, 
INT_VAL3, INT_VAL4      #Place WIDGET dans TABLE : horizontalement depuis le début de la colonne INT_VAL1 + 1 à la fin de la 
[, ATTACHOPTIONS1       #colonne INT_VAL2 ; verticalement de même avec INT_VAL3 et INT_VAL4.  Les ATTACHOPTIONS désignent le 
[, ATTACHOPTIONS2       #packing horizontal et vertical (par défaut EXPAND | FILL). INT_VAL5 et INT_VAL6 désignent une marge 
[,INT_VAL5[,INTVAL6]]]])#interne horizontale et verticale (en pixels, 0 par défaut)
TABL.{s,g}et_col_spacing#Une distance de minimum INT_VAL2 est préservée horizontalement entre la colonne INT_VAL1 et 
( INT_VAL1, INT_VAL2 )  #INT_VAL1 + 1. S'ajoute à la marge interne.
TABL.{s,g}et_row_spacing#
( INT_VAL1, INT_VAL2 )  #Même chose verticalement.
TABLE.set_col_spacings  #
( INT_VAL2 )            #Même chose mais pour toutes les colonnes.
TABLE.set_row_spacings  #
( INT_VAL2 )            #Même chose verticalement
TABLE.set_spacings      #
( INT_VAL2 )            #Même chose verticalement + horizontalement
TABLE.get_
default_row_spacing()   #
TABLE.get_
default_col_spacing()   #

Grid                    #Enfant de Container et Orientable. Similaire à Table, mais mieux.
                        #La méthode add() héritée de Container, dépendra de set_orientable() (sinon horizontal), et aura
                        #une largeur ou hauteur de 1.
                        #Il a une dimension 1x1 initialement, laquelle est augmentée en fonction des besoins de attach*
                        #Avoir un WIDGET à 0,0, sinon cela bugue.
GRID.attach             #Place WIDGET à la cellule INT_VAL1,INT_VAL2, pour une largeur d'INT_VAL3 et une hauteur d'INT_VAL4
( WIDGET_VAR, 4 INT_VAL)#cellules.
GRID.attach_next_to     #
( 2 WIDGET_VAR,         #Pareil, sauf que les deux premiers INT_VAL sont la cellule se trouvant à la position POSITIONTYPE
POSITIONTYPE, 2 INT_VAL)#par rapport à WIDGET2.
GRD.{g,s}et_{column,row}#
_homogeneous( BOOL_VAL )#Fait que les colonnes/rows s'étire avec la fenêtre (sinon non)
GRD.{g,s}et_{column,row}#
_spacing( UINT_VAL )    #Modifie le padding entre chaque colonne/row, en pixels (sinon 0)

Notebook                #Enfant de Container. Ensemble d'onglets (index commence à 0). Au début 0 pages.
NOTEBOOK.append_page
(WIDGET[, USTRING1      #Ajoute à la fin des onglets un nouvel onglet contenant WIDGET avec le titre USTRING1. USTRING2 est 
[, USTRING2]])          #affiché en cas de clic droit après un popup_enable(). Par défaut même chose que USTRING1.
NOTEBOOK.append_page
(WIDGET1[, WIDGET2
[, WIDGET3]])           #Même chose sauf que les titres ne sont pas des STRING mais n'importe quel widget que l'on veut
NOTBOK.prepend_page(...)#Comme append_page(...), mais ajoute l'onglet au début.
NOTEBOOK.insert_page
( ..., INT_VAL )        #Comme append_page(...), mais ajoute l'onglet à l'index INT_VAL
NOTEBOOK.remove_page    #
( [INT_VAL] )           #Supprime la page dont l'index est INT_VAL (défaut 0)
NOTEBOOK.remove_page    #
( WIDGET )              #Supprime la page associée au WIDGET principal WIDGET.

NOTEBOOK.
{g,s}et_tab_label_text  #
( WIDGET, USTRING )     #Modifie le titre USTRING de l'onglet dont le WIDGET principal est WIDGET. 
NOTEBOOK.
{g,s}et_tab_label       #
( WIDGET1, WIDGET2 )    #Même chose, mais avec un WIDGET2 comme titre.
NOTEBOOK.*et_menu_label*#Comme *et_tab_label*, mais avec le titre du clic droit, en cas de popup_enable()

NOTEBOOK.get_n_pages()  #Renvoie le nombre d'onglets.
NOTEBOOK.{g,s}et_
current_page( INT_VAL ) #L'onglet courant devient l'onglet numéro INT_VAL.
NOTEBOOK.next_page()    #Va au prochain onglet
NOTEBOOK.prev_page()    #Va au précédent onglet
NOTEBOOK.get_nth_page   #
( INT_VAL )             #Renvoie le WIDGET_ADR principal associé à l'onglet numero INT_VAL
NOTBOOK.page_num(WIDGET)#Renvoie le numéro INT_VAL de l'onglet contenant WIDGET
NOTEBOOK.reorder_child  #
( WIDGET, INT_VAL )     #L'onglet avec WIDGET devient l'onglet numéro INT_VAL.

NOTBOK.{s,g}et_show_tabs#Si false (défaut true) (sinon true), les tabs sont invisibles : l'user ne peut pas changer de tabs,
( [BOOL_VAL] )          #il faut les manipuler via set_current_page, etc.
NOTEBOOK.{s,g}et_tag_pos#
( POSITIONTYPE )        #Change POSITIONTYPE des tabs (sinon POS_TOP)
NOTEBOOK.
{s,g}et_scrollable      #
( [BOOL_VAL] )          #Si true (défaut true) et qu'il y a trop de tabs, on peut les scroller via des flèches.
NOTEBOOK.
{s,g}et_tab_reorderable #Si true (défaut true) (sinon non), l'onglet avec WIDGET peut changer de place via un drag&drop.
( WIDGET[, BOOL_VAL] )  #
NOTEBOOK.
{s,g}et_tab_detachable  #
( WIDGET[, BOOL_VAL] )  #Pareil, mais peut déplacer l'onglet même en dehors de son NOTEBOOK.
NOTEBOOK.
{g,s}et_show_border     #
( [BOOL_VAL] )          #Sensé changé le dessin d'un contour (défaut true), mais ne vois pas la différence.
NOTEBOOK.
{g,s}et_group_name      #
( USTRING )             #Associe NOTEBOOK à un group name USTRING.
NOTEBOOK.popup_enable() #Active le fait de voir une liste des onglets avec un clic droit sur l'un d'entre eux (désactivé par 
                        #défaut).
NOTEBOOK.popup_disable()#Désactive cela.
NOTEBOOK.get_tab_       #
{h,v}border()           #Renvoie le nombre UINT_VAL de pixels de padding du tab.

                                  ┌──────────┐
                                  │   MENU   │
                                  └──────────┘

MenuShell               #Enfant de Container. Base classe abstraite pour Menu et MenuBar.
MENUSHELL.append        #
( MENUITEM_VAR )        #Ajoute MENUITEM_VAR à la fin.
MENUSHELL.prepend       #
( MENUITEM_VAR )        #Ajoute MENUITEM_VAR au début.
MENUSHELL.insert        #
( MENUITEM_VAR, INT_VAL)#Ajoute MENUITEM_VAR à la position INT_VAL.
MENUSHELL.select_item   #
( MENUITEM_VAR )        #Sélectionne MENUITEM_VAR.
MENUSHELL.select_first  #
( [BOOL_VAL] )          #Sélectionne le premier MENUITEM_VAR sauf si false (défaut true) et qu'il est insensitive.
MENUSHELL.deselect()    #Désélectionne le MENUITEM_VAR couramment sélectionné.
MENUSHELL.cancel()      #Me semble identique.
MENUSHELL.activate_item #
(MENUITEM_VAR[,BOOLVAL])#Effectue MENUITEM_VAR.activate(), puis si true (défaut false), deactivate()
MENUSHELL.deactivate()  #Devrait effacer MENUSHELL mais ne semble pas marcher.
MENUSHELL.
get_selected_item()     #Renvoie le MENUITEM sélectionné sous forme de WIDGET_ADR.
MENUSHELL.
get_parent_shell()      #Renvoie le MENU parent de MENUSHELL sous forme de WIDGET_ADR.

MenuBar                 #Enfant de MenuShell. Contient un ensemble de Menu (en fait de MenuItem ayant des submenus)
MENUBAR.
{g,s}et_pack_direction  #
( PACKDIRECTION )       #Modifie le sens du teardown parmi : PACK_DIRECTION_{LTR,RTL,TTB,BTT}
MENUBAR.{g,s}et_child_
pack_direction          #
( PACKDIRECTION )       #Même chose pour les MENU enfants.

Menu                    #Enfant de MenuShell. Désigne une teardrop list, incluse dans une MenuBar.
                        #Contient une suite de MenuItem.
MENU.{g,[un]s}et_title  #
( USTRING )             #Modifie nom de MENU (pas celui affiché comme label).
MENU.popup( [PREDIC, ]  #Pop up un menu contextuel à l'endroit désigné par PREDIC (par défaut souris actuelle). 
UINT_VAL, UINT32_VAL    #PREDIC prend deux INT_VAR à remplir par les coordonnées locales à la root window, + un BOOL_VAR, et
[, REFPTR<GDK::DEVICE>])#ne renvoie rien. 
                        #UINT_VAL est le bouton de souris pressé, et UINT32_VAL le timestamp. Obtenu en général via le 
                        #GDKEVENTBUTTON d'un handler de press_button_event :
                        #  - bool Fonc( GdkEventButton* Var )
                        #    {
                        #      if ( ( Var->type == GDK_BUTTON_PRESS ) && ( Var->button == 3 ) )
                        #      {
                        #        MENU.popup( Var->button, Var->time );
                        #        MENU.show_all();
                        #      }
                        #      return false;
                        #    }
                        #Penser à bien faire MENU.show_all().
MENU.popdown()          #Popdown un menu contextuel ouvert via popup().
MENU.reposition()       #Remet le menu contextuel à la position courante du curseur.
MENU.attach             #Ajoute MENUITEM à MENU, mais en faisant de MENU une sorte de tableau : l'attache entre 
( MENUITEM, 4 UINT_VAL )#UINT_VAL1,UINT_VAL3 et UINT_VAL2,UINT_VAL4
MENU.{g,s}et_active     #
( INT_VAL )             #Modifie le MENUITEM sélectionné.
MENU.get_attach_widget()#Renvoie le WIDGET_ADR parent.
MENU.detach()           #Détache MENU du MENUITEM parent.
MENU.
{g,s}et_tearoff_state   #
( [BOOL_VAL] )          #Si true (défaut true), affiche une popup copie de MENU. Si false, supprime cette popup si créée.
MENU.reorder_child      #
( MENUITEM, INT_VAL )   #

MenuItem                #Enfant de Bin et d'Activatable. 
                        #Désigne un élément d'un Menu. Peut contenir récursivement un Menu lui-même.
                        #L'action à faire lors de sa sélection est défini par les méthodes héritées d'Activatable. Préférer
                        #cela à redéfinir signal activate.
MENUITEM( [USTRING] )   #USTRING est le label affiché (sinon celui de l'ACTION associée)
MENUITEM( [WIDGET] )    #Même chose, mais utilise un WIDGET au lieu d'un label.
MENUITEM.{g,s}et_label  #
( USTRING )             #Modifie le label.
MENUITEM.{g,s}et_submenu#
( MENU_VAR )            #Fait que MENUITEM lance un MENU. Semble provoquer des warnings.
MENUITEM.has_submenu()  #Renvoie true si submenu
MENUITEM.
set_reserve_indicator   #Si true, largeur est celle quand il y a un submenu associé, même sans submenu (défaut true) (sinon
( [BOOL_VAL] )          #false)
MENUITEM.
{s,g}et_right_justified #
( [BOOL_VAL] )          #Si true, alignement à droite (défaut true) (sinon false)
MENUITEM.activate()     #Emet signal activate
MENUITEM.
{g,s}et_use_underline   #
( [BOOL_VAL] )          #Si true, active les mnemotechnics (défaut true) (sinon false)

CheckMenuItem           #Enfant de MenuItem. MenuItem agissant comme une CheckButton.
CHECKMENUITEM
( USTRING[, BOOL_VAL] ) #Si true (défaut false), mnemotechnics.
CHECKMENUITEM.
{g,s}et_active          #
( [BOOL_VAL] )          #Modifie toggle state (défaut true)
CHECKMENUITEM.toggled() #Emet signal toggled.
CHECKMENUITEM.
{g,s}et_draw_as_radio   #
( [BOOL_VAL] )          #Dessine comme un RadioButton et non comme un CheckButton (défaut true) (sinon false)
CHECKMENUITEM.          #Fait que le CHECKMENUITEM devient inconsistent (défaut true) : apparaît toujours faux. A faire si 
{g,s}et_inconsistent    #l'expression à évaluer est pas dans un état "oui" ou "non" mais "erreur", et impossible de mettre 
( [BOOL_VAL] )          #"oui"

RadioMenuItem           #Enfant de CheckMenuItem. MenuItem agissant comme un RadioButton. Mêmes méthodes et signal que 
                        #RadioButton, sauf absence de join_group().

SeparatorMenuItem       #Enfant de MenuItem, étant un séparateur.

ImageMenuItem           #Enfant de MenuItem, étant une image, avec un label à côté.
IMAGEMENUITEM
( [[WIDGET_VAR, ]USTRING
[, BOOL_VAL]] )
IMAGEMENUITEM( STOCKID )
IMAGEMENUITEM.
{g,s}et_image           #
( WIDGET_VAR )          #
IMAGEMENUITEM.
{g,s}et_use_stock       #
( [BOOL_VAL] )          #Cf BUTTON.*et_use_stock()
IMAGEMENUITEM.{g,s}et_
always_show_image       #
( [BOOL_VAL] )          #Modifie le fait que l'image soit affichée (défaut true)

UIManager               #Permet d'instantier des menus et toolbars à partir d'un fichier XML.
                        #Un peu comme Builder, mais seulement pour menus et toolbars.
                        #Tags possibles (et tags qu'ils peuvent contenir) (ui doit toujours être là, en root) :
                        #  - ui                   -> menubar, toolbar, popup, accelerator
                        #  - menubar, menu, popup -> menu, menuitem, separator, placeholder
                        #  - toolbar              -> toolitem, separator, placeholder
                        #Attributs possibles (sinon valeur par défaut) : 
                        #  - name et action (pour menu, menuitem, toolitem, accelerator, où on est obligé de le mettre 
                        #    explicitement) pour tous, sauf ui. name : valeur par défaut == nom du tag. action : valeur par
                        #    défaut == "". action est le "name" d'une Action. Cela modifie label, accelerator, etc. de 
                        #    l'élément. L'Action doit faire partie de l'un des ActionGroup associés à UIMANAGER.
                        #  - position (valeur "top" ou "bot") pour menu, menuitem et toolitem
                        #  - expand (valeur true ou false) pour separator (signifie que si separator est à un des deux bouts,
                        #    il est hidden (défaut))
                        #Placeholder ne représente rien. Popup est menu contextuel (fenêtre popup via clic droit).
                        #"Path" : chaque tag parent est séparé par "/", et le nom du tag est représenté par son "name".
UIManager::create()     #Construit (mais n'instancie pas) le fichier XML dont chemin est USTRING. Renvoie un MergeId
UIMANGR.add_ui_from_file#(UINT_VAL) désignant les éléments courants introduits. Si un fichier a déjà été construit, n'écrase
( USTRING )             #pas mais merge (introduit dans le <ui> root, et merge éléments avec name commun)
UIMANAGER.
add_ui_from_string      #
( USTRING )             #Même chose, mais prend le contenu non dans un fichier, mais dans une string.
UIMANAGER.remove_ui     #Supprime éléments introduits via MergeId UINT_VAL, à moins qu'ils soient présents dans un autre 
( UINT_VAL )            #MergeId
UIMANAGER.add_ui        #
( UINT_VAL, 3 USTRING,  #Rajoute un élément de type UIMANAGERITEMTYPE, avec un Path USTRING1, un name USTRING2 et une
UIMANAGERITEMTYPE )     #action USTRING3. Le MergeId de cette opération est UINT_VAL (l'obtenir via UIMANAGER.new_merge_id())
UIMANAGER.
add_ui_separator*       #Même chose pour un Separator.
UIMANAGER.get_widget    #
( USTRING )             #Renvoie le WIDGET_ADR du fichier XML construit. USTRING est le path de l'élement.
UIMANAGER.get_toplevels #Renvoie un VECTOR<WIDGET_ADR> des éléments toplevel parmi (or'd) : UI_MANAGER_{AUTO,MENUBAR,MENU,
( UIMANAGERITEMTYPE )   #TOOLBAR,PLACEHOLDER,POPUP,MENUITEM,TOOLITEM,SEPARATOR,ACCELERATOR,POPUP_WITH_ACCELS}
UIMANAGER.get_ui()      #Renvoie le fichier XML interne, sous forme d'USTRING.
UIMANAGER.{insert,
remove}_action_group
( REFPTR<ACTIONGROUP> ) #Dis/Associe ACTIONGROUP
UIMANAGER.
get_action_groups()     #Renvoie VECTOR<REFPTR<ACTIONGROUP> >
UIMANAGER.get_action    #
( USTRING )             #Renvoie REFPTR<ACTION> de l'élement dont le path est USTRING.
UIMANAGER.
get_accel_group()       #Renvoie le REFPTR<ACCELGROUP> associé.
UIMANAGER.
{g,s}et_add_tearoffs    #
( [BOOL_VAL] )          #Fait que les menus peuvent être popped out (défaut true) (sinon false)

                                  ┌─────────────┐
                                  │   TOOLBAR   │
                                  └─────────────┘

ToolShell               #Enfant de Glib::Interface. Base classe abstraite pour Toolbar et ToolItemGroup.
TOLSHELL.get_icon_size()#Renvoie ICONSIZE.
TOLSHL.get_orientation()#Renvoie ORIENTATION
TOOLSHELL.
get_text_orientation()  #Renvoie ORIENTATION
TOOLSHELL.
get_text_alignment()    #Renvoie FLOAT_VAL.
TOOLSHELL.
get_text_size_group()   #Renvoie REFPTR<SIZEGROUP> actuel.
TOOLSHELL.
get_ellipsize_mode()    #Renvoie PANGO::ELLIPSIZEMODE
TOOLSHELL.get_style()   #Renvoie TOOLBARSTYLE
TOOLSHELL.
get_relief_style()      #Renvoie RELIEFSTYLE

Toolbar                 #Enfant de Container et de ToolShell. Contient des ToolItem.
TOOLBAR.append(TOOLITEM)
TOOLBAR.append          #
( TOOLBUTTON[, PREDIC] )#PREDIC est le callback du signal clicked.
TOOLBAR.preprend( ... ) #Cf MenuBar
TOOLBAR.insert
( ..., INT_VAL[, ... ] )#Cf MenuBar
TOOLBAR.get_n_items()   #Renvoie le nombre de TOOLITEM, sous forme d'INT_VAL.
TOOLBAR.get_nth_item    #
( INT_VAL )             #Renvoie TOOLITEM_ADR numéro INT_VAL
DRAG&DROP ==>           #Cf Chapitre Drag&Drop

TOLBR.{g,s}et_show_arrow#Si true (défaut true) (sinon true), si TOOLBAR trop petite pour afficher tous ses TOOLITEMS, une 
( [BOOL_VAL] )          #flèche permet d'accéder au reste.
TOOLBAR.{g,[un]s}et_
icon_size( ICONSIZE )   #Modifie la taille des TOOLITEM (défaut ICON_SIZE_LARGE_TOOLBAR)
TOOLBAR.{g,[un]s}et_
toolbar_style           #Modifie le fait de pouvoir afficher des images ou du texte dans les TOOLITEM, parmi :
( TOOLBARSTYLE )        #TOOLBAR_{ICONS,TEXT,BOTH,BOTH_HORIZ} (défaut TOOLBAR_ICONS)
TOLBR.get_relief_style()#Renvoie le RELIEFSTYLE parmi RELIEF_{NORMAL,HALF,NONE}.

ToolPalette             #Enfant de Container, Orientable et Scrollable. Représente un groupe de ToolItemGroup (à rajouter via
                        #add()).
TOOLPALETTE.
{g,s}et_group_position  #
( TOOLITEMGROUP_VAR, 
INT_VAL )               #
TOOLPALETTE.
{g,s}et_expand          #
( TOOLITEMGROUP_VAR
[, BOOL_VAL] )          #(par défaut true) (sinon false)
TOOLPALETTE.
{g,s}et_exclusive       #
( TOOLITEMGROUP_VAR,
BOOL_VAL )              #TOOLITEMGROUP_VAR sera le seul groupe déplié.
TOOLPALETTE.{g,[un]s}et_
icon_size( ICONSIZE )   #
TOOLPALETTE.{g,[un]s}et_
toolbar_style           #
( TOOLBARSTYLE )        #Cf Toolbar
DRAG & DROP ==>         #Cf Chapitre Drag & Drop

ToolItemGroup           #Enfant de ToolShell et de Container. Représente un groupe de ToolItem.
                        #Drag&Drop : cf Chapitre Drag&Drop
TOOLITEMGROUP([USTRING])#USTRING est le label.
TOOLITEMGROUP.
{g,s}et_label( USTRING )#
TOOLITEMGROUP.
{g,s}et_label_widget    #
( WIDGET_VAR )          #Comme set_label(), mais avec un WIDGET (par exemple image).
TOOLITEMGROUP.insert
(TOOLITEM_VAR[,INT_VAL])#INT_VAL est par défaut la dernière position.
TOOLITEMGROUP.
{g,s}et_item_position   #
( TOOLITEM_VAR, INT_VAL)#
TOOLITMGRUP.get_n_item()#
TOOLITMGRUP.get_nth_item#
( INT_VAL )             #Cf Toolbar.
TOOLITEMGROUP.
{g,s}et_ellipsize       #
( PANGO::ELLIPSIZEMODE )
TOOLITEMGROUP.
{g,s}et_header_relief   #
( RELIEFSTYLE )
TOOLITEMGROUP.
{g,s}et_collapsed       #
( [BOOL_VAL] )          #Si true (défaut true), replié.

ToolItem                #Enfant de Bin et d'Activatable. Membre d'une toolbar. Est juste un container vide à remplir.
                        #L'action est celle de clicked pour son enfant ToolButton.
                        #Pour Drag&Drop : cf Chapitre Drag&Drop.
TOOLITEM.
{g,s}et_homogeneous     #
( [BOOL_VAL] )
TOOLITEM.{g,s}et_expand #
( [BOOL_VAL] )          #Comme pour tout container.
TOOLITEM.
{g,s}et_tooltip_text    #
( USTRING )             #Modifie/Ajoute le tooltip
TOOLITEM.
{g,s}et_tooltip_markup  #
( USTRING )             #Pareil, mais markup HTML possible.
TOOLITEM.get*           #Mêmes méthodes que ToolShell (sauf get_style() -> get_relief_style())
TOLITEM.{g,s}et_visible_#
{horizontal,vertical}
( [BOOL_VAL] )          #Si false (défaut true) (sinon true), si l'orientation est horizontale/verticale, TOOLITEM disparaît.
TOOLITEM.
{g,s}et_is_important    #
( [BOOL_VAL] )          #Si false (défaut true), si TOOLBAR_BOTH_HORIZ, seul l'icône sera affiché, pas le texte.

SeparatorToolItem       #Enfant de ToolItem. Séparateur. Si invisible et "expanded", peut permettre d'espacer des ToolItem.
SEPARATORTOOLITEM.
{g,s}et_draw([BOOL_VAL])#Si false (défaut true) (sinon true), devient invisible.

ToolButton              #Enfant de ToolItem, étant un bouton et/ou un label.
TOOLBUTTON( [STOCKID] )
TOOLBUTTON
( [WIDGET[, USTRING]] )
TOOLBUTTON.{g,s}et_label#
( USTRING )
TOOLBUTTON.
{g,s}et_stock_id(STOKID)#
TOOLBUTTON.
{g,s}et_icon_name       #
( USTRING )             #
TOOLBUTTON.{g,s}et_
{icon,label}_widget     #
( WIDGET_VAR )          
TOOLBUTTON.
{g,s}et_use_underline   #
( [BOOL_VAL] )          #Modifie l'utilisation de mnemotechnics (défaut true) (sinon false)

ToggleToolButton        #Enfant de ToolButton, agissant comme un ToggleButton. Mêmes constructors.
TOGGLEBUTTON.
{g,s}et_active          #
( [BOOL_VAL] )          #Modifie le state.

RadioToolButton         #Enfant de ToggleToolButton, agissant comme un RadioButton.
RADIOTOOLBUTTON
( RADIOBUTTONGROUP_VAR,
[USTRING] )
RADIOTOOLBUTTON
( RADIOBUTTONGROUP_VAR,
STOCKID )
RADIOTOOLBUTTON
( WIDGET[, USTRING] )
RADIOTOOLBUTTON.
{g,s}et_group           #
( RADIOBUTTONGROUP_VAR )#Cf RadioButton

MenuToolButton          #Enfant de ToolButton, contenant un Menu, et représenté comme une flèche. Mêmes constructors.
MENUTOOLBUTTON.
{g,s}et_menu( MENU_VAR )
MENUTOOLBUTTON.
set_arrow_tooltip_      #
{text,markup}( USTRING )#Modifie le tooltip (avec ou sans markup HTML)

                                  ┌───────────────────────────┐
                                  │   WIDGETS NON-CONTAINER   │
                                  └───────────────────────────┘

Switch                  #Enfant de Widget et d'Activatable. Désigne un toggle bouton simpliste : "on" ou "off".
SWITCH.{g,s}et_active   #
( [BOOL_VAL] )          #Modifie son toggle state.

Separator               #Enfant d'Orientable et de Widget. Ligne séparant deux WIDGET.
SEPARATOR([ORIENTATION])#Défaut : ORIENTATION_HORIZONTAL

HSeparator              #Enfant de Separator, horizontal. Préférer Separator.

VSeparator              #Enfant de Separator, vertical. Préférer Separator.

Range                   #Enfant de Widget. Base classe pour Scrollbar et Scale. Les deux contiennent :
                        #  - un slider (curseur que l'on fait bouger)
                        #  - un trough (zone dans laquelle évolue le slider)
                        #  - un Adjustment lié, désignant les valeurs numériques associées aux deux derniers. Les remarques de
                        #    Adjustment sur les Scrollable valent pour lui aussi.
RANGE.
[un]{s,g}et_adjustment  #
( REFPTR<ADJUSTMENT> )  #Modifie l'ADJUSTMENT lié.
RANGE.set_range         #
(DOUBLE_VAL1, 
DOUBLE_VAL2)            #Modifie le lower et upper de l'Adjustment.
RANGE.{s,g}et_value     #
(DOUBLE_VAL)            #Modifie la value de l'Adjustment.
RANGE.set_increments    
(DOUBLE_VAL1,DOUBLE_VL2)#Modifie le step_increment et le page_size de l'Adjustment.
RANGE.{s,g}et_round_    #
digits( INT_VAL )       #Modifie le nombre de chiffres décimaux de la troncature à chaque changement de value. Marche pas ?
RANGE.{s,g}et_flippable #
( BOOL_VAL )            #Modifie le fait que le RANGE est inverted si sa direction est TEXT_DIR_RTL.
RANGE.{s,g}et_slider_   #
size_fixed( BOOL_VAL )  #Modifie le fait que la taille du slider dépend de la page_size de l'Adjustment.
RANGE.{s,g}et_min_slider_size(  )

Scale                   #Enfant de Range, désigne une barre avec un curseur pour choisir une valeur. 
SCALE
([[REFPTR<ADJUSTMENT>, ]
ORIENTATION] )          #ORIENTATION est par défaut ORIENTATION_HORIZONTAL.
SCALE.{s,g}et_digits    #Modifie la précision décimale (telle qu'affichée, mais aussi telle qu'arrondie après chaque 
(INT_VAL)               #changement)
SCALE.{s,g}et_draw_value
([BOOL_VAL])            #Si BOOL_VAL est true (défaut), la valeur est affichée à côté du Scale.
SCALE.{s,g}et_value_pos
(POSITIONTYPE)          #Change la position de la valeur affichée par rapport au Scale, parmi : POS_{LEFT,RIGHT,TOP,BOTTOM}
SCALE.add_mark(DOUBL_VL,
POSITIONTYPE, USTRING ) #Ajoute un trait/marqueur pour la valeur DOUBLE_VAL, avec le label USTRING.
SCALE.clear_marks()     #Supprime tous les marqueurs.

HScale                  #Scale horizontal, enfant de Scale. Préférer Scale.
HSCALE(DOUBLE_VAL1,     
DOUBLE_VAL2, DOUBLE_VL3)#Instantie un HSCALE, dont le range va de DOUBLE_VAL1 à DOUBLE_VAL2.
HSCL(REFPTR<ADJUSTMENT>)

VScale                  #Comme HScale, mais vertical.

Scrollbar               #Enfant de Range et d'Orientable, désigne une scrollbar. 
SCROLLBAR
( [REFPTR<ADJUSTMENT>   
[, ORIENTATION ]] )     #Pour ORIENTATION : cf Orientable.

HScrollbar              #Enfant de Scrollbar, horizontal. Préférer Scrollbar.
HSCROLLBAR([ADJUSTMENT])

VScrollbar              #Comme HScrollbar, mais vertical. Préférer Scrollbar.

Misc                    #Enfant de Widget. Base classe de Label, Arrow et Image. A les mêmes méthodes qu'Alignment.

Label                   #Enfant de Misc. Simple texte non-éditable par l'user.
                        #Pour mettre des liens hypertextes, utiliser <a href> avec set_markup()
LABEL(USTRING[, ARGS]   #Instantie un LABEL avec le message USTRING.
[, BOOL_VAL])           #ARGS sont 2 FLOAT_VAL ou 2 ALIGN, pour faire même chose que premiers arguments d'ALIGNMENT
                        #Si true (défaut true) (sinon false), mnemotechnics.
LABEL.{s,g}et_text      #
(USTRING)               #Modifie le message.
LABEL.{s,g}et_line_wrap #
([BOOL_VAL])            #Si true, line wrapping (penser à le faire). Par défaut true.
LABEL.{s,g}et_line_wrap
_mode( WRAPMODE )       #Modifie le line wrapping : cf TEXTBUFFER pour enum WRAPMODE.
LABEL.{s,g}et_justify   #
(JUSTIFICATION_VAL)     #L'alignement devient JUSTIFICATION, parmi JUSTIFY_{LEFT,RIGHT,FILL,CENTER}
LABEL.{s,g}et_selectable#
( [BOOL_VAL] )          #Si true, le texte devient sélectionnable pour copier dans le clipboard (défaut true).
LABEL.{g,s}et_ellipsize #
( PANGO::ELLIPSIZEMODE )
LABEL.{s,g}et_angle
( DOUBLE_VAL )          #Modifie rotation du texte : ne doit pas être line_wrapped, selectable ou ellipsized.
LABEL.set_pattern(USTRG)#Chaque caractère d'USTRING étant un underscore fera que le texte de LABEL à la même position sera
                        #souligné. Les caractères non-underscore sont ignorés.

LABL.{s,g}et_width_chars#
( INT_VAL )             #Cf ENTRY.*et_width_chars*
LABL.
{s,g}et_max_width_chars #
( INT_VAL )             #Comme set_width_chars, mais désigne non la largeur initiale, mais maximale
LABEL.select_region
( INT_VAL1[, INT_VAL2] )#Modifie la sélection courante (INT_VAL2 par défaut le dernier caractère).
LBL.get_selection_bounds
( INT_VAR1, INT_VAR2 )  #Cf TEXTBUFFER.get_selection_bounds()

LABEL.set_markup        #
( USTRING )             #Comme set_text, mais peut utiliser du Pango markup.
LABEL.{s,g}et_use_markup#
( BOOL_VAL )            #Fait que set_markup n'agit pas comme set_text (sinon false)
LABEL.{g,s}et_attributes#
( PANGO::ATTRLIST )     #Attribue un formattage PANGO::ATTRLIST au LABEL.
LABEL.
{g,s}et_single_line_mode#
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), les newlines sont supprimées.

LABEL.
{g,s}et_use_underline   #
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), mnemotechnics.
LABEL.{g,s}et_mnemonic_ #
widget( WIDGET_VAR )    #Fait que les mnemotechnics activent ce WIDGET. 
LABEL.set_markup_with_
mnemonic( USTRING )     #Comme set_markup, mais avec mnemotechnics.
LABEL.set_text_with_    #
mnemonic( USTRING )     #Comme set_text(), mais avec mnemotechnics
LABEL.
get_mnemonic_keyval()   #Renvoie le caractère utilisé comme mnemotechnic sous forme d'UINT_VAL.

LABEL.get_current_uri() #Renvoie la première URL définie via <a href>, sous forme d'USTRING.
LABEL.{g,s}et_track_    #
visited_links([BOOLVAL])#Fait que les liens cliqués apparaissent dans une autre couleur (défaut true) (sinon false)

LABEL.get_layout()      #Renvoie le REFPTR<PANGO::LAYOUT> utilisé (mais le modifier ne change pas LABEL)
LABEL.get_layout_offsets#
( 2 INT_VAR )           #Renvoie les coordonnées locales par rapport à LABEL du PANGO::LAYOUT utilisé par ce dernier.

AccelLabel              #Enfant de Label, sensé être associé à un WIDGET, et affiché à droite du label l'accelerator de ce
                        #WIDGET, mais ne semble pas marcher.

Image                   #Enfant de Misc. Image.
IMAGE( USTRING )        #L'image est dans le chemin USTRING.
IMAGE( REFPTR<PIXBUF> ) #L'image associée à PIXBUF.
IMAGE( REFPTR<ICONSET>, #Instantie une IMAGE représenté par l'ICONSOURCE d'ICONSET dont l'IconSize est ICONSIZE.
ICONSIZE )              #Si ICONSET n'a aucune ICONSOURCE associé à cet ICONSIZE, prend une autre ICONSOURCE (s'il y en a une),
                        #et la resize en fonction de la taille d'ICONSIZE. Il vaut mieux éviter ce resize, et avoir des images
                        #aux dimensions souhaitées (dont un set d'icône pour chaque taille standard)
IMAGE(STOCKID, ICONSIZE)#L'image est celle du STOCKITEM représenté par STOCKID pour la taille ICONSIZE.
IMAGE.set( ... )        #Mêmes arguments qu'instantiation.
IMAGE.set
( REFPTR<GIO::ICON>, 
ICONSIZE )              #L'image est GIO::ICON
IMAGE.set_from_icon_name#
( USTRING, ICONSIZE )   #Associe à l'ICONSOURCE dont le nom est USTRING, avec une taille ICONSIZE
IMAGE.clear()           #Dissocie l'image.
IMAGE.get_storage_type()#Renvoie type de l'image, parmi : IMAGE_{EMPTY,PIXBUF,STOCK,ICON_SET,ANIMATION,ICON_NAME,GICON}
IMAGE.get_pixbuf()      #Renvoie la REFPTR<PIXBUF>
IMAGE.get_stock         #
( STOCKID, ICONSIZE )   
IMAGE.get_icon_set      #
( REFPTR<ICONSET>, 
ICONSIZE )              #Renvoie dans les références
IMAGE.get_gicon()       #Renvoie le GIO::ICON
IMAGE_get_icon_name()   #Renvoie sous forme d'USTRING

Arrow                   #Enfant de Misc. Flèche.
ARROW( ARROWTYPE,       
SHADOWTYPE )            #ARROWTYPE parmi : ARROW_{UP,RIGHT,LEFT,DOWN,NONE}
ARROW.set( ARGS )       #Mêmes arguments qu'instantiation.

Calendar                #Enfant de Widget. Calendrier.
CALENDAR.get_day        #
( 3 INT_VAR )           #Année, mois puis jour. Renvoie date dans les références.
CALENDAR.get_day        #
( GLIB::DATE_VAR )      #
CALENDAR.select_month
( UINT_VAL1, UINT_VAL2 )#UINT_VAL1 est le mois, UINT_VAL2 est l'année.
CALENDAR.select_day     #
( UINT_VAL )            #
CALENDAR.[un]mark_day   #
( UINT_VAL )            #Fait qu'un jour devienne "marqué" (en gras)
CALENDAR.
get_day_is_marked       #
( UINT_VAL )            #Renvoie true si ce jour est "marqué"
CALENDAR.clear_marks()  #
CALENDAR.               #Modifie les paramètres parmi (or'd) :
set_display_options     #  - CALENDAR_SHOW_HEADING      : montre mois et année (défaut)
(CALENDARDISPLAYOPTIONS)#  - CALENDAR_SHOW_DAY_NAMES    : montre jours de la semaine en haut (défaut)
                        #  - CALENDAR_NO_MONTH_CHANGE   : enlève possibilité de changer de mois/année
                        #  - CALENDAR_SHOW_WEEK_NUMBERS : montre semaine de l'année
                        #  - CALENDAR_SHOW_DETAILS      : cf set_detail_func (défaut)

CALENDAR.set_detail_func#PREDIC prend 3 INT_VAL (année, mois et jour) et renvoie une USTRING. Chaque jour devient gras si
( PREDIC )              #pas de CALENDAR_SHOW_DETAILS, sinon ligne en dessous du jour.
                        #L'USTRING de chaque jour en fonction de PREDIC est affichée sous le jour si CALENDAR_SHOW_DETAILS,
                        #sinon dans une tooltip.
CALENDAR.{g,s}et_
detail_width_chars      #Modifie largeur maximale de l'USTRING de set_detail_func(), si CALENDAR_SHOW_DETAILS, en nombre de
( INT_VAL )             #caractères.
CALENDAR.{g,s}et_
detail_height_rows      #
( INT_VAL )             #Même chose pour la hauteur, en nombre de lignes.

ProgressBar             #Enfant d'Orientable et de Widget. Progress bar.
PROGRESSBAR.{g,s}et_text#
( USTRING )             #Affiche un message USTRING sur la progressbar
PROGRESSBAR.
{g,s}et_show_text       #
( BOOL_VAL )            #
PROGRESSBAR.
{g,s}et_ellipsize       #
( PANGO::ELLIPSIZEMODE )#Change l'ELLIPSIZEMODE du texte, parmi Pango::ELLIPSIZE_{NONE,BEGIN,MIDDLE,END}
PROGRESSBAR.
{g,s}et_fraction        #
( DOUBLE_VAL )          #Le pourcentage de remplissage de la barre devient DOUBLE_VAL (nombre entre 0 et 1)
PROGRESSBAR.pulse()     #Bouge le remplissage indéterminé. Le remplissage indéterminé est un rectangle qui bouge de gauche à 
                        #droite pour indiquer un temps indéterminé. Le pourcentage normal reste en mémoire.
PROGRESSBAR.
{g,s}et_pulse_step      #Modifie le pourcentage de la barre totale dont doit bouger le remplissage indéterminé à chaque 
( DOUBLE_VAL )          #pulse() (entre 0 et 1)
PROGRESSBAR.
{g,s}et_inverted        #
( [BOOL_VAL] )          #Fait que la barre se remplit dans l'autre sens (défaut true) (sinon false)

Spinner                 #Enfant de Widget. Représente une sorte de sablier-like.
SPINNER.start()         #
SPINNER.stop()          #Démarre et arrête le Spinner.

DrawingArea             #Enfant de Widget, widget personnalisable.
                        #Pour utiliser Cairomm à l'intérieur :
                        #  - connecter le signal draw (par exemple virtual fonction on_draw()) et dessiner à l'intérieur de 
                        #    l'handler.
                        #  - il faut assigner une taille à DRAWINGAREA, sinon taille minimale est allouée (1 pixel), via
                        #    set_size_request() ou set_*expand() par exemple.
                        #  - il faut dessiner en fonction de la taille courante (cf méthodes de WIDGET)

                                  ┌────────────────┐
                                  │   NON-WIDGET   │
                                  └────────────────┘

Orientable              #Enfant de Glib::Interface. Désigne l'orientation d'un WIDGET. Parent des enfants définissant une 
                        #version horizontale et verticale (tel que HBox et VBox) : permet de changer cette orientation runtime.
ORIENTABLE.{s,g}et_
orientation(ORIENTATION)#Choix : ORIENTATION_{VERTICAL,HORIZONTAL}

SizeGroup               #Groupe de WIDGET devant avoir la même taille (-> la taille du WIDGET ayant la taille maximale).
SizeGroup::create
( SIZEGROUPMODE )       #Renvoie un REFPTR<SIZEGROUP>
SIZEGROUP.
{add,remove}_widget     #
( WIDGET_VAR )          #
SIZEGROUP.get_widgets() #Renvoie un VECTOR<WIDGET>
SIZEGROUP.{g,s}et_mode  #
( SIZEGROUPMODE )       #Définit quelle taille importe parmi : SIZE_GROUP_{NONE,HORIZONTAL,VERTICAL,BOTH}
SIZEGROUP.
{g,s}et_ignore_hidden   #
( [BOOL_VAL] )          #Si false (défaut true) (sinon true), les WIDGET invisibles ou non mappés sont ignorés.

Editable                #Enfant de Glib::Interface. Base class pour un objet éditable, tel qu'Entry.
                        #Toutes les fonctions, sauf *et_editable, *clipboard et delete_selection, existent sous la forme
                        #*_vfunc( ARGS ), en protected : à faire hériter et redéfinir pour changer comportement.
EDITABL.{s,g}et_editable#
([BOOL_VAL])            #Si false, le champs est read-only (défaut true)
EDITABL.{s,g}et_position#
( INT_VAL )             #Modifie la position du curseur courant.
EDITABLE.select_region  #
( INT_VAL1, INT_VAL2 )  #Comme LAEL.select_region*
EDITABLE.
get_selection_bounds    #
( INT_VAR1, INT_VAR2 )  #Comme TEXTBUFFER.get_selection_bounds*
EDITABLE.get_chars      #
( INT_VAL1, INT_VAL2 )  #Renvoie l'USTRING d'EDITABLE.select_region( ARGS )
EDITABLE.insert_text    #
( USTRING, INT_VAL1,    #
INT_VAR2 )              #Insert les INT_VAL1 premiers caractères d'USTRING à partir de la position INT_VAR2
EDITABLE.delete_text
( INT_VAL1, INT_VAL2 )  #Supprime le texte d'EDITABLE.select_region( ARGS )
EDTBL.delete_selection()#Supprime la sélection courante.
EDITABL.copy_clipboard()#Fait un copier de la sélection courante dans le presse-papier.
EDITABLE.cut_clipboard()#Même chose pour couper.
EDITBL.paste_clipboard()#Même chose pour coller.

Adjustment              #Classe désignant les propriétés d'un range, et l'état actuel du scroll.
                        #Peut être associé à plusieurs WIDGET : par exemple à un Scrollbar et à un TextView.
                        #Non instantiable : utiliser factory method, renvoyant un REFPTR<ADJUSTMENT>
                        #Attaché à un non-Scrollable, la value, upper, etc. sont arbitraires.
                        #Cependant, pour un Scrollable, la valeur correspond au nombre de pixels (1 == 1 pixel).
                        #Pour ces widgets, les attributs d'Adjustment sont donc mis à jour dès changement du widget ou des 
                        #widgets qu'il contient (association au widget ; rajout de widgets ; redimensionnement ; etc.)
                        #Solution :
                        #  - Ne pas modifier donc alors lower() et upper(), mais *_increment().
                        #  - Le faire dépendre de l'espace disponible : ( page_size() - upper() + lower() ) / ratio
                        #  - Le mettre à jour à chaque emission du signal "changed"
                        #Les non-Scrollable ne sont pas mis à jour lors d'un redimensionnement, etc.
Adjustment::create      # - DOUBLE_VAL1 : Valeur initiale du range
(6 DOUBLE_VAL)          # - DOUBLE_VAL2 : Valeur minimale du range
                        # - DOUBLE_VAL3 : Valeur maximale du range
                        # - DOUBLE_VAL4 : Step increment (en utilisant par exemple les flèches sur un SpinButton, ou les
                        #                 touches de flèches) (défaut 1)
                        # - DOUBLE_VAL5 : Page increment (en utilisant par exemple PageUp) (défaut 10)
                        # - DOUBLE_VAL6 : Page size, partie visible du range (défaut 0). Si > upper(), l'ensemble du range est
                        #                 visible. La partie actuellement visible est [value();value()+page_size()[
                        #                 Uniquement pour les Scrollable.
                        #  +-------+--------------------------+    | Partie réelle
                        # lower    |                        upper  |
                        #          <---------------->              | Partie visible (Scrollable uniquement). Peut aller au-délà
                        #       value   page_size                  | de la Partie réelle (bug visuel)
ADJSTMNT.{s,g}et_value()
ADJSTMNT.{s,g}et_lower()
ADJSTMNT.{s,g}et_upper()
ADJUSTMENT.
{s,g}et_step_increment()
ADJUSTMENT.
{s,g}et_page_increment()
ADJUSTMENT.
{s,g}et_page_size()     #Modifie les mêmes valeurs que pour le constructor.
configure( ARGS )       #Même chose, mais avec les 6 arguments.
ADJUSTMENT.changed()
ADJSTMNT.value_changed()#Emet ce signal.

Border                  #Désigne un padding interne.
BORDER.{s,g}et_
{left,right,top,bottom} 
( INT_VAL )             #

Tooltip                 #Classe obtenue via signal quiery_tooltip de WIDGET. Cette classe + ce signal permettent de mettre des
                        #tooltips dynamiques, dépendant par exemple de la position de la souris, et aussi de rajouter des 
                        #icônes.
TOOLTIP.{g,s}et_
{text,markup}( USTRING )#Cf WIDGET
TOOLTIP.set_icon
( REFPTR<PIXBUF> )
TOOLTIP.set_icon( REFPTR#
<GIO::ICON>, ICONSIZE )
TOOLTIP.set_icon_from_  #
stock(STOCKID, ICONSIZE)
TOOLTIP.set_icon_from_  #
icon_name( USTRING, 
ICONSIZE )
TOOLTIP.unset_icon()    #
TOOLTIP.[un]set_custom  #
( WIDGET_VAR )          #Place un WIDGET dans le tooltip.
TOOLTIP.set_tip_area    #
( GDK::RECTANGLE )      #Modifie la zone pouvant avoir du contenu (coordonnées locales au TOOLTIP)

                                  ┌───────────┐
                                  │   ENTRY   │
                                  └───────────┘

Entry                   #Enfant d'Editable, de CellEditable et de Widget. Champs texte d'une seule ligne à remplir par l'user.
ENTRY
( [REFPTR<ENTRYBUFFER>])
ENTR.{s,g}et_text(USTRG)#Modifie le contenu d'Entry.
ENTR.{s,g}et_placeholder#
( USTRING )             #Modifie le texte affiché en demi-teinte lorsque l'ENTRY est vide et unfocused
ENTRY.{s,g}et_buffer
( REFPTR<ENTRYBUFFER> ) #Modifie l'ENTRYBUFFER associé.
ENTRY.{s,g}et_visibility
([BOOL_VAL])            #Si false, les caractères sont masqués (comme pour un password) (défaut true)
ENTRY.
[un]{s,g}et_invisible   #
( WCHAR_VAL )           #Modifie le caractère masquant, via set_visibility (sinon petit rond)
ENTRY.
{s,g}et_overwrite_mode  #
( [BOOL_VAL] )          #Modifie le fait qu'il s'agisse d'un overwrite mode,et non d'un insert mode (défaut true) (sinon false)
ENTRY.{s,g}et_has_frame #
( [BOOL_VAL] )          #Modifie le fait qu'il y ait un contour (défaut true) (sinon false)
ENTRY.{s,g}et_max_length
( INT_VAL )             #Cf TEXTBUFFER.*et_max_length*
ENTRY.get_text_length() #Renvoie nombre de caractères, sous forme d'UINT16_VAL
ENTR.{s,g}et_width_chars#
( INT_VAL )             #La largeur en pixels d'ENTRY devient == celle de 30 caractères moyens.
ENTRY.{s,g}et_alignment
( ALIGN )               #Modifie l'alignement du texte.

ENTRY.get_text_area()   #Renvoie la zone où est affiché l'ENTRYBUFFER par rapport à son parent, sous forme de GDK::RECTANGLE
ENTRY.
{s,g}et_inner_border    #
( BORDER )              #Modifie le padding interne. Semble provoquer des segfault ???
ENTRY.{g,s}et_progress_ #
{fraction,pulse_step,
pulse}( ARGS )          #Comme pour ProgressBar : intègre une PROGRESSBAR dans l'ENTRY.
ENTRY.{g,s}et_
activates_default       #
( [BOOL_VAL] )          #Si true (défaut true), appuyer sur Entrée active le default WIDGET de la fenêtre parente.

ENTRY.get_layout()      #Cf LABEL.get_layout()
ENTRY.get_layout_offsets#
( 2 INT_VAR )           #Cf LABEL.get_layout_offsets()

ENTRY.
set_icon_from_pixbuf    #Ajoute un icône PIXBUF dans l'ENTRY. Sa position est désigné par ENTRYICONPOSITION :
( REFPTR<GDK::PIXBUF>   #ENTRY_ICON_{PRIMARY,SECONDARY} (gauche ou droite, les deux en mêmes temps est possible)
[, ENTRYICONPOSITION] ) #(défaut : ENTRY_ICON_PRIMARY)
ENTR.set_icon_from_stock#
( STOCKID
[, ENTRYICONPOSITION ] )
ENTRY.
set_icon_from_icon_name #
( USTRING
[, ENTRYICONPOSITION] )
ENTRY.
set_icon_from_gicon     #
( REFPTR<GIO::ICON>
[, ENTRYICONPOSITION] ) #Comme set_icon_from_pixbuf(), mais en choisissant l'icône différemment (cf IMAGE.set())
ENTRY.unset_icon    
( [ENTRYICONPOSITION] ) #Supprime l'icône à la position ENTRYICONPOSITION (défaut ENTRY_ICON_PRIMARY)
ENTRY.
get_icon_storage_type   #
( [ENTRYICONPOSITION] ) #Comme IMAGE.get_storage_type(), pour l'icône
ENTRY.get_icon_{pixbuf,
stock,name,gicon}
( [ENTRYICONPOSITION] ) #Comme IMAGE.get*, pour l'icône
ENTRY.
{g,s}et_icon_activatable#
( [BOOL_VAL             #Si true (défaut true) (sinon true), fait que cliquer sur l'icône émettre les signaux icon_press et
[, ENTRYICONPOSITION]] )#icon_release pour l'icône spécifié.
ENTRY.
{g,s}et_icon_sensitive  #
( [ENTRYICONPOSITION    
[, BOOL_VAL]] )         #Si true (défaut true) (sinon false), fait que l'icône spécifié devient non-sensitive.
ENTRY.{g,s}et_icon_
tooltip_{text,markup}   #
( USTRING
[, ENTRYICONPOSITION] ) #Définit/modifie un tooltip, avec ou sans markup HTML.
ENTRY.get_icon_at_pos   #Pour les coordonnées locales indiquées, renvoie -1 si cela ne pointe pas sur un icône, 0 sur le
( INT_VAL1, INT_VAL2 )  #premier icône, et 1 sur le second, sous forme d'INT_VAL.
ENTRY.get_icon_area     #
( [ENTRYICONPOSITION] ) #Renvoie coordonnées locales de l'icône spécifié sous forme de GDK::RECTANGLE
DRAG&DROP DE L'ICONE ==>#Cf Chapitre Drag&Drop

EntryBuffer             #Buffer d'un Entry.
EntryBuffer::create     #
( [USTRING] )
ENTRYBUFFER.{g,s}et_text#
( USTRING )             #Renvoie le texte.
ENTRYBUFFER.
{g,s}et_max_length      #
( INT_VAL )             #Renvoie le nombre de caractères maximal (0 == infini) (sinon 0)
ENTRYBUFFER.get_bytes() #Renvoie le nombre d'octets, sous forme d'UINT_VAL
ENTRYBUFFER.get_length()#Renvoie le nombre de caractères, sous forme d'UINT_VAL
ENTRYBUFFER.insert_text #
( UINT_VAL, USTRING )   #Insert USTRING à la position UINT_VAL
ENTRYBUFFER.delete_text #
( UINT_VAL, INT_VAL )   #Supprime INT_VAL caractères à partir de la position UINT_VAL

SpinButton              #Enfant d'Entry, ajoutant des flèches up & down à droite du champs texte.
SPINBUTTON( ADJUSTMENT  #Le PageIncrement d'ADJUSTMENT fait référence à un clic du milieu sur les flèches. Le PageSize n'est 
[, DOUBLEVAL1[, UINTVL]]#pas utilisé. DOUBLE_VAL1 est la vitesse lors d'un maintien sur la flèche (défaut 0), UINT_VAL le 
                        #nombre de décimales à afficher (défaut 0)
SPINBUTTON.configure    #
( ARGS )                #Modifie arguments donnés à l'instantiation.
SPINBUTTON.{g,[un]s}et_
adjustment              #
( REFPTR<ADJUSTMENT> )  
SPINBUTTON.{g,s}et_value#
( DOUBLE_VAL )          #Modifie la valeur du champs texte.
SPINBUTON.{g,s}et_digits#
( UINT_VAL )            #Modifie nombre de décimales à afficher.
SPINBUTON.set_increments#
( 2 DOUBLE_VAL )        #Modifie le step et page increments.
SPINBUTON.get_increments
( 2 DOUBLE_VAR )        
SPINBUTON.set_range     #
( 2 DOUBLE_VAL )        #Modifie le min et max.
SPINBUTON.get_range     
( 2 DOUBLE_VAR )        
SPINBUTTON.spin         #Effectue une modification SPINTYPE de la valeur du champs texte, d'un montant de DOUBLE_VAL, parmi :
( SPINTYPE, DOUBLE_VAL )#SPIN_{{STEP,PAGE}_{FORWARD,BACKWARD},HOME,END,USER_DEFINED}
SPINBUTTON.
{g,s}et_numeric
( [BOOL_VAL] )          #Si BOOL_VAL == true (défaut true) (sinon false), fait que seuls des chiffres peuvent être entrés
SPINBUTTON.{g,s}et_wrap #Si BOOL_VAL == true (défaut true) (sinon false), fait que aller au-delà d'une limite du range fait 
( [BOOL_VAL] )          #aller dans l'autre limite
SPINBUTTON.             #Modifie la manière de mettre à jour, si la valeur entrée est invalide, parmi : UPDATE_ALWAYS (modifie
{g,s}et_update_policy   #la valeur (qui risque d'être 0) si la valeur entrée est invalide) et UPDATE_IF_VALID (ne change pas 
                        #la valeur si la valeur entrée est invalide) (défaut)
SPINBUTTON.
{g,s}et_snaps_to_ticks  #
( [BOOL_VAL] )          #Si BOOL_VAL == true (défaut true) (sinon true), arrondi les valeurs en fonction du StepIncrement

                                  ┌──────────────┐
                                  │   TREEVIEW   │
                                  └──────────────┘

TreeView                #Enfant de CONTAINER (cependant impossible de faire add()) et de SCROLLABLE. 
                        #Widget montrant graphiquement un TreeModel, ou une partie de celui-ci.
TREEVIEW
( [REFPTR<TREEMODEL>] ) #Le lie à TREEMODEL, mais il faut faire par exemple append* ou insert* pour l'afficher.
TREVIW.{g,[un]s}et_model
( [REFPTR<TREEMODEL>] )
TREEVIEW.append_column  #Affiche la colonne TMC du TREEMODEL, avec un titre USTRING. Renvoie position de la colonne suivante.
( [USTRING, ]TMC<T> )   #Possible d'ajouter deux fois la même colonne.
TREEVIEW.
append_column_editable  #
( USTRING, TMC<T> )     #Pareil, mais l'user peut modifier les champs.
TREEVIEW.               #Comme append_column_*, mais utilise un dernier argument USTRING étant une format string tel que 
append_column_numeric_* #printf permettant de changer impression. Ne marche qu'avec les champs ayant des TOUINT ou TOUFLOAT.
TREEVIEW.append_column  #Rajoute une colonne dont le type est celui désigné par CELLRENDERER. Les autres append_column* 
( USTRING, CELLRENDERER)#devinent par eux-mêmes le CELLRENDERER s'il s'agit de l'un des types déjà disponibles :
                        #ustring (pas STR), tout nombre (hors short et long double) ou RefPtr<Gdk::Pixbuf>. bool est montré 
                        #dans un CheckButton.
                        #Sinon, il faut définir un nouveau CELLRENDERER et utiliser cette méthode. CELLRENDERER peut aussi
                        #permettre un contrôle plus fin du rendu de la cellule (alignement, etc.)
TREEVIEW.insert_column* #Comme append_column* (hors append_column_numeric*), sauf qu'insertion et que dernier argument est un
                        #INT_VAL (la position)
TREEVIEW.remove_column  #
( TMC_VAR )
TREEVIEW.
remove_all_columns()    #
TREEVIEW.
move_column_after       #
( 2 TREECOLUMNVIEW_VAR )
TREEVIEW.
move_column_to_start    #
( TREECOLUMNVIEW_VAR )
TREEVIEW.
get_column( INT_VAL )   #Renvoie le TREEVIEWCOLUMN_ADR de la colonne numero INT_VAL.
TREEVIEW.get_columns()  #Renvoie VECTOR<TREEVIEWCOLUMN_ADR>
TREEVIEW.
get_column_cell_renderer#
( INT_VAL )             #Renvoie le CELLRENDERER_ADR de la colonne numero INT_VAL.

TREEVIEW.get_selection()#Renvoie la sélection courante / paramètres de sélection sous forme de REFPTR<TREESELECTION>
TREEVIEW.
{g,s}et_headers_visible #
( [BOOL_VAL] )          #(défaut true) (sinon true)
TREEVIEW.{g,s}et_
headers_clickable       #
( [BOOL_VAL] )          #(défaut true) (sinon false). Clique dessus ne fait rien par défaut.
TREEVIEW.set_rules_hint #
( [BOOL_VAL] )          #Fait que les colonnes ont une couleur qui s'alterne (défaut true) (sinon false). 

TREEVIEW.expand_row     #
( TREEPATH, BOOL_VAL )  #Expand rangée désignée par TREEPATH (récursif si true)
TREEVIEW.collapse_row   #
( TREEPATH )            #Inverse
TREEVIEW.expand_to_path #
( TREEPATH )            #Expand rangées parentes de TREEPATH.
TREEVIEW.expand_all()   #Expand toutes les rangées.
TREEVIEW.collapse_all() #Inverse.
TREEVIEW.row_expanded   #
( TREEPATH )            #Renvoie false si pas expanded.
TREEVIEW.{g,[re]s}et_
expander_column         #
( TREECOLUMNVIEW_VAR )  #Modifie colonne ayant les triangles pour expand.
TREVIW.map_expanded_rows#Invoque PREDIC pour toutes les rangées visibles (pas celles non-expanded), où PREDIC ne renvoie rien
( PREDIC )              #et prend TREEVIEW_ADR et TREEPATH en argument.

TREEVIEW.
columns_autosize()      #Redimensionne automatiquement les colonnes (en théorie pas besoin)
TREEVIEW.scroll_to_point#
( 2 INT_VAL )
TREEVIEW.scroll_to_cell #
(TREPATH,TREVIWCLMN_VAR,
[, 2 FLOAT_VAL] )
TREEVIEW.
scroll_to_{row,column}  #
( TREEPATH[, FLOAT_VAL])#Déplace scrolling

TREEVIEW.row_activated
( TREEPATH, 
TREEVIEWCOLUMN_VAR )    #Emet signal activate pour cellule dont rangée est TREEPATH et colonne TREEVIEWCOLUMN
TREEVIW.get_bin_window()#Renvoie la REFPTR<GDK::WINDOW> associée.

TreeViewColumn          #Enfant de CellLayout et d'Object. Désigne une colonne de TreeView. Peut contenir plusieurs sous-
                        #colonnes.
TREEVIEWCOLUMN
([USTRNG[, TMC]])       #USTRING est le titre.
TREEVIEWCOLUMN.
pack_{start,end}
( TMC[, BOOL_VAL] )     #Rajoute une sous-colonne. BOOL_VAL est "expand" (défaut true)
TREEVIEWCOLUMN.clear()  #Supprime toutes les sous-colonnes (mais pas la colonne elle-même).
TREEVIEWCOLUMN.
{g,s}et_title( USTRING )#
TREEVIEWCOLUMN.
{g,s}et_expand([BOOLVL])#
TREEVIEWCOLUMN.
{g,s}et_align(FLOAT_VAL)#
TREEVIEWCOLUMN.
set_align( ALIGN )      #
TREEVIEWCOLUMN.{g,s}et_
clickable( [BOOL_VAL] ) #Clic sur le header
TREEVIEWCOLUMN.{g,s}et_
widget( WIDGET_VAR )    #Widget contenu dans le bouton du header.
TREEVIEWCOLUMN.
{g,s}et_spacing(INT_VAL)#Modifie le nombre de pixels entre deux sous-colonnes.
TREEVIEWCOLUMN.{g,s}et_
visible( [BOOL_VAL] )   #Modifie la visibilité des sous-colonnes (pas de la colonne elle-même)
TREEVIEWCOLUMN.{g,s}et_
reorderable( [BOOL_VAL])#Possibilité par l'user de modifier endroit de la colonne (si celle adjacente peut aussi l'être)
TREEVIEWCOLUMN.{g,s}et_
resizable( [BOOL_VAL] ) #Possibilité par l'user de resize la colonne (si celle adjacente peut aussi être resized)
TREEVIEWCOLUMN.
{g,s}et_sizing
( TREEVIEWCOLUMNSIZING )#Parmi : TREE_VIEW_COLUMN_{GROW_ONLY,AUTOSIZE,FIXED}
TREEVIEWCOLUMN.
set_sort_column( TMC )
TREEVIEWCOLUMN.
set_sort_column(INT_VAL)#Fait que cliquer sur le header triera la colonne selon TMC ou colonne numéro INT_VAL.
TREEVIEWCOLUMN.
get_sort_column_id()    #
TREEVIEWCOLUMN.{g,s}et_
sort_indicator(BOOL_VAL)#Affiche un triangle dans le header pour indiquer si trié selon ordre croissant ou décroissant.
TREEVIEWCOLUMN.{g,s}et_
sort_order( SORTTYPE )  #
TREEVIEWCOLUMN.
get_x_offset()          #
TREVIEWCOLMN.get_width()#
TREEVIEWCOLUMN.{g,s}et_
{min,max,fixed}_width   #
( INT_VAL )             #
TREEVIEWCOLUMN.
cell_get_size           #
( RECTANGLE, 4 INT_VAR )#Met dans référence x,y,width,height de la colonne si doit afficher cellule RECTANGLE.
TREEVIWCLMN.is_visible()#Renvoie true si l'une des cellules est visible.
TREEVIEWCOLUMN.
get_tree_view()         #Renvoie TREEVIEW_ADR
TREEVIWCLMN.get_button()#Renvoie BUTTON_ADR
TREEVIEWCOLUMN.clicked()#Emet signal clicked.

TreeSelection           #Désigne une sélection courante / paramètres de sélection dans un TreeView.
TREESELECTION.{g,s}et_  #Parmi : SELECTION_{NONE,SINGLE,BROWSE,MULTIPLE}. NONE : impossible de sélectionner. BROWSE : comme
mode( SELECTIONMODE )   #SINGLE (défaut), mais impossible de désélectionner.
TREESELECTION.
get_tree_view()         #Sous forme de TREEVIEW_ADR
TREESLECTION.get_model()#Equivaut à get_tree_view()->get_model()
TREESELECTION.
get_selected()          #Sous forme de TREEITER
TREESELECTION.
get_selected_rows()     #Sous forme de VECTOR<TREEPATH> (pour sélection multiple)
TREESELECTION.
count_selected_rows()   #Renvoie nombre de TREEROW sélectionnés, sous forme d'INT_VAL
TREESELECTION.
selected_foreach*       #Comme TREEMODEL.foreach*, mais pour les élements sélectionnés.
TREESELECTION.          #[Dé]Sélectionne. ARGS désigne les rangées et peut être TREEPATH, TREEITER, TREEROW ou 2 TREEPATH
[un]select( ARGS )      #(désignant alors le début et la fin). Pas d'unselect avec TREEROW
TREESELECTION.
[un]select_all()        #
TREESELECTION.
is_selected( TREEPATH ) #
TREESELECTION.
is_selected( TREEITER ) #

CellRenderer            #Enfant d'Object. Désigne le rendering des cellules (contenant un WIDGET quelconque) d'une colonne de 
                        #TREEVIEW.
                        #Plupart des fonctions ont des fonctions virtuelles permettant de définir des CELLRENDERER persos pour
                        #faire un rendu de classes personnalisées : cf online doc.
CELLRENDERER.{g,s}et_
fixed_size( 2 INT_VAL ) #Taille absolue, fixe. Le get* prend des références.
CELLRENDERER.{g,s}et_
alignment( 2 FLOAT_VAL )#Le get* prend des références.
CELLRENDERER.{g,s}et_
padding( 2 INT_VAL )    #Le get* prend des références.
CELLRENDERER.{g,s}et_
visible( [BOOL_VAL] )   #Visibilité non de la cellule mais de son contenu (défaut true) (sinon true)
CELLRENDERER.{g,s}et_
sensitive( [BOOL_VAL] ) #(défaut true) (sinon true)
CELLRENDERER.
is_activatable()        #
CELLRENDERER.
get_preferred_*         #Comme WIDGET.get_preferred_*, sauf que prend un WIDGET_VAR en premier argument.
CELLRENDERER.
get_aligned_area
( WIDGET_VAR, 
CELLRENDERERSTATE,      #Pour un WIDGET étant dans la cellule indiqué par RECTANGLE1 et avec CELLRENDERERSTATE, parmi 
GDK::RECTANGLE1,        #CELL_RENDERER_{SELECTED,PRELIT,INSENSITIVE,SORTED,FOCUSED}, met dans RECTANGLE2 la zone d'affichage de
GDK::RECTANGLE2_VAR )   #WIDGET.
CELLRENDERER.render
( CAIRO::REFPTR<CAIRO::
CONTEXT>, WIDGET_VAR, 
GDK::RECTANGLE1, 
GDK::RECTANGLE2,        #Mêmes arguments (RECTANGLE1 : cellule entière, RECTANGLE2 : zone d'affichage du WIDGT), mais effectue 
CELLRENDERERSTATE )     #un rendering dans CAIRO::CONTEXT.
CELLRENDERER.activate
( GDKEVENT_ADR, 
WIDGET_VAR, USTRING,
GDK::RECTANGLE1, 
GDK::RECTANGLE2,        
CELLRENDERERSTATE )     #Mêmes arguments + USTRING désignant le TREEPATH : effectue activate(). Renvoie true si ok.
CELLRENDERER.
start_editing( ARGS )   #Mêmes arguments qu'activate(), active le fait d'éditer.
CELLRENDRER.stop_editing#
( [BOOL_VAL] )          #Désactive le fait d'éditer : si true (défaut false), signifie que dû à un cancel et non un confirm.
CELLRENDERER.get_state
( [WIDGET_VAR, ]        #
CELLRENDERERSTATE )     #Traduit CELLRENDERERSTATE en STATEFLAG, et le renvoie.
CELLRENDERER.property_* 
                        #  - mode : CELLRENDERERMODE, parmi CELL_RENDERER_MODE_{INERT,ACTIVATABLE,EDITABLE}
                        #  - cell_background : USTRING
                        #  - cell_background_gdk : GDK::COLOR
                        #  - cell_background_rgba : GDK::RGBA
                        #  - cell_background_set : BOOL, active ou non cell_background* 
                        #  - editing : BOOL_VAL, si la cellule est éditée en ce moment
                        #  - is_expander : BOOL_VAL, si le row actuel a des enfants
                        #  - is_expanded : BOOL_VAL, false si le row actuel est un enfant et n'est pas affiché

CellRendererPixbuf      #Enfant de CellRenderer, pour un RefPtr<Gdk::Pixbuf>
....property_*          #  - pixbuf : REFPTR<GDK::PIXBUF>
                        #  - expander_{open,close} : REFPTR<GDK::PIXBUF>
                        #  - stock_id : USTRING
                        #  - icon_name : USTRING
                        #  - gicon : REFPTR<GIO::ICON>
                        #  - stock_size : ICON_SIZE
                        #  - stock_detail : USTRING ( ??? )
                        #  - follow_state : BOOL_VAL

TreeSortable            #Enfant de Glib::Interface. Désigne un TreeModel pouvant être trié. Par défaut pas trié.
TREESORTABLE.
set_sort_column         #
( TMCB, SORTTYPE )
TREESORTABLE.
set_sort_column         #Trie l'ensemble des colonnes selon la colonne TMCB ou numéro INT_VAL, avec SORTTYPE parmi :
( INT_VAL, SORTTYPE )   #SORT_ASCENDING ou SORT_DESCENDING.
TREESORTABLE.[un]set_
default_sort_func(PREDC)#Modifie fonction de tri. PREDIC renvoie INT_VAL et prend deux TREEITER en arguments.
TREESORTABLE.
has_default_sort_func() #
TREESORTABLE.
set_sort_column         #
( TMCB, PREDIC )
TREESORTABLE.
set_sort_column         #
( INT_VAL, PREDIC )     #Pareil, mais juste pour une colonne précise.
TREESORTABLE.
get_sort_column_id      #Remplis les références avec le numéro de la colonne de tri actuelle, et son SORTTYPE.
( INT_VAR, SORTTYPE_VAR)#INT_VAR peut être DEFAULT_SORT_COLUMN_ID ou DEFAULT_UNSORTED_COLUMN_ID, auquel cas false est renvoyé.

TreeModel               #Enfant de Glib::Interface. Contenu d'un TreeView. Toutes les cellules ajoutées sont initialisées par 
                        #défaut avec le constructor par défaut.
TREEMODL.get_n_columns()#Renvoie nombre de colonnes, sous forme d'INT_VAL.
TREEMODEL.children()    #Renvoie rangées sous forme de TREENODECHILDREN.
TREEMODEL.get_iter(PATH)
TREEMODEL.get_iter      #Renvoie le TREEITER correspondant à PATH (USTRING désignant un PATH). TREEITER sera invalide (tester
( USTRING )             #avec ( TREEITER ) si aucun TREEROW ne correspond à ce PATH.
TREEMODEL.get_path        #
( TREEITER )            #Renvoie le PATH correspondant à TREEITER.
TREEMODEL.get_string    #
( TREEITER )            #Equivaut à get_path( TREEITER ).to_string()
TREEMODEL.foreach_iter  #
( PREDIC )              #Effectue PREDIC pour chaque TREEITER, PREDIC renvoyant bool et prenant un TREEITER.
TREEMODEL.foreach_path  #
( PREDIC )              #Pareil avec PATH (i.e. le PATH de chaque TREEITER)
TREEMODEL.foreach       #
( PREDIC )              #Pareil avec PREDIC prenant ( PATH, TREEITER )
TREEMODEL.get_flags()   #Renvoie TREEMODELFLAGS (or'd) parmi : TREE_MODEL_{ITERS_PERSIST,LIST_ONLY}
TREEMODEL.row*          #Emet signal row*. Prend comme arguments ceux demandés par le callback.

ListStore               #Enfant de TreeModel et de TreeSortable. Contenu d'un TreeView, sous forme de tableau.
ListStore::create( TMCR)#Renvoie un REFPTR<LISTSTORE> vide, dont les colonnes sont TMCR.
LISTSTORE.
set_column_types( TMCR )#Modifie le type des colonnes par TMCR.
LISTSTORE.append()      #Rajoute une rangée à la fin, et la renvoie sous forme de TREEITER.
LISTSTORE.prepend()     #Pareil, mais la rajoute au début.
LISTSTORE.insert        #
( TREEITER )            #Pareil, mais la rajoute avant la rangée désignée par TREEITER.
LISTSTORE.insert_after  #
( TREEITER )            #Pareil, mais pour la rangée après TREEITER.
LISTSTORE.erase(TREEITR)#Supprime la rangée désignée par TREEITER, et renvoie rangée suivante sous forme de TREEITER.
LISTSTORE.clear()       #Supprime toutes les rangées.
LISTSTORE.iter_swap     #
( 2 TREEITER )          #Swappe le numéro des deux rangées désignées par les arguments.
LISTSTORE.move          #
( 2 TREEITER )          #Déplace la rangée TREEITER1 vers la rangée désignée par TREEITER2.
LISTSTORE.reorder       #
( VECTOR<INT> )         #Modifie index des rangées en fonction de VECTOR contenant par exemple {4,2,1,3,0}

TreeStore               #Mêmes parents que ListStore. Contenu d'un TreeView, sous forme d'arbre.
                        #Chaque level/répertoire est un TREENODECHILDREN. Faire un prepend/append sur le TREENODECHILDREN
                        #d'un TREEROW fait de ce level un enfant du TREEROW.
                        #A les mêmes méthodes que ListStore, plus :
LISTSTORE.prepend       #
( TREENODECHILDREN )
LISTSTORE.append        #Ajoute une rangée étant enfant au TREEROW parent de TREENODECHILDREN (cf TREENODECHILDREN.children())
( TREENODECHILDREN )    #Les méthodes sans arguments rajoutent quant à elles une rangée top-level.
LISTSTORE.is_ancestor   #
( 2 TREEITER )          #Renvoie true si TREEITER1 est un enfant direct ou indirect de TREEITER2.
LISTSTORE.iter_depth    #
( TREEITER )            #Renvoie depth level.

TreeModelColumnRecord   #Ensemble des TreeModelColumnBase.
TMCR.add( TMCB_VAR )    #Rajoute une colonne TMCB.
TMCR.size()             #Renvoie nombre de colonnes TMCB associées.

TreeModelColumnBase     #Base classe de TreeModelColumn. Colonne d'un TreeModelColumnRecord : type seulement, pas conten.
                        #Ne peut pas être associé à plusieurs TreeModelColumnRecord.
TMCB.index()            #Renvoie numéro de colonne (-1 si associé à aucun TREEMODELCOLUMNRECORD)
TMCB == TMCB2           
TMCB != TMCB2           #
TreeModelColumn<T>      #TreeModelColumnBase contenant des T_VAL.
TreeModelColumn<T>::
ElementType             #Typedef depuis T

TreeIter                #Itérateur vers les TreeRow (value_type) d'un ListStore. Respecte BidirectionalIt. et Writable et 
                        #ReadableIt. Définie aussi ( TREEITER ) (si != end())

TreeRow                 #Enfant de TreeIter, rangée d'un ListStore (contenu).
                        #Puisqu'enfant de TreeIter, peut être utilisé comme argument demandant un TREEITER.
TREEROW[TMC<T>]         #Renvoie la valeur à la colonne TREEMODELCOLUMN de la rangée TREEROW, sous forme de référence T_VAR.
TREEROM.{g,s}et_value   #
( INT_VAL, T_VAL )      #Modifie la valeur de la colonne numéro INT_VAL, avec T_VAL.
( TREEROW )             #Renvoie false si rangée invalide.
TREEROW.children()      #Renvoie les TREENODECHILDREN du level inférieur, pour utilisation dans un LISTSTORE.
TREEROW.parent()        #Inverse : renvoie un TREEITER sur le level supérieur.

TreeNodeChildren        #Sorte de vector-like contenant un ensemble de TreeRow.
                        #Typedefs : value_type (TreeRow), size_type, difference_type, [const_][reverse_]iterator (TreeIter), 
                        #Aussi :
                        #  - ( TREENODECHILDREN ), empty() et size()
                        #  - [r]begin(), [r]end()
                        #  - TREENODECHILDREN[UINT_VAL] (renvoie TREEROW, read-only ?)

TreePath                #Représente la location d'un TreeRow potentiel sous forme de "vector-like" d'INT_VAL représentant 
                        #l'index pour chaque level du tree. Par exemple "2:0" est le premier noeud enfant du troisième noeud 
                        #toplevel.
                        #Si seulement un toplevel, comme pour les LISTSTORE, alors seulement un élément est contenu.
                        #Ne pointe pas vraiment de TreeRow réel, mais potentiel. Par conséquent, peut être dans un chemin
                        #non-existant. Ne modifie donc aucun TreeRow.
                        #Contient mêmes membres que TreeNodeChildren (mais avec int pour value_type), avec en plus :
TREEPATH( TREEITER )
TREEPATH( USTRING )     #USTRING : cf TREEPATH.to_string()
TREEPATH( UINT_VAL,     #
INT_VAL )               #path étant une suite de UINT_VAL fois INT_VAL, par exemple ( 3, 5 ) -> "5:5:5"
TREEPATH.to_string()    #Renvoie représentation de TREEPATH sous forme d'USTRING, par exemple "2:1:1"
TREEPATH ==, !=, <, <=,
>, >= TREEPATH2         #
TREEPATH.front()        #
TREEPATH.back()         #
TREEPATH.push_
{back,front}( INT_VAL ) #
TREEPATH.assign         #
( 2 INT_ITVR )
TREEPATH.append         #
( 2 INT_ITVR )
TREEPATH.next()         #
TREEPATH.prev()         #Ajoute/enlève 1 au noeud le plus inférieur.
TREEPATH.up()           #
TREEPATH.down()         #Ajoute/enlève un niveau de profondeur.
TREEPATH.is_{ancestor,
descendant}( TREEPATH2 )#

                                  ┌─────────────────────────┐
                                  │   ACTION&ACCELERATORS   │
                                  └─────────────────────────┘

Activatable             #Enfant de Glib::Interface. Désigne un Widget ayant un signal activate ou clicked, auquel on peut 
                        #associer une ACTION.
                        #Associer cette ACTION changera non seulement l'handler du signal, mais mettre aussi l'image, le label
                        #les accelerators, le tooltip, mnemotechnics et les traductions de l'ACTION. Pratique notamment si 
                        #ACTION est associé à un BUILTINSTOCKID.
ACTIVATABLE.
{g,s}et_related_action  #
( REFPTR<ACTION> )      #Modifie l'ACTION associée.
ACTIVATABLE.{s,g}et_use_
action_appareance       #
( [BOOL_VAL] )          #Modifie le fait qu'ACTION modifie l'image, etc. du widget ACTIVATABLE (défaut true) (sinon true)

Action                  #Désigne un callback pour un signal activate ou clicked d'un ACTIVATABLE, avec possibilité de mettre 
                        #une image, label, accelerator, mnemotechnics et tooltip. L'accelerator par défaut n'est mis que si un 
                        #AccelGroup est associé.
                        #Ce callback est modifié par signal activate ou clicked d'Action.
Action::create          #USTRING1 est le name, USTRING2 le label, USTRING3 le tooltip.
( [USTRING1[, STOCKID]  #STOCKID peut aussi être un USTRING4 désignant un icon name, auquel cas il s'agira de
[,USTRING2[,USTRING3]]])#Action::create_with_icon_name
                        #STOCKID remplit automatiquement l'image, label, etc.
ACTION.{g,s}et_name     #
( USTRING )             #Modifie le nom de l'ACTION (il ne s'agit pas du label à afficher)
ACTION.{g,s}et_label    #
( USTRING )             #Modifie le label (à afficher) d'ACTION
ACTN.{g,s}et_short_label#
( USTRING )             #Modifie le short label : ignore utilité.
ACTION.{g,s}et_gicon
( REFPTR<GIO::ICON> )   #Modifie l'image
ACTION.{g,s}et_icon_name
( USTRING )             #Même chose mais avec un nom d'icône
ACTION.{g,s}et_tooltip  #
( USTRING )             #Modifie le tooltip.
ACTION.{g,s}et_stock_id #
( STOCKID )             #Modifie le label, tooltip, icône, mnemotechnics et accel keys d'ACTION en fonction de STOCKID.
ACTION.{g,s}et_always_
show_image( [BOOL_VAL] )#Modifie le fait que l'image soit affichée (défaut true)

ACTION.{g,s}et_sensitive#
( [BOOL_VAL] )          #Modifie le fait que l'ACTION ne soit pas grisée ni non-activable (défaut true) (sinon true)
ACTION.is_sensitive()   #
ACTION.activate()       #Emet le signal activate
ACTION.
[un]block_activate()    #Dissocie/réassocie le signal activate de son handler.

ACTIN.{g,s}et_accel_path#
( USTRING )             #Modifie l'accel path.
ACTN.{g,s}et_accel_group#
( REFPTR<ACCELGROUP> )  #Modifie l'AccelGroup.

ToggleAction            #Enfant d'Action, utilisé par les Activatable dont le signal activate est déclenché par un signal 
                        #toggled, comme CheckMenuItem et ToggleToolButton. Cf méthodes de CHECKMENUITEM.
                        #Mêmes *::create()
TOGGLEACTION.
{g,s}et_active([BOOLVL])#
TOGGLEACTION.
{g,s}et_draw_as_radio   #
( [BOOL_VAL] )

RadioAction             #Enfant de ToggleAction, utilisé par les ACTIVATABLE dont le signal activate fait un effet "radio 
                        #bouton", comme RadioMenuItem et RadioToolButton. Mêmes méthodes que RadioButton, avec en plus :
RADIOACTION.
{g,s}et_current_value   #
( INT_VAL )             #Renvoie l'index dans le RADIOBUTTONGROUP de l'ACTIVATABLE concerné.

ActionGroup             #Désigne un groupe d'Action.
ActionGroup::create     #
( [USTRING] )           #Renvoie un REFPTR<ACTIONGROUP> dont le name est USTRING.
ACTIONGROUP.{g,s}et_name#
( USTRING )             #Modifie nom de l'ACTIONGROUP
ACTIONGROUP.add         #
( REFPTR<ACTION>        #ACCELKEY est le raccourci de l'accelerator, PREDIC l'handler du signal activate ou clicked d'ACTION, 
[, ACCELKEY][, PREDIC] )#tous deux pouvant être rajoutés par cette méthode, en plus du rajout d'ACTION dans le groupe.
ACTIONGROUP.remove      #
( REFPTR<ACTION> )      
ACTIONGROUP.
{g,s}et_sensitive       #
( [BOOL_VAL] )          #Comme ACTION, mais récursif.
ACTIONGROUP.get_action  #
( USTRING )             #Renvoie la REFPTR<ACTION> dont le nom est USTRING.
ACTIONGRUP.get_actions()#Renvoie l'ensemble des ACTION sous forme de VECTOR<REFPTR<ACTION> >
Scrollable              #Enfant de Glib::Interface. Désigne un Container pouvant être scrolled, via un ADJUSTMENT.

ACCELERATOR ==>         #Raccourcis clavier pour déclencher une Action ou un Widget.
                        #Un raccourci associe une ensemble de touche : GDK::MODIFIERTYPE + caractère GUINT_VAL, lié à un 
                        #accel path. Un accel path est une STRING désignant une ACTION ou un WIDGET, sous la forme : 
                        #"<window-name>/Item1/Item2". Les noms sont arbitraires et désignés par set_accel_path().
                        #Ex : "<MainWindow>/File/Open"
                        #Les AccelGroup contiennent un ensemble d'accelerators. Pour activer un accelerator à une WINDOW :
                        #  1) dis/associer une ACTION ou WIDGET à un ACCELGROUP (set_accel_group())
                        #  2) dis/associer cette ACTION ou WIDGET à un accel path (set_accel_path())
                        #  3) dis/associer cet accel path à un raccourci (AccelMap::change_entry() ou load()/save())
                        #  2+3) ActionGroup.add( ..., ACCELKEY )
                        #  1+2) WIDGET.set_accel_path()
                        #  1+2+3) WIDGET.add_accelerator()
                        #Je ne réussis plus qu'à le faire via add_accelerator(), et j'ignore pourquoi.
                        #On peut utiliser l'AccelGroup de la toplevel window par défaut avec WINDOW.get_accel_group, ou lui en 
                        #ajouter avec WINDOW.{add,remove}( REFPTR<ACCELGROUP> )

AccelGroup              #Ensemble d'accelerators. Préférer utiliser l'AccelGroup par défaut de la WINDOW via get_accel_group()
                        #que d'en instantier un.
AccelGroup::create()    #Renvoie un REFPTR<ACCELGROUP>
ACCELGROUP.[un]lock()   #(Dés)active temporairement les accelerators.
ACELGRUP.get_is_locked()#
AccelGroup::valid       #
( UINT_VAL,             #Renvoie false si la combinaison de touche indiquée ne peut pas être un accelerator (uniquement quand
GDK::MODIFIERTYPE )     #UINT_VAL désigne un control character)
AccelGroup::name        #
( UINT_VAL,             #Renvoie une USTRING représentant le raccourci, tel que retourné par ACCELKEY.get_abbrev() par exemple 
GDK::MODIFIERTYPE )     #"<Control>o"
AccelGroup::parse
( USTRING, UINT_VAR,    #Modifie les deux VAR références en fonction d'USTRING, représentant une string telle que renvoyée par
GDK::MODIFIERTYPE_VAR ) #AccelGroup::name()
AccelGroup::get_label   #
( UINT_VAL,             
GDK::MODIFIERTYPE )     #Comme name(), mais en user-friendly, affichable, par exemple "Ctrl+o"
AccelGroup::
{g,s}et_default_mod_mask#
( GDK::MODIFIERTYPE )   #Renvoie/modifie un default MODIFIERTYPE (si manque d'inspiration)

AccelMap::change_entry
( STRING, UINT_VAL,     #Associe l'accel path STRING au raccourci désigné par les arguments qui suit. Si true et qu'un
GDK::MODIFIERTYPE,      #raccourci existe déjà  pour cet accel path, le remplace. S'il n'y parvient pas, renvoie false.
BOOL_VAL )              #Utiliser 0 pour UINT_VAL a pour effet de dissocier le raccourci.
AccelMap::add_entry     #
( STRING, UINT_VAL, 
GDK::MODIFIERTYPE )     #Comme change_entry(), mais avec false, et ne renvoie rien.
AccelMap::lookup_entry  #
(STRING[, ACCELKEY_VAR])#Renvoie true si accel path STRING existe et, si ACCELKEY_VAR, met son raccourci dedans.
AccelMap::[un]lock_path #
( STRING )              #(Dés)active temporairement le raccourci associé à l'accel path STRING.
AccelMap::save( STRING )#Sauvegarde tous les raccourcis dans un fichier dont le filename est STRING.
AccelMap::load( STRING )#Inverse. A faire après avoir associer tous les AccelGroup.

AccelKey                #Représente les touches d'un accelerator.
ACCELKEY( UINT_VAL, 
GDK::MODIFIERTYPE
[, USTRING] )
ACCELKEY( USTRING1      #USTRING1 est la représentation renvoyée par get_abbrev()
[, USTRING2] )
ACCELKEY.is_null()      #Renvoie true si vide.
ACCELKEY.get_key()      #Renvoie l'UINT_VAL
ACCELKEY.get_mod()      #Renvoie le GDK::MODIFIERTYPE
ACCELKEY.get_path()     #Renvoie le path USTRING
ACCELKEY.get_abbrev()   #Renvoie une représentation d'ACCELKEY sous forme d'USTRING.

MNEMOTECHNICS ==>       #Il s'agit de lettres soulignés : quand un widget a le focus, tapper cette touche active son enfant
                        #avec cette mnemotechnic. Une mnemotechnic s'indique en mettant un underscore dans le label avant la
                        #lettre et en activant set_use_underline().
                        #Utilisé par exemple par les MenuItem. Différent des accelerators.

                                  ┌─────────────┐
                                  │   CHOOSER   │
                                  └─────────────┘

FontChooser             #Enfant de Glib::Interface. Base classe abstraite pour FontChooserDialog et FontChooserWidget.
FONTCHOOSER.
get_font_family()       #Renvoie la REFPTR<PANGO::FONTFAMILY> de la police sélectionnée.
FONTCHOOSER.
get_font_face()         #Pareil pour REFPTR<PANGO::FONTFACE>.
FONTCHOOSER.
{s,g}et_font_desc()     #Pareil pour PANGO::FONTDESCRIPTION.
FONTCHOOSER.            #Pareil pour la PANGO::FONTDESCRIPTION, mais sous forme d'USTRING, telle que retournée par
{s,g}et_font()          #PANGO::FONTDESCRIPTION.to_string()
FONTCHOOSER.
get_font_size()         #Pareil pour la taille, sous forme d'INT_VAL
FONTCHOOSER.
{g,s}et_preview_text    #
( USTRING )             #Modifie le texte de preview.
FONTCHOOSER.
{g,s}et_show_preview_   #
entry( [BOOL_VAL] )     #Modifie le fait qu'il y ait un preview (défaut true) (sinon true)

FontChooserWidget       #Enfant de Box et de FontChooser. Désigne une interface pour choisir une police.

FontChooserDialog       #Enfant de Dialog et de FontChooser. Comme FontSelectionDialog, mais plus d'options via méthodes
                        #héritées de FontChooser. Les Button sont "Cancel" et "Select" (OK)
FONTCHOOSERDIALOG
( [USTRING[, WINDOW]] ) #USTRING est le titre, WINDOW la fenêtre parente.

FontButton              #Enfant de Button. Désigne un BUTTON qui lance une FontChooserDialog, et affiche le résultat 
                        #(font family + style + size) sur le label du Button.
FONTBUTTON( [USTRING] ) #USTRING est le texte affiché sur le bouton avant sélection de la police.
FONTBUTTON.{g,s}et_title
( USTRING )             #Modifie le titre de la popup ouverte.
FONTBUTTON.{g,s}et_use_
{font,size}( [BOOL_VAL])#Ne semble pas changer quoi que ce soit (défaut true) (sinon true)
FONTBUTTON.{g,s}et_show_
{size,style}([BOOL_VAL])#Fait que le taille ou style est affiché sur le label du Button (défaut true) (sinon true)
FONTBUTTON.
{g,s}et_font_name       #
( USTRING )             #Imprime/modifie la police selon USTRING, tel qu'imprimé par PANGO::FONTDESCRIPTION.to_string()

FontSelection           #Enfant de VBox. Désigne une interface pour choisir une police : préférer FontChooserWidget
FontSelectionDialog     #Enfant de Dialog. Contient des outils pour choisir une police : préférer FontChooserDialog.

ColorSelection          #Enfant de VBox, désigne une interface pour choisir une couleur.
COLORSELECTION.         #Renvoie la couleur (hors transparence) de la couleur actuellement sélectionnée sous forme de 
{s,g}et_current_color() #GDK::COLOR
COLORSELECTION.
{s,g}et_current_alpha() #Renvoie l'alpha de la couleur actuellement sélectionnée sous forme d'UINT16_VAL
COLORSELECTION.
{s,g}et_current_rgba()  #Renvoie la couleur + alpha de la couleur actuellement sélectionnée sous forme de GDK::RGBA.
....{s,g}et_previous_*  #Comme {s,g}et_current_*, mais pour la couleur précédemment modifiée.
COLORSELECTION.{g,s}et_
has_opacity_control
([BOOL_VAL])            #Si BOOL_VAL == true (défaut), ajoute un HSCALE pour modifier l'opacité (désactivé par défaut)
COLORSELECTION.
{g,s}et_has_palette
([BOOL_VAL])            #Si true (défaut), ajoute des couleurs swatches (couleurs souvent utilisées)
COLORSELECTION.         #Renvoie true lors d'un clic, d'un maintien/dragging clic, et false lors de pas de clic ou released 
is_adjusting()          #clic

ColorSelectionDialog    #Enfant de Dialog. Contient une COLORSELECTION dans sa VBOX principale, et des BUTTONS "Help",
                        #"Cancel" et "Ok" dans sa BUTTONBOX principale (associés aux RESPONSETYPE approprié)
COLORSELECTIONDIALOG
( [USTRING] )           #Instantiation, avec le titre USTRING (par défaut null string)
COLORSELECTIONDIALOG.
get_color_selection()   #Renvoie la COLORSELECTION_ADR contenue.
property_*              #PROPR <Button*> : {ok,cancel,help}_button

ColorButton             #Enfant de Button. Désigne un BUTTON qui lance une ColorSelectionDialog, et affiche la couleur sur
                        #l'image du Button.
COLORBUTON([GDK::COLOR])
COLORBUTON([GDK::RGBA] )#COLRO ou RGBA est la couleur affichée sur le bouton avant première sélection (défaut noir opaque)
COLORBUTON.{g,s}et_title#
( USTRING )             #Modifie titre de la popup ouverte
COLORBUTON.{g,s}et_color#
( GDK::COLOR )
COLORBUTTON.{g,s}et_rgba#
( GDK::RGBA )
COLORBUTON.{g,s}et_alpha#
( UINT16_VAL )          #Modifie la couleur et/ou la transparence
COLORBUTTON.
{g,s}et_use_alpha       #
( [BOOL_VAL] )          #Modifie le fait de pouvoir utiliser de la transparence (défaut true) (sinon true)

FileChooser             #Enfant de Glib::Interface. Base classe abstraite pour FileChooserButton, FileChooserDialog et 
                        #FileChooserWidget.
                        #Les URI commencent par file:///, et sont optionnellement percent-encoded ; les filenames sont 
                        #encodés dans la locale demandée par l'OS actuel ; les USTRING utilisent les codepoints.
                        #Les WIDGET attendent souvent des USTRING, l'OS des filenames, et les réseaux des URI.
                        #Pour conversion entre eux (notamment un USTRING à partir d'un filename, et inversement) : cf Glibmm
FILECHOOSER.            #Renvoie le chemin du fichier actuellement sélectionné sous forme de filename STRING. set* renvoie 
{s,g}et_filename()      #false si le chemin spécifier ne peut pas être sélectionné (non-existant par exemple). Si plusieurs
                        #sélection, en retourne un au hasard : cf get_filenames()
FILECHOSER.{s,g}et_uri()#Pareil, mais sous forme d'URI, en USTRING
FILCHOSER.{s,g}et_file()#Pareil, mais sous forme de GIO::FILE
FILECHOOSER.{s,g}et_    #Comme get_* (filename, uri ou file), sauf que ne prend que le parent path. get_current_folder_filename
current_folder_*()      #est en fait "get_current_folder" tout court.
FILECHOOSER.
set_current_name(USTRNG)#Comme set_filename(), sauf que chemin non-absolu possible, et USTRING.
FILECHOOSER.
{s,g}et_local_only      #Si false (défaut true) (sinon true), possible de sélectionner des fichier non-locaux sur un réseau.
( [BOOL_VAL] )          #Utiliser alors get_uri et non get_filename

FILECHOOSER
{s,g}et_select_multiple #Sélection multiple possible (défaut true) (sinon non). Impossible avec 
( [BOOL_VAL] )          #FILE_CHOOSER_ACTION_{SAVE,CREATE_FOLDER} et FileChooserButton.
FILECHOOSER.[un]select_*#
( ARG )                 #(Dé)Sélectionne le * (filename, uri ou file) ARG (dépend de *)
FILECHOOSER.
[un]select_all()        #(Dé)Sélectionne tous les filenames du répertoire courant.
FILECHOOSER.get_*s()    #Comme FILECHOOSER.get_*() (filename, uri ou file), mais renvoie un vector<TYPE> des fichiers 
                        #sélectionnés.

FILCHOSER.{s,g}et_action#
( FILECHOOSERACTION )   #Change l'interface en fonction de FILECHOOSERACTION : cf FileChooserWidget.
FILECHOOSER.
{s,g}et_show_hidden     #
( [BOOL_VAL] )          #Faire apparaître les fichiers cachés. Ne semble pas marcher contrairement à CTRL-H.
FILECHOOSER.{s,g}et_do_
overwrite_confirmation  #Avec FILE_CHOOSER_ACTION_SAVE, demande confirmation si fichier existant : ne marche qu'avec 
( [BOOL_VAL] )          #FILECHOOSERDIALOG
FILECHOOSER.
{s,g}et_create_folders  #
( [BOOL_VAL] )          #Si false, bouton "Create Folder" est absent. Seulement pour FILE_CHOOSER_ACTION_{SAVE,CREATE_FOLDER}

FILECHOOSER.
{g,s}et_preview_widget  #Rajoute un WIDGET à droite de la sélection de fichier (sinon aucun), dont le but est de faire un 
( WIDGET_VAR )          #preview : il faut implémenter ce WIDGET soi-même.
FILECHOOSER.{g,s}et_
preview_widget_active   #Fait que le preview WIDGET est affiché (défaut true) (sinon true). Faire false si impossible de faire
( [BOOL_VAL] )          #un preview pour le fichier courant.
FILECHOOSER.{g,s}et_
use_preview_label       #
( [BOOL_VAL] )          #Fait que le titre du fichier courant est affiché en haut du preview widget (défaut true) (sinon false)
FILECHOOSER.
get_preview_*()         #Comme get_*() (filename, uri ou file), mais pour le fichier courant dont il faut faire un preview.
FILECHOOSER.
{g,s}et_extra_widget    #
( WIDGET_VAR )          #Rajoute un WIDGET dans la content area, en bas de la sélection de fichier.

FILECHOOSER.
{add,remove}_filter     #Rajoute un FILEFILTER dans la liste que l'user peut choisir. Le premier added est activé via
( REFPTR<FILEFILTER> )  #set_filter.
FILCHOSER.{s,g}et_filter#
( REFPTR<FILEFILTER> )  #FILEFILTER devient le filtre courant.
FILCHOSER.list_filters()#Renvoie la liste des filtres sous forme de VECTOR<REFPTR<FILEFILTER> >

FILECHOOSER.
{add,remove}_shortcut_  #
folder( STRING )        #Rajoute dans la barre à raccourcis un raccouci vers le filename STRING.
FILECHOOSER.
list_shortcut_folders() #Renvoie les shortcuts sous forme de VECTOR<STRING>
FILECHOOSER.*folder_uri*#Comme précédent, mais prenant un URI USTRING en argument.

FileFilter              #Filtre pour sélectionner certains types pour un FileChooser. Seuls les fichiers répondant à l'un des
                        #filtrages seront affichables et sélectionnables.
FileFilter::create()    #Renvoie un REFPTR<FILEFILTER>
FILEFILTER.{g,s}et_name #
( USTRING )             #Change nom du filtre (ex : "JPEG image (*.jpg, *.jpe, *.jpeg)")
FILEFILTER.add_pattern  #
( USTRING )             #Rajoute un filtrage étant une expression de globbing (ex : "*.cpp")
FILEFILTER.add_mime_type#Rajoute un filtrage par rapport au mime type (ex : "text/plain"). Regarder sur internet celui que l'on
( USTRING )             #veut
FILEFILTER.
add_pixbuf_formats      #
( USTRING )             #Rajoute un filtrage pour tous les formats d'image pouvant être traités par GDK::PIXBUF
FILEFILTER.get_needed() #Renvoie les types des filtrages sous forme de FILEFILTERFLAGS, parmi :
                        #FILE_FILTER_{FILENAME,URI,DISPLAY_NAME,MIME_TYPE} (or'd)
FILEFILTER.add_custom   #Définit un filtrage personnalisé. 
( FILEFILTERFLAGS,      #FILEFILTERFLAGS est son type. Le callback de SLOT doit renvoyer true en fonction de INFO, dont les
SIGC::SLOT<bool,        #CLASSDT sont : contains (FILEFILTERFLAGS) et 4 USTRING : filename, uri, display_name et mime_type,
FileFilter::Info cnst&>)#désignant un fichier courant.

FileChooserWidget       #Enfant de VBox et de FileChooser. Désigne une interface pour choisir un fichier.
FILECHOOSERWIDGET       #Parmi : FILE_CHOOSER_ACTION_{OPEN,SAVE,CREATE_FOLDER,SELECT_FOLDER}. Change le layout en fonction
( [FILECHOOSERACTION] ) #(possibilité de sélectionner des fichiers non-répertoires, bouton "Create folder", etc.). Défaut :
                        #OPEN.

FileChooserDialog       #Enfant de Dialog et FileChooser, remplit sa content area d'un FileChooserWidget.
FILECHOOSERDIALOG
([WINDOW, ]USTRING1     #WINDOW est le parent. USTRING1 le titre de la fenêtre. FILECHOOSERACTION est par défaut 
[, FILECHOOSERACTION])  #FILE_CHOOSER_ACTION_OPEN.

FileChooserButton       #Enfant de HBox et de FileChooser. Désigne un bouton qui lance un FILECHOOSERDIALOG, et qui affiche
                        #dans son label le fichier choisi. Seuls FILE_CHOOSER_ACTION_{OPEN,SELECT_FOLDER} sont possibles.
                        #Pour SAVE et CREATE_FOLDER, utiliser un Button lançant une FILECHOOSERDIALOG.
                        #Utiliser méthodes héritées de FileChooser pour retrouver fichier sélectionner.
FILECHOOSERBUTTON
( FILECHOOSERDIALOG )   #
FILECHOOSERBUTTON
( [USTRING, ]           #USTRING est le titre affiché sur le bouton avant choix du fichier. FILECHOOSERACTION est par défaut 
[FILECHOOSERACTION] )   #FILE_CHOOSER_ACTION_OPEN.
FILECHOOSERBUTTON.
{g,s}et_title( USTRING )#Modifie le titre de la popup ouverte.
FILECHOOSERBUTTON.
{g,s}et_width_chars
( INT_VAL )             #Cf ENTRY.*et_width_chars*
FILECHOOSERBUTTON.
{g,s}et_focus_on_click  #
( [BOOL_VAL] )          #Si true (défaut true) (sinon true), cliquer sur le bouton grab le focus.

RecentChooser           #Enfant de Glib::Interface. Base classe abstraite pour RecentChooserDialog, RecentChooserWidget, 
                        #RecentChooserMenu et RecentAction
RECENTCHOOSER.          #Renvoie le fichier sélectionné courant, sous forme de RECENTINFO. Semble buguer avec un 
get_current_item()      #RecentChooserDialog
RECENTCHOOSER.
{s,g}et_current_uri()   #Renvoie l'URI du fichier sélectionné, sous forme d'USTRING.
RECENTCHOSER.get_items()#Renvoie l'ensemble des fichiers sous forme de VECTOR<REFPTR<RECENTINFO> >.
RECENTCHOSER.get_uris() #Même chose pour les URI sous forme de VECTOR<USTRING>

RECENTCHOOSER.
{g,s}et_select_multiple #
( [BOOL_VAL] )          #Modifie le fait de pouvoir sélectionner plusieurs fichiers (défaut true) (sinon false)
RECENTCHOOSER.
[un]select_uri( USTRING)#
RECENTCHOOSER.
[un]select_all()        #

RECENTCHOOSER.
{g,[un]set_limit        #
( INT_VAL )             #Modifie le nombre maximum de fichiers affichables (sinon gtk_recent_files_limit de SETTINGS)
RECENTCHOOSER.
{g,s}et_local_only      #
( [BOOL_VAL] )          #Modifie l'affichage des fichiers distants (via file:///) (défaut true) (sinon true)
RECENTCHOOSER.
{g,s}et_show_not_found  #
( [BOOL_VAL] )          #Modifie l'affichage des fichiers non trouvés.
RECENTCHOOSER.
{g,s}et_show_tips       #Modifie l'affichage de tooltips (bulles infos) montrant le chemin complet des fichiers (défaut true)
( [BOOL_VAL] )          #(sinon false)
RECENTCHOOSER.
{g,s}et_show_icons      #
( [BOOL_VAL] )          #Modifie l'affichage des icônes à côtés des fichiers (défaut true) (sinon true)
RECENTCHOOSER.
{g,s}et_sort_type       #
( RECENTSORTTYPE )      #Modifie l'algorithme de tri parmi RECENT_SORT_{NONE,MRU,LRU,CUSTOM}
RECENTCHOOSER.
set_sort_func           #
( SIGC::SLOT<int, RefPtr
<RecentInfo> const&, 
RefPtr<RecentInfo>      #Si RECENT_SORT_CUSTOM utilise callback prenant les deux RECENTINFO comme argument, et renvoyant -1,
const&> const& )        #0 ou 1 selon comparaison.

RECENTCHOOSER.
{add,remove}_filter     #
( REFPTR<RECENTFILTER> )
RECENTCHOSER.
{s,g}et_filter          #
( REFPTR<RECENTFILTER> )
RECENTCHOSER.
list_filters()          #Comme pour FILECHOOSER, mais avec des RECENTFILTER.

RecentFilter            #Comme FileFilter, mêmes méthodes mais en plus :
                        #  - FILEFILTERFLAGS -> RECENTFILTERFLAGS parmi : RECENT_FILTER_{URI,DISPLAY_NAME,MIME_TYPE,
                        #    APPLICATION,GROUP,AGE}
                        #  - add_custom : FileFilter::Info -> RecentFilter::Info. Pareil mais avec membres supplémentaires 
                        #    groups (LIST<USTRING>), applications (LIST<USTRING>) et age (INT_VAL)
RECENTFILTER.
add_application(USTRING)#Rajoute un filtrage par rapport à l'application l'ayant utilisé
RECENTFILTER.add_group
( USTRING )             #Rajoute un filtrage par rapport au groupe : cf RECENTINFO
RECENTFILTER.
add_age( INT_VAL )      #Rajoute un filtrage par rapport à l'âge : cf RECENTINFO.
RecentChooserWidget     #Enfant de VBox et de RecentChooser.

RECENTCHOOSERWIDGET     
([REFPTR<RECENTMANAGR>])#Argument est par défaut RecentManager::get_default()

RecentChooserDialog     #Enfant de Dialog et de RencentChooser, remplit sa content area d'un RecentChooserWidget.
RECENTCHOOSERDIALOG
( [WINDOW, ]USTRING     #WINDOW est la fenêtre parente, USTRING le titre et RECENTMANAGER est par défaut
[,REFPTR<RECENTMANAGR>])#RecentManager::get_default()

RecentManager           #Représente une liste des derniers fichiers utilisés par une application donnée.
                        #L'âge maximum est dans gtk_recent_files_age de SETTINGS.
RecentManager::create() #Renvoie REFPTR<RECENTMANAGER> vide.
RecentManager::
get_default()           #Renvoie REFPTR<RECENTMANAGER> de l'application courante.
RECENTMANAGER.add_item  #Ajoute un fichier dont l'URI est USTRING. RECENTMANAGER::DATA a les membres USTRING : display_name,
( USTRING               #description, mime_type, app_name et app_exec à remplir (cf RECENTINFO) + membres "groups" 
[, RECENTMANAGER::DATA])#(VECTOR<USTRING>) désignant une liste de groupes de RECENTINFO auquel appartient RECENTINFO, et 
                        #is_private, BOOL_VAL indiquant si le fichier est propre à l'application.
                        #Sinon DATA est deviné.
RECENTMANAGER.
remove_item( USTRING )  #
RECENTMANAGER.
purge_items()           #remove_item sur tous les fichiers.
RECENTMANAGER.          
has_item( USTRING )     #Renvoie true si fichier dont URI est USTRING est présent.
RECENTMANAGER.move_item #
( USTRING1, USTRING2 )  #Modifie URI du fichier sont l'URI est USTRING1.
RECENTMANAGER.
lookup_item( USTRING )  #Renvoie fichier de RECENTMANAGER dont l'URI est USTRING sous forme de REFPTR<RECENTINFO>

RecentInfo              #Désigne un fichier dans un RecentChooser.
RECENTINFO.
get_uri_display()       #Renvoie l'URI sous forme d'USTRING.
RECENTINFO.             
get_short_name()        #Renvoie le filename sous forme d'USTRING.
RECENTINFO.             
get_display_name()      #Renvoie le basename sous forme d'USTRING.
RECENTINFO.
get_description()       #Renvoie une description sous forme d'USTRING (je ne reçois que des null strings)
RCNTINFO.get_mime_type()#Renvoie mime type sous forme d'USTRING.
RECENTINFO.get_{added,  #Renvoie temps (sous forme de TIME_T) d'ajout, modification et accès, mais semble-t-il pour la liste
modified,visited}()     #des derniers fichiers visités (donc pas mêmes résultats qu'avec un stat)
RECENTINFO.get_groups() #Renvoie les groupes dont il fait partie sous forme de VECTOR<USTRING>
RECENTINFO.has_group    #
( USTRING )             #Renvoie true si fait partie du group USTRING.
RECENTINFO.get_age()    #Renvoie nombre de jours depuis mise à jour de RECENTINFO, sous forme d'INT_VAL.
RECENTINFO.is_local()   #Renvoie true si fichier est local.
RECENTINFO.exists()     #Renvoie true si fichier existe toujours.
RECNTINFO == RECENTINFO2
RECNTINFO != RECENTINFO2#

RECENTINFO.             #Renvoie ensemble des applications ayant ce RECENTINFO dans leur RECENTMANAGER, sous forme de 
get_applications()      #VECTOR<USTRING>
RECENTINFO.
last_application()      #Renvoie dernière application l'ayant utilisé, sous forme d'USTRING.
RCNTINFO.has_application#
( USTRING )             #Renvoie true si application dont nom est USTRING a RECENTINFO dans son RECENTMANAGER.
RECENTINFO.
get_application_info    #Si application USTRING a RECENTINFO dans son RECENTMANAGER, renvoie true et met dans les trois 
( USTRING, STRING_VAR,  #arguments références le chemin d'exécution de l'application, le nombre d'utilisation et l'heure de
UINT_VAR, TIME_T_VAR )  #dernière utilisation.
RECENTINFO.
create_app_info(USTRING)#Renvoie application USTRING sous forme de REFPTR<GIO::APPINFO>.
RECENTINFO.get_icon     #Renvoie un icône représentant le mime type de RECENTINFO, de taille INT_VAL, sous forme de
( INT_VAL )             #REFPTR<GDK::PIXBUF>
RECENTINFO.get_gicon()  #Même chose, mais sans taille et sous forme de REFPTR<GIO::ICON>

RecentChooserMenu       #Enfant de Menu, d'Activatable et de RecentChooser : Menu pour les fichiers récents.
RECENTCHOOSERMENU     
([REFPTR<RECENTMANAGR>])#Argument est par défaut RecentManager::get_default()
RECENTCHOOSERMENU.
{g,s}et_show_numbers    #
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), rajoute un nombre numérotant chaque fichier

RecentAction            #Enfant d'Action et de RecentChooser : Actions pour un RecentChooserMenu.
RecentAction::create
( [USTRING1[, STOCKID]
[, USTRING2[, USTRING3  
[,REFPTR<RECNTMNGR>]]]])#Comme Action::create(), avec un dernier argument en plus.
RECENTACTION.
{g,s}et_show_numbers    #
( [BOOL_VAL] )          #Cf RecentChooserMenu

AppChooser              #Enfant de Glib::Interface. Base classe abstraite pour AppChooserButton, AppChooserDialog et 
                        #AppChooserWidget.

                                  ┌────────────┐
                                  │   ICONES   │
                                  └────────────┘

FONCTIONNEMENT DES      #Pour les icônes via StockID :
ICONES ==>              #  - recherche image dont le nom de fichier est STOCKID.get_string() + éventuelle extension.
                        #  - répertoire du début est par exemple {$HOME/.icons,/usr/share/icons/} sur Ubuntu
                        #  - puis il s'agit du nom du thème (cf gtk_icon_theme_name())
                        #  - dans ce répertoire, un fichier index.theme indique comment est construite l'arborescence :
                        #     - [Icon Theme]
                        #       Name=...        //Nom du thème
                        #       Comment=...     //Description brève du thème
                        #       Inherits=...    //Thèmes à rechercher si l'icône n'est pas trouvé. En général :
                        #                         Humanity,gnome,hicolor
                        #       Directories=... //Liste des répertoires et sous-répertoires 
                        #     - pour chaque DIR :
                        #       [DIR]
                        #       Size=...        //Taille (carrée, en pixel) des icônes
                        #       Context=...     // ??
                        #       Type=...        // ??
                        #L'"icon name" fait référence au basename de ce fichier : un fichier avec un tel basename est
                        #recherché dans le thème courant, en commençant par taille demandée, puis autres tailles disponibles.
STOCK ==>               #Il s'agit d'une banque de STOCKITEM, remplie par défaut par un STOCKITEM pour chaque BUILTINSTOCKID.

Stock::add( STOCKITEM ) #Rajoute STOCKITEM au Stock.
Stock::get_ids()        #Renvoie le STOCKID de tous les STOCKITEMS du Stock, sous forme de VECTOR<STOCKID>
Stock::lookup( STOCKID,
STOCKITEM_VAR )
Stock::lookup( STOCKID,
REFPTR<ICONSET>_VAR )
Stock::lookup( STOCKID,
ICONSIZE, IMAGE_VAR )   #Remplis les arguments (par références), en fonction du STOCKITEM dont l'id est STOCKID.

StockID                 #ID d'un StockItem. Est toujours associé à un nom USTRING.
STOCKID( BUILTINSTOCKID)#Instantie, parmi : STOCK::{DIALOG_AUTHENTICATION,DIALOG_INFO,DIALOG_WARNING,DIALOG_ERROR,
                        #DIALOG_QUESTION,DND,DND_MULTIPLE,ABOUT,ADD,APPLY,BOLD,CANCEL,CAPS_LOCK_WARNING,CDROM,CLEAR,CLOSE,
                        #COLOR_PICKER,CONVERT,CONNECT,COPY,CUT,DELETE,DIRECTORY,DISCARD,DISCONNECT,EDIT,EXECUTE,FILE,FIND,
                        #FIND_AND_REPLACE,FLOPPY,FULLSCREEN,LEAVE_FULLSCREEN,GOTO_BOTTOM,GOTO_FIRST,GOTO_LAST,GOTO_TOP,GO_BACK,
                        #GO_DOWN,GO_FORWARD,GO_UP,HARDDISK,HELP,HOME,INDEX,INFO,INDENT,UNINDENT,ITALIC,JUMP_TO,JUSTIFY_CENTER,
                        #JUSTIFY_FILL,JUSTIFY_LEFT,JUSTIFY_RIGHT,MISSING_IMAGE,MEDIA_FORWARD,MEDIA_NEXT,MEDIA_PAUSE,MEDIA_PLAY,
                        #MEDIA_PREVIOUS,MEDIA_RECORD,MEDIA_REWIND,MEDIA_STOP,NETWORK,NEW,NO,OK,OPEN,ORIENTATION_PORTRAIT,
                        #ORIENTATION_LANDSCAPE,ORIENTATION_REVERSE_LANDSCAPE,ORIENTATION_REVERSE_PORTRAIT,PASTE,PREFERENCES,
                        #PAGE_SETUP,PRINT,PRINT_ERROR,PRINT_PREVIEW,PRINT_REPORT,PRINT_WARNING,PROPERTIES,QUIT,REDO,REFRESH,
                        #REMOVE,REVERT_TO_SAVED,SAVE,SAVE_AS,SELECT_ALL,SELECT_COLOR,SELECT_FONT,SORT_ASCENDING,
                        #SORT_DESCENDING,SPELL_CHECK,STOP,STRIKETHROUGH,UNDELETE,UNDERLINE,UNDO,YES,ZOOM_100,ZOOM_FIT,ZOOM_IN,
                        #ZOOM_OUT}
                        #Ont donc déjà un label, une image, un accelerator, un tooltip et des traductions préexistantes.
STOCKID( USTRING )      #Instantie, à partir du nom de STOCKID.
STOCKID.get_string()    #Renvoie le nom de STOCKID, sous forme d'USTRING (en général gtk-* pour les BUILTINSTOCKID)
STOCKID.get_c_str()     #Renvoie le nom de STOCKID, sous forme de STR.
( STOCKID )             #Renvoie false si vide.
STOCKID.equal( STOCKID2)
STOCKID == STOCKID2
STOCKID != STOCKID2     #

StockItem               #Icône du "Stock", comprenant par défaut les icônes standards.
STOCKITEM( STOCKID, 
USTRING[, MODIFIERTYPE
[, UINT_VAL[,USTRING]]])
STOCKITEM.get_stock_id()#Renvoie le STOCKID associé.
STOCKITEM.get_label()   #Renvoie un label associé, sous forme d'USTRING (ex : "_About")
STOCKITEM.get_keyval()  #Représente respectivement une lettre (UINT_VAL) et un GDK::MODIFIERTYPE représentant une touche, 
STOCKITEM.get_modifier()#utilisé comme accelerator.
                        #Valeurs par défaut : 0 pour tous sauf : 
                        #  - "new"   : Ctrl-N
                        #  - "open"  : Ctrl-O
                        #  - "save"  : Ctrl-S
                        #  - "close" : Ctrl-W
                        #  - "quit"  : Ctrl-Q
                        #  - "copy"  : Ctrl-C
                        #  - "paste" : Ctrl-V
                        #  - "cut"   : Ctrl-X
                        #  - "find"  : Ctrl-F
                        #  - "find-and-replace" : Ctrl-R
                        #  - "help"  : Ctrl-H
STOCKITEM.              #Renvoie le message domain, sous forme d'USTRING. Il s'agit de "gtk30" pour tous, sauf "gtk30-media" 
get_translation_domain()#pour MEDIA* et gtk30-navigation pour GOTO* et GO*

IconSet                 #Représente un ensemble d'IconSource, représentant un même icône à plusieurs tailles (souvent tailles
                        #standards de BuiltinIconSize).
                        #Est toujours associé dès l'instantiation aux tailles BuiltinIconSize par défaut + celles crées via
                        #register_new, mais associé à aucune image.
                        #Une seule image peut être associée : je ne comprends pas pourquoi.
IconSet::create()       #Renvoie un REFPTR<ICONSET> vide.
IconSet::create
(REFPTR<GDK::PIXBUF>)   #Renvoie un REFPTR<ICONSET> dont l'image est PIXBUF.
IconSet::lookup_default #
( STOCKID )             #Renvoie un REFPTR<ICONSET> remplis en fonction de STOCKID.
ICONSET.add_source      #
( ICONSOURCE )          #Rajoute ICONSOURCE à ICONSET.
ICONSET.get_sizes()     #Renvoie l'ensemble des ICONSIZE associés (deux des ICONSOURCE associés + ceux par défault) sous forme
                        #de VECTOR<ICONSIZE>

IconSource              #Représente un icône, avec une taille précise. A aussi un nom associé (par défaut vide).
ICONSOURCE.
{s,g}et_filename(USTRNG)#Modifie l'image de l'icône, dont le chemin est USTRING.
ICONSOURC.{s,g}et_pixbuf#
( REFPTR<GDK::PIXBUF> ) #Modifie l'image de l'icône, en fonction de PIXBUF.
ICONSOURCE.{s,g}et_size #
( ICONSIZE )            #Modifie l'ICONSIZE associé.
ICONSOURCE.
{s,g}et_direction       #
( TEXTDIRECTION )       #Modifie la TEXTDIRECTION.
ICONSOURCE.             #Modifie le nom associé USTRING. get* renvoie 0 si nom associé vide. N'est pas l'icon name demandé
{s,g}et_icon_name(USTNG)#par plusieurs fonctions : cf "Fonctionnement des icônes"

IconSize                #Représente une taille d'icône. Pas forcément carré ni multiple de 2, mais c'est mieux.
                        #Chaque ICONSIZE est associé à un nom.
ICONSIZE(BUILTINICONSIZ)#Parmi : ICON_SIZE_{INVALID,MENU,SMALL_TOOLBAR,LARGE_TOOLBAR,BUTTON,DND,DIALOG} représentant une 
                        #taille de carré 16, 18, 20, 24, 32, 48, 24 pixels sur mon système. DND = "Drag&Drop"
                        #Leur noms par défaut sont : gtk-*, par exemple gtk-small-toolbar
IconSize::lookup        #
( ICONSIZE, INT_VAR1,   #Renvoie dans les INT_VAR références la largeur et hauteur, en pixels, d'ICONSIZE, pour une SETTINGS
INT_VAR2[, SETTINGS] )  #donnée (par défaut celle par défaut).
IconSize::register_new  #
( USTRING, INT_VAL1,    
INT_VAL2 )              #Crée une nouvelle taille d'INT_VAL1 * INT_VAL2 pixels, associé au nom USTRING.
IconSize::register_alias#
( USTRING, ICONSIZE )   #ICONSIZE devient également associée au nom USTRING.
IconSize::from_name     #
( USTRING )             #Renvoie l'ICONSIZE associée au nom USTRING.
IconSize::get_name      #
( ICONSIZE )            #Renvoie le nom USTRING associé à ICONSIZE.

                                  ┌──────────────┐
                                  │   TEXTVIEW   │
                                  └──────────────┘

TextView                #Container, enfant de Container et de Scrollable, désignant une zone de texte éditable multiligne.
                        #Les ADJUSTMENT sont accessibles via les CLASSFK héritées de Scrollable.
                        #On peut :
                        #  - rajouter des PIXBUF ou tout WIDGET (via TEXTCHILDANCHOR)
                        #  - définir des MARK se souvenant d'endroits
                        #  - appliquer plein de TAG, dont plupart des attributs de Pango
TEXTVIEW
( [REFPTR<TEXTBUFFER>] )
TEXTVIW.{s,g}et_buffer()#Renvoie le contenu de TEXTVIEW, sous forme de REFPTR<TEXTBUFFER>
TXTVIW.{g,s}et_wrap_mode#
( WRAPMODE )            #(sinon NONE)
TXTVIEW.{g,s}et_editable#
( [BOOL_VAL] )          #(défaut true) (sinon true)
TEXTVIEW.{g,s}et_pixels_
above_lines( INT_VAL )  #
TEXTVIEW.{g,s}et_pixels_
below_lines( INT_VAL )  #
TEXTVIEW.{g,s}et_pixels_
inside_wrap( INT_VAL )  #
TEXTVIEW.
{g,s}et_justification   #
( JUSTIFICATION )
TEXTVIEW.{g,s}et_{left,
right}_margin( INT_VAL )#
TEXTVIEW.{g,s}et_indent #
( INT_VAL )             
TEXTVIEW.{g,s}et_tabs   #
( PANGO::TABARRAY )     #Pour toutes ces fonctions : cf TextBuffer::Tag       
TEXTVIEW.
{g,s}et_cursor_visible  #
( [BOOL_VAL] )          #Fait que le curseur est visible (défaut true) (sinon true)
TXTVEW.{g,s}et_overwrite#
( [BOOL_VAL] )          #Cf ENTRY.set_overwrite_mode()
TEXTVIEW.
{g,s}et_accept_tabs     #
( [BOOL_VAL] )          #Si true (défaut true) (sinon true), la touche Tab marche.

TEXTVIEW.scroll_to      #
( TEXTITER[, DOUBLE_VAL1#Scrolle de manière à ce que TEXTITER soit visible, avec maximum DOUBLE_VAL1 de marge entre lui et 
[, 2 DOUBLE_VAL]] )     #le bord (défaut 0), et un alignement précis de DOUBLE_VAL2,DOUBLE_VAL3. Renvoie true s'il y a scoll.
TEXTVIEW.scroll_to
( REFPTR<MARK>, ... )   #Même chose, mais avec une MARK, et ne renvoie rien.
TEXTVIEW.
move_mark_onscreen      #
( REFPTR<MARK> )        #Déplace MARK de sorte qu'elle soit dans la zone actuellement visible. Renvoie true s'il y a eu scroll.
TEXTVIEW.
place_cursor_onscreen() #Même chose pour le curseur.
TXTVIEW.get_visible_rect#
( GDK::RECTANGLE_VAR )  #Remplis RECTANGLE_VAR des coordonnées locales de la zone visible par rapport au TEXTBUFFER entier.
TEXTVIEW.get_iter_      #
location( TEXTITER, 
GDK::RECTANGLE_VAR )    #Met les coordonnées locales du caractère TEXTITER dans RECTANGLE_VAR.
TEXTVIEW.
get_iter_at_location    #
(TEXTITER_VAR,2 INT_VAL)#Modifie TEXTITER_VAR en fonction des coordonnées locales des INT_VAL.
TEXTVIEW.get_line_yrange#
( TEXTITER, 2 INT_VAR ) #Met dans INT_VAR1 la position y de la ligne contenant TEXTITER, et dans INT_VAR2 sa hauteur.
TEXTVIEW.get_line_at_y  #
( TEXTITER_VAR,         #Met dans TEXTITER_VAR le premier caractère de la ligne dont la position y est INT_VAL1, et dans 
INT_VAL1, INT_VAR2 )    #INT_VAR2 la position y maximum de cette ligne.

TEXTVIEW.{back,for}ward_
display_line            #
( TEXTITER_VAR )        #Modifie TEXTITER_VAR pour le déplacer d'une ligne, mais visuelle (si wrapped,!= "TEXTITER-ligne" donc)
TEXTVIEW.{back,for}ward_
display_line{start,end} #
( TEXTITER_VAR )        #Même chose pour fin ou début de la "ligne visuelle"
TEXTVIEW.
starts_diplay_line      #
( TEXTITER )            #Renvoie true si TEXTITER est au début d'une "ligne visuelle"

TEXTVIEW.
add_child_at_anchor     #
( WIDGET_VAR,
REFPTR<TEXTCHILDANCHOR>)#Rajoute un WIDGET à l'endroit où est TEXTCHILDANCHOR.

TextBuffer              #Désigne un text buffer, tel qu'affiché dans une zone éditable (TEXTVIEW). Non instantiable.
                        #TEXT_ARGS signifie : ( USTRING ) ou ( CHAR_ADR_ITVR1, CHAR_ADR_ITVR2 ), désignant un texte.
                        #TEXT_RANGE signifie : TEXTITER1, TEXTITER2.
                        #"Ligne" signifie "paragraphe", espace entre deux newlines, pas ligne graphique.
TextBuffer::
create( [TAGTABLE] )

TEXTBUFFER.size()       #Renvoie le nombre de caractères écrits.
TEXTBUFFER.
get_line_count()        #Renvoie le nombre de lignes écrites.
TEXTBUFFER.get_text     #Renvoie le texte du range (par défaut tout le TEXTBUFFER), sous forme d'USTRING. Si false (défaut
([TEXTRANGE[,BOOL_VAL]])#true), les caractères invisible ne sont pas pris en compte.
TEXTBUFFER.set_text     #
( TEXT_ARGS )           #Remplace le texte.
TEXTBUFFER.insert       #
( TEXTITER, TEXT_ARGS ) #Insert un texte à TEXTITER, et renvoie un TEXTITER2 sur la fin de l'insertion.
TEXTBUFFER.insert       #
( TEXTITER, TEXTRANGE ) 
TEXTBUFFER.insert_at_   #
cursor( TEXT_ARGS )     #Même chose, mais TEXTITER est le curseur courant.
TEXTBUFFER.             #Comme insert*, sauf que prend un dernier argument BOOL_VAL (défaut true), et ne fait rien si 
insert_interactive_*    #l'editability de TEXTITER est == BOOL_VAL. Si devait renvoyer void -> renvoie bool ; sinon renvoie
                        #PAIR<TEXITER,BOOL>. BOOL du résultat indique si TEXTITER était == BOOL_VAL
TEXTBUFR.insert_with_tag#
( TEXTITER, TEXT_ARGS,  #
REFPTR<TAG> )           #Comme insert(), mais en plus applique TAG.
TXTBUFR.insert_with_tags#
( TEXTITER, TEXT_ARGS,  #
VECTOR<REFPTR<TAG> > )  #Pareil, mais avec plusieurs TAG.
TEXTBUFR.insert_with_tag#
( TEXTITER, TEXT_ARGS,  #
USTRING )               #Comme insert with tag(), mais utilise nom du TAG.
TXTBUFR.insert_with_
tags_by_name( TEXTITER, 
TEXTARGS,VECTR<USTRING>)#Comme insert_with_tags(), mais utilise nom du TAG.
TEXTBUFFER.erase
( TEXTRANGE )           #Supprime le texte du range.
TEXBUFFER.
erase_interactive*      #Comme insert_interactive_* mais pour erase
TEXTBUFFER.backspace    #
( TEXTITER[, BOOL_VAL] )#Supprime caractère précédant TEXTITER. Si BOOL_VAL est true (défaut true), "interactive".

TEXTBUFFER.begin()      #
TEXTBUFFER.end()        #
TEXTBUFFER.get_iter_at_ #
offset( INT_VAL )
TEXTBUFFER.get_iter_at_ #
line_offset( INT_VAL1,
INT_VAL2 )
TEXTBUFFER.get_iter_at_ #
line_index( INT_VAL1,
INT_VAL2 )
TEXTBUFFER.get_iter_at_ #Renvoie un TEXTITER : cf TEXTITER pour la signification. 
line( INT_VAL )         #line_offset et line_index prennent le numéro de la ligne en premier argument.

TEXTBUFFER.
get_has_selection()     #Renvoie true si du texte est sélectionné.
TEXTBUFFER.             
get_selection_bounds    #Effectue get_has_selected(), puis fait que la sélection courante est appliqué au range. Si pas de
( TEXTRANGE_VAR )       #sélection, TEXTITER_VAR1 == TEXTITER_VAR2, mais permet de connaître position courante.
TEXTBUFFER.select_range
( TEXTRANGE )           #Modifie la sélection courante.
TXTBUFER.erase_selection
( [BOOL_VAL] )          #Supprime le texte de la sélection courante. Si BOOL_VAL est true (défaut true), "interactive".
TEXTBUFFER.place_cursor #
( TEXTITER )            #Si sélection, plus de sélection, et déplace le curseur courant vers TEXTITER.

TXTBUFER.copy_clipboard #
( REFPTR<CLIPBOARD> )   #Copie la sélection courante dans CLIPBOARD.
TXTBUFR.paste_clipboard #
( REFPTR<CLIPBOARD>     #Colle la sélection courante dans CLIPBOARD à partir de TEXTITER (défaut curseur courant). Si true
[,TEXTITER][, BOOL_VAL])#(défaut true), "éditable".
TEXTBUFFER.cut_clipboard#
( REFPTR<CLIPBOARD>
[, BOOL_VAL])
TEXTBUFFER.{add,remove}_
selection_clipboard     #Fait que CLIPBOARD sera automatiquement remplis par la sélection courante à chaque fois que la 
( REFPTR<CLIPBOARD> )   #sélection courante changera.

TEXTBUFFER.insert_pixbuf#
( TEXTITER,             #Insert PIXBUF à partir de TEXTITER comme s'il s'agissait d'un seul caractère. Renvoie un TEXTITER sur
REFPTR<GDK::PIXBUF> )   #le caractère qui suit.
TEXTBUFFER.
insert_child_anchor     #
( TEXTITER, 
REFPTR<TEXTCHILDANCHOR>)#Insert TEXTCHILDANCHOR à partir de TEXTITER.
TEXTBUFFER.
create_child_anchor     #
( TEXTITER )            #Crée un REFPTR<TEXTCHILDANCHOR>, le renvoie et l'insert à partir de TEXTITER.
TEXTBUFFER.
get_iter_at_child_anchor#
(REFPTR<TXTCHILDANCHOR>)#Renvoie un TEXTITER sur la position de TEXTCHILDANCHOR

TEXTBUFFER.create_mark  #
( [USTRING, ]TEXTITER ) #Crée et renvoie une MARK à l'endroit TEXTITER dont le nom est USTRING.
TEXTBUFFER.add_mark     #
(REFPTR<TXTBUFER::MARK>,#
TEXTITER )              #Ajoute MARK à l'endroit TEXTITER.
TEXTBUFFER.move_mark    #
(REFPTR<MARK>, TEXTITER)#Déplace MARK vers TEXTITER.
TEXTBUFFER.delete_mark  #
( REFPTR<MARK> )        #Supprime MARK.
TEXTBUFFER.mark_by_name*#Comme move_mark()et delete_mark() sauf qu'utilise non un REFPTR<MARK> mais une USTRING désignant le
                        #name de la MARK.
TEXTBUFFER.get_mark     #
( USTRING )             #Renvoie la REFPTR<MARK> dont le name est USTRING
TEXTBUFFER.
get_iter_at_mark        #
( REFPTR<MARK> )        #Renvoie un TEXTITER pointant sur MARK.
TEXTBUFFER.get_insert() #Renvoie la REFPTR<MARK> du curseur courant. Le déplacer déplace le curseur courant.
TEXTBUFFER.
get_selection_bound()   #Même chose pour fin de la sélection courante (== curseur courant si pas de sélection)

TEXTBUFFER.set_modified #
( [BOOL_VAL] )          #Modifie le LastModifFlag (défaut true)
TEXTBUFER.get_modified()#Renvoie true si le LastModifFlag est false, et qu'une modification a eu lieu depuis le dernier
                        #set_modified().

DRAG&DROP ==>           #Cf Chapitre pour Drag&Drop

TEXTBUFFER.
get_tag_table()         #Renvoie la REFPTR<TEXTBUFFER::TAGTABLE> associé à TEXTBUFFER.
TEXTBUFFER.create_tag   #Effectue un Tag::create( USTRING ) (le renvoie donc) suivi d'un TAGTABLE.add( USTRING ). Attention, 
([USTRING])             #si TAG déjà existant, crash le programme : checker donc avec if ( ....lookup( ... ) ).
TEXTBUFFER.apply_tag    #
(REFPTR<TAG>, TEXTRANGE)#Applique le TEXTBUFFER::TAG sur le range.
TEXTBUFFER.remove_tag   #
(REFPTR<TAG>, TEXTRANGE)#Supprime toute utilisation de TEXTBUFFER::TAG sur le range.
TEXTBUFFER.
*_tag_by_name*          #Comme apply_tag() et remove_tag() mais utilise le nom USTRING du TAG, et non REFPTR<TAG>
TEXTBUFFER.remove_all_  #
tags( TEXTRANGE )       #Supprime tous les TEXTBUFFER::TAG sur le range.
TEXTBUFFER.register_
[de]serialize_tagset    #
( USTRING )             #Utilisé pour sérialiser/désérialiser les TAG, mais ne parvient pas à faire marcher.

TEXTBUFFER.{begin,end}_ #Emet le signal correspondant. Ces deux signaux sont par ailleurs émis simultanément à chaque opération
user_action()           #"intéractive", c'est-à-dire à chaque insertion/suppression de l'user, ou à chaque fonction avec le 
                        #mot "interactive" ou avec une BOOL_VAL indiquant l'"interactivité"
                        #Un begin_user_action() appelé explicitement ignorera les prochains signaux, jusqu'à appel explicite
                        #d'un end_user_action(). De plus, si un deuxième begin_user_action() a lieu, il n'émet pas non plus
                        #de signal, mais devra appelé un deuxième end_user_action() avant d'émettre un signal. Cela permet 
                        #de grouper un ensemble d'actions en une seule, dans un but d'undo-historique.

TextIter                #Désigne un itérateur de TextBuffer. Respecte BidirectionalIt. concept. La value_type est un GUNICHAR
                        #(cf GLIB::USTRING)
                        #Un TEXTITER est invalidé après toute modification de TEXTBUFFER (contrairement à un MARK)
TXTITER.get_buffer()    #Renvoie le TEXTBUFFER associé sous forme de REFPTR<TEXTBUFFER>
TXTITER.{s,g}et_offset()#Renvoie l'offset (nombre de caractères, pas d'octets) depuis le début du TEXTBUFFER.
TEXTITER.
{s,g}et_line_offset()   #Même chose, mais depuis le début de la ligne.
TEXTITER.
{s,g}et_line_index()    #Comme get_line_offset(), mais en octets, pas en caractères.
TEXTITER.{s,g}et_line() #Renvoie le numéro de ligne.
TEXTITER.get_text     
(TEXTITER2)             #Renvoie le texte compris dans le range, sous forme d'USTRING.
TEXTITER.{g,s}et_
visible_line_*(...)     #Comme {g,s}et_line_*(), mais ne compte pas les caractères invisible (via application d'un TAG)
TEXTITR.get_visible_text#
( TEXTITER2 )           #Même chose
TEXTITER.
get_chars_in_line()     #Renvoie le nombre de caractères de la ligne courante, sous forme d'INT_VAL.
TEXTITER.
get_bytes_in_line()     #Même chose, mais avec des octets.
TEXTITER.
{for,back}ward_search   #
( USTRING, 
TEXTSEARCHFLAGS,        #Rechecher USTRING entre position courante et TEXTITER3 (défaut fin du TEXTBUFFER), et si trouve,
2 TEXTITER_VAR          #renvoie true et met string trouvée dans les deux TEXTITER_VAR. TEXTSEARCHFLAGS est parmi :
[, TEXTITER3] )         #TEXT_SEARCH_{VISIBLE_ONLY,TEXT_ONLY,CASE_INSENSITIVE}

TEXTITER.
{for,back}ward_find_char#Effectue ++ ou -- jusqu'à TEXTITER (défaut fin du TEXTBUFFER) ou jusqu'à ce que PREDIC renvoie true.
( PREDIC[, TEXTITER] )  #PREDIC prend un GUNICHAR const& et renvoie bool.

TEXTITER.forward_       #Avance d'un cursor position (== une lettre, sauf les endroits où un curseur ne peut pas être, par
cursor_position()       #exemple entre un \r et une \n dans une newline Windows). Renvoie false si pas de mouvement.
TEXTITER.forward_char() #Même chose pour prochain caractère.
TEXTITER.forward_line() #Même chose pour prochaine ligne.
TEXTITER.
forward_word_end()      #Même chose pour prochain mot.
TEXTITER.
forward_sentence_end()  #Même chose pour prochaine phrase.
....forward_*s(INT_VAL) #Appelle INT_VAL fois forward_*()
....backward_*( ... )   #Comme ....forward_*, mais à l'envers. "end" est remplacé par "start" et désigne début et non fin.
TEXTITER.*ward_visible_*
( ... )                 #Pareil, mais ne compte pas les caractères invisible (via application d'un TAG)
TEXTITER.
forward_to_end()        #Avance à la fin du TEXTBUFFER.
TEXTITER.
forward_to_line_end()   #Avance à la fin de la ligne. Renvoie false si pas de mouvement.
TEXTITER.
{starts,insides,ends}_
{word,sentence,line}()  #Renvoie true si position courante est au début / dans / à la fin d'un word/phrase/ligne.
TEXTITER.
is_cursor_position()    #Renvoie true si position courante est une cursor position (cf forward_cursor_position())
TEXTITR.is_{start,end}()#Renvoie true si position courante est au début ou fin du TEXTBUFFER.

TEXTITER.in_range
( TEXTITER2, TEXTITER3 )#Renvoie true si TEXTITER se trouve dans le range.
TEXTITER.compare
( TEXTITER2 )           #Renvoie 0 si pointe au même endroit ; > 0 si TEXTITER est après TEXTITER2 ; < 0 sinon.
TEXTITER.order(TEXTITR2)#Si TEXTITER est après TEXTITER2, swap.
TEXTITER == TEXTITER2
... !=, <, >, <=, >=    #Préférer méthodes du dessus, plus rapides.

TEXITER.
{begins,ends,toggles,   #Renvoie true si TAG (par défaut tout TAG) commence ; se termine ; commence ou termine ; est présent
has}_tag( [REFPTR<TAG>])#à l'endroit présent.
TEXTITER.get_tags()     #Renvoie tous les TAG de l'endroit présent sous forme de VECTOR<TAG>
TEXTITER.
get_toggled_tags        #Renvoie les TEXTBUFFER::TAG (si true (défaut true), commençant, sinon terminant) à l'endroit
( [BOOL_VAL] )          #courant sous forme de VECTOR<TAG>
TEXTITER.{for,back}ward_
to_tag_toggle           #Avance/recule vers la prochaine/dernière toggle (début ou fin de TAG) de TAG. Si REFPTR est 0 : 
( REFPTR<TAG> )         #désigne tout TAG. Renvoie false si pas de mouvement.
TEXTITER.editable       #Renvoie truesi l'endroit courant à un TAG indiquant la propriété editable == BOOL_VAL (par défaut
( [BOOL_VAL] )          #true)
TEXTITER.can_insert     #
( [BOOL_VAL] )          #Même chose, mais en plus considère l'editability du TEXTBUFFER lui-même.
TEXTITER.get_language() #Renvoie PANGO::LANGUAGE de la position courante.

TextBuffer::TagTable    #Ensemble des tags associés (pas forcément appliqués) à un TEXTBUFFER. Non instantiable : utiliser
                        #factory method ...::create()
TAGTABLE.add            #Ajoute un TAG à TEXTBUFFER. Affiche un avertissement si TAG est déjà présent : vérifier avec un
( REFPTR<TAG> )         #if ( ...lookup( ... ) )
TAGTABLE.remove
( REFPTR<TAG> )         #Même chose, mais pour la suppression.
TAGTABLE.lookup
( USTRING )             #Renvoie le REFPTR<TAG> dont le nom est USTRING. Est REFPTR null si TAG absent.
TAGTABLE.get_size()     #Renvoie le nombre de TAGS associés.
TAGTABLE.foreach(PREDIC)#PREDIC est void et prend un REFPTR<TEXTBUFFER::TAG> const& en argument. Invoque PREDIC avec tous les
                        #TAG de TAGTABLE.

TextBuffer::Tag         #Désigne un ensemble de propriété tel que couleur, taille, etc. que l'on peut appliquer à un ensemble
                        #de mots dans un TEXTBUFFER.
                        #On ne peut pas ajouter deux fois le même TAG a un TEXTBUFFER, mais on peut l'appliquer autant de fois
                        #que l'on veut.
                        #Non instantiable : utiliser create()
TextBuffer::Tag::create 
( [USTRING] )           #Renvoie un REFPTR<TAG> dont le nom est USTRING (défaut : "")
TAG.property_*()        #Renvoie un PROP :
                        #  - PROP_R :
                        #     - name : <USTRING>, nom du tag
                        #  - PROP_W :
                        #     - background : <USTRING>, couleur d'arrière plan (USTRING format : cf Gdk::Color)
                        #     - paragraph_background : même chose, mais pour toute la ligne
                        #     - [paragrah_]background_gdk : même chose, mais avec <GDK::COLOR>, et est PROP
                        #     - foreground* : même chose, premier plan. paragraph_foreground pas disponible.
                        #  - PROP :
                        #     - background_full_height : <BOOL>, fait que la couleur d'arrière plan ait la hauteur des 
                        #       caractère (false) ou de la ligne (true, default)
                        #     - size <INT> : taille, en PANGO_SCALE
                        #     - size_points : <DOUBLE>, taille en points
                        #     - scale : <DOUBLE>, taille, par rapport à la taille par défaut
                        #     - fontdescription <FONTDESCRIPTION>
                        #     - font <USTRING> : FONTDESCRIPTION, mais comme une USTRING (cf Pangomm)
                        #     - family <USTRING> : nom d'une FONTFAMILY
                        #     - weight <PANGO::WEIGHT>
                        #     - style <PANGO::STYLE>
                        #     - variant <PANGO::VARIANT>
                        #     - stretch <PANGO::STRETCH>
                        #     - underline : <PANGO::UNDERLINE>
                        #     - strikethrough <BOOL>
                        #     - pixels_above_lines : <INT>, espace entre ligne courante et paragraphe du dessus. Seuls les
                        #       lignes sélectionnées entièrement sont concernées.
                        #     - pixels_below_lines : même chose, mais inverse.
                        #     - wrap_mode : <WRAPMODE>, wrap mode parmi : Pango::WRAP_NONE (défaut), WRAP_CHAR (coupe les mots)
                        #       WRAP_WORD (ne coupe pas les mots), WRAP_WORD_CHAR (comme WRAP_WORD)
                        #     - pixels_inside_wrap : <INT>, espace entre deux lignes wrappées (pour une seule même "véritable"
                        #       ligne)
                        #     - justification : <JUSTIFICATION>, Justification du paragraphe , parmi
                        #       JUSTIFY_{LEFT,RIGHT,FILL,CENTER}
                        #     - direction : <TEXTDIRECTION>, choix : TEXT_DIR_{NONE,RTL,LTR}
                        #     - indent : <INT>, en pixels
                        #     - left_margin : <INT>. Différence avec indent : s'applique sur toutes les lignes wrappées, pas 
                        #       seulement la première.
                        #     - right_margin : <INT>
                        #     - accumulative_margin <BOOL> : true si left_margin et right_margin s'accumulent
                        #     - tabs <PANGO::TABARRAY>
                        #     - rise <INT>
                        #     - language <USTRING> : cg Pangomm
                        #     - invisible : <BOOL>, invisible, mais là.
                        #     - editable : <BOOL>, possibilité de modifier/insérer
TAG.property_*_set()    #* est le même que ci-dessus, mais renvoie un PROP<BOOL> où, si false, la propriété est disabled
                        #tant que true n'est pas revenu.
TAG.{g,s}et_priority    #Si deux tags sont en conflits et non-complémentaires, et appliqués à une même zone, celui avec la 
( INT_VAL )             #plus grande priority l'emporte. La priority doit être >= 0 et < nombre de tags. Par défaut, le
                        #dernier tag créé a une priority + 1 par rapport à l'avant-dernier tag.

TextChildAnchor         #Point dans un TEXTBUFFER où l'on peut rajouter des WIDGET_VAR, via TEXTVIEW.add_child_at_anchor()
                        #Un WIDGET compte pour un caractère.
...::create()           #Renvoie un REFPTR<TEXTCHILDANCHOR>
TEXTCHILDANCHOR.
get_widgets()           #Renvoie les WIDGET associés sous forme de VECTOR<WIDGET_ADR>
TEXTCHILDANCHOR.
get_deleted()           #Renvoie true si associé à aucun TEXTBUFFER.

TextBuffer::Mark        #Désigne une position marque-page dans un TEXTBUFFER.
                        #Contrairement aux TEXTITER, ils restent valides, même après modification du TEXTBUFFER.
...::create( [USTRING] )#USTRING est le name. Renvoie un REFPTR<MARK>
MARK.get_buffer()       #Renvoie le REFPTR<TEXTBUFFER> associé.
MARK.get_iter()         #Renvoie un TEXTITER pointant sur cet endroit.
MARK.{g,s}et_visible    #
( [BOOL_VAL] )          #Si true (défaut true) (sinon false), une ligne verticale est affichée à l'endroit de la MARK.
MARK.get_name()         #Renvoie nom USTRING de la MARK.
MARK.get_deleted()      #Renvoie true si TEXTBUFFER.delete_mark() a été appelée sur MARK.

                                  ┌───────────────┐
                                  │   DRAG&DROP   │
                                  └───────────────┘

DRAG & DROP ==>         #Un Widget devient draggable après un drag_source_set()
                        #Un Widget devient droppable après un drag_dest_set()
                        #Un Widget draggable, lors d'un dragging émet les signaux (dans l'ordre) :
                        #  - drag_begin <void,RefPtr<Gdk::DragContext> > : début du drag
                        #  - drag_data_get <void,RefPtr<Gdk::DragContext>,SelectionData&,uint,uint> : fin du drag, successful.
                        #    SELECTIONDATA est vide au début. Premier uint est l'"info" de la source. Deuxième uint est le
                        #    timestamp du drop. But : remplir le message à transmettre via SelectionData.
                        #  - drag_failed <bool,RefPtr<Gdk::DragContext>,DragResult> : fin du drag, si non successful. 
                        #    But : donner infos pourquoi échec et état du contexte. DragResult parmi :
                        #    DRAG_RESULT_{SUCCESS,NO_TARGET,USER_CANCELLED,TIMEOUT_EXPIRED,GRAB_BROKEN,ERROR}
                        #  - drag_data_delete <void,RefPtr<Gdk::DragContext> > : fin du drag, si successful et ACTION_MOVE.
                        #    But : supprimer le widget source.
                        #  - drag_end <void,RefPtr<Gdk::DragContext> > : fin du drag, successful ou non
                        #Un Widget droppable, lors d'un dropping émet les signaux (dans l'ordre) :
                        #  - drag_motion <bool,RefPtr<Gdk::DragContext>,int,int,uint> : drag bouge d'un pixel dans la zone du
                        #    drop-widget (survol). uint est le timestamp, les deux int sont les coordonnées depuis le coin
                        #    supérieur gauche du drop-widget.
                        #  - drag_leave <void,RefPtr<Gdk::DragContext>,uint> : drag quitte la zone du widget après 
                        #    l'avoir survolé. uint est le timestamp.
                        #  - drag_data_received <void,RefPtr<Gdk::DragContext>,int,int,SelectionData&,uint,uint> : drop.
                        #    Même signification que data_get, avec en plus deux int indiquant les coordonnées.
                        #    But : accéder au message transmis via SelectionData.
                        #  - drag_drop <bool,RefPtr<Gdk::DragContext>,int,int,uint> : drop. Même signification que drag_motion
                        #Le timestamp est à l'échelle de l'application, pas seulement du drag donné.
                        #Pour qu'un dropping ait lieu :
                        #  - les TARGETENTRY du drag-Widget et du drop-Widget doivent concorder.
                        #  - les DRAGACTION doient concorder
                        #Pour passer un message : cf SelectionData.
                        #Après tout drop, invoquer DRAGCONTEXT.drag_finish()

SelectionData           #Data/Information transmise lors d'un drag & drop. 
                        #Rempli par handler de drag_data_get et accédé par celui de drag_data_received.
                        #Le set et le get doivent être du même type :
                        #  - set()  <-> get_data(), get_data_as_string(), get_length(), get_format(); get_data_type()
                        #  - set_text() <-> get_text()
                        #  - set_pixbuf() <-> get_pixbuf()
                        #  - set_uris() <-> get_uris()
                        #Utiliser les trois dernières en fonction du résultat de target_include*, sinon set()
                        #Ne pas instantier soi-même : utiliser seulement via des callbacks auquel le système fournit un 
                        #SELCTIONDATA par référence.
SELECTIONDATA.set       #Remplit SelectionData par INT_VAL2 octets depuis UCHAR_ADR. INT_VAL1 sert d'info pour la
( [STRING, ]INT_VAL1,   #destination : en général le nombre de bits par pixels si image. STRING est la "target" (utiliser 
UCHAR_ADR, INT_VAL2 )   #get_target() si une seule "target")
SELECTIONDATA.set
( STRING1, STRING2 )    #
SELECTIONDATA.
get_data_type()         #Renvoie STRING mise par set()
SELCTINDATA.get_format()#Renvoie INT_VAL1 mis par set()
SELCTINDATA.get_length()#Renvoie la taille de SELECTIONDATA sous forme d'INT_VAL
SELECTIONDATA.get_data()#Renvoie SELECTIONDATA sous forme d'UCHAR_ADR.
SELECTIONDATA.
get_data_as_string()    #Renvoie SELECTIONDATA sous forme de STRING.
SELECTIONDATA.
{g,s}et_text( USTRING ) #Pas de "target" précisé ici.
SELECTIONDATA.{g,s}et_
pixbuf( REFPTR<PIXBUF> )#Remplit avec une image.
SELECTIONDATA.{g,s}et_
uris( VECTOR<USTRING> ) #Remplit avec une suite d'USTRING.
SELCTINDATA.get_target()#Renvoie la "target" de la source, sous forme de STRING
SELECTIONDATA.
targets_include_uri()   #Renvoie true si au moins une "target" est relative aux URI.
SELECTIONDATA.
targets_include_text()  #Même chose pour text.
SELECTIONDATA.
targets_include_image   #
( [BOOL_VAL] )          #Même chose pour PIXBUF (Si true (défaut true), seulement PIXBUF que GTK sait écrire)

DragContext             #Contexte d'un dragging donné.
DRAGCONTEXT.set_icon
([REFPTR<CAIRO::SURFC>])
DRAGCONTEXT.set_icon
( REFPTR<GDK::PIXBUF>, 
2 INT_VAL )
DRAGCONTEXT.set_icon    #
( USTRING, 2 INT_VAL )
DRAGCONTXT.set_icon_name#
( USTRING, 2 INT_VAL )  #Modifie l'icône. Les INT_VAL décalent l'icône vers la gauche et le haut.
DRAGCONTEXT.
get_source_window()     #Renvoie la REFPTR<WINDOW> où a commencé le drag.
DRAGCONTEXT.
get_dest_window()       #Même chose pour le drop, si drop a eu lieu, sinon REFPTR vide.
DRGCONTXT.list_targets()#Renvoie l'ensemble des "target" de la source, sous forme de VECTOR<STRING>
DRGCONTXT.get_protocol()#Renvoie le DRAGPROTOCOL utilisé, parmi : DRAG_PROTO_{NONE,MOTIF,XDND,ROOTWIN,WIN32_DROPFILES,OLE2,
                        #LOCAL}
DRGCNTXT.get_selection()#Renvoie type de sélection, par exemple "XdndSelection", sous forme d'USTRING
DRAGCONTEXT.drag_finish #
( BOOL_VAL1, BOOL_VAL2, #A invoquer après tout drop : BOOL_VAL1 doit être true si succès ; BOOL_VAL2 true s'il faut supprimer
UINT32_VAL )            #source ; UINT32_VAL est le timestamp.
DRAGCONTXT.get_actions()#Renvoie le DRAGACTION du drag-widget.
DRAGCONTXT.
get_suggested_action()  #Pareil ?
DRAGCONTXT.
get_selected_action()   #Renvoie le DRAGACTION du drop-widget.
Widget::
drag_get_source_widget  #
( REFPTR<DRAGCONTEXT> ) #Renvoie le drag-widget sous forme de WIDGET_ADR.

TargetEntry             #Police désignant qu'un dropping peut avoir lieu. Trois filtres : 
                        #  - "target" : une USTRING désignant le type de données, par exemple mime_type
                        #  - "info"   : comme "target", mais sous d'id UINT_VAL. Ne filtre pas, mais passé à plusieurs signaux.
                        #  - "flags"  : TARGETFLAGS désignant cibles admises parmi (or'd) : TARGET_{SAME,OTHER}_{WIDGET,APP}.
                        #               Par défaut toutes : possible donc de cibler une autre application ou le même widget.
TARGETENTRY( [USTRING
[, TARGETFLAGS
[, UINT_VAL]]] )
TARGETENTRY.
{g,s}et_target( USTRING)#
TARGETENTRY.
{g,s}et_info( UINT_VAL )#
TARGETNTRY.{g,s}et_flags#
( TARGETFLAGS )         

TargetList              #Ensemble de TargetEntry.
TargetList::create      #
( VECTOR<TARGETENTRY> ) #Renvoie un REFPTR<TARGETENTRY>
TARGETLIST.add( ARGS )  #Ajoute un TargetEntry( ARGS )
TARGETLIST.add
( VECTOR<TARGETENTRY> )
TARGETLIST.remove       #
( USTRING )             #Supprime TARGETENTRY dont la "target" est USTRING
TARGETLIST.find         #
( USTRING, UINT_ADR )   #Renvoie true si TARGETENTRY avec "target" USTRING et "info" UINT_VAL existe.

WIDGET.drag_source_set  #MODIFIERTYPE sont les touches pouvant démarrer le drag. Par défaut toutes. Penser à or'd BUTTON*_MASK
( VECTOR<TARGETENTRY>   #si redéfinition. GDK::DRAGACTION parmi : ACTION_{DEFAULT,COPY,MOVE,LINK,PRIVATE,ASK} (défaut COPY)
[, GDK::MODIFIERTYPE    #est l'action effectuée (pour info à passer au drop-widget). MOVE devrait supprimer l'original,
[, GDK::DRAGACTION]] )  #LINK créer un lien, PRIVATE est quand on ignore l'action que fera le drop-widget, ASK quand il lui
                        #sera demandé s'il le veut.
                        #Souvent Shift indique MOVE au lieu de COPY.
WDGT.drag_source_unset()#
WIDGET.drag_source_     #
set_icon( ARGS )        #Modifie l'icône lors du drag. ARGS : REPTR<PIXBUF>, STOCKID ou USTRING (icon name)
WIDGT.drag_{source,dest}
_add_{text,image,uri}_  #
targets()               #Fait qu'un ensemble de "target" pour les textes/images/URI sont ajoutés.

WIDGET.drag_dest_set    #TARGETENTRY : comme drag_source_set().
( [VECTOR<TARGETENTRY>] #DESTDEFAULTS est or'd parmi :
[, DESTDEFAULTS         #  - DEST_DEFAULT_MOTION    : permet d'activer signal motion et leave
[, GDK::DRAGACTION]] )  #  - DEST_DEFAULT_HIGHLIGHT : fait qu'il y ait un highlighting lors du survol
                        #  - DEST_DEFAULT_DROP      : permet d'activer signaux drop et data_received
                        #  - DEST_DEFAULT_ALL       : ensemble des trois (défaut)
                        #DRAGACTION est la liste or'd des DRAGACTION acceptées (par défaut tous)
WIDGET.drag_dest_unset()#
WDGT.drag_dest_
{g,s}et_target_list     #
( REFPTR<TARGETLIST> )  #
WIDGET.
drag_dest_find_target   #
(REFPTR<GDK::DRAGCNTEXT>#Renvoie sous forme d'USTRING la première "target" présente à la fois dans DRAGCONTEXT et dans 
[, REFPTR<TARGETLIST>] )#TARGETLIST (par défaut celle de WIDGET), où Gdk::NONE si aucun.

WIDGET.                 #Dessine des contours. Utilisé automatiquement lors d'un survol lors d'un drag, mais on peut l'utiliser
drag_[un]highlight()    #soi-même, notamment dans les handlers de drag_leave et drag_motion

METHODES SPECIALES ==>  #Ces méthodes de D&D sont spéciales à ces classes :

TOOLITEM.
set_use_drag_window     #Si true (défaut true) (sinon false), TOOLITEM peut être dragged (sinon impossible), mais ne peut plus 
( [BOOL_VAL] )          #être activé

TOOLITEMGROUP.
get_drop_item           #
( INT_VAL1, INT_VAL2 )  #Comme TOOLBAR.get_drop_index(), mais renvoie non l'index mais le TOOLITEM_ADR

TOOLPALETE.get_drop_item#
( 2 INT_VAL )           #Cf ToolItemGroup
TOLPALETE.get_drop_group#
( 2 INT_VAL )           #Pareil mais pour un TOOLITEMGROUP_ADR
TOOLPALETE.get_drag_item#
( SELECTIONDATA )       #Renvoie le TOOLITEM_ADR actuellement dragged via SELECTIONDATA.
TOOLPALETTE.
set_drag_source( ... )  #
TOOLPALETTE.
add_drag_dest( ... )    #Sensé être des drag_source_set() et drag_dest_set() récursifs, mais ne parvient pas à le faire marcher

TOOLBAR.get_drop_index  #Renvoie le numéro INT_VAL du TOOLITEM se trouvant aux coordonnées indiquées (pixels, depuis container
( INT_VAL1, INT_VAL2 )  #parent).
TOOLBAR.[un]set_drop_
highlight_item          #
( TOOLITEM_VAR, INT_VAL)#Ajoute/Supprime des contours autour de la place qu'aurait TOOLITEM s'il était placé à l'index INT_VAL

TEXTBUFFER.get_{copy,
paste}_target_list()    #Renvoie un REFPTR<TARGETLIST> de toutes les listes pour un drag ou un drop.

ENTRY.
drag_icon_drag_source   #
( REFPTR<TARGETLIST>
[, GDK::DRAGACTION      #Définie l'icône d'ENTRY comme un drag-widget, comme via un appel à drag_source_set(). DRAGACTION est
[, ENTRYICONPOSITION]] )#par défaut ACTION_COPY.
ENTRY.get_current_      #Si un icône d'ENTRY est currently dragged, renvoie 0 ou 1 selon son ENTRYICONPOSITION ; sinon renvoie
icon_drag_source()      #-1, sous forme d'INT_VAL.

CLIPBOARD ==>           #Pas D&D, mais utilise aussi les mêmes objets :

Clipboard               #Représente un presse-papier. Son contenu est représenté par un SELECTIONDATA interne.
                        #Attention : utiliser les méthodes get* correspondant au set* invoqué. Par exemple pas de
                        #wait_for_text() après un set(), etc.
Clipboard::get          #Renvoie un REFPTR<CLIPBOARD> en fonction de GDKATOM. Pour instantier un GDKATOM, faire :
( [GDKATOM] )           #  - gdk_atom_intern( STR, false )
                        #Par défaut, GDKATOM dont la STR est "CLIPBOARD" signifiant le presse-papier de l'OS. 
                        #N'a pas l'intention cependant de manipuler le presse-papier de l'OS mais juste de permettre d'utiliser
                        #un presse-papier pour communication entre deux programmes GTK. En effet, faire un coller avec le
                        #presse-papier de l'OS après un set* (autre que set_text()) renvoie une chaine vide même si le 
                        #CLIPBOARD est en fait bien remplis. Cependant avec set_text(), cela fonctionne.
                        #Cependant destruction de CLIPBOARD peut détruire contenu du presse-papier : cf store()
WIDGET.get_clipboard    #Renvoie un REFPTR<CLIPBOARD> dont l'identifiant est USTRING et associé à WIDGET. Mêmes identifiants
( USTRING )             #que ci-dessus.
CLIPBOARD.store()       #Si presse-papier de l'OS, fait que celui-ci n'est pas détruit et est conservé à la fin de 
                        #l'application. Pertinent que pour set_text()
CLIPBOARD.clear()       #Supprime contenu du SELECTIONDATA interne.

CLIPBOARD.set           #Fait que lorsque le contenu de CLIPBOARD sera demandé via un wait* ou request*, PREDIC1 sera appelé.
( VECTOR<TARGETENTRY>,  #PREDIC1 est void et prend ( SelectionData&, uint ). Il faut remplir SELECTIONDATA avec des data dont
PREDIC1, PREDIC2 )      #le type sera l'un de VECTOR<TARGETENTRY>. UINT_VAL est l'"info".
                        #PREDIC2 est void et ne prend rien. ???
CLIPBOARD.              #Si CLIPBOARD a été remplis avec un contenu dont la "target" est USTRING, renvoie la SELECTIONDATA 
wait_for_contents       #remplie par set(). Sinon, renvoie une SELECTIONDATA corrompue dont l'utilisation fait crasher le
( USTRING )             #programme : utiliser wait_is_target_available() pour vérifier.
CLIPBOARD.
wait_is_target_available#
( USTRING )             #Renvoie true si CLIPBOARD contient une SELECTIONDATA dont la "target" est USTRING
CLIPBOARD.
wait_for_targets()      #Renvoie un VECTOR<USTRING> représentant l'ensemble des "targets" de la SELECTIONDATA de CLIPBOARD
                        
CLIPBOARD.set_text      #Comme set(), mais utilise des TARGETENTRY automatique pour le type texte, et remplis tout de suite
( USTRING )             #le CLIPBOARD avec USTRING. Doit être utilisé avec ses propres méthodes : wait_for_text(), 
                        #wait_is_text_available(), etc., et non celles de set(), à l'exception de wait_for_targets()
CLIPBORD.wait_for_text()#Comme wait_for_contents(), mais pour un set_text(). Renvoie une USTRING.
CLIPBOARD.
wait_is_text_available()#Comme wait_is_target_available(), mais pour un set_text().

CLIPBOARD.set_image     #
( REFPTR<GDK::PIXBUF> ) 
CLPBORD.wait_for_image()#
CLIPBOARD.wait_
is_image_available()    #Pareil mais pour des REFPTR<PIXBUF>

CLPBORD.wait_for_uris() #Pareil mais pour des VECTOR<USTRING>. Cependant, pas de set_uris() disponible. Ou bien CLIPBOARD est
CLIPBOARD.              #remplis d'uris automatiquement par une fonction de Gtkmm (ignore s'il en existe), ou bien on peut
wait_is_uris_available()#faire un set() avec comme target "text/uri-list" et utiliser SELECTIONDATA.set_uris()
                        #Cependant j'ai trouvé le nom de la target dans le code source, je pense pas que ce soit portable : 
                        #utiliser alors set() + wait_for_contents(), avec une "target" arbitraire mais des VECTOR<USTRING>
                        #pour avoir même résultat.

CLIPBOARD.request*      #Comme CLIPBOARD.wait_for*, sauf qu'au lieu de renvoyant un TYPE, ne renvoie rien et prend un argument
                        #supplémentaire PREDIC de type void et prenant un TYPE comme argument. 
                        #Ce PREDIC sera alors invoqué avec le TYPE correspondant.

                                  ┌──────────────────────┐
                                  │   BUILDER&SETTINGS   │
                                  └──────────────────────┘

BUGS AVEC GLADE ==>     #Glade crashait toujours : j'ai corrigé en installant libgladeui-dev

GLADE FILE ==>          #  - En faire un par fenêtre
                        #  - Les mettre dans répertoire root source data/
                        #  - Mettre des macros dessus pour plus de flexibilité

Builder                 #Désigne une instantiation d'une interface créée via Glade. 
                        #Glade crée des fichiers .glade (fichiers XML décrivant l'interface créée).
                        #Un BUILDER permet d'aller récupérer l'objet que l'on veut (par exemple la WINDOW principale), en 
                        #désignant l'objet par son "name" (celui utilisé dans Glade, cf aussi Buildable).
                        #Non-instantiable, utiliser la factory method.
Builder::create()       #Renvoie un REFPTR<BUILDER> vide.
Builder::               #USTRING1 est le fichier du fichier .glade. Si USTRING2, seul le WIDGET dont le nom est USTRING2 pourra
create_from_file        #être manipulé. Renvoie un REFPTR<BUILDER>. Exception Glib::FileError, Glib::MarkupError et
( USTRING1[, USTRING2] )#Glib::BuilderError possibles. 
                        #On peut aussi utiliser une STR à la place d'USTRING2 ou un VECTOR<USTRING> pour un ensemble d'objets.
Builder::
create_from_string      #
( USTRING1[, USTRING2] )#Comme create_from_file(), sauf qu'USTRING1 contient le contenu du fichier .glade, non son filename.
BUILDER.add_from_*      #
( ARGS )                #Comme create_from_*, mais hors instantiation, et en rajout.
BUILDER.get_widget      #Place le WIDGET de BUILDER dont le name (Cf Buildable) est USTRING dans WIDGET. WIDGET_ADR reçoit une 
( USTRING, WIDGET_ADR ) #référence : le WIDGET n'est pas instantié pendant get_widget(), mais pendant create_from_file(). 
                        #get_widget() ne peut donc pas créer des doubles (par exemple deux fenêtres principales).
                        #Le WIDGET_ADR est automatiquement "manage" : il faut cependant donc ou bien le mettre dans un 
                        #container ou le détruire manuellement.
                        #Faire un if ( WIDGET_ADR ) pour tester existence.
                        #Pour chaque WIDGET ayant un callback, faire un get_widget(), et un signal*connect(), avec un bind si
                        #besoin d'arguments. L'association des callbacks automatiquement via le nom indiqué dans Glade n'est
                        #disponible qu'en C.
                        #Exemple :
                        # Gtk::Button* Bouton = 0;
                        # builder->get_widget( "button1", Bouton );
                        # if ( Bouton )
                        #   Bouton->signal_clicked().connect( sigc::bind( sigc::ptr_fun( myhandler ), Bouton->get_label() ) );
                        # delete Bouton;
BUILDER.get_object      #
( USTRING )             #Renvoie un REFPTR<GLIB::OBJECT> de l'OBJECT dont le nom est USTRING.A faire pour les OBJECT non-WIDGET

Buildable               #Classe abstraite, enfant de Glib::Interface. Désigne un objet instantiable par BUILDER.
BUILDABLE.{g,s}et_name  #
( USTRING )             #Change le "name" de l'objet, tel qu'utilisé par BUILDER.get_widget() ou get_object()

Settings                #Désigne les paramètres user-defined pour un GDK::SCREEN donné.
Settings::get_default() #Renvoie le REFPTR<SETTINGS> par défaut.
WIDGET.get_settings()   #Renvoie le REFPTR<SETTINGS> de WIDGET.
property_gtk_*()        #PROP :
                        #  - theme_name : USTRING, pour le reste, ex "Radiance"
                        #  - key_theme_name : USTRING, cf GtkBindingSet plus bas : theme pour cela, ex "Default"
                        #  - font_name : USTRING (ex "Ubuntu 11")
                        #  - xft_antialias : INT_VAL (0 no, 1 yes, -1 default), aliasing sous X (défaut true)
                        #  - xft_hinting : pareil pour aliasing hinting
                        #  - xft_hintstyle : USTRING, parmi hint{none,light,medium,full} (défaut hintlight)
                        #  - xft_rgba : USTRING, subpixel antialiasing parmi {none,rgb,bgr,vrgb,vbgr} (défaut rgb)
                        #  - xft_dpi : INT_VAL, dpi * PANGO_SCALE (défaut PANGO_SCALE * 96)
                        #  - icon_theme_name : USTRING, pour les icônes, ex "ubuntu-mono-light"
                        #  - icon_sizes : USTRING, taille des BUILTINICONSIZE
                        #  - toolbar_icon_size : ICONSIZE, celui utilisé par défaut pour les icônes de toolbar (défaut 
                        #    ICON_SIZE_LARGE_TOOLBAR)
                        #  - cursor_theme_name : USTRING, pour les curseurs, ex "DMZ-White"
                        #  - cursor_theme_size : INT_VAL. Si 0, default. (défaut 24)
                        #  - button_images : BOOL, si false, un Button ne peut contenir qu'un label ou un WIDGET, pas les
                        #    deux (défaut : false)
                        #  - recent_files_limit : INT_VAL, nombre maximum de fichiers dans un RecentChooser (défaut 50)
                        #  - recent_files_max_age : INT_VAL, nombre maximum de jours pour être dans un RecentManager (défaut 
                        #    30)
                        #  - double_click_{time,distance} : INT_VAL, temps (ms) ou distance (pixels) maximum entre deux clics 
                        #    pour être un double clic (défaut 400ms et 5 pixels)
                        #  - cursor_blink : BOOL_VAL, clignotement curseur pour Entry ou TextView (défaut false)
                        #  - split_cursor : BOOL_VAL, diviser curseur pour les textes bidirectionnels (défaut true)
                        #  - menu_bar_accel : USTRING, touche accelerator pour la MenuBar (défaut "F10")
                        #  - dnd_drag_threshold : INT_VAL, nombre de pixels de mouvement avant de commencer un drag (défaut 10)
                        #  - show_input_method_menu : BOOL_VAL, context menu (clic droit) sur Entry ou TextView permet de 
                        #    changer input method (ex : Chinese input method) (défaut true)
                        #  - enable_animations : BOOL_VAL (défaut true)

                                  ┌───────────────────┐
                                  │   CUSTOMIZATION   │
                                  └───────────────────┘

CSS : 
  - WIDGET.reset_style()
  - WIDGET.get_style_property( USTRING, T_VAR )

StyleContext            #Informations de customisation, pour un WIDGET donné, construit comme une combinaison de STYLEPROVIDER.
                        #Leur précédence dépend de leur priorité (plus grand, plus prioritaire)
WIDGET.
get_style_context()     #Renvoie le STYLECONTEXT associé.
gtk_widget_style_get( WIDGET_ADR[, CSS_PROP, TYPE_ADR]..., NULL )   #Semble mettre dans TYPE_ADR la valeur de la CSS_PROP pour
WIDGET_ADR
STYLECONTEXT.
add_provider            
( REFPTR<STYLEPROVIDER>,
UINT_VAL )              #Rajoute un STYLEPROVIDER de priorité UINT_VAL (STYLE_PROVIDER_PRIORITY_{FALLBACK,USER} ???)

StyleProvider           #Enfant de Glib::Interface. Base classe pour informations de customisation, pour un WIDGET donné.

CssProvider             #Enfant de STYLEPROVIDER, utilisant des fichiers .css pour les infos de customisation.
                        #Feuille CSS par défaut : {$HOME/.themes,/usr/share/themes}/$THEME_NAME/gtk-3.0/gtk.css
                        #$THEME_NAME : cf Gtk::Settings "theme_name"
CssProvider::create()   #CSSPROVIDER vide
CssProvider::
get_default()           #CSSPROVIDER par défaut, quand aucun n'est sinon mis
CssProvider::get_named  
( USTRING1, USTRING2 )  #???
CSSPROVIDER.
load_from_data( STRING )#Ecrase fichier .css interne par contenu de STRING
CSSPROVIDER.            #Pareil, mais avec le fichier dont le path est STRING (doit être dans l'encoding utilisé par l'OS pour
load_from_path( STRING )#les filenames : cf filename_from_utf8( USTRING ))
CSSPROVDR.load_from_file
( REFPTR<GIO::FILE> )   #Pareil
CSSPROVIDER.to_string() #Renvoie le fichier .css sous forme d'USTRING

SYNTAXE FICHIER .CSS ==>#Voici :

STATEMENT : RULE ou @RULE

@RULE :
  - @import url("/chemin/vers/fichier.css");
  - @binding-set : lie touche à une property. Dans un fichier
    {$HOME/.themes,/usr/share/themes}/$KEY_THEME_NAME/gtk-3.0/gtk-key.css ($KEY_THEME_NAME : cf Gtk::Settings "key_theme_name")
      Cf GtkBindingSet pour comprendre
  - @define-color NOM COLOR : @NOM devient un alias de COLOR

COLOR :
  - simple (les définir si possible toujour via des @define-color) :
    - #ff00ff ou #f0f
    - rgb( 3 UCHAR_VAL ) ou rgb( 3 POURCENTAGES% )
    - rgba( 4 UCHAR_VAL ) ou rgb( 4 POURCENTAGES% )
  - composée :
    - non-gradient :
      - mix( COLOR1, COLOR2, FLOAT_VAL ) : COLOR1 * FLOAT_VAL + COLOR2 * ( 1 - FLOAT_VAL )
      - shade( COLOR, FLOAT_VAL ) : équivaut à mix( COLOR, rgb( 3 FLOAT_VAL% ), 0.5 )
      - lighter( COLOR ) : équivaut à shade( COLOR, 1 )
      - darker( COLOR ) : équivaut à shade( COLOR, 0 )
    - gradient :
      - -gtk-gradient(linear, FLOAT_VAL1 FLOAT_VAL2, FLOAT_VAL3 FLOAT_VAL4[, color-stop( FLOAT_VAL5, COLOR )]...) :
          va de FLOAT_VAL1;FLOAT_VAL2 à FLOAT_VAL3;FLOAT_VAL4 : 0 à 1, mais peut utiliser "top" et "left" pour 0, et "right"
          et "bottom" pour 1. Les FLOAT_VAL5 des color-stop sont aussi de 0 à 1
      - -gtk-gradient(radial, FLOAT1 FLOAT2, FLOAT3, FLOAT4 FLOAT5, FLOAT6[, color-stop( FLOAT_VAL5, COLOR )]...) :
          FLOAT3 et FLOAT6 sont les rayons (0 à 1)

CSS_PROP ? :
  - text-shadow: INT_VAL1, INT_VAL2, COLOR : ajoute une drop shadow avec un offset en pixels, sur du texte ou icones
  - box-shadow: INT_VAL1, INT_VAL2, INT_VAL3, COLOR : pareil pour les widgets rectangulaires, avec INT_VAL3 augmentant taille
    de chaque côté
  -

RULE :
  SELECTOR[, SELECTOR...] {
    CSS_PROP: VAL;... 
  }

SELECTOR :
  WIDGET[#NAME] [.MEMBRE]... [:STATE]...

WIDGET :
  - * pour dire "tous" (ou rien, mais seulement avec .MEMBRE et #NAME ?)
  - WIDGET : seulement WIDGET (nom de la class C, ex : GtkAssistant), pas ses enfants
  - WIDGET * : WIDGET et tous ses enfants
  - WIDGET1 WIDGET2   : pour un WIDGET2 enfant d'un WIDGET1
  - WIDGET1 > WIDGET2 : pour un WIDGET2 enfant direct d'un WIDGET1
  - WIDGET REGION[:PARTIE] : désigne une partie spécifique d'un WIDGET. PARTIE possibles : "first-child", "last-child"

MEMBRE :
  - CLASSDT "name" d'un WIDGET ayant déclaré via :
      gtk_style_context_add_class( , GTK_STYLE_CONTEXT_NAME ) dans l'instance init ???
    suivi de :
      #define GTK_STYLE_CONTEXT_NAME "name" ???
  - il y en a prédéfini pour les classes GTK+ existantes

NAME :
  - WIDGET dont le name est NAME (nom mis via WIDGET.{g,[un]s}et_name( USTRING ))

STATE : 
  - hover/prelight, active, insensitive, focused, selected, inconsistent, "rien" (normal)

CSS_PROP :
  - pas properties, mais "style properties"
  - il y en a prédéfinies pour les classes GTK+ existantes

VAL :
  - dépend du TYPE de CSS_PROP
  - shade(), etc. possible

CSS_PROP :
  - 

MEMBRES prédéfinis :
  - AccelLabel : accelerator
  - Assistant : sidebar, highlight
  - Button : button, default
  - Calendar : button, header, highlight, view
  - CellRendererProgress : progressbar
  - CellRendererSpinner : spinner
  - CellRendererToggle : check, radio
  - CheckButton : check
  - CheckMenuItem : check
  - ComboBox : combobox-entry
  - CustomPaperUnixDialog : inline-toolbar
  - Dnd : dnd
  - Entry : entry, progressbar, image
  - Expander : expander
  - FileChooserDefault : inline-toolbar
  - FileChooserEntry : tooltip
  - FileChooser : sidebar
  - Frame : frame
  - HandleBox : dock
  - IconView : cell, rubberband, view
  - InfoBar : error, info, question, warning
  - MenuBar : menubar
  - Menu : button, menu
  - MenuItem : menuitem
  - Notebook : notebook
  - Orientable : horizontal, vertical
  - Paned : pane-separator
  - ProgressBar : trough, progressbar
  - RadioButton : radio
  - RadioMenuItem : radio
  - Range : button, scrollbar, slider, trough
  - Scale : scale, mark, scale-has-marks-{above,below}
  - Scrollbar : scrollbar, frame
  - Separator : separator
  - SeparatorMenuItem : separator
  - SeparatorToolItem : separator
  - SpinButton : button, spinbutton
  - Spinner : spinner
  - Switch : slider, trough
  - TextView : view
  - ToggleButton : button
  - Toolbar : toolbar
  - ToolItemGroup : expander, horizontal, vertical
  - Tooltip : tooltip
  - TreeView : cell, rubberband, separator, expander, view
  - Window : background, grip

Regions : 
  - TreeView : column, column-header, row
  - Notebook : tab

Modifier Settings par défaut (n'arrive pas à le faire marcher) :
  - {$HOME/.themes,/usr/share/themes}/$THEME/gtk-3.0/settings.ini :
    - commence par "[Settings]"
    - puis statements "gtk-* = VAL", avec des tirets au lieu des underscores

$HOME/.themes,/usr/share/themes/ : GTK+
$THEME_DIR/*/cursors/ : curseurs
$HOME/.icons,/usr/share/icons/ : icons

                                  ┌───────────┐
                                  │   ENUMS   │
                                  └───────────┘

PackOptions         #Enum désignant une manière de placer les widgets dans une BOX. Valeurs possibles (en fonction du BOOL_VAL 
                    #utilisé lors de l'instantiation de la HBOX ou VBOX) :
                    #  - PACK_SHRINK + false : les widgets ont leur taille minimum, et sont collés vers le bord (supérieur ou 
                    #    gauche pour pack_start(), inférieur ou droite pour pack_end())
                    #  - PACK_EXPAND_PADDING + false : les widgets ont leur taille minimum, mais sont répartis les uns par 
                    #    rapport aux autres avec un espace égal (et aussi par rapport aux bords)
                    #  - PACK_EXPAND_PADDING ou PACK_SHRINK + true : les widgets ont leur taille minimum, mais la taille + 
                    #    marge de chacun d'eux est la même.
                    #  - PACK_EXPAND_WIDGET + false : les widgets ont une taille propre, et sont étirés au maximum pour 
                    #    couvrir toute la zone.
                    #  - PACK_EXPAND_WIDGET + true : les widgets ont tous la même taille, et sont étirés au maximum pour 
                    #    couvrir toute la zone.
                    #Dans l'ordre :
+------------------------------------------------------------------------------+
|xxyyyyyyyyyy                                                    aaaabbbbbbbbbb|
|         xx            yyyyyyyyyy           aaaa            bbbbbbbbbb        |
|       xx             yyyyyyyyyy              aaaa            bbbbbbbbbb      |
|xxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbb|
|xxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbb|
+------------------------------------------------------------------------------+

AttachOptions       #Enum désignant le packing d'un WIDGET dans une TABLE. Valeurs possibles (peut être or'd) :
                    # - EXPAND : le widget doit prendre le maximum de place dans la cellule
                    # - SHRINK : si le widget est trop petit, il est rétréci plutôt que de disparaître.
                    # - FILL : la cellule doit prendre le maximum de place

ButtonBoxStyle      #Enum désignant le layout d'un ButtonBox. Valeurs possibles :
                    # - BUTTONBOX_DEFAULT_STYLE et BUTTONBOX_EDGE :
                    # xxxx                   xxxxx                    xxxxx                    xxxxxx
                    # - BUTTONBOX_SPREAD :
                    #            xxxx           xxxxx           xxxxx           xxxxx
                    # - BUTTONBOX_START :
                    # xxxx xxxx xxxx xxxx
                    # - BUTTONBOX_END
                    #                                                           xxxx xxxx xxxx xxxx
                    # - BUTTONBOX_CENTER
                    #                             xxxx xxxx xxxx xxxx

A APPRENDRE ==>         #Gio::File
                        #Gio::AppInfo

done, being_print et paginate : Preview Print bouton ou Print bouton
request_page_setup : ?

                                  ┌───────────────────┐
                                  │   CUSTOM WIDGET   │
                                  └───────────────────┘

NOUVEAUX WIDGETS ==>    #Il faut redéfinir toutes les vfunc présentes obligatoirement si classe abstraite, et facultativement
                        #sinon. Les vfunc sont des versions en virtual protected member de méthodes déjà présentes, avec
                        #*_func() à la fin, et même signature (dont virtual, et const { }). Si override facultatif (méthode
                        #déjà définie par parent), alors override méthode du parent :
                        #  - Widget : show_all, get_accessible, get_request_mode, get_preferred_*
                        #  - Container : child_type, forall, composite_name, {g,s}et_child_property
                        #  - CheckButton, CheckMenuItem : draw_indicator
                        #  - Frame : compute_child_allocation
                        #  - Range : get_range_border
                        #  - Scale : draw_value, calc_digits_
                        #  - Activatable : update, sync_action_properties
                        #  - CellArea : get_preferred_*, get_request_mode
                        #  - ListStore, TreeStore : set_value_impl (pas de "_vfunc")
                        #  - CellEditable : start_editing
                        #  - CellLayout : pack_start, pack_end, clear, add_attribute, clear_attributes, reorder
                        #  - Editable : delete_text, get_chars, select_region, get_selection_bounds, {g,s}et_position, 
                        #    insert_text
                        #  - RecentChooser : get_current_uri, unselect_uri, [un]select_all, get_recent_manager, {add,
                        #    remove}_filter
                        #  - ToolShell : get_icon_size, get_orientation, get_style, get_relief_style, rebuild_menu
                        #  - TreeDragDest : drag_data_received, row_drop_possible
                        #  - TreeDragSource : drag_data_get, drag_data_delete
                        #  - TreeModel : get_flags, get_n_columns, get_column_type, iter_next, get_iter, iter_children, 
                        #    iter_parent, iter_nth_child, iter_nth_root_child, iter_has_child, iter_n_children, 
                        #    iter_n_root_children, [un]ref_node, get_path, get_value, {g,s}et_value_impl
                        #  - TreeSortable : {g,s}et_sort_column_id, set_sort_func, set_default_sort_func, 
                        #    has_default_sort_func, sort_column_changed

PROTECTED MEMBERS ==>   #On *peut* également utiliser ces protected members dans les classes dérivées.
                        #Constructors :
                        #  - RadioMenuItem, TreeModelColumnBase : constructor avec arguments
                        #  - Toutes classes avec fonction create() : constructor avec mêmes arguments. 
                        #  - Widget, Bin, MenuShell, Misc, Range, IconSet, RecentInfo, TargetList, CellArea, CellAreaBox, 
                        #    EntryCompletion, CssProvider, AccelGroup, PageSetup, Gdk::Device, Gdk::DeviceManager, Gdk::
                        #    Display, Gdk::Visual : constructor vide
                        #Méthodes :
                        #  - Widget : [un]realize, set_mapped, set_realized, set_has_window, set_window, 
                        #    transform_cairo_context_to_window, get_requisition, get_style_property_value, realize_if_needed, 
                        #    should_draw_window (static)
                        #  - MenuItem : add_accel_label, set_accel_key
                        #  - Window : destroy_
                        #  - Menu : attach_to_widget
                        #  - CellRendererText : edited
                        #  - PrintSettings : create_from_key_file (static), create_from_file (static)
                        #  - IconSet, RecentInfo, TargetList : operator delete
                        #Attributs :
                        #  - ListView : m_model, m_model_columns
                        #  - AccelKey : key_, mod_, path_
                        #  - RadioButtonGroup : group_
                        #  - StockID : id_
                        #  - ListViewText::TreeModelColumns : m_columns

                                  ┌───────┐
                                  │   C   │
                                  └───────┘

UTILISER GTK+ DANS      #Soit C++OBJ un objet en Gtkmm, et COBJ* son équivalent en C :
GTKMM ==>               #  - tout objet a une fonction C++OBJ.gobj() renvoyant le COBJ* sous-jacent, par référence
                        #  - gobj_copy() aussi pour les classes copyconstructibles
                        #  - pour tout objet, une fonction globale wrap(COBJ[, BOOL_VAL]) renvoyant C++OBJ existe (si true 
                        #    (défaut false), copie, sinon référence)

CALLBACKS ==>           #On peut utiliser les callbacks définis dans Glade en C, à condition de :
                        #  - précéder leur type de G_MODULE_EXPORT. Par exemple : 
                        #      G_MODULE_EXPORT void MyCallback( ... ) { ... }
                        #  - mettre pkg-config gmodule-2.0
                        #  - utiliser gtk_builder_connect_signals()

TRADUCTION EN C ==>     #Types :
                        #  - Namespace::C++Classe <-> NamespaceCClasse (struct)
                        #      - Exemple : Gtk::Label <-> GtkLabel ; Gdk::Window -> GdkWindow
                        #    - Pour macros : Namespace::C++MACRO <-> NAMESPACE_C++MACRO
                        #    - Pour Cairo : 
                        #       - namespace_classe_t
                        #       - Exceptions :
                        #         - Cairo::Context <-> cairo_t (pas de mytype, seulement namespace "cairo")
                        #  - Changement de types :
                        #    - références <-> pointeurs
                        #    - RefPtr <-> pointeurs
                        #    - leur typedef (ex: gboolean -> bool), sauf pour les unsigned <-> gTYPE
                        #    - Glib::ustring <-> gchar* (STR)
                        #  - Classes enfant de Glib::Interface sont des interfaces <-> héritées donc via 
                        #    G_IMPLEMENT_INTERFACE() :
                        #  - Constructor :
                        #    - Constructor <-> instantiation via namespace_cclasse_new( ARGS ) sous forme de GtkWidget*, 
                        #      renvoyant en fait un g_object_new( ... ), souvant sans autre ligne de commande.
                        #      Préférer manipuler des GtkWidget* que le type réel : évite plein de transtypage explicites.
                        #       - Exemple : GtkWidget* my_label = gtk_label_new( ARGS )
                        #    - Si plusieurs constructors <-> plusieurs namespace_cclasse_new* avec noms différents
                        #    - Si constructor protected <-> pas de namespace_cclasse_new()
                        #    - Si *::create( ARGS ) <-> namespace_cclasse_new( ARGS )
                        #       - exception pour Cairo <-> namespace_cclasse_create( ARGS )
                        #Fonctions :
                        #  - C++CLASS.FONC( ARGS ) <-> namespace_cclasse_fonc( CCLASSE*, ARGS ) :
                        #     - fonction non virtual :
                        #       - NAMESPACEMTYPEclass_ADR->fonction est initialisé à namespace_cclasse_fonc;
                        #     - fonction virtual :
                        #       - virtuelle non-pure (initialisé) : comprend des fonctions d'interfaces et aussi des 
                        #         CLASSE.FONC_vfunc() ("_vfunc" absent en C). Effectue :
                        #           if ( NAMESPACEMTYPEclass_ADR->fonction )
                        #             NAMESPACEMTYPEclass_ADR->fonction( CCLASSE*, ARGS )
                        #           else 
                        #             // définition de la fonction
                        #       - fonction virtuelles pures (interfaces uniquement), effectue :
                        #           g_return_if_fail( NAMESPACEMTYPEclass_ADR->fonction != NULL );
                        #           NAMESPACEMTYPEclass_ADR->fonction( CCLASSE*, ARGS )
                        #    - Exemple : LABEL.set_text( ARGS ) -> gtk_label_set_text( GtkLabel*, ARGS )
                        #  - fonction static : Namespace::FONC( ARGS ) <-> namespace_fonc( ARGS ); //Sans CCLASSE* donc
                        #  - les enfants ne redéfinissent pas des helpers sur les fonctions héritées
                        #    - sauf quand ils redéfinissent les fonctions héritées
                        #  - property :
                        #    - tout get/set_property simple <-> property "property"+helper namespace_cclasse_{g,s}et_"property"
                        #    - tout property_*() + const overload <-> pareil
                        #    - flags :
                        #       - en général READWRITE, rarement seulement READABLE ou WRITABLE
                        #       - pas de new*, et les new* des enfants utilisent cette property <-> CONSTRUCT
                        #       - pas d'autres flags
                        #    - unset_property -> pas d'helper
                        #  - signaux : 
                        #    - signal dont nom est "SIGNAL" (avec "_" devenu "-") :
                        #      - Soit "CLASSFK", la CLASSFK asscié par défaut au signal en C :
                        #         - en C++, CLASSFK initialisé au callback CLASSFK_callback(), qui lui-même appelle fonction 
                        #           virtual on_SIGNAL (absents en C)
                        #         - donc on_SIGNAL() + "signal" <-> "signal"
                        #    - return value : même ; arguments : entouré de premier argument GtkMytype* et dernier argument
                        #      void* (data associées)
                        #    - en général G_SIGNAL_RUN_LAST
                        #  - n'utilise pas les constructor ni destructor, mais directement instance_init() et finalize()
                        #  - operator++, operator bool, etc. <-> fonction avec autre nom
                        #    - ex : TEXTITER++ <-> g_text_iter_forward_char( GTKTEXTITER_ADR )
                        #Autres :
                        #  - Arguments implicites <-> valeur par défaut des properties
                        #  - g_return_if_fail : 
                        #    - ( NAMESPACE_IS_MYTYPE( ADR ) ) dans toute fonction utilisant un pointeur NamespaceMytype*
                        #    - d'autres, vérifiant par exemple si des pointeurs sont NULL
                        #  - cf les *set_style_classes ??? après GtkStyleContext
                        #    - gtk_style_context_add_class() dans l'instance init pour les enfants de widget ???
                        #    - style properties ???
                        #  - pas de parent <-> souvent enfant de GBoxed
                        #Quid du free ou unref ???

DEFINIR NOUVEAU WIDGET  #  - définir GType enfant du parent (cf GObject) (ou interface)
NON-ENFANT DIRECT DE    #  - définir namespace_cclasse_new(), si instantiable
WIDGET ==>              #  - penser à utiliser extern "C" {  }
                        #  - gtk_widget_queue_resize lors d'un changement de taille ?
                        #  - utiliser des bitfields pour des properties bool ou enum

DEFINIR NOUVEAU WIDGET  #En plus des considérations précédentes :
ENFANT DIRECT DE        #  - redéfinir :
WIDGET ==>              #    - gtk_widget->get_preferred_{width,height}
                        #    - gtk_widget->draw() :
                        #      - utiliser gtk_render* ???

BINDING C VERS C++ ==>  #  - cf gmmproc
                        #  - ADR en return value -> RefPtr<T>, avec un const overload

AU-DELA DE GTK ==>      #  - Glib::wrap( GOBJECT_ADR[, BOOL_VAL] ) renvoie un REFPTR<T>
                        #Parfois :
                        #  - méthodes namespace_cclasse_ref( cclasse* ) renvoyant cclasse* (appelé par new()) et 
                        #    namespace_cclasse_unref( cclasse* ) : je mets alors ("C : *_ref")
                        #  - méthodes namespace_cclasse_free( cclasse* ) et namespace_cclasse_copy( cclasse* ) : je mets alors
                        #    ("C : *_free, *_copy")
                        #  - méthode namespace_cclasse_destroy( cclasse* ) : je mets alors ("C : *_destroy")

LORS DE LA RELECTURE    #Regarder équivalent en "fonction" des overloaded operator (pour traduction simple en C)
TOTALE ==>              #
