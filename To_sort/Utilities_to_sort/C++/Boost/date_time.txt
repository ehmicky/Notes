
               
   DATE_TIME   
               

                                  ┌─────────────────┐
                                  │   GENERALITES   │
                                  └─────────────────┘

HEADER ==>              #Pour tout inclure : <boost/date_time.hpp>
                        #Pour plus fin (... est boost/date_time) :
                        #Pour gr:: : <.../gregorian/gregorian.hpp>
                        #Pour p_t:: : <.../posix_time/posix_time.hpp>
                        #Pour l_t:: : <.../local_time/local_time.hpp>
                        #Pour d_t:: :
                        #  - date : <.../date.hpp>
                        #  - date_duration : <.../date_duration.hpp>
                        #  - time_duration : <.../time_duration.hpp>
                        #  - period : <.../period.hpp>
                        #  - date_itr* : <.../date_iterator.hpp>
                        #  - time_itr* : <.../time_iterator.hpp>
                        #  - *functor : <.../adjust_functors.hpp>
                        #  - lié aux timezones : <.../local_time/local_time.hpp>
LIBRARIES ==>           #libboost_date_time[-mt]

NAMESPACE ==>           #Désignés par des abbréviations dans ma doc' :
                        #  - boost::date_time::  -> d_t::
                        #  - boost::gregorian::  -> gr::
                        #  - boost::posix_time:: -> p_t::
                        #  - boost::local_time:: -> l_t::

SERIALIZATION ==>       #Les classes suivantes sont Serializable via 
                        #boost::serialization :
                        #  - <.../gregorian/greg_serialize.hpp> (gr::) :
                        #    - date, greg_day, greg_weekday, date_duration, 
                        #      date_period partial_date, *_day_of_week_*
                        #  - <.../posix_time/time_serialize.hpp> (p_t::) :
                        #    - ptime, time_duration, time_period

PORTABILITE ==>         #gcc 3.3, MSVC 7.1, Intel 8.1, Codewarrior 9.4, 
                        #QCC 3.3.5
                        #Quelques problèmes possibles d'IO avec Borland.

TRAITS ==>              #De nombreux typedefs sont disponibles pour extend la
                        #bibliothèque de manière plus générique (par exemple 
                        #ajouter un nouveau calendrier autre que le grégorien). 
                        #Cf la documentation en ligne si besoin de cela un jour

GREGORIAN ET JULIAN ==> #Le calendrier julien est celui utilisé avant 1582, le
                        #grégorien depuis 1582, mais son adoption dépend du pays
                        #concerné (certains pays l'ayant adopté jusqu'au XXème 
                        #siècle). Il y a un décalage entre les deux : ainsi, il
                        #faut considérer une date en fonction du calendrier de
                        #l'époque, à un endroit donné.
                        #Le calendrier julien utilise déjà les années 
                        #bissextiles, et n'a pas non plus d'an 0.
                        #Cependant la réforme grégorienne :
                        #  - fait que les années séculaires non multiples de
                        #    400 ne sont plus bissextiles (ramenant l'année à
                        #    365,2425 jours et non 365,25, ce qui réduit 
                        #    l'écart par rapport à l'année solaire réelle). 
                        #    Ainsi, l'existence d'un 29 février 1700 dépend des
                        #    pays.
                        #  - supprime les 10 (ou plus si adoption tardive) jours
                        #    qui suivent, pour réajuster le retard (ces jours 
                        #    dépendent de la date d'adoption)
                        #  - fait que l'année commence en janvier et non en mars
                        #Boost utilise le calendrier grégorien proleptique, qui
                        #extend les dates avant 1582, permettant d'avoir un 
                        #range allant de 1400 à 9999.

JOUR JULIEN ==>         #Nombre de jours écoulés depuis le 1er janvier 4713 av.
                        #J-C, selon le calendrier julien, à midi. Utilisé par 
                        #les astronomes (symbole : AJD) pour unifier les 
                        #différents calendriers.
                        #Le Jour Julien Modifié (MJD) est égal à AJD - 2400000.5
                        #(donc depuis le 17 novembre 1858 à minuit, selon le
                        #calendrier grégorien)

AUTRES CALENDRIERS ==>  #  - Chinois (campagnes et traditionnel seulement)
                        #  - Juifs
                        #  - hégirien (musulmans, année légèrement plus courte,
                        #    an 1 = an grégorien 1432)
                        #  - indien (an 1 = an grégorien 78, nouvel an le 21/22
                        #    mars)
                        #  - persan (Iran et Afghanistan)

                                  ┌──────────┐
                                  │   ENUM   │
                                  └──────────┘

d_t::special_values     #Enum désignant une DATE spéciale. Les infinis sont 
                        #utiles pour les intervals de temps. Valeurs possibles :
d_t::not_a_date_time    #Date vide ou invalide
d_t::neg_infin          #Désigne une date antérieure à toute date
d_t::pos_infin          #Désigne une date postérieure à toute date
d_t::min_date_time      #01/01/1400
d_t::max_date_time      #31/12/9999
d_t::not_special        #Désigne une date n'étant pas l'une des autres 
                        #special_values, c'est-à-dire normale.
                        #Si argument de l'instantiation d'une DATE ou autre, 
                        #celle-ci devient not_a_date_time.
d_t::NumSpecialValues   #Nombre de special_values.

d_t::weekdays           #Enum désignant un jour de la semaine. On peut utiliser 
                        #les nombres directement (0 pour dimanche, etc.).
                        #Valeurs possibles :
d_t::Sunday             #
d_t::Monday             #
d_t::Tuesday            #
d_t::Wednesday          #
d_t::Thursday           #
d_t::Friday             #
d_t::Saturday           #

d_t::months_of_year     #Enum désignant un mois. On peut utiliser les nombres
                        #directement (1 pour Jan, etc.). Valeurs possibles :
d_t::Jan                #
d_t::Feb                #
d_t::Mar                #
d_t::Apr                #
d_t::May                #
d_t::Jun                #
d_t::Jul                #
d_t::Aug                #
d_t::Sep                #
d_t::Oct                #
d_t::Nov                #
d_t::Dec                #
d_t::NotAMonth          #
d_t::NumMonths          #Nombre de valeurs possibles.

d_t::time_resolutions   #Désigne la résolution maximale de l'horloge courante.
                        #Valeurs possibles :
d_t::sec                # - 0 chiffres après la virgule
d_t::tenth              # - 1
d_t::hundreth           # - 2
d_t::milli              # - 3
d_t::ten_thousandth     # - 4
d_t::micro              # - 6
d_t::nano               # - 9

                                  ┌────────────────────┐
                                  │   POINT TEMPOREL   │
                                  └────────────────────┘

d_t::date <T1, T2, T3>  #Base time pour un jour précis.
                        #T1 est un CRTP, T2 est une classe de traits/police
                        #indiquant le type de calendrier, T3 est le type 
                        #utilisé pour la durée.

d_t::date<...>::
date_type               # T1
d_t::date<...>::
calendar_type           # T2
d_t::date<...>::
duration_type           # T3
d_t::date<...>::
year_type               # Pour un gr::date : gr::greg_year
d_t::date<...>::
month_type              # Pour un gr::date : gr::greg_month
d_t::date<...>::
day_type                # Pour un gr::date : gr::greg_day
d_t::date<...>::
day_of_week_type        # Pour un gr::date : gr::greg_weekday
d_t::date<...>::
ymd_type                # Pour un gr::date : gr::greg_year_month_day

D_T::DATE(YEAR_TYPE,
MONTH_TYPE, DAY_TYPE)   
D_T::DATE(YMD_TYPE)     #Lance exception si problème.

D_T::DATE.year()        #Renvoie l'année de D_T::DATE sous forme de GREG_YEAR.
D_T::DATE.month()       #Renvoie le mois de D_T::DATE sous forme de GREG_MONTH.
D_T::DATE.day()         #Renvoie le jour de l'année de D_T::DATE sous forme de 
                        #GREG_DAY.
D_T::DT.year_month_day()#Renvoie D_T::DATE sous forme de GREG_YEAR_MONTH_DAY
D_T::DATE.day_of_week() #Renvoie le jour de la semaine de D_T::DATE (Sun..Sat).
D_T::DATE.week_number() #Renvoie le numéro de la semaine dans l'année (1..53).

D_T::DATE.is_infinity() #Renvoie true si D_T::DATE == date_time::neg_infin ou
                        #date_time::pos_infin.
DT::DT.is_neg_infinity()#Renvoie true si D_T::DATE == date_time::neg_infin
DT::DT.is_pos_infinity()#Renvoie true si D_T::DATE == date_time::pos_infin
D_T.is_not_a_date_time()#Renvoie true si D_T::DATE == date_time::not_a_date_time
D_T::DATE.is_special()  #Renvoie false si D_T::DATE n'est pas l'une des valeurs
                        #de SPECIAL_VALUES
D_T::DATE.as_special()  #Renvoie D_T::DATE sous forme de SPECIAL_VALUES
                        #(si D_T::DATE_TIME.is_special() == false, renvoie 
                        #date_time::not_special)

D_T::DATE == D_T::DATE2
D_T::DATE != D_T::DATE2
D_T::DATE <= D_T::DATE2
D_T::DATE >= D_T::DATE2           
D_T::DATE < D_T::DATE2            
D_T::DATE > D_T::DATE2  #Test d'égalités.

D_T::DATE - D_T::DATE2  #Renvoie une DURATION_TYPE.
D_T::DATE + DURATIN_TYPE    
D_T::DATE - DURATIN_TYPE#Renvoie un D_T::DATE. 

D_T::DATE += DURATIN_TYP
D_T::DATE -= DURATIN_TYP#Modifie D_T::DATE

gr::date                #Classe désignant une date selon le calendrier grégorien
                        #Enfant de d_t::date<gr::date, gr::gregorian_calendar,
                        #gr::date_duration>.
                        #Redéfinit typedefs duration_type, year_type, 
                        #month_type, day_type, ymd_type, date_rep_type, 
                        #date_int_type.
                        #Reprend les constructors.

gr::date<...>::
day_of_year_type        #

DATE()                  #Equivaut à DATE(date_time::not_a_date_time)
DATE(SPECIAL_VALUES)

DATE.day_of_year()      #Renvoie le jour de l'année de DATE (1..365).
DATE.end_of_month()     #Renvoie le dernier jour du mois de DATE, sous forme 
                        #d'une DATE 

DATE.julian_day()       #Renvoie le Jour Julien de DATE.
DATE.modjulian_day()    #Renvoie le Jour Julien Modifié de DATE.

gr::greg_year_month_day #Struct désignant une date grégorienne.

GREG_YEAR_MONTH_DAY
(GREG_YEAR, GREG_MONTH,
GREG_DAY)   

GREG_YEAR_MONTH_DAY.year#Année, sous forme de GREG_YEAR
GREG_YER_MONTH_DAY.month#Mois, sous forme de GREG_MONTH
GREG_YEAR_MONTH_DAY.day #Jour de l'année, sous forme de GREG_DAY

gr::greg_day            #Classe désignant un jour. A un overloadable typecast
                        #vers USHORT_VAL.

GREG_DAY(USHORT_VAL)    #Constructor. Lance une exception
                        #gregorian::bad_day_of_month pour un USHORT_VAL invalide

GREG_DAY.as_number()    #Renvoie GREG_DAY sous forme d'USHORT_VAL.

gr::greg_weekday        #Classe désignant un jour de la semaine. A un 
                        #overloadable typecast vers USHORT_VAL.

GREG_WEEKDAY            #Constructor. Lance une exception gregorian::bad_weekday
(D_T::WEEKDAYS)         #pour un USHORT_VAL invalide

GREG_WEEKDAY.as_number()#Renvoie GREG_WEEKDAY sous forme d'USHORT_VAL.

GREG_WEEKDAY.as_number()#
GREG_WEEKDAY.as_enum()  #
GREG_WEEKDAY.
as_short_string()       #
GREG_WEEKDAY.
as_long_string()        #
GREG_WEEKDAY.
as_short_wstring()      #Renvoie GREG_WEEKDAY sous forme d'USHORT_VAL, 
GREG_WEEKDAY.           #DATE_TIME::WEEKDAYS_OF_YEAR, STR ou WSTR. "short" 
as_long_wstring()       #renvoie l'abbréviation, "long" le mot complet.

gr::greg_month          #Classe désignant un mois. A un overloadable typecast
                        #vers USHORT_VAL. A les mêmes getters que greg_weekday.

GREG_MONTH(USHORT_VAL)  #Constructor. Lance une exception gregorian::bad_month 
                        #pour un USHORT_VAL invalide (en dehors de {1..10})
GREG_MONTH(DATE_TIME::  
MONTHS_OF_YEAR)         #Même chose.

gr::greg_year           #Classe désignant un jour. A un overloadable typecast
                        #vers USHORT_VAL.

GREG_YEAR(USHORT_VAL)   #Constructor. Lance une exception gregorian::bad_year 
                        #pour un USHORT_VAL invalide (en dehors de 1400-10000)

GREG_YEAR.as_number()   #Renvoie GREG_YEAR sous forme d'USHORT_VAL.

NANOSECONDES ==>        #Attention, le nombre de ticks par secondes, et la
                        #résolution maximale dépend du système : il s'agit en
                        #général de microsecondes, mais nanosecondes est parfois
                        #supporté.

d_t::base_time<T1,T2>   #Base classe pour désigner une heure.
                        #T1 est le CRTP, T2 une classe de traits/police.
                        #A les mêmes fonctions suivantes que d_t::date :
                        #is_infinity(), is_neg_infinity(), is_pos_infinity(),
                        #is_not_a_date_time(), is_special(), ==, !=, <=, >=, >,
                        # <, -, +, +=, -= et constructor avec SPECIAL_VALUES.

...::time_type          # T1
...::date_type          # gr::date pour ptime et local_date_time 
...::date_duration_type # gr::date_duration pour ptime et local_date_time
...::time_duration_type # p_t::time_duration pour ptime et local_date_time

BASE_TIME(DATE_TYPE,
TIME_DURATION_TYPE      #Lance exception si problème.
[, DST_FLAG ]           #Cf l_t::local_date_time pour DST_FLAG

BASE_TIME.date()        #Renvoie la DATE_TYPE de BASE_TIME.
BASE_TIME.time_of_day() #Renvoie la TIME_DURATION_TYPE de BASE_TIME.

p_t::ptime              #Enfant de d_t::base_time<p_t::ptime, 
                        #p_t::posix_time_system>
                        #Désigne une gr::date + heure (jusqu'à la nanoseconde). 
                        #Redéfinit time_duration_type et time_type.
                        #Reprend constructor ( SPECIAL_VALUES )

...::time_system_type   # p_t::posix_time_system

PTIME([GR::DATE
[, P_T::TIME_DURATION]])#Par défaut gr::date(), et minuit.

l_t::                   #Enfant de d_t::base_time<T1, p_t::posix_time_system>
local_date_time_base    #T2 est la time_zone_base.
<T1,T2>                 #Désigne une heure et date T1 + une time_zone_base.
                        #(date et heure locale donc)
                        #Redéfinit date_duration_type, time_duration_type et 
                        #time_type.

...::time_system_type   # p_t::posix_time_system
...:utc_time_type       # T1

L_T::LOCAL_DATE_TIME_BAS
(PTIME, TIME_ZONE_PTR)          
L_T::LOCAL_DATE_TIME_BAS
(SPECIAL_VALUES,
TIME_ZONE_PTR)
L_T::LOCAL_DATE_TIME_BAS#Equivaut à L_T::LOCAL_DATE_TIME_BASE
DATE, TIME_DURATION,    #(PTIME(DATE, TIME_DURATION), TIME_ZONE_PTR, BOOL_VAL),
TIME_ZONE_PTR, BOOL_VAL)#sauf que si la TIME_DURATION a deux références 
                        #possibles (à cause d'un recul de daylight savings qui
                        #vient d'intervenir), l'heure des daylight savings est
                        #prise si BOOL_VAL est true, sinon non.
L_T::LOCAL_DATE_TIME_BAS#Même chose, mais FLAG est ici utilisé : si 
(DATE, TIME_DURATION,   #l_t::EXCEPTION_ON_ERROR, une exception 
TIME_ZONE_PTR, FLAG)    #l_t::ambiguous_result ou l_t::time_label_invalid est
                        #lancée ; si l_t::NOT_DATE_TIME_ON_ERROR, 
                        #L_T::LOCAL_DATE_TIME_BASE est initialisée avec 
                        #l_t::not_a_date_time

L_T::LOCAL_DATE_TIME_BAS
.zone()                 #Renvoie la TIME_ZONE_PTR associée.
L_T::LOCAL_DATE_TIME_BAS
.is_dst()               #Renvoie true s'il y a des daylight savings.
l_t::
local_date_time_base::  #Renvoie une instance de l'enum d_t::time_is_dst_result
check_dst()             #en fonction de l'état actuel des daylight savings.
LOCAL_DAT_TIM.utc_time()#Renvoie la PTIME au temps UTC de L_T::LOCAL_DAT_TIM_BAS
L_T::LOCAL_DATE_TIM_BAS.        
local_time()            #Renvoie la PTIME au temps local de L_T::LOCL_DAT_TIM_BS
L_T::LOCAL_DATE_TIM_BAS.        
local_time_in           #Renvoie la PTIME au temps locale de la zone
(TIME_ZONE_PTR)         #TIME_ZONE_PTR de L_T::LOCAL_DATE_TIME_BASE

d_t::local_date_time    #Typedef depuis d_t::local_date_time_base<p_t::ptime,
                        #d_t::time_zone_base<p_t::ptime,char> >

gr::day_clock::
universal_day()         #Renvoie la DATE courante UTC.
gr::day_clock::         #Renvoie la DATE courante locale (fuseaux horaires + 
local_day()             #daylight-saving-time compris)
gr::day_clock::
universal_day_ymd()     #
gr::day_clock::         #
local_day_ymd()         #Comme ci-dessus, mais avec des GREG_YEAR_MONTH_DAY

p_t::second_clock::         
universal_time()        #
p_t::second_clock::     
local_time()            #Comme ci-dessus mais avec des PTIME (à la seconde près)
p_t::microsec_clock::           
universal_time()        #
p_t::microsec_clock::   #Même chose, mais à la microseconde près (parfois 
local_time()            #seulement à la seconde près sous Windows)

l_t::local_sec_clock::  #Retourne la LOCAL_DATE_TIME courante, pour la zone
local_time(TIME_ZON_PTR)#TIME_ZONE_PTR, à la seconde près.
l_t::
local_microsec_clock::
local_time(TIME_ZON_PTR)#Même chose, à la microseconde près.

gr::to_tm(GR::DATE)         
p_t::to_tm(P_T::PTIME)        
p_t::to_tm
(P_T::TIME_DURATION)
l_t::to_tm              #
(L_T::LOCAL_DATE_TIME)  #Renvoie sous forme de STD::TM
gr::date_from_tm(STD:TM)#Renvoie STD::TM sous forme de GR::DATE
p_t::ptime_from_tm      #
(STD::TM)               #Renvoie STD::TM sous forme de P_T::PTIME
p_t::from_time_t        #
(STD::TIME_T)           #Renvoie STD::TIME_T sous forme de P_T::PTIME

                                  ┌───────────┐
                                  │   DUREE   │
                                  └───────────┘

d_t::date_duration<T>   #Base classe désignant un nombre de jours entre deux
                        #dates indéterminées.
                        #T est une classe de traits. Deux existent :
                        #  - d_t::duration_traits_adapted
                        #  - d_t::duration_traits_long, comme adapted, mais
                        #    interdit utilisation de special_values

D_T::DATE_DURATION      #Construit une D_T::DATE_DURATION de LONG_VAL jours
(LONG_VAL)              #Peut etre négatif.
D_T::DATE_DURATION      
(SPECIAL_VALUES)        #d_t::pos_infin et d_t::neg_infin peuvent être utiles.

D_T::DATE_DURATION ==
D_T::DATE_DURATION2
!=, <=, >=, <, >        #Tests d'égalités

D_T::DATE_DURATION -=
D_T::DATE_DURATION2
D_T::DATE_DURATION +=
D_T::DATE_DURATION2
D_T::DATE_DURATION /= 
INT_VAL

D_T::DATE_DURATION +
D_T::DATE_DURATION2
D_T::DATE_DURATION -
D_T::DATE_DURATION2         
D_T::DATE_DURATION / 
INT_VAL 
-D_T::DATE_DURATION     #Opérations sur D_T::DATE_DURATION. 

D_T::DATE_DURATIN.days()#Renvoie le nombre de jours de D_T::DATE_DURATION sous 
                        #forme de LONG_VAL.
D_T::DATE_DURATION.     
is_negative()           #Renvoie true si D_T::DATE_DURATION est négatif
D_T::DATE_DURATION.     
is_special()            #Renvoie true si D_T::DATE_DURTIN est une SPECIAL_VALUES
D_T::DATE_DURATIN.unit()#Renvoie la plus petite valeur possible pour 
                        #D_T::DATE_DURATION

gr::date_duration       #Enfant de 
gr::days                #d_t::date_duration<d_t::duration_traits_adapted>

GR::DATE_DURATION
([LONG_VAL])            #Argument peut être par défaut 0.

gr::weeks               #Enfant de gr::date_duration, s'instantiant avec un
                        #nombre de semaines précisé dans le constructor.
gr::months              #Classe désignant un nombre de mois ou d'années.
gr::years               #Possède les mêmes membres que gr::date_duration, mais
                        #n'a pas de lien avec : leur seul utilité est d'être
                        #mis à droite d'un DATE +, +=, -, ou -=, souvent de
                        #manière temporaire.
                        #S'instantie avec le nombre de mois/années (INT_VAL)
                        #ou avec une SPECIAL_VALUE.
                        #Pour gr::months, attention : ajouter X months puis 
                        #retirer X months à une DATE ne redonne pas la même 
                        #DATE parfois si celle-ci est la dernière d'un mois : 
                        #utiliser les month_iterator pour cela)

d_t::time_duration      #Base classe. Désigne une heure ou une durée (jusqu'à 
<T1,T2>                 #la nanoseconde ou microseconde, selon OS).
                        #A les mêmes CLASSFK que D_T::DATE_DURATION mais
                        #d'autres en plus, et des constructors différents.
                        #T1 doit être la classe enfant elle-même.
                        #T2 doit être un time_resolutions_traits<...>, 
                        #désignant notamment la résolution maximale.

D_T::TIME_DURATION      #Construit une D_T::TIME_DURATION de :
(LONG_VAL1, LONG_VAL2,  #  - LONG_VAL1 heures
LONG_VAL3, [, LONG_VL4])#  - LONG_VAL2 minutes
                        #  - LONG_VAL3 secondes
                        #  - LONG_VAL4 ticks (par défaut 0)
                        #    Pour connaître la valeur d'un
                        #    tick sur le système présent, utiliser 
                        #    d_t::time_duration::ticks_per_second()
                        #Chaque valeur peut être négative. Si la somme totale
                        #donne une heure négative, hours(), seconds(), etc.
                        #donneront tous un résultat négatif.
D_T::TIME_DURATION      #Attention : hours(), minutes(), seconds(), ticks(), 
(SPECIAL_VALUES)        #fractional_seconds(), total_nanoseconds(), 
                        #total_microseconds(), total_milliseconds(), 
                        #total_seconds() deviennent alors impossibles.

D_T::TIM_DURATIN.hours()#Renvoie le nombre d'heures de la partie "heures" de 
                        #D_T::TIME_DURATION, sous forme de LONG_VAL
D_T::TIM_DURTN.minutes()#Renvoie le nombre de minutes de la partie "minutes" de 
                        #D_T::TIME_DURATION, sous forme de LONG_VAL (-59 à 59)
D_T::TIM_DURTN.seconds()#Renvoie le nombre de secondes de la partie "secondes"
                        #de D_T::TIME_DURATION, sous forme de LONG_VAL (-59 à 59)
D_T::TIME_DURATION.     #Renvoie le nombre de ticks de la partie "ticks" de
fractional_seconds()    #D_T::TIME_DURATION, sous forme de LONG_VAL
D_T::TIME_DURATION.     #Renvoie le nombre total de secondes de D_T::TIME_DURATION, 
total_seconds()         #sous forme de LONG_VAL.
D_T::TIME_DURATION.     
total_milliseconds()    #Même chose pour les millisecondes.
D_T::TIME_DURATION.     
total_microseconds()    #Même chose pour les microsecondes.
D_T::TIME_DURATION.     
total_nanoseconds()     #Même chose pour les nanosecondes.
D_T::TIME_DURATN.ticks()#Même chose pour les ticks, mais sous forme 
                        #d'INT64_T_VAL

D_T::TIME_DURATION.     
invert_sign()           #Renvoie D_T::TIME_DURATION en inversant son signe.

D_T::TIME_DURATION.
is_neg_infinity()       #
D_T::TIME_DURATION.
is_pos_infinity()       #
D_T::TIME_DURATION.     #Comme pour DATE (is_not_a_date_time() est comme 
is_not_a_date_time()    #is_not_a_date())

TIM_DURATIN.resolution()#Renvoie la résoluion maximale du système sous forme de
                        #DATE_TIME::TIME_RESOLUTIONS
d_t::time_duration::    #Renvoie la résoluion maximale du système sous forme du
num_fractional_digits() #nombre de chiffres décimaux en dessous de la seconde
                        #(9 pour les nanosecondes, 6 pour les microsecondes)
d_t::time_duration::            
ticks_per_second()      #Renvoie le nombre de ticks par seconde du système.

D_T::TIME_DURATION 
/ INT_VAL
D_T::TIME_DURATION 
* INT_VAL
D_T::TIME_DURATION 
*= INT_VAL              #Opérations.

p_t::time_duration      #Typedef depuis d_t::time_duration<d_t::time_duration, 
                        #d_t::time_resolutions_traits<...> >, mettant la
                        #résolution en fonction du système courant.

p_t::hours(INT64_T_VAL) #
p_t::minutes(INT64_T_VL)#
p_t::seconds(INT64_T_VL)#
p_t::millisec[onds]     #
(INT64_T_VAL)           
p_t::microsec[onds]     #
(INT64_T_VAL)           
p_t::nanosec[onds]      #Enfant de P_T::TIME_DURATION, instantié avec INT64T_VAL
(INT64_T_VAL)           #heures/minutes/secondes/milli/micro/nanosecondes.

                                  ┌─────────────┐
                                  │   PERIODE   │
                                  └─────────────┘

d_t::period <WVR1, WVR2>#Classe désignant une période entre deux BASE_TIME
                        #déterminées (de type WVAR1). WVAR2 est DUREE, le même
                        #DUREE que la BASE_TIME désignée par WVAR1            
                        #(DAT_DURATION pour DATE, TIME_DURATION pour les autres)
                        #Si la deuxième BASE_TIME précède ou est égale à la
                        #première, PERIOD est dit "null".

PERIOD(BASE_TIME,
BASE_TIME2)             #BASE_TIME2 n'est pas inclus.
PERIOD(BASE_TIME, DUREE)#Comme PERIOD(BASE_TIME, BASE_TIME + DUREE)

PERIOD.begin()          #Renvoie la première BASE_TIME de PERIOD.
PERIOD.last()           #Renvoie la BASE_TIME précédant la dernière BASE_TIME de 
                        #PERIOD.
PERIOD.end()            #Renvoie la dernière BASE_TIME de PERIOD.
PERIOD.length()         #Renvoie la DUREE entre begin() et last()
PERIOD.is_null()        #Renvoie true si PERIOD est null.
PERIOD ==               #Teste si le begin() et le last() des deux PERIOD sont
PERIOD2                 #les mêmes.
PERIOD <                #Teste si PERIOD.last() <= PERIOD2.last()
PERIOD2         
PERIOD >                #Teste si PERIOD.begin() >= PERIOD2.begin()
PERIOD2         

PERIOD.contains         #
(BASE_TIME)             #Renvoie true si BASE_TIME se trouve dans PERIOD.
PERIOD.contains         #Renvoie true si le begin() et le last() de PERIOD2 se
(PERIOD2)               #trouve dans PERIOD.
PERIOD.intersects       #Renvoie true si le begin() ou le last() de PERIOD2 se
(PERIOD2)               #trouve dans PERIOD.
PERIOD.is_adjacent      #Renvoie true si DAT_PERIOD.begin() == DAT_PERIOD2.end()
(PERIOD2)               #ou PERIOD2.begin() == DAT_PERIOD.end().
PERIOD.is_before        #
(BASE_TIME)             #Renvoie true si PERIOD.last() < BASE_TIME
PERIOD.is_after         #
(BASE_TIME)             #Renvoie true si PERIOD.begin() > BASE_TIME
PERIOD.intersection     #Renvoie les BASE_TIME communes aux deux PERIOD sous
(PERIOD2)               #forme d'une nouvelle PERIOD, ou une PERIOD null si
                        #intersects() renvoie false.
PERIOD.merge(PERIOD2)   #Si intersects() renvoie true, renvoie l'union des deux 
                        #PERIOD sous forme d'une nouvelle PERIOD ; sinon 
                        #renvoie une PERIOD null.
PERIOD.span(PERIOD2)    #Renvoie date_period(min(begin(), begin2()), 
                        #max(end(), end2()))

PERIOD.shift(DUREE)     #Rajoute DUREE à BASE_TIME et BASE_TIME2
PERIOD.expand(DUREE)    #Enlève DUREE à BASE_TIME et le rajoute à BASE_TIME2

gr::date_period         #Typedef depuis d_t::period<gr::date, gr::date_duration>
p_t::time_period        #Typedef depuis d_t::period<p_t::ptime, 
                        #p_t::time_duration>
l_t::local_time_period  #Typedef depuis d_t::period<l_t::local_date_time, 
                        #p_t::time_duration>

                                  ┌────────────────┐
                                  │   ITERATEURS   │
                                  └────────────────┘

CONCEPTS DE             #Ne respecte aucun concept d'itérateur car manque
DATE_ITR_BASE ==>       #plusieurs choses. Pour les rajouter, on peut par
                        #exemple définir une classe enfant qui définit ces
                        #concepts :
                        #ReadableIt. + WritableIt. ou IncrementableIt. :
                        #  - typedefs difference_type, pointer, reference
                        #LvalueIt. :
                        #  - redéfinir *, pour qu'il renvoie une référence
                        #    (peut être nécessaire d'instantier un pointeur
                        #    vers la CLASSDT dans la classe enfant pour 
                        #    pouvoir y accéder)
                        #IncrementableIt. :
                        #  - redéfinir ++VAL, mais aussi VAL++
                        #Autre traversal concept :
                        #  - ces concepts

d_t::date_itr_base<T1>  #Base classe abstraite d'un itérateur stockant un T1_VAL
                        #(une BASE_TIME) et l'itérant via ++ et --
                        #Ses enfants doivent définir get_offset(const T&) const, 
                        #renvoyant DURATION_TYPE (l'avancée à chaque ++) et 
                        #get_neg_offset(...) (pour --)
                        #Opérations disponibles :
                        #  - *VAL
                        #  - ++VAL et --VAL (non VAL++ ni VAL--)
                        #  - VAL == T1_VAL, !=, <, <=, >, >=

DATE_ITR_BASE(T1_VAL)   

DATE_ITR_BASE::         
value_type              #Typedef depuis T1
DATE_ITR_BASE::
duration_type           #Typedef depuis T1::duration_type
DATE_ITR_BASE::
iterator_category       #input_category_tag, mais ce n'est pas le cas en fait.

gr::date_iterator       #Typedef depuis d_t::date_itr_base<gr::date>

d_t::date_itr<T1, T2>   #Enfant de d_t::date_itr_base<T2>.
                        #T1 est une classe avec des CLASSFK 
                        #get[neg_]offset(const T2&), renvoyant DURATION_TYPE,
                        #et un constructor prenant un INT_VAL.
                        #get_[neg_]offset(...) invoque T1.get[neg_]offset(...)

DATE_ITR(T2_VAL         
[, INT_VAL])            #Instantie T1 avec ( INT_VAL ), par défaut 1.

d_t::day_functor<T>     #
d_t::week_functor<T>    #Fonctors, instantiés avec un INT_VAL, invoqués avec un
d_t::month_functor<T>   #T_VAL (BASE_TIME), renvoyant INT_VAL * T::TIME_DURATION 
d_t::year_functor<T>    #séparant T_VAL du prochain day/week/month/year.

gr::day_iterator        #
gr::week_iterator       #
gr::month_iterator      #
gr::year_iterator       #Typedefs depuis s_t::date_itr<d_t::*_functor, gr::date>

p_t::time_itr<T>        #Comme d_t::date_itr_base, mais sans get_*offset : 
                        #l'offset est précisé à l'instantiation 
                        #Pas de value_type ni d'iterator_category.

TIME_ITR(T1_VAL,        
TIME_DURATION)          #TIME_DURATION est l'offset à avancer à chaque ++ ou --

p_t::time_iterator      #Typedef depuis p_t::time_itr<p_t::ptime>
l_t::local_time_iterator#Typedef depuis p_t::time_itr<l_t::local_date_time>

                                  ┌─────────────────┐
                                  │   GENERATEURS   │
                                  └─────────────────┘

                        #Tout ce chapitre peut être abstrait, les gr:: étant 
                        #enfant d'un parent avec <gr::date> dans leur template.
                        #Cf les headers.
                        #DateGenerateur désigne l'un des 5 fonctors suivants
                        #(pas les fonctions). Il y a en tout 3 bases classes.
                        #On peut les << et >> (eux, non leur résultat) pour
                        #changer leur comportement (extraction) ou imprimer
                        #leur comportement (ex : "first Mon of Feb").

d_t::                   
year_based_generator<T> #
gr::year_based_generator#Base classe pour des classes générant une DATE précise
                        #via get_date(), en fonction de critères propres, 
                        #précisés lors de l'instantiation.
                        #On peut ainsi créer ses propres générateurs.
                        #first_day_of_the_week_after/before sont cependant
                        #des classes sans parent.

YEAR_BASED_GENERATOR.
get_date(WVAL)          #Renvoie une DATE en fonction des critères.

gr::first_day_of_the_   #Calcule le premier lundi (ou mardi, etc.) d'un mois
week_in_month           #donné, en fonction de l'année demandée. WVAL est une 
                        #GREG_YEAR. Enfant de year_based_generator.
                        #Instantié avec un GREG_WEEKDAY et un GREG_MONTH.

gr::last_day_of_the_    #
week_in_month           #Même chose mais pour le dernier lundi (ou mardi, etc.)

gr::nth_day_of_the_     #Même chose mais pour le énième lundi (ou mardi, etc.)
week_in_month           #Instantié avec un INT_VAL, un GREG_WEEKDAY et un 
                        #GREG_MONTH. L'INT_VAL désigne le numéro de la semaine
                        #dans le mois (1 à 5, 5 désignant toujours la dernière
                        #semaine (qui peut donc être la 4ème si 28 jours))

gr::first_day_of_the_   #Calcule le premier lundi, ou mardi, etc. après la
week_after              #date demandée. WVAL est une DATE. Enfant de 
                        #year_based_generator. Instantié avec un GREG_WEEKDAY.

gr::first_day_of_the_   #
week_before             #Même chose, mais avant la date demandée.

gr::next_weekday(DATE,  #Renvoie le prochain GREG_WEEKDAY après DATE (inclus), 
GREG_WEEKDAY)           #sous forme de DATE.
gr::previous_weekday    #
(DATE, GREG_WEEKDAY)    #Même chose, mais avec le dernier GREG_WEEKDAY
gr::days_until_weekday  #Renvoie le nombre de jours entre DATE (inclus) et le 
(DATE, GREG_WEEKDAY)    #prochain GREG_WEEKDAY, sous forme de DATE_DURATION.
gr::days_before_weekday #
(DATE, GREG_WEEKDAY)    #Même chose, mais avec le dernier GREG_WEEKDAY.

gr::gregorian_calendar::
day_of_week             #Renvoie le jour de la semaine de GREG_YEAR_MONTH_DAY 
(GREG_YEAR_MONTH_DAY)   #sous forme de WEEKDAYS
gr::gregorian_calendar::
week_number             #Renvoie le numéro de la semaine de GREG_YEAR_MONTH_DAY
(GREG_YEAR_MONTH_DAY)   #pour son année (0..52)
gr::gregorian_calendar::    
end_of_month_day        #Renvoie le jour du mois terminant le mois déterminé par
(GREG_YEAR, GREG_MONTH) #GREG_MONTH et GREG_YEAR
gr::gregorian_calendar::    
is_leap_year(GREG_YEAR) #Renvoie true si GREG_YEAR est bissextile.

gr::gregorian_calendar::
day_number(YER_MNTH_DAY)#
gr::gregorian_calendar::
julian_day_number       #
(GREG_YEAR_MONTH_DAY)   #Renvoie GREG_YEAR_MONTH_DAY, sous forme du Jour Julien.
gr::gregorian_calendar::
modjulian_day_number    #Renvoie GREG_YEAR_MONTH_DAY, sous forme du Jour Julien
gr::gregorian_calendar::
from_day_number         #
(INT_VAL)
gr::gregorian_calendar::
from_julian_day_number  #
(INT_VAL)
gr::gregorian_calendar::
from_modjulian_day_     #Renvoie le GREG_YEAR_MONTH_DAY correspondant au Jour
number(INT_VAL)         #Julien ou Jour Julien Modifié INT_VAL.
(GREG_YEAR_MONTH_DAY)   #Modifié.
gr::gregorian_calendar::#Renvoie "Epoch" sous forme de GREG_YEAR_MONTH_DAY (mais
epoch()                 #il s'agit ici de la date minimale, 1er janvier 1400)

                                  ┌────────────────┐
                                  │   TIME ZONES   │
                                  └────────────────┘

l_t::time_is_dst_result #Etat des daylight savings
l_t::is_not_in_dst      #
l_t::is_in_dst          #
l_t::ambiguous          #
l_t::invalid_time_label #

d_t::time_zone_base     #Désigne une time zone, interface pour les autres
<WVAR1[, WVAR2]>        #classes de time zone (par concept, et non par héritage)

TIME_ZONE_BASE.         #Renvoie le nom non abbrégé de la time zone, hors 
std_zone_name()         #daylight saving time, sous forme de STRING
TIME_ZONE_BASE.
std_zone_abbrev()       #Renvoie le nom abbrégé, hors daylight saving time
TIME_ZONE_BASE.
dst_zone_name()         #Renvoie le nom non abbrégé, pendant dst
TIME_ZONE_BASE.
dst_zone_abbrev()       #Renvoie le nom abbrégé, pendant dst
TIME_ZONE_BASE.has_dst()#Renvoie false s'il n'y a pas de daylight savings shift.
TIME_ZONE_BASE.
dst_local_start_time    #Renvoie la PTIME à laquelle commence les daylight
(GREG_YEAR)             #savings pour l'année GREG_YEAR.
TIME_ZONE_BASE.         
dst_local_end_time      #Même chose, mais quand ils s'arrêtent.
(GREG_YEAR)             
TIME_ZONE_BASE.         #Renvoie le daylight savings shift, sous forme de 
dst_offset()            #TIME_DURATION
TIME_ZONE_BASE.         #Renvoie le décalage par rapport à UTC, sous forme de 
base_utc_offset()       #TIME_DURATION
TIME_ZONE_BASE.         #Renvoie la time zone sous forme de STRING (telle que
to_posix_string()       #celle instantiée pour une POSIX_TIME_ZONE)

l_t::time_zone          #Typedef depuis time_zone<posix_time::ptime, char>. Ne
                        #sert que d'interface (par concept).
l_t::time_zone_ptr      #Typedef depuis boost::shared_ptr<time_zone>
l_t::wtime_zone         #Typedef depuis time_zone<posix_time::ptime, wchar_t>
l_t::wtime_zone_ptr     #Typedef depuis boost::shared_ptr<wtime_zone>

l_t::posix_time_zone    #Hérite (par concept) de time_zone, mais avec un 
                        #constructor :

POSIX_TIME_ZONE(STRING) #STRING doit être, soit :
                        #  - OFFSET représentant : [+|-]HH[:MM[:SS]]
                        #  - TIME représentant soit :
                        #     - M[m]m.w.d ('M' est littéral, w est le numéro de 
                        #       la semaine (1..5), d le jour de la semaine
                        #       (0..6))
                        #     - Jddd ('J' est littéral, d est le jour de l'année
                        #       (1..365) (29 février jamais compté))
                        #     - ddd (d est le jour de l'année (0..365), où 59 
                        #       est le 29 février, même pendant les années non-
                        #       bissextiles)
                        #  - ABREV une suite de lettres
                        #Sous la forme :
                        #  - ABREV1OFFSET1[ABREV2[OFFSET2],TIME1[/OFFSET3],TIME2
                        #    [/OFFSET4]]
                        #Où :
                        #  - ABREV1 est la std_zone_abbrev
                        #  - OFFSET1 est la base_utc_offset (seuls ces deux sont
                        #    requis s'il n'y a pas de daylight savings)
                        #  - ABREV2 est la dst_zone_abbrev
                        #  - OFFSET2 est la dst_offset (par défaut 01:00)
                        #  - TIME1 et TIME2 sont le premier et le dernier jour 
                        #    des dayling saving lights
                        #  - OFFSET3 et OFFSET4 sont l'heure de ce premier et de
                        #    ce dernier jour (par défaut 02:00)
                        #Des exceptions local_time::bad_offset ou 
                        #local_time::bad_adjustment sont lancées en cas d'erreur
                        

l_t::custom_time_zone   #Hérite (par concept) de time_zone, mais avec comme
                        #constructor :

CUSTOM_TIME_ZONE        
(TIME_ZONE_NAMES,       
TIME_DURATION,
DST_ADJUSTMENT_OFFSETS, #TIME_DURATION est le base_utc_offset, les autres sont
DST_CALC_RULE_PTR)      #expliquées ci-dessous.

l_t::time_zone_names    #Désigne un nom + abbréviation de time zone.

TIME_ZONE_NAMES(STRING1,#Les quatre paramètres (accessibles via les getters) :
STRING2, STRING3,       #std_zone_name, std_zone_abbrev, dst_zone_name et 
STRING4)                #dst_zone_abbrev.

l_t::
dst_adjustment_offsets  #Désigne des daylight saving rules shift.

DST_ADJUSTMENT_OFFSETS  #Les arguments correspondent à :
(TIME_DURATION1,        #  - dst_offset
TIME_DURATION2,         #  - heure du premier jour de daylight savings
TIME_DURATION3)         #  - heure du dernier jour de daylight savings

l_t::dst_calc_rule      #Désigne le dst_local_start_time et le 
                        #dst_local_end_time. Cinq instantiations possibles :
                        #  - d_t::partial_date_dst_rule(DATE, DATE2)
                        #  - d_t::first_last_dst_rule
                        #    (gr::first_day_of_the_week_in_month(...),
                        #    gr::last_day_of_the_week_in_month(...))
                        #  - d_t::last_last_dst_rule
                        #    (gr::last_day_of_the_week_in_month(...),
                        #    gr::last_day_of_the_week_in_month(...))
                        #  - d_t::nth_last_dst_rule
                        #    (gr::nth_day_of_the_week_in_month(...),
                        #    gr::last_day_of_the_week_in_month(...))
                        #  - d_t::nth_day_of_the_week_in_month_dst_rule
                        #    (gr::nth_day_of_the_week_in_month(...),
                        #    gr::nth_day_of_the_week_in_month(...))
l_t::dst_calc_rule_ptr  #Smart pointer depuis dst_calc_rule

l_t::tz_database        #Désigne une base de données de time zones.

TZ_DATABASE()           #Constructor vide (database vide)

TZ_DATABASE.            #Remplie la database avec le fichier .csv dont le chemin
load_from_file(STRING)  #est STRING (un exemple avec 377 time zones est dans
                        #les sources :
                        #./libs/date_time/data/date_time_zonespec.csv)
                        #Le fichier .csv est composé :
                        #  - d'une ligne d'header non prise en compte
                        #  - d'une ligne par time zone.
                        #Chaque time zone a 11 champs, entourés de " " et 
                        #séparés par des blanks. Il s'agit :
                        #  - de l'identifiant
                        #  - des 9 champs d'une time_zone, tel que pour une
                        #    POSIX_TIME_ZONE (un champs vide devant être une
                        #    null string), avec les ABREV suivies d'un champs
                        #    avec la version longue.
TZ_DATABASE.add_record  #Rajoute une time zone, avec l'identifiant STRING, et
(STRING, TIME_ZONE_PTR) #la time zone TIME_ZON_PTR.
TZ_DATABASE.            
time_zone_from_region   #
(STRING)                #Renvoie la TIME_ZONE_PTR associée à l'identifiant STRING
TZ_DATABAS.region_list()#Renvoie tous les identifiants de la database, sous 
                        #forme de STD::VECTOR<STRING>

                                  ┌──────────────────────────┐
                                  │   CONVERSION EN STRING   │
                                  └──────────────────────────┘

                        #Ces fonctions convertissent des strings en dates, et
                        #inversement.
                        #Si DATE, PTIME, etc. initialisée avec garbage, pas
                        #d'exception, mais initialisé avec d_t::not_a_date_time
                        #Il est possible d'imprimer, mais aussi d'extraire des
                        #d_t::special_values. Le format par défaut est :
                        #"not-a-date-time", "-infinity", "+infinity" et 
                        #(extraction only) "minimum date-time", 
                        #"maximum-date-time"
                        #Les DateGenerateur indiquent la classe elle-même, pas
                        #le résultat de son operator()
                        #Cela ne respecte la locale courante que pour le nom des mois et jours de la semaine.
                        # +---------------+-------------------+---------------+
                        # |   ARGUMENT    | FORMAT DE STRING  |    RESULTAT   |
                        # +---------------+-------------------+---------------+
BASIC_OSTREAM <<        # |   GR::DATE    |    YYYY-µµ-dd     |   Impression  |
                        # |  P_T::PTIME   |YYYY-mm-dd HH:MM:SS| (Modifiable   |
                        # |               |   [.NNNNNN[NNN]]  | par *facets)  |
                        # |L_T::LCL_DT_TIM|YYYY-mm-dd HH:MM:SS|               |
                        # |               |[.NNNNNN[NNN]][TMZ]|               |
                        # |               |(TMZ est l'abbrév. |              |
                        # |               | du nom de la TMZ  |               |
                        # |               |      courante     |               |
                        # |GR::DAT_DURATIN|      NOMBRE       |               |
                        # |P_T::TIM_DURTIN|      HH:MM:SS     |               |
                        # |               |   [.NNNNNN[NNN]]  |               |
                        # | DateGenerateur|ex:"first Mon of   |               |
                        # |               |        Feb"       |               |
BASIC_ISTREAM >>        # | Mêmes que <<  |    Mêmes que <<   |   Extraction  |
                        # | Doit être VAR |                   |(Modifiable par|
                        # |               |                   |*input_facets) |
                        # +---------------+-------------------+---------------+
gr::from_simple_string  # |    STRING     |  YYYY-[µ]µ-[d]d   |     DATE      |
gr::from_us_string      # |    STRING     |  [µ]µ-[d]d-YYYY   |     DATE      |
gr::from_uk_string      # |    STRING     |  [d]d-[µ]µ-YYYY   |     DATE      |
gr::                    # |               |                   |               |
from_undelimited_string # |               |                   |               |
gr::date_from_iso_string# |    STRING     |    YYYYmm[d]d     |     DATE      |
p_t::from_iso_string    # |    STRING     |  YYYYmmddTHHMMSS  |     PTIME     |
                        # |               |   [.NNNNNN[NNN]]  |               |
p_t::time_from_string   # |    STRING     |YYYY-mm-dd HH:MM:SS|     PTIME     |
                        # |               |   [.NNNNNN[NNN]]  |               |
p_t::                   # |    STRING     |      HH:MM:SS     | TIME_DURATION |
duration_from_string    # |               |   [.NNNNNN[NNN]]  |               |
gr::                    # |    STRING     |   [YYYY-mm-dd/    |  DATE_PERIOD  |
date_period_from_string # |               |    YYYY-mm-dd]    |               |
gr::from_stream         # | ITVR1, ITVR2  |  YYYY-[µ]µ-[d]d   |     DATE      |
                        # | (extrait une  |                   |               |
                        # | STRING entre  |                   |               |
                        # |   les deux)   |                   |               |
                        # +---------------+-------------------+---------------+
gr::special_value_from_ # |               |    Le nom d'une   |               |
string                  # |    STRING     |d_t::special_values|               |
                        # +---------------+-------------------+---------------+
gr::to_simple_string    # |     DATE      |    YYYY-µµ-dd     |     STRING    |
                        # |  DATE_PERIOD  |   [YYYY-µµ-dd/    |     STRING    |
                        # |               |    YYYY-µµ-dd]    |               |
p_t::to_simple_string   # |    PTIME      |YYYY-mm-dd HH:MM:SS|     STRING    |
                        # |               |   [.NNNNNN[NNN]]  |               |
                        # |  TIME_PERIOD  |[YYYY-mm-dd HH:MM: |     STRING    |
                        # |               | SS[.NNNNNN[NNN]]/ |               |
                        # |               | YYYY-mm-dd HH:MM: |               |
                        # |               | SS[.NNNNNN[NNN]]] |               |
                        # | TIME_DURATION |     HH:MM:SS      |     STRING    |
                        # |               |   [.NNNNNN[NNN]]  |               |
gr::to_iso_string       # |     DATE      |      YYYYmmdd     |     STRING    |
p_t::to_iso_string      # | TIME_DURATION |HHMMSS[.NNNNN[NNN]]|     STRING    |
                        # |     PTIME     |    YYYYmmddTHH    |     STRING    |
                        # |               | MMSS[.NNNNNN[NNN]]|               |
gr::to_sql_string       # |               |                   |               |
gr::                    # |               |                   |               |
to_iso_extended_string  # |     DATE      |     YYYY-mm-dd    |     STRING    |
p_t::                   # |     PTIME     |   YYYY-mm-ddTHH:  |     STRING    |
to_iso_extended_string  # |               |MM:SS[.NNNNNN[NNN]]|               |
                        # +---------------+-------------------+---------------+
gr::                    # |                                                   |
date_period_from_wstring# |                                                   |
gr::to_simple_wstring   # |                                                   |
gr::to_iso_wstring      # |            Equivalents wide-characters            |
gr::to_sql_wstring      # |     Regarder header pour version générique.       |
gr::                    # |                                                   |
to_iso_extended_wstring # |                                                   |
                        # +---------------------------------------------------+
                        #  - µ signifie un mois sous forme littérale (abrégée ou
                        #    non : Jan, January), m sous forme numérique.
                        #  - Les délimiteurs - peuvent être aussi / ou espace
                        #  - Les 'T' sont littéraux.

                                  ┌─────────┐
                                  │   I/O   │
                                  └─────────┘

FACETS ==>              #Elles modifient l'effet de << et >> sur d_t::date, d_t::base_time, et leurs enfants
                        #  - mais aussi les d_t::period<T>, DateGenerateur et d_t::special_values liés (par exemple 
                        #    gr::date_period pour un gr::date_facet).
                        #     - [period,date_generator,special_values]_[formatter,parser] sont utilisés à cet effet, et passés
                        #        à date_facet ou time_facet pendant son instantiation ou via des méthodes
                        #     - format_date_parser n'est utilisé que pour l'extraction, mais fonctionne sur le même principe
                        #  - enfants de std::facet. Tous peuvent être construits avec un dernier argument, instantiant 
                        #    std::facet avec cet argument.
                        #  - elles modifient le format par défaut, et divers paramètres
                        #Pour utiliser :
                        #  - imbue() un std::basic_ostream ou istream avec un std::locale( LOCALE, FACET_ADR ), où FACET est 
                        #    une DATE_FACET_ADR ou TIME_FACET_ADR
                        #Le formattage de d_t::date_duration et d_t::time_duration ne semblent pas modifiables.

LOCALIZATION ==>        #Seuls les jours de la semaine et mois sont respectées de la locale courante.
                        #On peut aussi utiliser les séquences d'échappement date propres à la locale courante, notamment "%x"
                        #pour les date, "%X" pour les time et "%X %Z" pour les local_time. Ex : 
                        #  - std::cout.imbue( std::locale( std::locale(), new gr::date_facet( "%X" ) ) );
                        #Sinon, il faut utiliser soi-même time_get de std::locale pour avoir les représentations correctes.

+-----------------------------+-------------------+------------------------------+--------------------+-----------------------+
| CLASSE                      | ACTION SUR        | SPECIALISATION               | ACTION SUR         | TEMPLATE SPECIALISE   |
+-----------------------------+-------------------+------------------------------+--------------------+-----------------------+
|d_t::date_facet<T1,T2>       | << d_t::date      | gr::date_facet               | << gr::date        | <gr::date,char>       |
|                             |                   | gr::wdate_facet              |                    | <gr::date,wchar_t>    |
|d_t::time_facet<T1,T2>       | << d_t::base_time | p_t::time_facet              | << p_t::time       | <p_t::time,char>      |
|                             |                   | p_t::wtime_facet             |                    | <p_t::time,wchar_t>   |
|                             |                   | l_t::local_time_facet        | << l_t::local_time | <l_t::local_time,char>|
|                             |                   | l_t::local_wtime_facet       |                    | <l_t::local_time,wc_t>|
+-----------------------------+-------------------+------------------------------+--------------------+-----------------------+
*[local_][date|time]_input_facet : même chose, mais pour >>, et non <<

+-------------------------------+--------------------+-------------------------------+----------------------------------------+
| CLASSE                        | ACTION SUR         | SPECIALISATION                | TEMPLATE SPECIALISE                    |
+-------------------------------+--------------------+-------------------------------+----------------------------------------+
| d_t::period_formatter<T>      | d_t::period<T1,T2> | gr::period_formatter          | <char>                                 |
|                               |                    | gr::wperiod_formatter         | <wchar_t>                              |
| d_t::format_date_parser       | Noms de jours et   | Aucun                         | T1 est la d_t::base_time ou d_t::date  |
| <T1,T2>                       | mois               |                               | T2 est le char_type                    |
| d_t::special_values_formatter | d_t::special_values| gr::special_values_formatter  | <char>                                 |
| <T>                           |                    | gr::wspecial_values_formatter | <wchar_t>                              |
| d_t::date_generator_formatter | Générateurs        | Aucun                         | T1 est la d_t::base_time ou d_t::date  |
| <T1,T2>                       |                    |                               | T2 est le char_type                    |
+-------------------------------+--------------------+-------------------------------+----------------------------------------+
[period|date_generator|special_values]_parser : même chose, mais pour >>, et non <<

d_t::date_facet<T1,T2>  #WSTR si T2 est wchar_t, STR sinon.
                        #Ses membres :

...::
input_collection_type   #std::vector<[W]STR>
...::char_type          #T2
...::
period_formatter_type   #d_t::period_formatter_type<T2>
...::special_values_
formatter_type          #special_values_formatter_type<T2>
...::date_type          #
...::duration_type      #
...::month_type         #
...::day_of_week_type   #
...::period_type        #
...::partial_date_type  #
...::*kday*_type        #
...::day_type           #

DATE_FACET()            #N'invoque rien.
DATE_FACET([W]STR       #Invoque format([W]STR)
[, PERIOD_FORMATTER_TYPE#Si PERIOD_FORMATTER_TYPE, invoque period_formatter()
[, SPECIAL_VALUES_      #Si SPECIAL_VALUES_FORMATTER_TYPE, invoque 
FORMATTER_TYPE[, DATE_  #special_values_formatter()
GEN_FORMATTER_TYPE]]])  #Si DATE_GEN_FORMATTER_TYPE, invoque 

DATE_FACET([W]STR,      #Invoque format([W]STR) puis 
INPUT_COLLECTION_TYPE)  #short_month_names(INPUT_COLLECTION_TYPE)

format([W]STR)          #Modifie le format imprimé par défaut en utilisant une
                        #string telle que celle utilisée par strftime() 
                        #(séquence d'échappement date). Cf doc.
                        #A noter que certaines séquences ne sont possibles
                        #qu'avec les date_facet, non les date_input_facet
                        #Si une d_t::date essaye d'utiliser des flags d'heures, 
                        #etc., ils impriment comme si l'heure, etc. était 0.
set_iso_format()        #Equivaut à format("%Y%m%d")
set_iso_extended
_format()               #Equivaut à format("%Y-%m-%d")
month_format([W]STR)    #Modifie le format imprimé pour une impression de 
                        #MONTH_TYPE isolée.
weekday_format([W]STR)  #Même chose pour un DAY_OF_WEEK isolé.
short_weekday_names     #
(INPUT_COLLECTION_TYPE) #Modifie les strings renvoyés par %a
long_weekday_names      #
(INPUT_COLLECTION_TYPE) #Même chose pour %A
short_month_names       #
(INPUT_COLLECTION_TYPE) #Même chose pour %h
long_month_names        #
(INPUT_COLLECTION_TYPE) #Même chose pour %B

put(STREAMBUF_ITERATOR, #Revient à faire IOS_BASE << ARGS, mais en utilisant 
IOS_BASE, CHAR_TYPE,    #FACET et non la facet/locale d'IOS_BASE.
ARGS)                   #CHAR_TYPE est le fill character.

period_formatter        #Modifie les délimiteurs d'une impression de period_type
(PERIOD_FORMATTER_TYPE) #(les dates sont quant à elles mêmes que si pas dans une
                        #période) en fonction de PERIOD_FORMATTER_TYPE
special_values_formatter#
(SPECIAL_VALUES_        #Modifie l'impression des special_values, en fonction de
FORMATTER_TYPE)         #SPECIAL_VALUES_FORMATTER_TYPE.
date_gen_phrase_strings #
(INPUT_COLLECTION_TYPE, #Modifie l'impression des DateGenerateur en fonction de
INT_VAL)                #date_generator_formatter.elements(ARGS)

d_t::period_formatter<T>  #Désigne les délimiteurs lors de l'impression d'une
                          #period_type.

...::string_type          #
...::char_type            #

D_T::PERIOD_FORMATTER     #Effectue :
([RANGE_DISPLAY_OPTIONS   #  - range_option(RANGE_DISPLAY_OPTIONS), par défaut
[, [W]STR1[, [W]STR2      #    AS_CLOSED_RANGE
[, [W]STR3[, [W]STR4]]]]])#  - delimiter_strings(ARGS), avec les arguments par
                          #    défaut : / [ ) ]
D_T::PERIOD_FORMATTER.
range_option()            #Renvoie le RANGE_DISPLAY_OPTIONS de PERIOD_FORMATTER
D_T::PERIOD_FORMATTER.    #Modifie le D_T::PERIOD_FORMATTER<T>::
range_option              #RANGE_DISPLAY_OPTIONS :
(RANGE_DISPLAY_OPTIONS)   #  - d_t::period_formatter<T>::AS_OPEN_RANGE, utilise
                          #    l'open end delimiter, et imprime la dernière
                          #    date excluse
                          #  - d_t::period_formatter<T>::AS_CLOSED_RANGE,utilise
                          #    le closed end delimiter, et imprime la dernière
                          #    date incluse
D_T::PERIOD_FORMATTER.
delimiter_strings         #
([W]STR1, [W]STR2,        #Modifie le middle, start, open end et closed end
[W]STR3, [W]STR4)         #delimiter

d_t::special_values       
_formatter<T>             #Désigne l'impression des SPECIAL_VALUES

...::char_type            #
...::string_type          #
...::collection_type      #std::vector<string_type>

D_T::SPECIAL_VALUES       #Les arguments désignent le début et fin d'une arrays
_FORMATTER([W]STR_ADR1,   #de strings. Ne prend en compte que les trois 
[W]STR_ADR2)              #premières strings. 
D_T::SPECIAL_VALUES_      #Modifient dans l'ordre : not_a_date_time, neg_infin,
FORMATTER                 #pos_infin (pas min/max_date_time, qui sont toujours
(COLLECTION_TYPE_ITVR1,   #imprimées (mais pas extraites) comme des dates 
COLLECTION_TYPE_ITVR2)    #normales)

d_t::date_generator_      #T1 est la d_t::base_time, T2 le char_type.
formatter<T1,T2>          #Désigne l'impression des DateGenerateur, c'est-à-dire
                          #les mots employés.

...::char_type
...::string_type
...::collection_type      #std::vector<string_type>

D_T::DATE_GENERATOR_
FORMATTER([9 STRING_TYPS])#Instantie et, si ARGS, invoque elements(ARGS, 0),
                          #ARGS étant converti en collection_type

D_T::DATE_GENERATOR_
FORMATTER.elements        #Instantie et, si ARGS, invoque elements(ARGS, 0)
(COLECTION_TYP[, INT_VAL])#Change les mots utilisés par DateGenerateur. Il y en
                          #a 9, dans l'ordre : "first", "second", "third", 
                          #"fourth", "fifth", "last", "before", "after", "of".
                          #Si INT_VAL, commence à modifier l'élément numéro
                          #INT_VAL seulement, et ne prend que les 9 - INT_VAL
                          #strings de COLLECTION_TYPE.

d_t::format_date_parser   #T1 est la d_t::base_time, T2 le char_type.
<T1,T2>                   #Désigne l'impression des jours et mois.

...::string_type
...::input_collection_type#std::vector<string_type>

FORMAT_DATE_PARSER
(STRING_TYPE, STD::LOCALE)#STRING_TYPE est le format, pour pour format(). Les
FORMAT_DATE_PARSER        #noms des mois courts, longs, jours cours et longs
(STRING_TYPE,             #sont extraits des arguments (si STD::LOCALE, utilise
4 INPUT_COLLECTION_TYPES) #la locale courante)

FORMAT_DATE_PARSR.format()#

FORMAT_DATE_PARSER.
format(STRING_TYPE)       #
FORMAT_DATE_PARSER.
short_month_names         #
(INPUT_COLLECTION_TYPE)
FORMAT_DATE_PARSER.
long_month_names          #
(INPUT_COLLECTION_TYPE)
FORMAT_DATE_PARSER.
short_weekday_names       #
(INPUT_COLLECTION_TYPE)
FORMAT_DATE_PARSER.
long_weekday_names        #
(INPUT_COLLECTION_TYPE)   #Cf constructor.

d_t::time_facet<T1,T2>  #Exactement comme d_t::date_facet (son parent), sauf
                        #que pas de constructor avec deux éléments.

d_t::date_input_facet   #Comme d_t::date_facet, sauf que :
<T1,T2>                 #  - utilisé pour l'extraction non l'impression
                        #  - "put()" -> "get()"
                        #  - utilisent des classes "*parser", non "*formatter"
                        #  - son constructor prend entre le premier et le 
                        #    troisième argument, un FORMAT_DATE_PARSER_TYPE
d_t::time_input_facet   #Différences : cf d_t::date_input_facet, mais pour 
<T1,T2>                 #d_t::time_facet

d_t::period_parser<T>   #Comme d_t::period_formatter sauf que :
                        #  - range_display_options s'appelle period_range_option
d_t::special_values     #Comme d_t::special_values_formatter sauf que :
_parser<T>              #  - modifie aussi min/max_date_time
                        #  - constructor avec 5 STRING_TYPE possible
                        #  - .sv_strings( 5 STRING_TYPES ), pour modifier après
                        #    construction
d_t::date_generator_    #Comme d_t::date_generator_formatter sauf que :
parser<T1,T2>           #  - elements() s'appelle element_strings(), et prend
                        #    neuf STRING_TYPE en argument.

