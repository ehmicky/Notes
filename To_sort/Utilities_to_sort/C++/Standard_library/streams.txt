
             
   STREAMS   
             

                                  ┌─────────────────┐
                                  │   GENERALITES   │
                                  └─────────────────┘

ORGANISATION GENERALE   
   ==>                  #Voici la hierarchie d'héritance suivie des classes :

ios_base             +--> cin
 |                   +-------------> istringstream <--+
 |    +--> istream --+-----> ifstream <------------+  |
 v    +      +           +------> stringstream <-+ +---- filebuf <--+
ios --+      +-> stream -+-> fstream  <----------|-+  |             +- streambuf
      +      +       +---------> ostringstream <-+-|--+- stringbuf <+
      +--> ostream --+-----> ofstream <------------+  
                     +--> cout, cerr, clog

-------+-----------+----------+---------+---------+-----------------------------
 <ios> | <istream> |<iostream>|<fstream>|<sstream>|        <streambuf>
       | <ostream> |          |         |         |
-------+-----------+----------+---------+---------+-----------------------------

RESUME ==>              #  - ios_base : bases des streams, type independant
                        #  - ios : base des streams, relatives aux streams
                        #          non-wide characters (utilisant des CHAR_VAL)
                        #  - istream, ostream, stream : stream associé à un
                        #    streambuf
                        #  - cin, cout, cerr, clog : flux standards
                        #  - ifstream, ofstream, fstream : stream associé à un
                        #    filebuf, pratique d'utilisation
                        #  - ifstream, ofstream, fstream : stream associé à un
                        #    stringbuf, pratique d'utilisation
                        #  - streambuf, filebuf, stringbuf : buffer + stream
                        #    utilisés par les streams.

HEADERS ==>             #Voici l'ordre d'inclusion des headers :
                        #  <ios> <-+-- <istream> <---+  +-- <iostream>
                        #          +-- <ostream> <---+--+-- <fstream>
                        #          +-- <streambuf> <-+  +-- <sstream>
                        #          +-- <iomanip>
                        #Les headers sur une même colonne ne s'incluent pas
                        #mutuellement.
                        #Il faut donc inclure <iostream> et <fstream> pour avoir
                        #la plupart des fonctionnalités, et <sstream> et 
                        #<iomanip> si l'on veut utiliser leur fonctionnalités
                        #respectives.
AVANTAGE IOSTREAMS      #  - Type-safety : Pas de typage dynamique via les "%" 
SUR CSTDIO ==>          #    de printf(), scanf(), etc.
                        #  - Moins d'erreur via les "%"
                        #  - extensibilité et héritage des classes

EXEMPLE DE LECTURE EN   #  - while ( ( std::cout << "Question\n" ) &&
INPUT ==>               #    ! ( std::cin >> a ) )
                        #    {
                        #       std::cout << "Erreur" << std::endl;
                        #       std::cin.clear();
                        #       std::cin.ignore(std::numeric_limits
                        #       <std::streamsize>::max(), '\n');
                        #    }

                                  ┌──────────────────────────────┐
                                  │   FMTFLAGS ET MANIPULATORS   │
                                  └──────────────────────────────┘

ios_base::fmtflags      #Type indiquant une combinaison or'd de fmtflags.
                        #Les fmtflags liés à tout stream par défaut sont skipws 
                        #et dec. Cependant, clog ajoute aussi unitbuf.
                        #Supprimer dec n'a aucun effet car cela restera décimal.
                        #Ne pas confondre les fmtflags (qui sont des flags) et
                        #les manipulators (qui sont des fonctions).

FMTFLAGS
ECRITURE/LECTURE ==>    #Voici :
ios_base::boolalpha     #Ecrire une BOOL_VAL écrit "true" ou "false" et non 1 
                        #ou 0 (il faut qu'il s'agisse bien d'une BOOL_VAL, pas
                        #de quelque chose pouvant être un INT_VAL, par exemple
                        #une BOOL_VAR ou la valeur de retour d'une BOOL_FNC_VAR)
                        #Et lire "true" ou "false" depuis IOS_BASE vers un
                        #BOOL_VAR ne provoque pas d'erreur.
ios_base::dec           #Les chiffres sont lus et écrits en base décimale.
ios_base::hex           #Les chiffres sont lus et écrits en base hexadécimale
ios_base::oct           #Les chiffres sont lus et écrits en base octale

FMTFLAGS ECRITURE ==>   #Voici :
ios_base::showbase      #Ecrire un nombre hexadécimal sur IOS_BASE rajoute 0x 
                        #devant, et 0 pour un octal. oct ou hex doit avoir été
                        #appliqué.
ios_base::uppercase     #Les lettres et éventuellement le 0x d'un nombre
                        #hexadécimal (via le fmtflag hex) sont écrits avec des
                        #majuscules.
ios_base::showpoint     #Si ni le fmtflag fixed, ni scientific n'est activé,
                        #fait que la precision courante ne désigne pas le
                        #nombre maximal de chiffres, mais le nombre exact, ce
                        #qui signifie que :
                        #  - des 0 sont ajoutés à la fin au besoin
                        #  - la virgule est toujours présente, même après un
                        #    nombre rond.
ios_base::fixed         #Fait que la precision courante désigne le nombre de
                        #chiffres après la virgule, et non le nombre de chiffres
                        #total (cf IOS_BASE.precision())
ios_base::scientific    #Fait que les TOUFLOAT_VAL sont imprimés sous la forme
                        #CHIFFRE.NOMBREe+|-NOMBRE
ios_base::showpos       #Rajoute un + avant les nombres positifs
ios_base::unitbuf       #L'IOS_BASE est flushed après chaque appel à <<
ios_base::left          #Si la taille du taille < width courante, le padding
                        #via le fill character aligne le texte sur la gauche.
ios_base::right         #Même chose, mais sur la droite
ios_base::internal      #Comme right, mais s'il y a un signe + ou -, il est 
                        #aligné sur la gauche, contrairement au reste du texte

FMTFLAGS LECTURE ==>    #Voici :
ios_base::skipws        #Ignore les leading whitespaces avec l'operator >>

FMTFLAGS MASQUE ==>     #Il s'agit de l'union de plusieurs fmtflags, utilisée
                        #comme masque :
ios_base::adjustfield   #Masque de left, right et internal
ios_base::basefield     #Masque de dec, oct et hex
ios_base::floatfield    #Masque de scientific et fixed

IOS_BASE.flags()        #Renvoie les FMTFLAGS courants

IOS_BASE.flags          #Clear et renvoie tous les fmtflags de IOS_BASE, et
(FMTFLAGS_VAL)          #active FMTFLAGS_VAL
IOS_BASE.setf           #
(FMTFLAGS_VAL           #Clear le masque FMTFLAGS_VAL2, et active FMTFLAGS_VAL
[, FMTFLAGS_VAL2])      #Par défaut le masque est nul.
IOS_BASE.unsetf         #Clear FMTFLAGS_VAL, qui peut être un masque ou un
(FMTFLAGS_VAL)          #fmtflag isolé.

IOS_BASE.precision()    #Renvoie la précision courante (par défaut 6). La
                        #précision est, pour un TOUFLOAT_VAL, le nombre de 
                        #chiffres :
                        #  - Si les fmtflags scientific ou fixed ne sont pas
                        #    activés. Il s'agit du nombre de chiffres maximal
                        #    après et avant la virgule, et peut donc être plus 
                        #    court (car les 0 finaux sont tronqués).
                        #    Par ailleurs, si la partie entière a un nombre de 
                        #    chiffres > precision, la notation scientific est
                        #    utilisée, la precision désignant toujours le nombre
                        #    de chiffres avant et après la virgule, et non
                        #    seulement après.
                        #  - après la virgule, si fixed est activé. Des 0 sont
                        #    ajoutés à la fin au besoin.
                        #  - après la virgule, sans l'exponent, si scientific 
                        #    est activé. Même chose pour les 0.

IOS_BASE.precision
(STREAMSIZE_VAL)        #set precision, et renvoie l'ancienne

IOS_BASE.width()        #Renvoie la width courante (par défaut 0). Il s'agit du
                        #nombre minimal de caractère à imprimer pour la 
                        #prochaine écriture sur IOS_BASE. Si la prochaine
                        #écriture a une taille inférieure, elle est remplie par
                        #une itération du fill character, en fonction des
                        #fmtflags internal, left ou right (par défaut right)
                        #La width est réinitialisée à 0 après tout écriture.

IOS_BASE.width          #La width courante d'IOS_BASE devient STREAMSIZE_VAL, et
(STREAMSIZE_VAL)        #l'ancienne width est renvoyée.

IOS_BASE.getloc()       #Renvoie la LOCALE associée à IOS_BASE

IOS_BASE.imbue(LOCALE)  #LOCALE devient la locale d'IOS_BASE

MANIPULATORS ==>        #Il s'agit de FONC_VAR prenant un argument de type 
                        #IOS_BASE ou ses classes dérivées, et renvoyant une
                        #valeur du même type, qui modifient des fmtflags sur
                        #un stream.
                        #Ils peuvent être invoqués via OSTREAM << 
                        #MANIPULATOR_ADR ou ISTREAM >> MANIPULATOR_ADR 
                        #directement, ISTREAM ou OSTREAM devenant l'argument du
                        #manipulator.
                        #Tous les fmtflags ont leur version avec le même nom
                        #sous forme de manipulator, qui active donc le fmtflag
                        #du même nom, comme avec setf()
                        #Il y a cependant quelques manipulators en plus :

noboolalpha(IOS_BASE)   #Négation de boolalpha, équivaut donc à
                        #IOS_BASE.unsetf(ios_base::boolalpha), sauf que IOS_BASE
                        #est renvoyé.
noshowbase(IOS_BASE)    #Négation de showbase
noshowpoint(IOS_BASE)   #Négation de showpoint
noshowpos(IOS_BASE)     #Négation de showpos
noskipws(IOS_BASE)      #Négation de skipws
nounitbuf(IOS_BASE)     #Négation de unitbuf
nouppercase(IOS_BASE)   #Négation de uppercase

ws(ISTREAM)             #Lit les prochaines whitespaces d'ISTREAM, jusqu'au 
                        #premier caractère non whitespace.
endl(OSTREAM)           #Ecrit une newline sur OSTREAM, puis flushe OSTREAM.
ends(OSTREAM)           #Ecrit un '\0' sur OSTREAM.
flush(OSTREAM)          #Equivaut à OSTREAM.flush()
HEADER ==>              #<iomanip>

SET-MANIPULATORS ==>    #Il s'agit de manipulators qui prennent non pas un 
                        #IOS_BASE ou dérivé en argument, mais d'autres types.
                        #Ils ne peuvent être utilisés que via l'opérateur >> ou
                        #<<, ce qui permet de les lier à un IOS_BASE ou dérivé,
                        #que l'on appellera IOS_BASE ici (sauf qu'un IOS_BASE
                        #est renvoyé)

setbase(INT_VAL)        #La base devient INT_VAL. INT_VAL ne peut être que 8
                        #(oct), 10 (dec) ou 16 (hex)
setprecision(INT_VAL)   #Equivaut à IOS_BASE.precision(INT_VAL)
setfill(CHAR_TYPE_VAL)  #Equivaut à IOS_BASE.fill(CHAR_TYPE_VAL)
setw(INT_VAL)           #Equivaut à IOS_BASE.width(INT_VAL)
setiosflags(FMTFLGS_VAL)#Equivaut à IOS_BASE.setf(FMTFLAGS_VAL)
resetiosflags           #
(FMTFLAGS_VAL)          #Equivaut à IOS_BASE.unsetf(FMTFLAGS_VAL)

                                  ┌───────────┐
                                  │   BASES   │
                                  └───────────┘

HEADER ==>              #<ios>

fpos <WVAR>             #Classe pour représenter une position absolue (depuis
                        #le début donc) d'un get/put pointer.
                        #Elle est convertible en int (représentant alors 
                        #l'offset depuis le début, en nombre de caractères), on 
                        #peut faire des addition, soustractions, ==, !=.
                        #WVAR est un type de shift.
streampos               #Spécialisation de fpos avec <mbstate_t> (grande 
                        #majorité des cas, sauf pour les chinois, etc.).
streamoff               #Type pour représenter la position relative d'un 
                        #get/put pointer.
streamsize              #Type pour représenter la taille d'un stream (souvent
                        #signed int ou signed long)

ios_base                #Les constructors sont protected ou private, et IOS_BASE
                        #ne peut pas être instantiée, seules ses classes 
                        #dérivées le peuvent.

ios_base::openmode      #Classe enregistrant les modes d'ouverture d'un stream.
                        #Lorsqu'un OPENMODE est requis, il est possible de
                        #donner une instantiation d'OPENMODE, mais aussi de
                        #simplement donner les openmode-flags or'd.

OPENMODE                #Instantie un OPENMODE, avec les valeurs VAL... Ces
(VAL[ | VAL2]...)       #dernières doivent être des openmode-flags or'd. Il y a
                        #un copy operator et copy constructor aussi.

ios_base::in            #Droit de lecture
ios_base::out           #Droit d'écriture. En l'absence d'ios_base::in, implique
                        #ios_base::trunc
ios_base::app           #Le stream position est placé à la fin du fichier à
                        #chaque écriture.
ios_base::ate           #Le stream position est placé à la fin du fichier à
                        #l'ouverture
ios_base::trunc         #Troncature du fichier lors de l'ouverture. De plus, si
                        #le fichier n'existe pas, il est créé.
                        #Pas possible sans ios_base::out.
ios_base::binary        #Le stream est considéré comme binary et non text

ios_base::seekdir       #Enum représentant la position d'un get/put pointer.
                        #Possibles valeurs (static) :

ios_base::beg           #Position du beginning get/put pointer
ios_base::cur           #Position du current get/put pointer
ios_base::end           #Position du ending get/put pointer

ios_base::iostate       #Type composé initialisé avec des ios-errors flags or'd.
                        #Associé à un fichier pour indiquer s'il a rencontré une
                        #erreur ou atteint EOF. Un fichier ayant l'un des flags
                        #(sauf goodbit) activé ne peut plus faire d'I/O 
                        #normalement. Voici les ios-errors-flags :

ios_base::goodbit       #Représente l'absence d'erreur (en général 0, il s'agit
                        #donc en fait d'une absence de flags)
ios_base::eofbit        #Le fichier a atteint EOF. (il faut donc faire un 
                        #clear() pour utiliser le fichier à nouveau)
ios_base::failbit       #Le fichier a une erreur interne. Peut par exemple être
                        #provoqué par une erreur avec seekg(), get(), getline(),
                        #ignore(), peek(), read(), clear(), setstate(), << et
                        #>>, etc.
ios_base::badbit        #Le fichier a une erreur externe.

ios_base::failure       #Classe, enfant d'exception, signalant une erreur d'I/O
FAILURE(STRING_TYPE)    #Instantie une FAILURE, avec le message STRING_TYPE
                        #utilisé par le membre hérité what()

IOS_BASE.               #Fait qu'en cas d'appel EVENT_VAL pour IOS_BASE, 
register_callback       #*EVENT_CALLBACK est invoqué avec comme EVENT_VAL 
(EVENT_CALBACK, INT_VAL)#l'événement concerné, comme IOS_BASE l'IOS_BASE 
                        #courante, et comme INT_VAL INT_VAL.

ios_base::event         #Enum utilisé par register_callback() et pouvant
                        #prendre trois valeurs :
                        #  - copyfmt_event : indique qu'IOS_BASE est utilisé
                        #    comme argument de copyfmt() ou invoque
                        #    copyfmt()
                        #  - erase_event : indique qu'IOS_BASE est détruit
                        #  - imbue_event : indique qu'IOS_BASE invoque imbue()
ios_base::event_callback#Type de VOID_FONC_ADR utilisé par register_callback(),
                        #prenant trois arguments : EVENT_VAL, IOS_BASE puis
                        #INT_VAL)

IOS_BASE.xalloc()       #Retourne un index INT_VAL à utiliser avec iword ou
                        #pword. Il désigne l'index d'une extensible static array
                        #à l'intérieur d'IOS_BASE pouvant être utilisée pour
                        #stocker des données temporaires. L'index retourné n'est
                        #plus reliable après une nouvelle opération sur IOS_BASE
                        #Il y en fait deux indexs : l'une stocke des LONG_VAL,
                        #l'autre des VOID_ADR
IOS_BASE.iword(INT_VAL) #Retourne une référence à l'élément LONG_VAL à l'index 
                        #INT_VAL (qui doit provenir de xalloc()) de l'internal
                        #array.
IOS_BASE.pword(INT_VAL) #Retourne une référence à un VOID_ADR à l'index INT_VAL
                        #(qui doit provenir de xalloc()) de l'internal array.
                        #Ce dernier ne peut être utilisé comme lvalue que non-
                        #déréférencé

ios_base::              #Si BOOL_VAL (par défaut true) est true, s'assure que
sync_with_stdio         #les opérations sur les flux standards de cstdio 
([BOOL_VAL])            #(stdin, etc. ) ne sont pas entremêlés avec cin, etc., 
                        #et sont opérés selon l'ordre du code.

ios                     #Classe de stream dont les éléments sont des CHAR_VAL, 
                        #associée à un STREAMBUF.

IOS(STREAMBUF_ADR)      #Instantie un IOS associé à STREAMBUF. Il s'agit d'un
                        #explicit constructor. Le copy constructor est
                        #indisponible.

IOS.rdbuf()             #Renvoie le FILEBUF associé à IOS, sous forme de 
                        #FILEBUF_ADR.

IOS.rdbuf(FILEBUF_ADR)  #Fait qu'IOS devient associé à FILEBUF, puis appelle
                        #clear(). Renvoie l'ancien FILEBUF associé à IOS, sous
                        #forme de FILEBUF_ADR.
                        #Permet donc une redirection des flux standards si IOS
                        #est un flux standard

IOS.rdstate()           #Renvoie l'état des ios-error-flags d'IOS, sous forme
                        #d'IOSTATE_VAL

IOS.clear([IOSTATE_VAL])#Fait que l'état des ios-error-flags d'IOS devient
                        #IOSTATE_VAL (par défaut ios_base::goodbit).
IOS.setstate(IOSTAT_VAL)#Rajoute les flags spécifiés par IOSTATE_VAL à IOS, sauf
                        #s'il les possède déjà.

IOS.good()              #Renvoie true si ni goodbit, ni eofbit, ni failbit n'est
                        #activé.
IOS.eof()               #Renvoie true si l'eofbit d'IOS est activé.
IOS.bad()               #Renvoie true si le badbit d'IOS est activé.
IOS.fail()              #Renvoie true si le failbit d'IOS est activé.
( ! IOS )               #Renvoie true si le badbit ou failbit d'IOS est activé.
( IOS )                 #Test vrai si ni le badbit ni le failbit d'IOS n'est
                        #activé.
*IOS                    #Renvoie NULL si le badbit ou failbit d'IOS est activé,
                        #non-NULL sinon. N'utiliser que pour les questions
                        #d'ios-errors-flags.

IOS.exceptions          #Fait qu'IOSTAT_VAL devient l'exception mask d'IOS.
(IOSTATE_VAL)           #Un exception mask est la liste des ios-error-flags qui
                        #lancent une exception ios_base::failure s'ils sont
                        #activés (sauf pour goodbit, qui ne fait rien).
                        #Par défaut, l'exception mask == goodbit.

IOS.copyfmt(IOS2)       #Copie tous les membres d'IOS2 vers IOS, sauf le
                        #STREAMBUF pointer et les ios-errors-flags. Inclut
                        #donc notamment :
                        #  - les fmtflags
                        #  - le fill character, la precision, la width
                        #  - le tie pointer
                        #  - l'exception mask
                        #Il s'agit d'une deep copy. Renvoie IOS.

IOS.fill()              #Renvoie le fill character (par défaut ' ')

IOS.fill(CHAR_TYPE_VAL) #Le fill character devient CHAR_TYPE_VAL, et l'ancien 
                        #fill character est renvoyé.

IOS.tie()               #Renvoie l'OSTREAM dont est tied IOS, sous forme 
                        #d'OSTREAM_ADR, ou NULL si IOS n'est tied à aucun 
                        #OSTREAM.
                        #Le fait qu'un IOS soit tied à OSTREAM fait qu'à chaque
                        #opération sur IOS, les buffers de OSTREAM sont flushed.
                        #Par défaut cin, cerr et clog sont tied à cout.

IOS.tie(OSTREAM_ADR)    #Fait que IOS est tied à OSTREAM, et renvoie OSTREAM_ADR

IOS.imbue(LOCALE)       #Si associé à un STREAMBUF, effectue STREMBUF.imbue(...)
                        #sinon, effectue IOS_BASE.imbue(...)

IOS.narrow(CHAR_TYPE1,  #Renvoie l'équivalent de CHAR_TYPE1 selon la LOCALE 
CHAR_VAL2)              #courante, sous forme de CHAR_VAL, ou CHAR_VAL2 si pas
                        #d'équivalents.
IOS.widen(CHAR_VAL)     #Renvoie CHAR_VAL sous forme de CHAR_TYPE, selon la 
                        #LOCALE courante.

                                  ┌──────────────────────────┐
                                  │   ISTREAMS ET OSTREAMS   │
                                  └──────────────────────────┘

HEADER ==>              #<istream>

istream                 #Classe d'input stream : il s'agit d'un enfant d'ios.

ISTREAM(STREAMBUF_ADR)  #Instantie un ISTREAM, en l'associant à STREAMBUF.

HEADER ==>              #<iterator, istream>

istream_iterator <WVAR  #Classe d'INPUT_ITERATOR lié à un BASIC_ISTREAM.
[, WVAR2[, WVAR3        #WVAR est le type de caractère renvoyé par *ISTREAM_ITVR
[, WVAR4]]]>            #(en général le même que WVAR2).
                        #WVAR2 et WVAR3 sont les deux arguments passés au
                        #template de BASIC_ISTREAM (par défaut char et 
                        #char_traits <WVAR2>). Faire wchar_t en WVAR2 pour un
                        #WISTREAM.
                        #WVAR4 est la distance entre deux itérateurs, par
                        #défaut ptrdiff_t.

ISTREAM_ITVR()          #Renvoie un INPUT_ISTREAM_ITVR, pouvant être utilisé
                        #comme un EOF (comme un *.end()) pour tout ISTREAM_ITVR.
ISTREAM_ITVR(ISTREAM)   #Renvoie un INSERT_ISTREAM_ITVR, placé sur le premier
                        #caractère d'ISTREAM.
                        #Si ISTREAM a le fmtflag skipws, ISTREAM_ITVR++ skippera
                        #les whitespaces : si ce n'est pas désiré (majorité des
                        #cas), faire un ISTREAM >> noskipws avant.
                        #*ISTREAM_ITVR effectue une lecture d'ISTREAM comme >> :
                        #s'il a été instantié avec int pour WVAR par exemple,
                        #il cherche à lire un INT_VAL et non un CHAR_TYPE_VAL.
                        #Cependant, ++ avance toujours d'un seul caractère.

HEADER ==>              #<istream>

ISTREAM >> VAR          #L'opérateur >> lit le prochain mot de ISTREAM. Les
                        #"mots" sont délimités par whitespace. Les leading 
                        #whitespaces sont lus mais ignorés. Ne lit pas le
                        #whitespace délimiteur.
                        #Le mot est ensuite interprété en fonction du type de
                        #VAR, il peut donc être lu :
                        #  - comme un TOUINT_VAL, dont bool
                        #  - comme un TOUFLOAT_VAL
                        #  - comme un CHAR_TYPE_VAL
                        #  - comme un [W]STR ou une STRING_TYPE
                        #  - comme un TOUINT_VAL hexadécimal, si VAR est un 
                        #    VOID_ADR
                        #  - comme un BITSET (le mot doit être composé 
                        #    seulement de 1 et de 0)
                        #Si le mot ne peut pas être interprété (ne suit pas le
                        #format, seulement possible pour les nombres, les bools
                        #et les bitsets), ou s'il s'agit d'EOF, une valeur par 
                        #défaut est enregistrée dans VAR (0 pour les nombres, et
                        #1 ou 0 pour bool, '\0' pour char et NULL pour [W]STR),
                        #et le failbit est set, ou l'eofbit s'il s'agit d'EOF. 
                        #De plus ISTREAM n'est au final pas lu (son buffer n'est 
                        #pas vidé).
                        #Renvoie ISTREAM, sauf si EOF, auquel cas renvoie NULL.
                        #Ainsi, puisque si le failbit est set, ( ISTREAM ) 
                        #renvoie false, si l'on veut faire un nouvel essai
                        #après un >> ayant échoué (par exemple jusqu'à ce que
                        #l'utilisateur entre quelque chose de correct), il faut 
                        #à chaque boucle supprimer le failbit, et aussi lire les
                        #précédentes données, par exemple pour std::cin :
                        #  - while ( ! ( std::cin >> a ) )
                        #    {
                        #       std::cin.clear();
                        #       std::cin.ignore(std::numeric_limits
                        #       <std::streamsize>::max(), '\n');
                        #    }
ISTREAM >> STREAMBUF    #Lit ISTREAM jusqu'à EOF, et écrit cela dans STREAMBUF.
                        #Même chose pour le failbit et l'eofbit.
ISTREAM >> FONC_ADR     #FONC_ADR est un MANIPULATOR. Fait que ce MANIPULATOR
                        #est invoqué avec ISTREAM comme argument. Ce dernier
                        #doit faire partie de ceux autorisés pour l'écriture.

ISTREAM.peek()          #Renvoie la valeur du caractère pointé par le current
                        #get pointer, sous forme d'INT_VAL, sans pour autant
                        #déplacer ce dernier.
                        #Si ce caractère est EOF, l'eofbit est set.

ISTREAM.get()           #Lit un caractère et le renvoie sous forme de INT_VAL,
                        #dont peut-être EOF.
ISTREM.get(CHAR_TYP_VAR)#Lit un caractère et l'enregistre dans CHAR_TYPE_VAR.
                        #Renvoie ISTREAM, ou NULL si EOF a été atteint.
ISTREAM.get([W]STR,     #Lit ISTREAM jusqu'à ce que :
STREAMSIZE_VAL          #  - STREAMSIZE_VAL - 1 caractères soient lus. Si 
[, CHAR_TYPE_VAL])      #    STREAMSIZE_VAL == 1, le failbit est set.
                        #  - CHAR_TYPE_VAL soit rencontré. Il n'est alors pas
                        #    lu. Un appel successif tel quel du même get() 
                        #    buttera donc sur le même CHAR_VAL
                        #  - EOF soit rencontré, auquel cas l'eofbit est set.
                        #Et écrit dans [W]STR les caractères lus, en rajoutant un
                        #'\0' final.
                        #CHAR_TYPE_VAL est par défaut newline.
                        #Renvoie ISTREAM, ou NULL si EOF a été attein. En cas 
                        #d'erreur, le failbit est set.
ISTREAM.get(STREAMBUF   #Comme le get() précédent, sauf que :
[, CHAR_TYPE_VAL])      #  - n'enregistre pas dans un [W]STR mais un STREAMBUF 
                        #    (qui n'est pas tronqué, mais écrit (sans insertion))
                        #  - seul le délimiteur CHAR_TYPE_VAL ou EOF permet 
                        #    d'arrêter la lecture.
ISTREAM.getline([W]STR  #Comme get avec ces arguments, sauf que si CHAR_VAL a
STREAMSIZE_VAL          #été rencontré, le current get pointer est ensuite 
[, CHAR_TYPE_VAL])      #avancé d'un caractère via ignore() pour pointer le 
                        #caractère qui suit CHAR_TYPE_VAL.

HEADER ==>              #<string>
getline(ISTREAM,        #Comme le précédent getline() sauf que :
STRING_TYPE,            #  - il s'agit d'une global fonction
[, CHAR_TYPE_VAL])      #  - une STRING_TYPE est utilisée
                        #  - aucun STREAMSIZE_VAL n'est utilisé (seul EOF ou
                        #    CHAR_TYPE_VAL stoppe la ligne)

ISTREAM.read([W]STR,    #Lit ISTREAM jusqu'à ce que STREAMSIZE_VAL caractères
STREAMSIZE_VAL)         #soient lus ou qu'OEF soit atteint, et écrit le résultat
                        #dans [W]STR (sans rajouter de '\0' final).
                        #Si EOF est atteint, eofbit et failbit sont set.
                        #Return ISTREAM
ISTREAM.readsome([W]STR,#Comme read(), sauf que :
STREAMSIZE_VAL)         #  - s'arrête quand le buffer associé à ISTREAM est vide
                        #    (par exemple pour une named pipe)
                        #  - renvoie le nombre de caractères lus.
ISTREAM.ignore          #Lit STREAMSIZE_VAL (par défaut 1) caractères d'ISTREAM
([STREAMSIZE_VAL        #à moins qu'INT_VAL (par défaut EOF) soit lu, auquel
[, INT_VAL]])           #cas la lecture s'arrête (le current get pointer 
                        #pointant alors le caractère suivant INT_VAL).
                        #Si EOF est lu, l'eofbit est set.
ISTREAM.unget()         #Equivaut à ISTREAM.rdbuf()->sungetc(), mais renvoie
                        #ISTREAM.
ISTREAM.putback         #Equivaut à ISTREAM.rdbuf()->sputbackc(CHAR_TYPE_VAL),
(CHAR_TYPE_VAL)         #mais renvoie ISTREAM.

ISTREAM.tellg()         #Renvoie un STREAMPOS_VAL indiquant la position du
                        #current get pointer, ou -1 si erreur.

ISTREAM.seekg           #Place le current get pointer à la position absolue
(STREAMPOS_VAL)         #STREAMPOS_VAL. Si la position est out of range, le
                        #failbit est set.
ISTREAM.seekg           
(STREAMOFF_VAL,         #Place le current get pointer à la position SEEKDIR_VAL
SEEKDIR_VAL)            # + STREAMOFF_VAL. Même chose pour le failbit.

ISTREAM.gcount()        #Renvoie le nombre de caractères lus par la dernière
                        #opération de lecture, parmi : get, getline, ignore, 
                        #read, readsome, peek, putback et unget (ces trois
                        #dernières renvoyant toujours 0), sous forme de
                        #STREAMSIZE_VAL.

ISTREAM.sync()          #Flushe les input buffers. Renvoie 0 si succès, -1 
                        #sinon (dont si ISTREAM est unbuffered

HEADER ==>              #<ostream>

ostream                 #Classe d'output stream : il s'agit d'un enfant d'ios.

OSTREAM(STREAMBUF_ADR)  #Instantie un OSTREAM associé à STREAMBUF

HEADER ==>              #<iterator, ostream>

ostream_iterator <WVAR  #
[, WVAR2[, WVAR3        #Classe d'OUTPUT_ITERATOR lié à un BASIC_OSTREAM.
[, WVAR4]]]>            #Les paramètres sont les mêmes qu'istream_iterator

OSTREAM_ITVR(OSTREAM    #Renvoie un OUTPUT_OSTREAM_ITVR, placé sur le premier
[, [W]STR]              #caractère d'OSTREAM. Le copy constructor et le copy
                        #operator sont disponibles, mais pas le constructor par
                        #défaut. [W]STR est le délimiteur (par défaut null 
                        #string).
*OSTREAM_ITVR = WVAL    #Ecrit WVAL suivi du délimiteur, et avance l'itérateur. 
OSTREAM_ITVR = WVAL     #Les deux sont synonymes. C'est la seule opération 
                        #disponible.
OSTREAM_ITVR++
++OSTREAM_ITVR          #Ne fait rien.

HEADER ==>              #<ostream>

OSTREAM << VAL          #Ecrit VAL dans OSTREAM. VAL peut être un NOMBRE, un
                        #CHAR_TYPE_VAL, une [W]STR ou une STRING_TYPE
OSTREAM << BITSET       #Ecrit BITSET de manière binaire, avec les leading zeros
OSTREAM << STREAMBUF_ADR#Lit STREAMBUF jusqu'à son EOF, et écrit cela dans
                        #OSTREAM. Le failbit est set si problème.
OSTREAM << FONC_ADR     #FONC_ADR est un MANIPULATOR. Fait que ce MANIPULATOR
                        #est invoqué avec OSTREAM comme argument. Le MANIPULATOR
                        #doit faire partie de ceux autorisés pour l'écriture.
EXTENSION DE << ==>     #Pour étendre << à sa propre classe, comme il est
                        #impossible de rajouter un operator :
                        #  - std::ostream& std::ostream::operator<<(MaClasse&)
                        #On peut cependant utiliser le << global :
                        #  - std::ostream& operator<<(std::ostream&, MaClasse&)
                        #Il faut alors que le << global soit friend de MaClasse.
                        #Même chose pour >>.

OSTREM.put(CHAR_TYP_VAL)#Ecrit CHAR_TYPE_VAL sur OSTREAM.
OSTREAM.write([W]STR,   #Ecrit les STREAMSIZE_VAL premiers octets de [W]STR sur
STREAMSIZE_VAL)         #OSTREAM, ou [W]STR entier si STREAMSIZE_VAL > taille de
                        #[W]STR. Renvoie OSTREAM.

OSTREAM.tellp()         #Comme tellg(), mais pour le put pointer.

OSTREAM.seekp           #
(STREAMPOS_VAL)         
OSTREAM.seekp           
(STREAMOFF_VAL,         
SEEKDIR_VAL)            #Comme seekg(), mais pour le put pointer.

OSTREAM.flush()         #Flushe les output buffers. Renvoie OSTREAM

HEADER ==>              #<ostream>

iostream                #Classe d'input/output stream : il s'agit d'un enfant
                        #d'istream et d'ostream. Permet donc à la fois 
                        #l'écriture et la lecture (et les méthodes associées à
                        #cela)

IOSTREAM(STREAMBUF_ADR) #Instantie un IOSTREAM associé à STREAMBUF

                                  ┌────────────────────┐
                                  │   FLUX STANDARDS   │
                                  └────────────────────┘

HEADER ==>              #<iostream>

cin                     #Instantiation d'ISTREAM, créée automatiquement et liée
                        #à l'entrée standard.
cout                    #Instantiation d'OSTREAM, créée automatiquement et liée
                        #à la sortie standard
cerr                    #Instantiation d'OSTREAM, créée automatiquement et liée
                        #à l'erreur standard, unbuffered
clog                    #Instantiation d'OSTREAM, créée automatiquement et liée
                        #à l'erreur standard, buffered, donc plus efficient, 
                        #mais moins reliable

                                  ┌──────────────────┐
                                  │   FILE STREAMS   │
                                  └──────────────────┘

HEADER ==>              #<fstream>

ifstream                #Classe d'input file stream : il s'agit d'un enfant
                        #d'istream, qui permet quelques méthodes pour ouvrir et
                        #fermer un fichier plus simplement (c'est-à-dire 
                        #associer un FILEBUF à l'istream).
                        #Tout IFSTREAM est associé à un FILEBUF.

IFSTREAM()              #Instantie un IFSTREAM, associé à aucun fichier.
IFSTRM([W]STR[, OPNMOD])#Equivaut à IFSTREAM() suivi de IFSTREAM.open([W]STR
                        #[, OPENMODE])

IFSTREAM.open([W]STR    #Equivaut à IFSTREAM.rdbuf->open(), sauf que si le 
[, OPENMODE])           #fichier n'a pas pu être ouvert, le failbit d'IFSTREAM 
                        #est set, et qu'OPENMODE est ios_base::in par défaut.
IFSTREAM.close()        #Equivaut à IFSTREAM.rdbuf->close(), sauf qu'en cas
                        #d'échec (notamment si aucun fichier n'était associé),
                        #le failbit d'IFSTREAM est set.

IFSTREAM.is_open()      #Equivaut à IFSTREAM.rdbuf->is_open()

ofstream                #Classe d'output file stream : similaire à ifstream,
                        #sauf que :
                        #  - il s'agit d'un enfant de ostream, et non istream
                        #  - l'argument par défaut d'open() est ios_base::out

fstream                 #Classe d'input/output file stream : similaire à 
                        #ifstream, sauf que :
                        #  - il s'agit d'un enfant de ostream et d'istream à la
                        #    fois.
                        #  - l'argument par défaut d'open() est ios_base::out |
                        #    ios_base::in

                                  ┌────────────────────┐
                                  │   STRING STREAMS   │
                                  └────────────────────┘

HEADER ==>              #<sstream>

istringstream           #Classe d'input string stream : il s'agit d'un enfant
                        #d'istream, permettant d'ouvrir et de fermer un
                        #stringbuf plus facilement. Tout ISTRINGSTREAM est
                        #associé à un STRINGBUF.
                        #L'utilisation des STRINGBUF permet donc de manipuler
                        #une string avec les méthodes dévouées aux fichiers en
                        #théorie.

ISTRINGSTRM([STRING_TYP,#Instantie une ISTRINGSTREAM vide selon le mode 
[OPENMODE]])            #OPENMODE (par défaut ios_base::in) puis invoque
                        #ISTRINGSTREAM.str(STRING_TYPE) (par défaut une 
                        #STRING_TYPE vide)

ISTRINGSTREAM.rdbuf()   #Renvoie le STRINGBUF associé à ISTRINGSTREAM sous forme
                        #de STRINGBUF_ADR.
ISTRINGSTREAM.str()     #Equivaut à ISTRINGSTREAM.rdbuf->str()

ISTRINGSTREAM.str       #Equivaut à ISTRINGSTREAM.rdbuf->str(STRING_TYPE)
(STRING_TYPE)

ostringstream           #Classe d'output string stream : similaire à
                        #istringstream, sauf que :
                        #  - il s'agit d'un enfant de ostream, et non istream
                        #  - l'OPENMODE par défaut est ios_base::out

stringstream            #Classe d'input/output string stream : similaire à 
                        #istringstream, sauf que :
                        #  - il s'agit d'un enfant de ostream et d'istream à la
                        #    fois.
                        #  - l'OPENMODE par défaut est ios_base::out | 
                        #    ios_base::in

                                  ┌────────────────┐
                                  │   STREAMBUFS   │
                                  └────────────────┘

HEADER ==>              #<streambuf>

streambuf               #Virtual base classe pour les buffers.
                        #Un buffer est suite d'éléments en mémoire, associée à
                        #un autre élément général (un fichier, une string, etc.)
                        #servant de tampon.
                        #Cette base classe définie des fonctions communes pour
                        #le buffer, quel que soit le support (fichier, etc.)
                        #utilisé par la classe enfant, de sorte que les classes
                        #enfants agissent de manière similaire bien qu'ayant des
                        #supports différents.

HEADER ==>              #<iterator, streambuf>

istreambuf_iterator     #Classe d'ITERATOR lié à un BASIC_STREAMBUF accessible
<WVAR[, WVAR2]>         #en lecture, renvoyant un INPUT_ITVR lors de sa 
                        #construction.
                        #WVAR et WVAR2 sont les éléments du template du
                        #BASIC_STREAMBUF : WVAR est char ou wchar_t donc pour
                        #un STREAMBUF ou WSTREAMBUF, et WVAR2 est par défaut
                        #char_traits<WVAR>.
                        #Mis à part le template, les seules différences avec
                        #istream_iterator sont :
                        #  - le constructor peut être instantié avec des
                        #    STREAMBUF (ou enfants) (mais peut aussi l'être 
                        #    avec un ISTREAM)
                        #  - le copy constructor ne prend bien sûr comme
                        #    argument que d'autres ISTREAMBUF_ITVR

ostreambuf_iterator     #Classe d'ITERATOR lié à un BASIC_STREAMBUF accessible
<WVAR[, WVAR2]>         #en écriture, renvoyant un OUTPUT_ITVR lors de sa 
                        #construction.
                        #Les paramètres sont similaires à istreambuf_iterator.
                        #Par rapport à ostream_iterator, les seules différences
                        #sont les mêmes qu'entre istreambuf_iterator et
                        #istream_iterator, plus :
                        #  - Le délimiteur lors du constructor est indisponible
                        #  - un membre OSTREAMBUF_ITVR.failed() renvoie true si
                        #    l'une des opérations d'écriture a échoué

HEADER ==>              #<streambuf>

STREAMBUF.pubsetbuf     #Fait que le buffer de STREAMBUF devient [W]STR, de 
([W]STR, STREAMSIZE_VAL)#taille STREAMSIZE_VAL. Si [W]STR == NULL et 
                        #STREAMSIZE_VAL == 0, STREAMBUF devient unbuffered.
                        

STREAMBUF.sbumpc()      #Lit un caractère (le current get pointer est déplacé
                        #après avoir lu le caractère), ou EOF s'il se trouve à
                        #l'endroit de l'ending get pointer.
STREAMBUF.snextc()      #Lit un caractère (le current get pointer est déplacé
                        #avant d'avoir lu le caractère), ou EOF s'il se trouve
                        #sur le dernier élément.

STREAMBUF.sgetc()       #Renvoie le caractère pointé par le current get pointer,
                        #sous forme d'INT_VAL, ou EOF s'il se trouve à l'endroit
                        #de l'ending get pointer.
                        #Ne déplace pas le current get pointer.
STREAMBUF.sgetn([W]STR, #Lit STREAMSIZE_VAL caractères, ou moins si EOF est
STREAMSIZE_VAL)         #rencontré, et place ces derniers dans [W]STR.
                        #Renvoie le nombre de caractères lus, sous forme de
                        #STREAMSIZE_VAL.

STREAMBUF.sputc         #Ecrit CHAR_TYPE_VAL.
(CHAR_TYPE_VAL)         #Renvoie CHAR_TYPE_VAL, ou EOF si erreur.
STREAMBUF.sputn([W]STR, #Ecrit les STREAMSIZE_VAL premiers caractères à partir 
STREAMSIZE_VAL)         #de [W]STR. Si la taille de [W]STR < STREAMSIZE_VAL, il 
                        #y aura un buffer overflow.
                        #Renvoie le nombre de caractères écrits.

STREAMBUF.sungetc()     #Si le current get pointer n'est pas à l'endroit du
                        #beginning get pointer, le recule d'un caractère et
                        #renvoie le nouveau caractère pointé.
                        #Le caractère précédent doit avoir été juste lu, sinon
                        #la méthode n'a pas d'effet et renvoie 0.
                        #Si le current get pointer est à l'endroit du beginning
                        #get pointer, cela renvoie EOF.
STREAMBUF.sputbackc     #Comme sungetc(), sauf que si CHAR_TYPE_VAL != dernier
(CHAR_TYPE_VAL)         #caractère lu (étant aussi le nouveau caractère pointé),
                        #alors CHAR_TYPE_VAL sera lu à la place de ce caractère 
                        #lors de la prochaine lecture.
                        #Cependant, si un nouvel appel à sputbackc() a lieu et
                        #que CHAR_TYPE_VAL diffère à nouveau, cet effet n'a plus
                        #lieu et -1 est renvoyé.
                        #Dans aucun cas, cela écrit en fait quoi que ce soit
                        #(seul l'input buffer est affecté)

STREAMBUF.pubseekoff    #Le get et/ou put pointer est déplacé à la position
(STREAMOFF_VAL,         #SEEKDIR_VAL + STREAMOFF_VAL.
SEEKDIR_VAL[, OPENMODE])#Le get pointer est concerné si OPENMODE contient 
                        #ios_base::in, et le put pointer avec ios_base::out.
                        #OPENMODE contient par défaut les deux
                        #Renvoie la nouvelle position du/des pointer sous forme
                        #de STREAMPOS_VAL.
STREAMBUF.pubseekpos    #
(STREAMPOS_VAL,         #Comme pubseekoff(), sauf que la nouvelle position n'est
[, OPENMODE])           #pas SEEKDIR_VAL + STREAMOFF_VAL, mais STREAMPOS_VAL.

STREAMBUF.pubsync()     #Flushe les buffers, et renvoie 0 si succès, -1 sinon.

STREAMBUF.in_avail()    #Renvoie le nombre de caractères compris entre le 
                        #current get pointer et le ending get pointer.
                        #Si le current get pointeur se trouve là où est le
                        #ending get pointer par ailleurs, les caractères non
                        #encore flushés (s'il y en a) sont ajoutés au 0 
                        #normalement renvoyé.

STREAMBUF.getloc()      #Renvoie la LOCALE associée à STREAMBUF

STREMBF.pubimbue(LOCALE)#LOCALE devient la locale de STREAMBUF. A une précédence
                        #sur la LOCALE imbued à IOS_BASE

GET ET PUT POINTERS ==> #Les get et put pointers sont les file position 
                        #indicators pour la lecture et l'écriture. Il y a pour
                        #chacun des deux, trois sortes :
                        #  - le current, celui en court
                        #  - le beginning, marquant le premier élément du stream
                        #  - le ending, marquant l'élément suivant le dernier 
                        #    élément du stream, comme un EOF
                        #Les get et put pointers sont en fait toujours 
                        #synchronisés, sauf en mode append.

STREAMBUF PROTECTED     #Les méthodes disponibles publiquement dans streambuf 
METHODS ==>             #sont fondées sur des méthodes protected. Ce sont ces
                        #méthodes protected qui sont redéfinies par les classes
                        #dérivées, et non les classes publiques directement.
                        #Dans la base classe streambuf, ces méthodes sont 
                        #parfois déjà définies, parfois non.
                        #Dans tous les cas, elles sont redéfinies par les
                        #classes enfants, de sorte que les public methods ont un
                        #effet similaire quelque soit la classe enfant.
                        #Voici une liste (qu'importe ces méthodes par ailleurs :
                        #elles sont protected) : underflow(), uflow(), 
                        #pbackfail(), overflow(), setbuf(), seekoff(), 
                        #seekpos(), sync(), imbue(), xsgetn(), xsputn(), 
                        #showmanyc(), gptr(), pptr(), eback(), pbase(), 
                        #egptr(), epptr(), gbump(), pbump(), setg(), setp().

HEADER ==>              #<fstream>

filebuf                 #Classe enfant de streambuf, associé à un fichier.

FILEBUF()               #Instantie un FILEBUF, associé à aucun fichier.

FILEBUF.open([W]STR     #Associe FILEBUF avec le fichier dont le chemin est 
, OPENMODE)             #[W]STR, avec les modes d'accès OPENMODE, à moins que 
                        #FILEBUF ait déjà un fichier associé.
                        #Renvoie FILEBUF_ADR si succès, NULL sinon.
FILEBUF.close()         #Fait que FILEBUF, qui doit être associé à un fichier, 
                        #n'est plus associé à lui.
                        #L'ouput buffer est flushed.
                        #Renvoie FILEBUF_ADR si succès, NULL sinon (dont si 
                        #aucun fichier n'était associé).

FILEBUF.is_open()       #Renvoie true si un fichier est associé à FILEBUF.

HEADER ==>              #<sstream>

stringbuf               #Classe enfant de streambuf, associé à une string.

STRINGBUF([STRING_TYPE, #Instantie une STRINGBUF, associé à STRING_TYPE (par
[OPENMODE]])            #défaut vide), selon OPENMODE.

STRINGBUF.str()         #Renvoie la [W]STR associée à STRINGBUF.

STRINGBUF.str(STRNG_TYP)#STRING_TYPE devient associée à STRINGBUF, et le get et
                        #put pointers sont placés au début, et l'ancienne 
                        #STRING_TYPE est renvoyée.

                                  ┌─────────────────────┐
                                  │   WIDE CHARACTERS   │
                                  └─────────────────────┘

BASIC_ I/O ==>          #Chaque classe principale a en fait une version précédée
                        #du suffixe basic_ (sauf ios_base, et les flux standards
                        #qui ne sont pas des classes mais des objets) :
                        #  - basic_ios, basic_ifstream, basic_filebuf, etc.
                        #Ces classes prennent un template <WVAR[, WVAR2]>
                        #WVAR est le type des caractères du stream. WVAR2 sont
                        #les traits de WVAR, par défaut char_traits <WVAR>.
                        #Toutes les classes présentées ci-dessus sont en fait
                        #des spécialisations d'une classe basic_* avec le
                        #template <char>. Il existe une seconde spécialisation,
                        #avec le template <wchar_t>
                        #  - CHAR_TYPE signifie WVAR
                        #  - [W]STR CHAR_TYPE*
                        #  - STRING_TYPE basic_string<WVAR, WVAR2>

WIDE CHARACTERS I/O ==> #Toutes les classes précédentes existent pour les
                        #wde characters. Il s'agit en fait de spécialisations
                        #des classes basic_*, avec le template <wchar_t>.
                        #Les headers sont les mêmes, les noms des membres aussi.
                        #Seules différences :
                        #  - un 'w' est ajouté devant le nom des principales
                        #    classes : wistream, wostream, wiostream, 
                        #    wstreambuf, wifstream, wofstream, wfstream, 
                        #    wfilebuf, wstringstream, wistringstream, 
                        #    wostringstream ;
                        #    ainsi que pour wcin, wcout, wcerr et wclog.
                        #  - il faut utiliser des WSTRING et non des STRING, et
                        #    des WSTR et non des STR
