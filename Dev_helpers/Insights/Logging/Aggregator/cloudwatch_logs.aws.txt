
                   
   CLOUDWATCH_LOGS  
                   



TODO ==>
  - CloudTrail: see unfinished "CloudWatch logs" chapter
  - CloudWatch metrics:
     - embedded metrics: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Embedded_Metric_Format.html
     - best practices: https://docs.aws.amazon.com/securityhub/latest/userguide/cloudwatch-controls.html
  - CloudWatch dashboard:
     - DLOG
  - Lambda:
     - https://docs.aws.amazon.com/lambda/latest/dg/urls-monitoring.html
     - https://docs.aws.amazon.com/lambda/latest/dg/nodejs-logging.html
     - https://docs.aws.amazon.com/lambda/latest/dg/monitoring-cloudwatchlogs.html
     - ENVVAR AWS_LAMBDA_LOG_GROUP_NAME, AWS_LAMBDA_LOG_STREAM_NAME
     - Insights:
        - https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-metrics.html (second half of page)
        - https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-Troubleshooting.html
        - https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Lambda-Insights-example-event.html
     - https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html

Already read:
  - Analyzing log data with CloudWatch Logs Insights
  - Working with log groups and log streams
  - Creating metrics from log events using filters
  - Real-time processing of log data with subscriptions
  - Exporting log data to Amazon S3

GOAL ==>                      #Aggregates logs to single place, with rotation, and possibility to create CloudWatch alarms when log line match pattern

VERSION ==>                   #2023-07-17


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              API              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SERVICE_DOMAIN                #logs.amazonaws.com
                              #Can use HTTP[S]

FORMAT ==>                    #JSON
                              #Uses REQ.Action|Version

REQ_ID                        #x-amzn-RequestId [S]

PAGINATION ==>                #REQ.limit NUM (def|max: 50) + REQ|RES.nextToken except:
                              #  - def|max 1e4: StartQuery()
                              #  - def|max 1e4 or 1MB: GetLogEvents|FilterLogEvents()
                              #  - def|max 1e4 and use RES.nextBackwardToken|nextForwardToken: GetLogEvents()
                              #  - def|max 1e3 and use REQ.maxResults: DescribeQueries|QueryDefinitions()
                              #  - no pagination: DescribeAccountPolicies(), GetLogGroupFields(), TestMetricFilter()

THROTTLING ==>                #Max:
                              #  - 50 requests/sec: CreateLogStream()
                              #  - 5 requests/sec: DescribeLogStreams()

PRICING ==>                   #  - 0.5$/GB read
                              #  - 0.03$/GB stored
                              #  - GetLogEvents(): same price as out traffic on EC2

CloudWatchLogsFullAccess      #AWS managed POLICY allowing logs:*
CloudWatchLogsReadOnlyAccess  #Same but readonly


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             GROUP             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CreateLogGroup()              #Req:
                              #  - only logGroupName, kmsKeyId
                              #Res: empty
PutRetentionPolicy()          #Req:
                              #  - only logGroupName, retentionInDays
                              #Res: empty
DeleteRetentionPolicy()       #Req:
                              #  - only logGroupName
                              #Res: empty
DescribeLogGroups()           #Req LOG_GROUP_REQ
                              #Res: logGroups LOG_GROUP_ARR
                              #  - no tags
                              #  - only arn|logGroupName|creationTime if logGroupNamePattern used
DeleteLogGroup()              #Req:
                              #  - only logGroupName
                              #Res: empty

LOG_GROUP                     #Group of LOG_STREAMs
                              #Max 2e4
LOG_GROUP.arn                 #LOG_GROUP_ARN. arn:aws:logs:REGION:ACCOUNT_ID:log-group:LOG_GROUP
LOG_GROUP.logGroupName        #'LOG_GROUP'. Max 512 chars, [[:alnum:]_-/.#]
                              #Can include a NAMEPATH
LOG_GROUP_REQ
 .logGroupNamePrefix          #STR. Filter logGroupName that start with STR
LOG_GROUP_REQ
 .logGroupNamePattern         #STR. Filter logGroupName that include STR, case-insensitively
LOG_GROUP.creationTime        #DATE_NUM

LOG_GROUP.retentionInDays     #NUM (def: none) of days before deleting LLEVENTs, among:
                              #  - 1|3|5 days
                              #  - 1-2 weeks
                              #  - 1-6 months
                              #  - 1|1.5|2-10 years

LOG_GROUP.storedBytes         #Total NUM of bytes stored


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STREAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CreateLogStream()             #Req: LOG_STREAM
                              #  - only logStreamName, logGroupName
                              #Res: empty
DescribeLogStreams()          #Req: LOG_STREAM_REQ
                              #Res: LogStreams LOG_STREAM_ARR
                              #  - no logGroupName
DeleteLogStream()             #Req: LOG_STREAM
                              #  - only logStreamName, logGroupName
                              #Res: empty

LOG_STREAM                    #Series of LLEVENTs
                              #Deleted if empty for 2 months
LOG_STREAM.arn                #LOG_STREAM_ARN. arn:aws:logs:REGION:ACCOUNT_ID:log-group:LOG_GROUP:log-stream:LOG_STREAM
LOG_STREAM.logStreamName      #'LOG_STREAM'. Max 512 chars, no : or *
LOG_STREAM_REQ
 .logStreamNamePrefix         #STR
LOG_STREAM.creationTime       #DATE_NUM
LOG_STREAM.firstEventTimestamp#DATE_NUM of earliest LLEVENT
LOG_STREAM.lastIngestionTime  #DATE_NUM of latest LLEVENT starting processing
LOG_STREAM.lastEventTimestamp #DATE_NUM of latest LLEVENT finishing processing

LOG_STREAM[_REQ]
 |METRIC_FILTER.logGroupName  #'LOG_GROUP'
LOG_STREAM_REQ
 .logGroupIdentifier          #'LOG_GROUP'|LOG_GROUP_ARN

LOG_STREAM_REQ.orderBy        #'LogStreamName' (def) or 'LastEventTime'
LOG_STREAM_REQ.descending     #BOOL (def: false). Sorting order


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutLogEvents()                #Req: LLEVENTS
                              #  - no LLEVENT.ingestionTime
                              #Res: LLEVENTS_NEW
GetLogEvents()                #Req: LLEVENTS_REQ
                              #  - no filterPattern, logStreamNamePrefix
                              #Res: events LLEVENT_ARR
FilterLogEvents()             #Req: LLEVENTS_REQ
                              #  - logStreamName STR -> logStreamNames STR_ARR + logStreamNamePrefix STR
                              #  - no startFromHead
                              #Res: events LLEVENT_ARR, searchedLogStreams LLEVENTS_RES_ARR

LLEVENTS.logEvents            #LLEVENT_ARR
                              #Max 1e4. Max 1MB
LLEVENT                       #Log message
                              #Max 256KB

LLEVENT.message               #STR

LLEVENT.ingestionTime         #DATE_NUM of LLEVENT itelf
LLEVENT.timestamp             #DATE_NUM of event being logged
                              #Max 14 days before ingestionTime, and 2h after it
                              #LLEVENTS.logEvents is sorted by LLEVENT.timestamp
                              #  - in request, must be sorted, with a max 24h span
LLEVENTS_REQ.startTime|endTime#DATE_NUM. Filter by LLEVENT.timestamp
LLEVENTS_REQ.startFromHead    #BOOL (def: true). asc|desc sorting order.
                              #Always sorted by LLEVENT.timestamp

LLEVENTS_NEW
 .rejectedLogEventsInfo       #LLEVENTS_REJECT. LLEVENTs that failed
LLEVENTS_REJECT
 .tooOldLogEventEndIndex      #NUM of LLEVENTs with a timestamp >14d older than ingestionTime
LLEVENTS_REJECT
 .tooNewLogEventStartIndex    #NUM of LLEVENTs with a timestamp >2h newer than ingestionTime
LLEVENTS_REJECT
 .expiredLogEventEndIndex     #NUM of LLEVENTs beyond LOG_GROUP.retentionInDays

LLEVENTS[_REQ|RES]
 .logStreamName               #'LOG_STREAM'
LLEVENTS_RES
 .searchedCompletely          #BOOL. Whether all LLEVENTs in LOG_STREAM were searched

LLEVENTS[_REQ].logGroupName   #'LOG_GROUP'
LLEVENTS_REQ
 .logGroupIdentifier          #'LOG_GROUP'|LOG_GROUP_ARN

LLEVENTS_REQ.filterPattern    #'FILTER_PATTERN'

LIVE TAIL ==>                 #View LLEVENTs as they come
                              #Can filter by LOG_GROUPs|LOG_STREAMs|FILTER_PATTERNs
                              #Can highlight specific words
                              #Requires PACTION logs:Start|StopLiveTail


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        FILTER PATTERN         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FILTER_PATTERN                #Filter LLEVENTs by their message
                              #One of the following syntaxes
                              #Max 1KB

ANY MATCH ==>                 #
''                            #Matches anything

STRING MATCH ==>              #Does not create $FVARs
VAL                           #Can use wildcard *
                              #Case-sensitive
                              #Must "-quote non-[:alnum:]
VAL ...                       #Includes all of VALs
?VAL ...                      #Includes any of VALs
-VAL ...                      #Does not include VAL

JSON MATCH ==>                #Set each JSON field as $FVAR
{ $.VARR OP VAL }             #VARR: 1|many of .VAR, ['VAR'] or [NUM]
                              #VAL: STR, "STR" or NUM
                              #  - can include wildcard *
{ $.VARR = != VAL }           #
{ $.VARR > >= < <= NUM }      #
{ $.VARR is null|true|false } #Same as = "null|true|false"
{ $.VARR not exists }         #Is undefined
{ ... || ... }
{ ... && ... }
{ (...) }                     #

WHITESPACE-DELIMITED MATCH ==>#For example, *.tsv
                              #Fields can []-quote or "-quote whitespaces
[FVAR, ...]                   #Set each field as $FVAR
[FVAR OP VAL, ...]            #VAL can use wildcard *
                              #OP: = != > >= < <=
                              #Default OP VAL: = * (always match)
[FVAR [OP VAL] || ..., ...]
[FVAR [OP VAL] && ..., ...]   #
[..., ...]                    #FVAR can be named ... in any position
                              #This sets each field as $NUM FVAR (1-based)
[wNUM [OP VAL], ...]          #FVAR can be named wNUM to match field at position NUM
                              #Last wNUM cannot use OP VAL
                              #  - can workaround this by adding a dummy wNUM at end
[]                            #Same as [...]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          METRIC MAIN          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutMetricFilter()             #Req: METRIC_FILTER
                              #  - no creationTime
                              #Res: empty
DescribeMetricFilters()       #Req: METRIC_FILTER|METRIC_TRANSFORM
                              #  - only logGroupName, metricName, metricNamespace
                              #  - only filterName -> filterNamePrefix STR
                              #Res: metricFilters METRIC_FILTER_ARR
DeleteMetricFilter()          #Req: METRIC_FILTER
                              #  - only filterName, logGroupName
                              #Res: empty

METRIC_FILTER                 #Create CloudWatch METRIC_DATA from LLEVENTs
                              #Max 100 per LOG_GROUP
METRIC_FILTER.filterName      #'METRIC_FILTER'
METRIC_FILTER.creationTime    #DATE_NUM

METRIC_FILTER.filterPattern   #'FILTER_PATTERN'

METRIC_FILTER
 .metricTransformations       #METRIC_TRANSFORM_ARR. METRIC_DATA being created
METRIC_TRANSFORM.metricName   #'METRIC'. METRIC.MetricName
METRIC_TRANSFORM
 .metricNamespace             #'NAMESPACE'. METRIC.Namespace
METRIC_TRANSFORM.dimensions   #OBJ. METRIC.Dimensions
                              #Max 3 DVARs
                              #If >1000 different DVALs in an hour, METRIC_FILTER automatically disabled
                              #DVAL include $FVAR
METRIC_TRANSFORM.metricValue  #STR. METRIC_DATUM.Value
                              #Can include $FVAR
METRIC_TRANSFORM.defaultValue #STR. METRIC_DATUM.Value
                              #Emitted when METRIC_FILTER.filterPattern does not match
                              #Goals:
                              #  - knowing frequency when filterPattern matches or not
                              #  - prevent undefined PERIODs, i.e. with no METRIC_DATA
METRIC_TRANSFORM.unit         #STR. METRIC_DATUM.Unit

LOG_GROUP.metricFilterCount   #NUM of METRIC_FILTERs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          METRIC TEST          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TestMetricFilter()            #Req: TEST_FILTER_REQ
                              #Res: matches TEST_FILTER_RES_ARR

TEST_FILTER_REQ               #Try a METRIC_FILTER against test LLEVENTs
TEST_FILTER_REQ               #STR_ARR of test LLEVENT.message
 .logEventMessages            #Max 50
TEST_FILTER_REQ.filterPattern #'FILTER_PATTERN'

TEST_FILTER_RES.eventMessage  #STR. Value in logEventMessages
TEST_FILTER_RES.eventNumber   #NUM. Index in logEventMessages
TEST_FILTER_RES
 .extractedValues             #{ $FVAR: STR, ... } matched by FILTER_PATTERN


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          QUERY MAIN           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


StartQuery()                  #Req: QUERY
                              #  - logGroupIdentifiers -> logGroupIdentifiers + logGroupName[s] STR[_ARR]
                              #  - no queryId, createTime, status
                              #Res: QUERY
                              #  - only queryId
                              #Paginates QUERY_RESULTS.results for GetQueryResults()
DescribeQueries()             #Req: QUERY
                              #  - only logGroupIdentifiers -> logGroupName STR
                              #  - only status
                              #Res: queries QUERY_ARR
                              #  - logGroupIdentifiers -> logGroupName STR
                              #  - no startTime|endTime
StopQuery()                   #Req: QUERY
                              #  - only queryId
                              #Res: QUERY
                              #  - only status -> success BOOL
GetQueryResults()             #Req: QUERY
                              #  - only queryId
                              #Res: QUERY_RESULTS

QUERY                         #Advanced search|query for LLEVENTs
                              #Called "Logs Insights"
                              #60m timeout. Once complete, deleted after 7d
                              #Max 30 running at once
QUERY.queryId                 #QUERY_MID
QUERY.createTime              #DATE_NUM

QUERY.queryString             #'QUERY_STRING'

QUERY.logGroupIdentifiers     #'LOG_GROUP'|LOG_GROUP_ARN_ARR
                              #Max 50

QUERY.startTime|endTime       #DATE_NUM, filtering by LLEVENT.timestamp

QUERY_RESULTS.results         #QUERY_RESULT_ARR_ARR
                              #Each QUERY_RESULT_ARR is a LLEVENT
                              #Each QUERY_RESULT is a FIELD
QUERY_RESULT.field            #'FIELD'
QUERY_RESULT.value            #STR

QUERY[_RESULTS].status        #STR among:
                              #  - Scheduled
                              #  - Running
                              #  - Complete
                              #  - Failed, Cancelled, Timeout
                              #  - Unknown

QUERY_RESULTS.statistics      #QUERY_STATS
QUERY_STATS.recordsMatched    #NUM of LLEVENTs matched
QUERY_STATS.recordsScanned    #NUM of LLEVENTs read
QUERY_STATS.bytesScanned      #NUM of bytes read, from QUERY_STATS.recordsScanned


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       QUERY DEFINITION        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutQueryDefinition()          #Req: QUERYDEF
                              #  - no lastModified
                              #Res: QUERYDEF
                              #  - only queryDefinitionId
DescribeQueryDefinitions()    #Req: QUERYDEF
                              #  - only name -> queryDefinitionNamePrefix STR
                              #Res: queryDefinitions QUERYDEF_ARR
DeleteQueryDefinition()       #Req: QUERYDEF
                              #  - only queryDefinitionId
                              #Res: success BOOL

QUERYDEF                      #Saved 'QUERY_STRING'
                              #Must be either:
                              #  - manually retrieved, then run separately with StartQuery()
                              #  - used through UI console
QUERYDEF.queryDefinitionId    #QUERYDEF_MID
QUERYDEF.name                 #'QUERYDEF'
                              #Can include a NAMEPATH, shown as folders in UI console
QUERYDEF.lastModified         #DATE_NUM

QUERYDEF.queryString          #'QUERY_STRING'

QUERYDEF.logGroupNames        #'LOG_GROUP'_ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         QUERY FIELDS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GetLogGroupFields()           #Req: QUERY_FIELDS_REQ
                              #Res: logGroupFields QUERY_FIELD_ARR
GetLogRecord()                #Req: QUERY_RECORD_REQ
                              #Res: QUERY_RECORD_RES

QUERY_FIELDS_REQ              #Retrieves|parses names of all FIELDs of specific LLEVENTs
QUERY_FIELDS_REQ
 .logGroupIdentifier          #'LOG_GROUP'|LOG_GROUP_ARN
QUERY_FIELDS_REQ.logGroupName #'LOG_GROUP'
QUERY_FIELDS_REQ.time         #DATE_NUM. Filter for LLEVENTs 8m before|after DATE_NUM.
                              #If not specified, filter for LLEVENTs in last 15m

QUERY_FIELD.name              #'FIELD'
QUERY_FIELD.percent           #NUM of LLEVENTs with that FIELD not undefined

QUERY_RECORD_REQ              #Retrieves|parses names + values of all FIELDs of a single LLEVENT
QUERY_RECORD_REQ
 .logRecordPointer            #STR. LLEVENT's @ptr

QUERY_RECORD_RES.logRecord    #{ FIELD: STR, ... }


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         QUERY SYNTAX          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


QUERY_STRING                  #The syntax is the next chapters
                              #Keywords are case-insensitive
                              #Max 10KB

#COMMENT                      #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          QUERY FIELD          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FIELD                         #One of the following
`FIELD`                       #Quoting needed unless only [[:alnum:].@]

VARR                          #If LLEVENT.message 'OBJ|ARR_JSON', OBJ|ARR.VARR
                              #VARR: 1|many of .VAR, .NUM
                              #Max 200

@message                      #LLEVENT.message
@ingestionTime                #LLEVENT.ingestionTime
@timestamp                    #LLEVENT.timestamp
@log                          #'ACCOUNT_ID:LOG_GROUP'
@logStream                    #'LOG_STREAM'

@ptr                          #LLEVENT_MID. Always output in QUERY_RESULTs

SERVICE-SPECIFIC ==>          #A few SERVICEs define their own


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         QUERY COMMAND         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


COMMAND | ...                 #Pipe COMMANDs
fields|parse|sort|stats ...
 as FIELD,...                 #Alias, i.e. rename COMMAND's outputs

COMMAND                       #One of the following

fields FIELD_EXPR,...         #Output those FIELDs, in each LLEVENT
display FIELD,...             #Only keep those FIELDs, in each LLEVENT

parse FIELD "..."             #String matching, extracting each * as a FIELD2
parse FIELD /.../             #REGEXP matching, extracting each (?<FIELD2>...)

filter BOOL_EXPR              #Only keep LLEVENTs where BOOL_EXPR is true
sort FIELD asc|desc           #Sort by FIELD
limit NUM                     #Only keep first NUM LLEVENTs

dedup FIELD,...               #Ignore LLEVENTs with same FIELDs values as previous LLEVENTs
                              #"previous" is based on sort order
                              #Undefined values are not considered duplicates
                              #Must be either last COMMAND, or before `limit` as a last COMMAND

pattern STR_EXPR              #Automatically detect shared patterns. Produces FIELDs:
                              #  - @pattern STR: common substring, with * for variable parts
                              #     - can be used with parse COMMAND
                              #  - @sampleCount NUM: total of matching LLEVENTs
                              #  - @ratio NUM: percentage of matching LLEVENTs
                              #  - @severityLabel 'Error|Warning|Info|Debug': log severity


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       QUERY AGGREGATION       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


stats AFUNC(...),...          #COMMAND that groups by STR_EXPR and outputs FIELDs from aggregate AFUNCs
 by STR_EXPR,...              #UI shows results as charts:
                              #  - bar chart: always
                              #  - if group by bin(): line chart, stacked area chart, pie chart
                              #AFUNCs follow

count([*])->NUM               #NUM of LLEVENTs
count(FIELD)->NUM             #NUM of LLEVENTs where FIELD is not undefined
count_distinct(FIELD)->NUM    #Approximate NUM of LLEVENTs with unique FIELDs

avg(NUM_FIELD)->NUM           #
sum(NUM_FIELD)->NUM           #
stddev(NUM_FIELD)->NUM        #

min|max(FIELD)->VAL           #
pct(FIELD, NUM)->VAL          #Percentile value

sortsFirst|Last(FIELD)->VAL   #First|last value, in current sorting order
earliest|latest(FIELD)->VAL   #First|last value, in @timestamp sorting order


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       QUERY EXPRESSION        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPR                          #Can use the following

VAL = != VAL2                 #

ispresent(FIELD)->BOOL        #true unless undefined
coalesce(FIELD,...)->FIELD    #First FIELD not undefined

(...)                         #
BOOL and or BOOL2
not BOOL                      #
VAL [not] in ARR              #

NUM < <= > >= NUM2            #
greatest|least(NUM,...)->NUM  #

NUM + - * / ^ % NUM2          #
abs(NUM)->NUM                 #
ceil|floor(NUM)->NUM          #
log(NUM)->NUM                 #
sqrt(NUM)->NUM                #

STR like /REGEXP/             #BOOL. REGEXP match
STR =~ /REGEXP/               #Must use (?FLAGS), not /REGEXP/FLAGS
STR like STR2                 #BOOL. Has substring
strcontains(STR, STR2)->0|1   #Same as 0|1

strlen(STR)->NUM              #Length in Unicode codepoints
isempty(FIELD)->0|1           #1 if undefined or empty STR
isblank(FIELD)->0|1           #1 if undefined, empty STR or only whitespaces
concat(STR,...)->STR2         #
toupper|tolower(STR)->STR2    #
[l|r]trim(STR[, 'CHARS'])->STR#
substr(STR, NUM[, NUM2])->STR2#Substring at index NUM, for NUM2 chars (def: all)
replace
 (FIELD, STR, STR2)->STR3     #

toMillis
 ('DATE'_FIELD)->DATE_NUM     #
fromMillis
 (DATE_NUM)->'DATE'_FIELD     #
datefloor|dateceil            #Rounding down|up.
 ('DATE', 'PERIOD')->'DATE'   #PERIOD is NUM followed by y|q|mo|w|d|h|m|s|ms, yr|qtr|mon|hr|min|sec|msec
                              #or year|quarter|month|week|day|hour|minute|second|millisecond
bin('PERIOD')->'DATE'         #Same as datefloor(@timestamp, 'PERIOD')

isValidIp[V4|6](FIELD)->BOOL  #
isIp[V4|6]InSubnet
 (FIELD, "CIDR")->BOOL        #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       SUBSCRIPTION MAIN       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutSubscriptionFilter()       #Req: SUBSCRIPTION
                              #  - no creationTime
                              #Res: empty
DescribeSubscriptionFilters() #Req: SUBSCRIPTION
                              #  - only filterName -> filterNamePrefix STR
                              #  - only logGroupName
                              #Res: subscriptionFilters SUBSCRIPTION_ARR
DeleteSubscriptionFilter()    #Req: SUBSCRIPTION
                              #  - only filterName, logGroupName
                              #Res: empty

SUBSCRIPTION                  #Send a LOG_GROUP's LLEVENTs to a Lambda FUNCTION or Kinesis STREAM|FIREHOSE
                              #On delivery failure due to 5** or throttling, retry for up to 24h
                              #Max 2 per LOG_GROUP
SUBSCRIPTION.filterName       #'SUBSCRIPTION'
SUBSCRIPTION.creationTime     #DATE_NUM

SUBSCRIPTION.logGroupName     #'LOG_GROUP'

SUBSCRIPTION.filterPattern    #'FILTER_PATTERN'

SUBSCRIPTION.destinationArn   #ARN of either Lambda FUNCTION, Kinesis STREAM|FIREHOSE or DESTINATION

SUBSCRIPTION.roleArn          #ROLE_ARN used to write LLEVENTs onto SUBSCRIPTION.destinationArn
                              #Requires PACTION iam:PassRole
                              #If using a DESTINATION, should use DESTINATION.roleArn instead
                              #  - unless logs come from another SERVICE, in which case:
                              #     - both SUBSCRIPTION|DESTINATION.roleArn must be used
                              #     - SUBSCRIPTION.roleArn must grant PACTION logs:PutLogEvents instead


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     SUBSCRIPTION PAYLOAD      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PAYLOAD                       #Sent to the SUBSCRIPTION destination
                              #Is OBJ_JSON that is base64'd and gzip'd
PAYLOAD.owner                 #ACCOUNT_ID
PAYLOAD.logGroup              #'LOG_GROUP'
PAYLOAD.logStream             #'LOG_STREAM'
PAYLOAD.subscriptionFilters   #'SUBSCRIPTION'_ARR
PAYLOAD.messageType           #Either:
                              #  - 'DATA_MESSAGE': usual one
                              #  - 'CONTROL_MESSAGE': ping
PAYLOAD.logEvents             #LLEVENT_ARR
                              #Only message, timestamp, and id LLEVENT_MID


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      SUBSCRIPTION LAMBDA      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PERMISSION ==>                #Must use LAMBDA FUNC_VERSION.Role, not SUBSCRIPTION.roleArn
                              #Use a LAMBDA PERMISSION policy:
                              #  - Principal.Service 'logs.amazonaws.com'
                              #  - allow PACTION lambda:InvokeFunction
                              #  - COND_KEY aws:SourceArn LOG_GROUP_ARN, aws:SourceAccount ACCOUNT_ID

INVOCATION ==>                #InvocationType 'Event'
REQ.awslogs.data              #'PAYLOAD_JSON_GZIP_BASE64'
RES                           #None


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     SUBSCRIPTION KINESIS      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PERMISSIONS ==>               #Must use SUBSCRIPTION.roleArn
                              #Use a trust policy for Principal.Service 'logs.amazonaws.com'
                              #  - COND_KEY aws:SourceArn arn:aws:logs:REGION:ACCOUNT_ID:*
                              #Use a ROLE policy to allow PACTION kinesis:PutRecord
AWSServiceRoleForLogDelivery  #SERVICE_LINKED_ROLE used as SUBSCRIPTION.roleArn with Kinesis FIREHOSE
                              #Automatically created, if PACTION iam:CreateServiceLinkedRole
AWSServiceRoleForLogDelivery  #AWS managed POLICY used by AWSServiceRoleForLogDelivery
 Policy                       #Allows PACTIONs firehose:PutRecord[Batch]|ListTagsForDeliveryStream
                              #  - providing Firehose delivery stream has TAG LogDeliveryEnabled 'true'
                              #     - automatically setup by AWS

SUBSCRIPTION.distribution     #Whether to group:
                              #  - 'ByLogStream': by LOG_STREAM
                              #  - 'Random': randomly, i.e. uniform distribution of LLEVENTs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:  SUBSCRIPTION CROSS-ACCOUNT   :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutDestination()              #Req: DESTINATION
                              #  - no arn, creationTime, accessPolicy, forceUpdate
                              #Res: destination DESTINATION
                              #  - no tags, forceUpdate
PutDestinationPolicy()        #Req: DESTINATION
                              #  - only destinationName, accessPolicy, forceUpdate
                              #Res: empty
DescribeDestinations()        #Req: DESTINATION
                              #  - only destinationName -> destinationNamePrefix STR
                              #Res: destinations DESTINATION_ARR
                              #  - no tags, forceUpdate
DeleteDestination()           #Req: DESTINATION
                              #  - only destinationName
                              #Res: empty

DESTINATION                   #SUBSCRIPTION.destinationArn that can be used in a different ACCOUNT
                              #Can only be Kinesis STREAM|FIREHOSE, not Lambda FUNCTION
                              #Must be in same REGION as LOG_GROUP
                              #A test PAYLOAD is sent on DESTINATION creation
DESTINATION.arn               #DESTINATION_ARN. arn:aws:logs:REGION:ACCOUNT_ID:destination:DESTINATION
DESTINATION.destinationName   #'DESTINATION'
DESTINATION.creationTime      #DATE_NUM

DESTINATION.targetArn         #Kinesis STREAM|FIREHOSE_ARN

DESTINATION.roleArn           #Like SUBSCRIPTION.roleArn, but for DESTINATION.targetArn
DESTINATION.accessPolicy      #Resource-based 'POLICY' to allow DESTINATION to be used as SUBSCRIPTION.roleArn
                              #E.g. can restrict which ACCOUNTs can send to DESTINATION
                              #Must have:
                              #  - PACTION logs:PutSubscriptionFilter
                              #  - Resource DESTINATION_ARN
                              #Max 5KB
DESTINATION.forceUpdate       #BOOL (def: false). Allow upserting.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EXPORT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CreateExportTask()            #Req: EXPORT
                              #  - no taskId, executionInfo, status
                              #Res: EXPORT
                              #  - only taskId
DescribeExportTasks()         #Req: EXPORT
                              #  - only taskId, statusCode
                              #Res: exportTasks EXPORT_ARR
                              #  - no logStreamNamePrefix
CancelExportTask()            #Req: EXPORT
                              #  - only taskId
                              #Res: empty

EXPORT                        #Export LOG_GROUP to S3 OBJECTs
                              #24h timeout
EXPORT.taskId                 #EXPORT_MID
EXPORT.taskName               #'EXPORT'
EXPORT
 .executionInfo.creationTime  #DATE_NUM

EXPORT.logGroupName           #'LOG_GROUP'
EXPORT.logStreamNamePrefix    #STR. Only if 'LOG_STREAM' start with STR
EXPORT.from|to                #DATE_NUM. Filter by LLEVENT.timestamp

EXPORT.destination            #S3 'BUCKET'
                              #Must be in same REGION as LOG_GROUP
EXPORT.destinationPrefix      #STR. Prefix to all S3 OBJECTs

PERMISSIONS ==>               #Must allow:
                              #  - PACTION s3:GetBucketAcl on BUCKET, s3:PutObject on OBJECTs
                              #     - also some kms:* if using S3-KMS (see its doc)
                              #  - Principal.Service 'logs.amazonaws.com'
                              #  - COND_KEY aws:SourceArn LOG_GROUP_ARN, aws:SourceAccount ACCOUNT_ID
                              #  - COND_KEY s3:x-amz-acl 'bucket-owner-full-control' (only for s3:PutObject)

EXPORT.status.code            #STR among:
                              #  - PENDING
                              #  - RUNNING
                              #  - PENDING_CANCEL, CANCELLED
                              #  - COMPLETED, FAILED
EXPORT.status.message         #STR
EXPORT
 .executionInfo.completionTime#DATE_NUM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              KMS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


AssociateKmsKey()             #Req: KMS_ASSOC
                              #Res: empty
DisassociateKmsKey()          #Req: KMS_ASSOC
                              #  - no kmsKeyId
                              #Res: empty

KMS_ASSOC                     #Sets default KMS_KEY_ID for LOG_GROUP|QUERY_RES
KMS_ASSOC.kmsKeyId            #KMS_KEY_ID
KMS_ASSOC.logGroupName        #'LOG_GROUP'
KMS_ASSOC.resourceIdentifier  #Either:
                              #  - LOG_GROUP_ARN
                              #  - 'arn:aws:logs:REGION:ACCOUNT_ID:query-result:*'

LOG_GROUP.kmsKeyId            #KMS_KEY_ID. Encrypt LLEVENTs at rest
QUERY_RES.encryptionKey       #KMS_KEY_ID. Encrypt QUERY_RESULTs at rest

PERMISSIONS ==>               #Must allow:
                              #  - Principal.Service 'logs.amazonaws.com'
                              #  - PACTIONs kms:[Re]Encrypt*|Decrypt*|GenerateDataKey*|Describe*
                              #  - COND_KEY aws:SourceArn KMS_ACCOC.resourceIdentifier, aws:SourceAccount ACCOUNT_ID
                              #  - COND_KEY kms:EncryptionContext:aws:logs:arn LOG_GROUP_ARN


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           MASK MAIN           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutDataProtectionPolicy()     #Req: DATA_POLICY
                              #  - no lastUpdatedTime
                              #Res: DATA_POLICY
GetDataProtectionPolicy()     #Req: DATA_POLICY
                              #  - only logGroupIdentifier
                              #Res: DATA_POLICY
DeleteDataProtectionPolicy()  #Req: DATA_POLICY
                              #  - only logGroupIdentifier
                              #Res: empty

DATA_POLICY                   #Mask sensitive data in LLEVENTs of a LOG_GROUP with ***
DATA_POLICY.logGroupIdentifier#'LOG_GROUP'|LOG_GROUP_ARN
DATA_POLICY.lastUpdatedTime   #DATE_NUM

DATA_POLICY.policyDocument    #'MASK_POLICY'
                              #Max 30KB

LOG_GROUP.dataProtectionStatus#STR. Whether LOG_GROUP has a DATA_POLICY, among:
                              #  - DISABLED
                              #  - ACTIVATED
                              #  - DELETED, ARCHIVED

LLEVENTS_REQ|QUERY_RECORD_REQ #BOOL (def: false). If true, do not mask.
 .unmask                      #Requires PACTION logs:Unmask
                              #  - this also allows not masking in UI console

unmask                        #QUERY COMMAND to not mask


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         MASK ACCOUNT          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutAccountPolicy()            #Req: ADATA_POLICY
                              #  - no lastUpdatedTime, accountId
                              #Res: accountPolicy ADATA_POLICY
DescribeAccountPolicies()     #Req: ADATA_POLICY
                              #  - only policyName, policyType
                              #  - only accountId -> accountIdentifiers ACCOUNT_ID_ARR
                              #     - only when using a monitoring ACCOUNT with CloudWatch cross-account observability
                              #Res: accountPolicies ADATA_POLICY_ARR
DeleteAccountPolicy()         #Req: ADATA_POLICY
                              #  - only policyName, policyType
                              #Res: empty

ADATA_POLICY                  #Like DATA_POLICY but for all LOG_GROUPs in an ACCOUNT
                              #Requires DATA_POLICY-related PACTIONs too
ADATA_POLICY.policyName       #'ADATA_POLICY'
ADATA_POLICY.lastUpdatedTime  #DATE_NUM

ADATA_POLICY.accountId        #ACCOUNT_ID
ADATA_POLICY.policyType       #Always 'DATA_PROTECTION_POLICY'
ADATA_POLICY.scope            #Always 'ALL'

ADATA_POLICY.policyDocument   #'MASK_POLICY'

LOG_GROUP.inheritedProperties #'ACCOUNT_DATA_PROTECTION' if LOG_GROUP has a ADATA_POLICY


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          MASK POLICY          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MASK_POLICY                   #'OBJ_JSON'
                              #Max 30KB
MASK_POLICY.Version           #Always '2021-06-01'
MASK_POLICY.Name              #'MASK_POLICY'
MASK_POLICY.Description       #STR

MASK_POLICY.Statements        #MASK_STATEMENT_ARR
                              #Must have 1 item, with MASK_OP.Deidentify|Audit
MASK_STATEMENT.Sid            #'MASK_STATEMENT'
MASK_STATEMENT.Operation      #MASK_OP

MASK_OP.Deidentify.MaskConfig #Always empty OBJ

MASK_OP                       #MASK_DESTINATION
 .Audit.FindingsDestination   #Send masked values to a destination
MASK_DESTINATION
 .CloudWatchLogs.LogGroup     #Send to a 'LOG_GROUP'
MASK_DESTINATION.S3.Bucket    #Send to a 'BUCKET'
MASK_DESTINATION
 .Firehose.DeliveryStream     #Send to a Kinesis STREAM_ARN

MASK_STATEMENT.DataIdentifier #DATAID_ARN_ARR. Defines what to mask
                              #Must be the same for each MASK_STATEMENT
                              #Always arn:aws:dataprotection::aws:data-identifier/DATAID
                              #DATAIDs are automatically managed by AWS, listed below


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        POLICY RESOURCE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PutResourcePolicy()           #Req: LOG_GROUP_POLICY
                              #  - no lastUpdatedTime
                              #Res: resourcePolicy LOG_GROUP_POLICY
DescribeResourcePolicies()    #Req: empty
                              #Res: resourcePolicies LOG_GROUP_POLICY_ARR
DeleteResourcePolicy()        #Req: LOG_GROUP_POLICY
                              #  - only policyName
                              #Res: empty

LOG_GROUP_POLICY.policyName   #'LOG_GROUP_POLICY'
LOG_GROUP_POLICY
 .lastUpdatedTime             #DATE_NUM

LOG_GROUP_POLICY
 .policyDocument              #IAM 'POLICY'

PACTION logs:Create|Update|Get|List|DeleteLogDelivery???

https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/aws-services-sending-logs.html
https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AWS-logs-and-resource-policy.html
https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_OpenSearch_Stream.html


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TAGS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ListTagsForResource()         #Req: RESOURCE_TAGS
                              #  - only resourceArn
                              #Res: RESOURCE_TAGS
                              #  - no resourceArn
TagResource()                 #Req: RESOURCE_TAGS
                              #Res: empty
UntagResource()               #Req: RESOURCE_TAGS
                              #  - tags -> tagKeys STR_ARR
                              #Res: empty

RESOURCE_TAGS                 #
RESOURCE_TAGS.resourceArn     #LOG_GROUP|DESTINATION_ARN
RESOURCE_TAGS.tags            #TAGS

LOG_GROUP|DESTINATION.tags    #TAGS
