
         
   GDB   
         

                                  ┌───────────┐
                                  │   APPEL   │
                                  └───────────┘

gdb [FILE]              #Debug FILE (à moins que l'on souhaite préciser plus 
                        #tard FILE via file).
                        #FILE est un binaire, mais le fichier source est 
                        #recherché en fonction de DIR_PATH et du chemin inscrit
                        #dans le binaire si compilé avec -g (parfois entier,
                        #parfois seulement le basename), selon l'ordre :
                        #  - CHEMIN
                        #  - DIR_PATH/CHEMIN
                        #  - DIR_PATH/$(basename CHEMIN)
                        #DIR_PATH est par défaut $cdir:$cwd, $cdir signifiant 
                        #le répertoire d'origine du source, et $cwd le 
                        #répertoire courant.
                        #Par défaut FILE est le fichier à exécuter et celui
                        #donc dont gdb lit la table des symboles, mais on peut
                        #dissocier les deux avec -s et -e
                        #FILE peut aussi être un fichier objet (avant le 
                        #linking, pas un exécutable) : on pourra inspecter ses
                        #symboles mais pas faire ru ; ou encore une shared
                        #library ou un fichier core.
-c FILE                 
-core=FILE              #Exécute cor FILE au début de gdb.
-p PID                  #Débug le process en cours avec le pid PID (attention,
-pid PID                #si le source file n'est pas disponible ou si compilé
                        #avec -O, résultat inattendu)
-s FILE                 #Spécifie le FILE dont il faut lire la table des 
-symbols FILE           #symboles
-e FILE
-exec FILE              #Spécifie le FILE à exécuter.

-q                      
-quiet                  #N'affiche pas la licence, etc. au démarrage.
-args FILE ARGS         #Exécute FILE avec des arguments ARGS plutôt que sans
                        #arguments.

-ex COMMAND             #Exécute la commande gdb COMMAND au lancement. Il peut
-eval-command COMMAND   #y avoir plusieurs -ex à la suite pour exécuter
                        #plusieurs COMMAND à la suite (qu'on peut terminer par
                        #une commande "q").

-d DIR                  
-directory DIR          #Equivaut à faire un dir DIR.
-cd DIR                 #Equivaut à faire un cd DIR.
-tty TTY                #Equivaut à faire un tty TTY
-write TTY              #Equivaut à faire un set wr on

-return-child-result    #L'exit code de gdb devient le même que celui du
                        #processus débuggué. Utile en batch mode.

                                  ┌───────────┐
                                  │   BASES   │
                                  └───────────┘

COMPILATION FLAGS ==>   #Compiler avec des aides pour le debuggage, au format
                        #DWARF2 si possible. Avec gcc, cela revient à
                        #utiliser le flag -ggdb.
                        #L'optimisation (dont -O) peut nuire au debuggage.
                        #Néanmoins, si le bug ne survient qu'après optimisation,
                        #on peut debugguer un programme optimisé, mais cela
                        #donnera des résultats surprenants.
                        #Utiliser -g3 avec gcc pour avoir les macros expansions.

READLINE ET HISTORIQUE  #Possibilité d'utiliser Haut et Bas pour l'historique.
 ==>                    #Entrée réexécute la dernière commande.
                        #Tab fait une autocomplétion (sur COMMAND mais aussi sur
                        #une VAR (classe, fonction, var, etc.) entrée en 
                        #argument), ou les membres d'un objet.
                        #Readline disponible, comme en shell.

COMMENTAIRES ==>        #Tout ce qui suit un # (au début) est un commentaire.

AUTRES LANGAGES ==>     #Supporte C / C++, mais aussi (avec quelques 
                        #différences) :
                        #  - ASM
                        #  - Objective-C (cl, br, info li, j, li et print
                        #    supportent les method names, cf chapitre 15.4.3)
                        #  - ADA (GNAT uniquement) (catch exception, assert)
                        #  - D
                        #  - OpenCL C
                        #  - Fortran (77 uniquement ; mettre un _ au début 
                        #    d'une VAR)
                        #  - Pascal (limité)
                        #  - Modula-2 (GNU compiler uniquement)

C++ ==>                 #On peut utiliser les opérateurs . et -> pour indiquer 
                        #CLASSDT ou CLASSFK. GDB utilise le namespace courant 
                        #(dans une fonction, pas besoin de retaper son nom pour 
                        #accéder à ses membres).
                        #On peut utiliser :: 
                        #En cas d'overload, il suffit d'indiquer le prototype
                        #de la fonction précise que l'on veut.

VIM ET PYCLEWN ==>      #Pyclewn fait buguer certaines choses : dans le doute,
                        #essayer gdb sans Vim.

INLINE FONCTIONS ==>    #Normalement (pas pu tester), les inline fonctions sont
                        #affichés comme des fonctions normales : elles ont leur
                        #propre frame, etc. Cependant :
                        #  - info fr indique qu'il s'agit d'inline function
                        #  - on ne peut pas utiliser leur FUNC_ADR comme ENDROIT
                        #    ou ENDROIT_ADR
                        #  - fini ne montre pas la return value

                                  ┌─────────────────┐
                                  │   CONVENTIONS   │
                                  └─────────────────┘

ENDROIT                 #Signifie ou bien :
                        #  - [FILE:]NOMBRE : la ligne numéro NOMBRE de FILE
                        #    (par défaut FILE courant)
                        #  - [+|-]NOMBRE : la ligne NOMBRE fois précédente/
                        #    suivante.
                        #  - [FILE:]FUNC_VAR : la fonction FUNC_VAR de FILE (par
                        #    défaut FILE courant) (sa première ligne).
                        #  - *ADR : ADR peut être 0x... ou 0...
                        #FILE doit être entouré de ' ', par exemple s'il 
                        #contient un '.'

ENDROIT_ADR             #Signifie ADR, ADR_LIT ou FUNC_ADR.
                        #Peut être additionné ou soustrait avec une valeur
                        #(base 8, 10 ou 16), mais pas d'espace alors autour du
                        #+ et -.

DATA                    #Fait référence à toute VAL possible dans le langage
                        #sous-jacent, et accessible dans la portée courante,
                        #notamment :
                        #  - VAR 
                        #  - ( VAR + 3 ) / 2
                        #  - ADR [+|-NOMBRE] 
                        #  - *ADR_LIT
                        #  - CLASS_VAR
                        #  - CLASS.CLASSDT
                        #  - CLASS::CLASSFK (utiliser ::)
                        #  - FUNC_ADR [+|-NOMBRE]
                        #  - FUNC_VAR(ARGS) (return value) : ARGS doit parfois
                        #    etre échappé (dont les " "). Ne marche pas si
                        #    FUNC_VAR contient un breakpoint.
                        #  - ( TEST )
                        #CLASSFK, FUNC_VAR et FUNC_VAR() ne marchent pas si la
                        #fonction est inline.
                        #Additionner/soustraire une [FUNC_]ADR permet de
                        #pointer un endroit de la fonction, voire une autre
                        #fonction.
                        #On peut aussi faire :
                        #  - *ADR@NOMBRE : renvoie un array de NOMBRE
                        #    éléments de sizeof(*ADR) octets, commençant par 
                        #    *ADR.
                        #  - {TYPE} ADR : équivaut à (TYPE)*ADR

SYMBOL                  #Désigne un symbole :
                        #  - VAR
                        #  - ADR
                        #  - CLASS_VAR
                        #  - FUNC_VAR
                        #  - typedef

RANGE                   #Désigne un ensemble de numeros de breakpoints, 
                        #threads, etc. :
                        #  - NOMBRE[-NOMBRE2] [NOMBRE3[-NOMBRE4]]...

                                  ┌───────────────┐
                                  │   LANCEMENT   │
                                  └───────────────┘

fil FILE                #Utilise désormais (ou met à jour) le fichier FILE pour
                        #le fichier à exécuter et la table des symboles.
ex FILE                 #Même chose, mais seulement pour le fichier à exécuter.
sy FILE                 #Même chose, mais seulement pour la table des symboles.
cor FILE                #Lit le core dump FILE et se place au dernier 
                        #emplacement avant l'exception. Permet d'analyser
                        #l'état de la mémoire, registres, variables, stack, etc.
                        #lors du dernier moment avant l'exception. Ne permet
                        #pas de lancer le programme : il s'agit juste
                        #d'une analyse statique de la dernière situation.
                        #Le core dump doit avoir été produit à partir d'un
                        #exécutable/library compilée avec des symboles de 
                        #debuggage, ce qui permet de voir la ligne source qui
                        #pose problème. Sinon, le seul indice est dans $eip :
                        #on peut deviner où il pointe en loadant les symboles
                        #d'un exécutable similaire à celui ayant produit le
                        #core dump.
at PID                  #Utilise désormais le processus dont le PID est PID. Le
                        #stoppe (car le debug). Aucun FILE ne doit être 
                        #actuellement débuggué.
det                     #Détache le processus actuellement attaché via at.

set exec-w COMMANDE     #Exécute COMMANDE ARGS au lieu de FILE ARGS lors de
                        #l'exécution du débuggage avec ru par exemple.
                        #COMMANDE doit donc être un wrapper, comme :
                        #  - env "VAR=VAL" pour passer une environment variable
                        #  - un script shell se terminant par exec "$@"
                        #Par défaut, pas de wrapper.
unset exec-w            #Equivaut à set exec-w ""

                                  ┌───────────────┐
                                  │   EXECUTION   │
                                  └───────────────┘

set arg [ARGS]          #Modifie les arguments passés à ru (pas d'ARGS si pas
                        #d'argument).
ru [ARGS]               #Exécute le programme jusqu'à la fin (le programme ne 
                        #doit pas déjà avoir été commencé)
                        #Si ARGS est absent, les arguments éventuellement 
                        #précisé via un précédent set arg sont passés.
                        #Sinon, effectue un set arg ARGS avec ARGS.
                        #On peut faire des redirections de stdin, stdout, etc.
                        #mais celles-ci sont considérées comme des ARGS.
sta [FUNC] [ARGS]       #Comme ru, mais précise la FUNC principale (par défaut
                        #main dans un programme C et C++), et place un tb dessus

                                  ┌─────────────────┐
                                  │   PROGRESSION   │
                                  └─────────────────┘

next [NOMBRE]           #Continue l'exécution jusqu'à la prochaine instruction,
                        #mais sans descendre dans les fonctions (doit avoir été
                        #précédemment interrompu), et ce NOMBRE fois (par 
                        #défaut 1). Ne s'arrête pas sur les déclarations sans
                        #initialisation.
step [NOMBRE]           #Même chose, mais en descendant dans les fonctions, à
                        #condition que celles-ci aient été compilées avec -ggdb,
                        #cette dernière condition n'ayant lieu que si :
                        #  - set ste on (defaut)
                        #Descend aussi dans les constructors et destructors.
                        #Ne s'arrête pas non plus sur les declarations sans
                        #initialisation.
ni [NOMBRE]             #Comme next, mais n'avance pas d'une ligne mais d'une
                        #instruction processeur.
stepi [NOMBRE]          #Même chose pour step, sauf que cela

cont [NOMBRE]           #Continue l'exécution du programme après avoir été
                        #interrompu, et ignore NOMBRE breakpoints/watchpoints
                        #(par défaut 0)
unt [ENDROIT]           #Continue l'exécution jusqu'à ENDROIT. Ne marche que
                        #dans la fonction courante.
                        #Si ENDROIT n'est pas précisé, agit comme next, sauf
                        #que les itérations dans les boucles sont zappées.
adv ENDROIT             #Comme unt ENDROIT, mais inclue aussi les fonctions
                        #appelées par la fonction courante (récursivement)
fini                    #Continue l'exécution jusqu'à la fin de la fonction
                        #courante (ne marche pas dans le main), et affiche sa
                        #return value.
ret [DATA]              #Termine la fonction courante, et lui fait retourner
                        #DATA (par défaut 200)
j ENDROIT               #Fait que l'instruction courante devient ENDROIT, puis
                        #effectue un cont. Les registres, etc. ne changent pas, 
                        #donc on peut avoir des résultats étranges, notamment 
                        #si l'on change de fonction.

                                  ┌────────────────────────────┐
                                  │   PROGRESSION EN ARRIERE   │
                                  └────────────────────────────┘

ch                      #Crée un checkpoint sur la position courante, associé
                        #à un numero. Crée en fait un fork.
resta NOMBRE            #Revient à l'endroit du checkpoint NOMBRE. L'état du
                        #programme débuggué est le même (variable, etc.), mais
                        #pas celui du débuggage lui-même (état de GDB, 
                        #breakpoints, etc.). L'endroit courant devient lui-même
                        #un checkpoint.
del ch NOMBRE           #Supprime le checkpoint numero NOMBRE.
info ch                 #Imprime des infos (numero, emplacement) sur les
                        #checkpoints courants.

rec                     #Commence une session d'enregistrement, nécessaire au
                        #fonctionnement des commandes "reverse" sous GNU/Linux
                        #(mais ne devrait pas l'être sous certaines plateformes)
                        #Ralentit grandement GDB.
                        #Une fois la session terminée, il est possible de 
                        #reparcourir en avant/arrière la zone enregistrée en
                        #mode "replay" (les instructions ne sont pas vraiment
                        #exécutées par le CPU). On peut sauvegarder/restaurer
                        #celle-ci avec rec sa/r.
rec sa FILE             #Sauvegarde l'enregistrement.
rec r FILE              #Restaure l'enregistrement.
rec d                   #Reprend l'enregistrement, après avoir jeté 
                        #éventuellement l'enregistrement existant depuis le
                        #point actuel.
rec st                  #Stoppe l'enregistrement.
set rec i NOMBRE        #Modifie le nombre d'entrée maximale de l'enregistrement
                        #(par défaut 200000)
set rec i [on]|of       #(Dés)active le fait que l'enregistrement utilise un
                        #buffer linéaire et non circulaire.

rc                      
reverse-step
reverse-stepi           
reverse-next            #Equivaut à cont, step, si, next, ni et fini, mais à
reverse-nexti           #l'envers. N'est pas assuré de fonctionner à 100%.
reverse-f               #On doit être en mode "rec" sous GNU/Linux.
set exec-di r|f         #Si r, fait que cont, step, si, next, ni et fini seront
                        #associés à rc, etc., et vice-versa (par défaut f).

                                  ┌───────────┐
                                  │   STOPS   │
                                  └───────────┘

STOP ==>                #Après un breakpoint, etc. ou après un next, etc.,
                        #la commande "courante", celle précisée dans ma doc
                        #et indiquée par une flèche avec Pyclewn, est en fait 
                        #la prochaine qui va être exécutée (pour la fonction
                        #courante) et la commande en cours (pour les fonctions
                        #du dessus)

br [ENDROIT] [if TEST]  #Met un breakpoint sur ENDROIT (par défaut instruction 
                        #courante).
                        #Fait que la prochaine exécution s'arrêtera sur ce
                        #breakpoint (juste avant ENDROIT), si TEST est true
                        #(par défaut true)
tb [ENDROIT][if TEST]   #Comme br, mais le breakpoint est temporaire et est
                        #détruit dès utilisation.
hb [ENDROIT] [if TEST]  #Comme br, sauf qu'au lieu d'être un software breakpoint
                        #c'est un hardware breakpoint. Différences :
                        #  - un software breakpoint est intrusif : il écrit un
                        #    0xcc (int 0x03) dans le programme débuggué. A la 
                        #    lecture de "int 0x03" (debug interrupt), le code
                        #    est stoppé et 0x0cc est swapped avec l'ancienne 
                        #    valeur. Pose des problèmes si :
                        #     - il s'agit d'un ROM (écriture impossible, et
                        #       copier le ROM sur la RAM empêche de résoudre
                        #       certains bugs)
                        #     - il s'agit d'un self-modifying code
                        #  - un hardware breakpoint utilise des registres du
                        #    CPU (dr0 à dr7) (non-intrusif). Cependant, on ne 
                        #    peut en utiliser que 4 à la fois sous x86 par 
                        #    exemple.
                        #br est automatiquement remplacé par un hb si le
                        #programme est read-only.
thb [ENDROIT][if TEST]  #Comme hb, mais le breakpoint est temporaire et est
                        #détruit dès utilisation.
rb PATTERN              #Effectue un br ENDROIT pour chaque ENDROIT contenant
                        #le PATTERN (regexps étendues). Exemples utiles :
                        #  - toutes les fonctions d'une classe : CLASS::
                        #  - toutes les fonctions d'un fichier : FILE:.
cl [ENDROIT]            #Supprime le breakpoint à ENDROIT (par défaut 
                        #instruction courante)

wa DATA [if TEST]       #Met un watchpoint sur DATA : l'exécution s'interrompera
                        #à la prochaine modification de DATA, si TEST est true
                        #(par défaut TRUE)
                        #DATA doit être dans la portée locale courante, et le 
                        #watchpoint sera détruit dès qu'on sort de cette portée.
                        #DATA ne peut pas être une FUNC_ADR ou FUNC_VAR(ARGS).
                        #DATA peut être un TEST : l'exécution s'interrompera
                        #quand TEST sera vrai.
                        #Un watchpoint ne marche pas pendant un appel de 
                        #fonction via cal ou print FUNC_VAR(ARGS)
                        #GDB essaie de mettre toujours des hardware watchpoints
                        #(même concept que hardware breakpoint) avec wa, et le
                        #fait toujours avec rw et aw. Cependant, cela devient
                        #impossible en cas de :
                        #  - épuisement des hardware watchpoints (4 maximum)
                        #  - DATA a un type trop grand
rw DATA                 #Met un read-watchpoint : pareil que wa DATA sauf que 
                        #c'est pour la lecture et non la modification de DATA.
aw DATA                 #Met un read-or-write watchpoint.
info wat                #Affiche des informations sur les watchpoints, sont leur
                        #numéro.

cat ARG                 #Met un catchpoint (interruption lorsque) sur un
                        #événement en fonction de ARG :
                        #  - t : throw.
                        #  - c : catch( )
                        #  - exe : exec*()
                        #  - f : fork()
                        #  - v : vfork()
                        #  - s [STRING|NOMBRE] : syscall dont le nombre ou le
                        #    nom (par exemple "exit") est STRING ou NOMBRE (si 
                        #    pas spécifié, désigne tout syscall).
tcat ARG                #Comme car, mais est supprimé avec usage.

disab [RANGE]           #Disable les b/w/cpoints du RANGE (!= supprime)
                        #RANGE est par défaut tous les b/w/cpoints.
en [STRING] [RANGE]     #Contraire de dis : (re-)enable. De plus si STRING est :
                        #   - once : après la prochaine interruption, il sera
                        #     disabled.
                        #   - delete : après la prochaine interruption, il sera
                        #     supprimé (comme tb et tw)
dele [RANGE]            #Comme dis, mais supprime.
info br [NOMBRE]        #Affiche des informations sur les b/w/cpoints 
                        #courants, ainsi que leur numero, adresse, endroit, 
                        #disabled/enabled, et leur type (pour watchpoints)
                        #Si NOMBRE est spécifié, seul celui ayant ce numero
                        #est affiché.
ig NOMBRE1 NOMBRE2      #Fait que le b/c/wpoint numéro NOMBRE1 sera ignoré pour
                        #les NOMBRE2 prochaines fois. Permet donc aussi de 
                        #savoir combien de fois un breakpoint est rencontré
                        #(avec un NOMBRE2 très grand)
cond NOMBRE [TEST]      #Rajoute/remplace/enlève (si TEST est absent) un "if
                        #TEST" pour le break/watch/catchpoint NOMBRE.
comm [RANGE]            #Il s'agit de plusieurs lignes.
[COMMANDES...]          #Fait qu'à chaque interruption sur les break/watch/
end                     #catchpoint RANGE (par défaut les derniers break/watch/
                        #catchpoints créés), les COMMANDES GDB seront effectuées
                        #Si l'un des breakpoints, etc. avait déjà un comm, 
                        #celui-ci est remplacé (ne pas mettre de COMMANDES
                        #supprime donc toute COMMANDE déjà placée).
                        #La COMMANDE "silent" est disponible dans un tel bloc,
                        #et signifie que la notification normalement imprimée
                        #lors d'une inerruption sur un breakpoint, etc. ne sera
                        #pas imprimée.
save b FILE             #Enregistre les break/watch/catchpoints courants dans
                        #un script GDB FILE, ce qui permet de les récupérer à
                        #nouveau avec source FILE (les watchpoints sont souvent
                        #pas récupérables entre plusieurs sessions).

                                  ┌────────────┐
                                  │   FRAMES   │
                                  └────────────┘

CALL STACK ==>          #Dans GDB, chaque frame est associée à un numéro..
                        #Eviter de compiler avec -fomit-frame-pointer
                        #La frame courante est celle sur laquelle toutes les
                        #opérations ont lieu (dont unt, adv, br, wa, print,
                        #etc.), sauf next, step, ni, si, cont, qui ont 
                        #toujours lieu dans la frame la plus basse.
                        #Il peut être par exemple utile de remonter si l'on a
                        #été interrompu dans une frame trop basse.
                        #La flèche dans Vim est toujours dans la frame courante.

bt [[-]NOMBRE] [f]      #Affiche des informations sur le call stack (adresse,
                        #emplacement, arguments et (si f) variables locales de 
                        #chaque frame).
                        #Si NOMBRE, ne cible que les NOMBRE frames les plus
                        #basses (quel que soit la frame courante) ou, avec -,
                        #les plus hautes.
set ba l NOMBRE         #Limite le nombre de frames affichables via bt à NOMBRE
                        #(par défaut 0 : illimité)
set ba past-m [on]|of   #(Dés)active le fait que bt aille au-delà de main(),
                        #jusqu'au code généré par le système et la libc pour 
                        #lancer le programme (par défaut off).
set pri f STRING        #Affecte le fait que parmi les arguments d'une frame,
                        #après un appel à bt et fr, sont imprimés :
                        #  - all : tous
                        #  - scalars : tous, sauf les éléments complexes 
                        #    (arrays, classes, etc.) (défaut)
                        #  - none : aucun

info fr                 #Affiche des informations sur la frame courante : niveau
                        #de récursion, adresses (courante, caller, calling, 
                        #arguments, local variables), registres (program
                        #counter), langage.
info lo                 #Affiche les variables locales de la frame courante.
info ar                 #Affiche les arguments de la frame courante, et leur
                        #adresse.

sel [NOMBRE]            #Fait que la frame NOMBRE (par défaut la frame courante)
                        #devient la frame courante.
fr [NOMBRE]             #Comme sel, mais affiche ensuite des informations sur
                        #elle (adresse, emplacement, arguments et ligne 
                        #d'exécution courante) 
up [NOMBRE]             #Equivaut à faire un fr vers la frame NOMBRE fois (par
                        #défaut 1) au-dessus.
down [NOMBRE]           #Même chose, mais en-dessous.
up-s [NOMBRE]           #Comme up, mais avec sel.
down-s [NOMBRE]         #Comme down, mais avec sel.

                                  ┌────────────────┐
                                  │   PRINT ET X   │
                                  └────────────────┘

print[/TYPE] [DATA]     #Affiche la valeur de DATA (par défaut la DATA du
                        #dernier print)
                        #L'imprime en fonction de son type, mais on peut la 
                        #caster grâce à TYPE :
                        #  - c : char
                        #  - s : char* (s'arrête au premier \0)
                        #  - d : int decimal
                        #  - u : unsigned int decimal
                        #  - x : int hexa
                        #  - o : int octal
                        #  - t : int binaire
                        #  - f : float
                        #  - a : SYMBOLE+OFFSET, où SYMBOLE est le symbole le
                        #        plus proche, précédé de l'adresse de DATA.
x[/[NOMBRE]TYPE[UNIT]]  #Affiche la valeur de *ENDROI_ADR (par défaut le 
[ENDROI_ADR]            #dernier info li, la DATA du dernier print ou le 
                        #dernier breakpoint du dernier info br)
                        #TYPE est la même chose que pour print, avec cette
                        #possibilité en plus :
                        #  - i : instruction machine (taille variable sur 
                        #        certaines architectures, dont x86). Ignore
                        #        UNIT. Un pointeur => est affiché comme avec
                        #        disas.
                        #De plus, c'est couplé avec UNIT qui fait que c, s, d,
                        #etc. ne désignent pas un char, un int, etc. mais un
                        #type (TOUINT ou TOUFLOAT) de :
                        #  - b : 1 octet
                        #  - h : 2 octets
                        #  - w : 4 octets
                        #  - g : 8 octets
                        #Par exemple xb désigne un CHAR_VAL hexa, hs une string
                        #dont les caractères font 16 bits (UTF-16), etc.
                        #UNIT est par défaut, dans l'ordre :
                        #  - b, si TYPE est c ou s
                        #  - w, si TYPE est a
                        #  - le dernier UNIT (implicite ou explicite)
                        #  - w, si pas de dernier UNIT
                        #NOMBRE indique le nombre de groupes de TYPE-UNIT à 
                        #imprimer (par défaut 1).
                        #L'endianess des groupes de UNIT octets est respectée
                        #(sauf avec s).
                        #Par exemple si les 4 prochains octets à partir 
                        #d'ENDROI_ADR sont 0a 0b 0c puis 0d (sur une machine
                        #little-endian):
                        #  - x/4xb ENDROI_ADR -> 0a 0b 0c 0d ("vraie" état de la
                        #    mémoire)
                        #  - x/xw ENDROI_ADR -> 0d0c0b0a (le mot est little-
                        #    endian)
                        #Répéter non pas la même commande x, mais seulement "x" 
                        #analysera le [NOMBRE]TYPE[UNIT] suivant (ou taper 
                        #juste Entrée).
                        #Préciser une FUNC_ADR permet donc de scanner, word par 
                        #word, une fonction en mémoire.
disp[/[NOMBR]TYPE[UNIT]]#Effectue un print[/TYPE] DATA à chaque interruption.
[DATA]                  #Si NOMBRE ou UNIT est précisé, ou que TYPE est i ou s,
                        #effectue non pas un print, mais un x (DATA doit donc
                        #être un ENDROI_ADR).
                        #Quand DATA devient hors de portée, elle est disabled.
                        #Quand elle est à nouveau à portée, elle est enabled.
                        #Si DATA est omis, imprime l'ensemble des disp et leur
                        #valeur.
                        #Chaque disp est associé à un numéro.
und NOMBRE              #Supprime le disp numéro NOMBRE.
dis di NOMBRE           #Disable le disp numéro NOMBRE.
ena di                  #Enable le disp numéro NOMBRE.
info di                 #Imprime des infos sur les disp actuels.

$$NOMBRE                #Chaque valeur imprimée par print est conservée dans une
                        #variable avec un numéro, jusqu'au prochain fil ou
                        #sy : les values history.
                        #Cette variable est substituée par la ( NOMBRE - 1 ) 
                        #dernière value history
$                       #Equivaut à $$0
$$                      #Equivaut à $$1
sho va [NOMBRE]         #Imprime 10 values histories, à partir de la numéro
                        #NOMBRE (par défaut $$9). Réappuyer sur entrée imprime
                        #les dix suivantes.

set pri sy [on]|of      #Avec print/a, si SYMBOLE est dans un autre fichier,
                        #imprime le nom de ce fichier (défaut off)
set pri m NOMBRE        #N'effectue l'effet de set pri sy que OFFSET est <=
                        #NOMBRE
set pri array-i [on]|of #Imprime les indices des arrays (défaut off)
set pri e NOMBRE        #Maximum de valeurs imprimables pour un array (0 pour
                        #illimité, 200 par défaut).
set pri n [on]|of       #Fait que l'impression d'un array s'arrête au premier
                        #'\0' (utile s'il contient en fait une STR)
set pri array [on]|of   #Imprime les arrays de manière plus jolie, mais moins
                        #compacte (défaut off).
set pri pr [on]|of      #Même chose pour les classes/structures/unions.
set pri o [on]|of       #Imprime le type d'une CLASS_ADR après transformation
                        #polymorphique (défaut off)

                                  ┌─────────┐
                                  │   FIN   │
                                  └─────────┘

k                       #Kill (permet de relancer à nouveau depuis le début).
CTRL-C                  #Interrompt l'exécution du programme (pas de gdb). Peut
                        #être repris.
q                       #Quitte.
ge FILE                 #Crée un core dump FILE sauvegardant l'état actuel
                        #(registre, etc.). N'enregistre pas la source, ni les
                        #prochaines et anciennes instructions, juste l'état
                        #actuel.

du [FORMAT] m FILE      #Sauvegarde la zone mémoire allant d'ENDROI_ADR1 à
ENDROI_ADR1 ENDROI_ADR2 #ENDROI_ADR2 dans FILE, au FORMAT :
                        #  - b : binaire (défaut)
                        #  - i : Intel hex
                        #  - s : Motorola S-Record
                        #  - t : Tektronix hex
du [FORMAT] v FILE VAR  #Sauvegarde la valeur (et l'adresse, sauf pour b) de VAR
                        #dans FILE (même FORMAT que ci-dessus)
app m FILE ENDROI_ADR1
ENDROI_ADR2             #Comme du, sauf que FORMAT est forcément binaire, et que
app v FILE VAR          #FILE est appended et non écrasé.
resto FILE [b] [NOMBRE1 #Restaure le contenu de FILE (obtenu après un du ou app)
[ NOMBRE2 [NOMBRE3]]]   #dans la mémoire actuelle. b est obligatoire si FILE est
                        #au format binaire. 
                        #Les formats i, s et t sauvegardent l'adresse de fin et
                        #début de la zone mémoire/variable au moment de 
                        #l'enregistrement, et le format b restaure tout à 
                        #l'adresse 0x0, jusqu'à la dernière adresse possible.
                        #Cependant, on peut ajouter NOMBRE1 à cette fin et ce
                        #début.
                        #De plus, si NOMBRE2 est précisé, l'adresse de début
                        #devient NOMBRE2+NOMBRE1. Même chose pour NOMBRE3 et 
                        #l'adresse de fin.

                                  ┌─────────────┐
                                  │   SOURCES   │
                                  └─────────────┘

li [ENDROIT]            #Imprime 10 lignes source, avec ENDROIT (par défaut la
                        #ligne courante) au centre.
                        #Un nouvel appel, ou simplement appuyer sur Return,
                        #imprimera les 10 lignes suivantes.
                        #l - retournera en arrière.
                        #Si ENDROIT est [+|-]NOMBRE, ENDROIT ne désigne pas la
                        #ligne du centre, mais la dernière ligne, excluse.
                        #Ainsi li +1 inclue les dernières lignes jusqu'à la
                        #ligne courante, et li - de même, mais en excluant la
                        #ligne courante.
li ENDROIT1, ENDROIT2   #Imprime les lignes numéro ENDROIT1, ENDROIT2.
                        #L'un des ENDROIT peut être omis, signifiant alors
                        #"depuis le début" ou "la fin"
set lis NOMBRE          #Modifie le nombre de lignes de contexte de l.
sea PATTERN             #Imprime la prochaine ligne source (à partir de la
                        #ligne courante, ou du dernier sea) contenant PATTERN 
                        #(regexps étendus)
reverse-sea PATTERN     #Même chose, mais dans l'autre sens.

info prog               #Affiche l'adresse courante, l'état (running ou non) et
                        #le PID du programme débugué.
info source             #Affiche les emplacements du source, le nombre de ligne,
                        #le langage et le format de debuggage.
info sources            #Imprime l'ensemble des fichiers sources (dont ceux 
                        #inclus récursivement), en séparant ceux déjà lus de
                        #ceux pas lus.
set la STRING           #Indique le langage du programme : toujours fait 
                        #automatiquement, mais juste au cas où GDB n'arrive pas 
                        #à reconnaître.
sho la                  #Affiche le langage du programme (parmi ceux supportés).
                        #Utile quand on a pas la source.

wh                      #Montre le code source dans une sous-fenêtre.

                                  ┌──────────────┐
                                  │   SYMBOLES   │
                                  └──────────────┘

set cas on|of           #(Dés)active le fait la sensibilité à la casse lorsque 
                        #l'on indique une SYMBOL (défaut on)
info ad SYMBOL          #Désigne l'adresse et l'endroit de SYMBOL.
info sc ENDROIT         #Effectue un info ad sur tous les SYMBOL définis
                        #dans la fonction contenant ENDROIT.
info sy ENDROI_ADR      #Désigne le nom du symbole (et éventuellement l'offset
                        #par rapport à un autre symbole) du SYMBOL enregistré à
                        #ENDROI_ADR.
mai pr m FILE           #Imprime l'ensemble des SYMBOL et leur emplacement dans
                        #un fichier texte FILE.
mai pr sy FILE          #Même chose, mais n'inclue que les SYMBOL des fichiers 
                        #déjà lus (cf info sources)
mai pr p FILE           #Même chose, mais pour les fichiers déjà lus ou 
                        #partiellement lus.

wha SYMBOL              #Imprime le type de SYMBOL.
pt SYMBOL               #Comme wha, mais s'il s'agit dun type complexe, imprime
                        #aussi l'ensemble de ses membres.
info ty [PATTERN]...    #Imprime l'ensemble des types contenant PATTERN (par 
                        #défaut .), et le fichier source dans lequel ils sont
                        #définis.
info fu [PATTERN]...    #Même chose pour les fonctions (dont le nom contient
                        #PATTERN)
info va [PATTERN]...    #Même chose pour les variables.
info sh [PATTERN]...    #Même chose pour les shared libraries.
set op [on]|of          #Imprime le type des CLASS_ADR (par défaut off)

find [/[NOMBRE][UNIT]]  #Recherche toutes les occurences des DATA... entre
ENDROI_ADR1, ENDRO_ADR2,#ENDROI_ADR1 et ENDROI_ADR2, et reporte l'adresse des
DATA[, DATA...]         #occurences trouvées. ENDROI_ADR2 peut aussi être 
                        #+NOMBRE, comme pour disas.
                        #Les DATA sont interprétées selon leur type, mais peut
                        #être interprétée selon un nouveau NOMBRE et UNIT
                        #(comme x). Par exemple :
                        #  - "hello" : doit mettre /5b
                        #  - 0x40 : doit mettre /b, sinon c'est interprété comme
                        #           un int, donc 0x00000040 est recherché.
                        #$_ enregistre l'adresse de la dernière occurence, et
                        #$numfound le nombre d'occurences.
                        #Ne pas oublier les virgules.
                        #L'endianess des DATA est toujours corrigée pour la 
                        #cible : ne pas s'en soucier.

                                  ┌────────────────┐
                                  │   BAS NIVEAU   │
                                  └────────────────┘

disas [OPT] [ENDROI_ADR]#Imprime le désassemblage de la fonction contenant 
                        #ENDROIT_ADR (par défaut la ligne courante). 
                        #L'instruction courante est indiquée par un =>.
                        #Si OPT est /m, les lignes sources sont indiquées en
                        #plus du désassemblage.
                        #Si OPT est /r, les instructions hexa sont indiquées en
                        #plus de leur version ASM. On peut faire /mr.
disas [OPT] ENDROI_ADR, #Même chose, sauf que seuls les instructions allant
ENDROI_ADR2             #d'ENDROIT_ADR (inclus) à ENDROI_ADR2 (exclus) sont 
                        #désassemblées.
                        #ENDROI_ADR2 peut aussi être +NOMBRE, signifiant alors
                        #ENDROIT_ADR+NOMBRE.
set disassembly STRING  #Modifie la syntaxe utilisée pour le désassemblage x86 :
                        #a pour AT&T (défaut), i pour Intel.
set disassemble [on]|os #(Dés)active le fait d'imprimer un désassemblage de la
                        #ligne (ou instruction si pas de sources) courante après
                        #chaque interruption.

info li ENDROIT         #Affiche l'adresse de la première instruction (incluse)
                        #et la dernière (excluse) de la ligne source contenant
                        #ou désignée par ENDROIT.

info reg [REGISTRE]...  #Affiche la valeur courante des registres CPU spécifiés,
                        #par défaut les plus courants, en hexa et en décimal 
                        #(et sous la forme ADRESSE+OFFSET pour l'instruction 
                        #pointer), pour la frame courante.
info al                 #Fait un info reg sur tous les registres (dont ceux pour
                        #les floats et les vecteurs)
$REGISTRE               #Renvoie la valeur de REGISTRE. Sous x86, Intel Core 2 
                        #les REGISTRE possibles sont : eax, ebx, ecx, edx, esp, 
                        #ebp, esi, edi, eip, eflags, cs, ss, ds, es, fs, gs ;
                        #et aussi st0 à st7, fctrl, fstat, ftag, fiseg, fioff, 
                        #foseg, fooff, fop, xmm0 à xmm7, mxcsr, mm0 à mm7.
                        #Est modifiable, ce qui permet de modifier un registre.
$pc                     #Désigne le counter register ($eip sous x86), toute 
                        #architecture confondue.
                        #Par exemple :
                        #  - x/i $pc
$sp                     #Désigne le stack pointer ($esp sous x86).
$fp                     #Désigne l'adresse du frame pointer ($ebp sous x86)
$ps                     #Désigne le processor status ($eflags sous x86)

info fl                 #Imprime des infos sur les registres liés aux floats 
                        #(x87)
info ve                 #Imprime des infos sur les registres liés aux vecteurs 
                        #(MMX, SSE*)

info au                 #Imprime l'auxiliary vector, qui contient des infos sur
                        #l'architecture, le programme, le nom de l'exécutable,
                        #l'UID, etc.
info os processes       #Renvoie la liste des processus en cours, avec leur PID
                        #et UID.
                        
info fi                 #Imprime l'ensemble des fichiers, sections et leur
                        #adresse.
mai inf se [PATTERN]... #Imprime les sections ASM, dont le nom contient PATTERN 
                        #(par défaut .). Si PATTERN contient ALLOBJ, les 
                        #sections des shared libraries sont aussi recherchées.

                                  ┌─────────────┐
                                  │   SIGNAUX   │
                                  └─────────────┘

sig SIGNAL              #Envoie SIGNAL puis (si le programme ne s'arrête pas dû
                        #à ce signal), fait un cont.
                        #Faire un sig 0 après interruption du programme dû à
                        #l'irruption d'un signal permet de continuer en ignorant
                        #le signal (ce qui ne marche pas toujours si le kernel
                        #refuse malgré tout l'exécution de l'instruction).
ha RANGE STRING         #Change la disposition des signaux contenu dans RANGE
                        #(qui peut contenir le numéro de ces signaux, mais 
                        #aussi leur nom précédé par SIG). STRING peut être :
                        #  - [no]i : le signal est passé au programme débuggué
                        #    ou intercepté par GDB
                        #  - [no]pr : l'irruption du signal est notifiée
                        #  - [no]s : le signal stoppe l'exécution de GDB
info ha                 #Imprime les dispositions courantes des signaux : par
                        #défaut, les signaux faisant interrompre normalement
                        #un programme ont noi/pr/s ; et les autres i/nopr/nos
$_siginfo               #Contient des informations sur le dernier signal 
                        #délivré, sous Unix sous forme d'un siginfo_t (cf 
                        #signal.h). Ecriture possible (en général).

                                  ┌─────────────────────────┐
                                  │   ACTIONS INSTRUSIVES   │
                                  └─────────────────────────┘

set var VAR = DATA      
set var {TYPE}ADR = DATA#Modifie VAR

cal FUNC_VAR(ARGS)      #Appelle FUNC_VAR(ARGS) : doit être une fonction 
                        #utilisable dans le code.
set unwindo [on]|of     #(Dés)active le fait que si cal émet un signal,
                        #l'instruction courante est déplacée dans la fonction
                        #appelée, là où le signal a été émis. Si désactivé, on 
                        #revient simplement à l'endroit avant l'appel à cal.
                        #Concerne aussi toute DATA sous la forme FUNC_VAR(ARGS)
set unwind-o [on]|of    #Même chose pour les exceptions.

set wr [on]|of          #Fait que le programme débuggué est read-write, et non
                        #read-only (défaut off). Doit être fait avant de charger
                        #le fichier/programme.
                        #Ouvrir en write permet de patcher le binaire, mais
                        #GDB peut aussi involontairement le modifier.

me ENDRO_ADR1 ENDRO_ADR2#Définit une zone mémoire allant d'ENDROI_ADR1 à
[ACESS] [NOMBRE] [CACHE]#ENDROI_ADR2, laquelle sera désormais :
                        #  - selon ACCESS :
                        #     - ro : read-only
                        #     - wo : write-only
                        #     - rw : read-write (défaut, concerne l'accès de
                        #            GDB, ne permet pas d'écrire/lire une zone
                        #            refusée par le kernel)
                        #  - selon NOMBRE :
                        #     - 8, 16, 32 ou 64 pour désigner le nombre de bits
                        #       lus/écrits à chaque access (par défaut, pas de
                        #       restriction, les 4 accès sont possibles)
                        #  - selon CACHE :
                        #     - cache : utilise un cache, ce qui améliore les
                        #       performances, mais peut comporter des erreurs 
                        #       sur les variables volatiles, etc.
                        #     - nocache : pas de cache (defaut)
                        #ENDROI_ADR2 peut désigner la dernière adresse mémoire
                        #avec "0".
                        #Une zone mémoire est associée à un numero. Par défaut,
                        #il n'y a pas de zone mémoire.
info me                 #Imprime des infos sur les zones mémoire.
ena me NOMBRE           #Enable la zone mémoire numero NOMBRE
disab me NOMBRE         #Disable la zone mémoire numero NOMBRE
dele me NOMBRE          #Supprime la zone mémoire numero NOMBRE
set me i [on]|of        #Fait que, si une zone mémoire est définie, tout accès
                        #en dehors d'une zone mémoire devient impossible
                        #(defaut off)

PREVENTION INTERVENTION #On peut éviter que GDB s'immisce trop dans le
DE GDB ==>              #programme, mais cela limite ses fonctionnalités (utile
                        #surtout avec set no). Par défaut, toutes ces options
                        #sont désactivées :
set may-write-r [on]|of #(Dés)active le fait d'empêcher GDB d'écrire sur un 
                        #registre du CPU (par exemple avec print ou jump)
set may-write-m [on]|of #(Dés)active le fait d'empêcher GDB d'écrire sur la
                        #mémoire (par exemple avec print)
set may-insert-b [on]|of#(Dés)active le fait d'empêcher GDB d'insérer des
                        #breakpoints (dont ceux utilisés en interne)
set may-insert-t [on]|of#Même chose pour les (non-fast) tracepoints
set may-insert-f [on]|of#Même chose pour les fast tracepoints
set may-int [on]|of     #(Dés)active le fait d'empêcher GDB d'interrompre les
                        #threads (interr ou CTRL-C)
set ob [on]|of          #(Dés)active may-write-r, may-write-m, may-insert-b,
                        #may-insert-t, may-int et no.

                                  ┌──────────────────────────┐
                                  │   ACTIONS DE DEBUGGAGE   │
                                  └──────────────────────────┘

set $VAR = DATA         #Crée une variable de debuggage VAR.
                        #On peut par exemple mettre une adresse mémoire.
sho conv                #Imprime l'ensemble des variables de debuggage.
$_                      #Variable ayant l'ADR du dernier breakpoint (après un
                        #info br), du dernier info li, du dernier ENDROI_ADR
                        #examiné avec x ou de la dernière occurence trouvée par
                        #find.
$__                     #Variable ayant le dernier *ENDROI_ADR (déréférencé) 
                        #imprimé par x.
$_exitcode              #Exit code, une fois que le programme est terminé (hors
                        #k)

set env VAR[=VAL]       #Modifie l'environment variable VAR (pour le fichier
unset env VAR           #débuggué, pas pour GDB lui-même).

she COMMANDE            #Exécute COMMANDE (subshells et builtins possibles)
mak ARGS                #Equivaut à she make ARGS.

cd DIR                  #Change le répertoire courant de GDB (pas du fichier
                        #debuggué).
pwd                     #Imprime le répertoire courant de GDB.

set lo [on]|of          #(Dés)active le logging de l'output de GDB (pas de 
                        #celui du fichier débuggué) vers FILE (par défaut 
                        #./gdb.txt) (par défaut off)
set lo f FILE           #Le logging file devient FILE (redémarrer le logging si
                        #activé)
set lo ov [on]|of       #(Dés)active le fait que le logging soit en overwrite, 
                        #et non append (par défaut off)
set lo r [on]|of        #(Dés)active la non-impression sur l'écran si logging 
                        #activé (par défaut off)
tty TTY                 #Redirige l'output et l'input du fichier debuggué vers 
                        #TTY (par exemple /dev/pts/1). Doit redémarrer le
                        #programme. Pas toujours permis.

set disab [on]|of       #(Dés)active le fait que l'adresse space se voit alloué
                        #un espace non-aléatoire (par défaut on).
                        #Cela permet d'avoir toujours la même adresse 
                        #d'exécution à chaque ru, ce qui est pratique pour le
                        #debuggage.
                        #Cependant, les OS randomize en pratique cette adress
                        #space pour des raisons de sécurité, donc mettre off
                        #permet de coller au comportement réel

                                  ┌────────────┐
                                  │   CONFIG   │
                                  └────────────┘

sho OPT                 #Montre les valeurs actuelles de la configuration option
                        #OPT. Toute option activable avec set est une OPT,
                        #sauf : 
                        #  - vers : version de GDB
                        #  - comm : montre l'historique
                        #  - us   : montre les user-defined commands
                        #  - conv : montre les variables crées avec 
                        #           set var $VAR = VAL
                        #  - dir  : montre DIR_PATH
                        #  - pat  : montre le $PATH actuel

set target-c CHARSET    #Indique le CHARSET (ex : UTF-8) de l'architecture cible
                        #Faire <Tab><Tab> pour avoir les différentes valeurs
                        #possibles. Affecte les "...", les STR et les CHAR_VAL.
set ho CHARSET          #Même chose pour l'hôte.
set cha CHARSET         #Même chose pour l'hôte + la cible.
set target-w CHARSET    #Même chose que set cha, mais pour les wide characters :
                        #L"...", WSTR et WCHAR_VAL

dir [DIR]               #Ajoute DIR au $DIR_PATH (par rechercher les fichiers
                        #source). Sans DIR : remet $DIR_PATH à son état 
                        #d'origine.
set su PATTERN1 PATTERN2#Ajoute le fait que occurence de ^PATTERN1/ dans chaque 
                        #DIR du $DIR_PATH est remplacée (à chaque recherche) par
                        #PATTERN2.
unset su                #Défait tous les set su.
pat DIR                 #Ajoute DIR au $PATH (pour rechercher les fichiers 
                        #objets)

                                  ┌────────────────────┐
                                  │   MULTITHREADING   │
                                  └────────────────────┘

MULTITHREADING ==>      #Notification automatique en cas de création ou d'exit 
                        #d'un thread, avec indication de l'adresse du thread.
                        #Les commandes GDB lancées ne le sont que pour le 
                        #thread actif, cependant les autres threads continuent
                        #leur exécution jusqu'à :
                        #  - la fin de la commande GDB
                        #  - ou si l'un des threads tombe sur breakpoint, 
                        #    signal, etc., auquel cas il devient le thread
                        #    actif
                        #Dans les deux cas, tous les threads s'interrompent à
                        #nouveau.
                        #Par exemple next relance les autres threads, avance 
                        #d'une instruction pour le thread courant (sauf 
                        #interruption d'un autre thread), et interrompt les 
                        #autre threads alors, même si ceux-ci sont en plein 
                        #milieu d'un syscall (ce qui aura pour effet de faire 
                        #échouer le syscall à cause de GDB, ce qui peut aussi
                        #arriver avec GDB pendant la création ou la destruction
                        #d'un thread).
                        #On peut modifier ceci avec :
set scheduler on|of|s   #Si :
                        #  - on : toute reprise après une interruption (cont,
                        #         next, etc.) ne ciblera que le thread courant
                        #  - s  : toute reprise, sauf step, ciblera tous les
                        #         threads.
                        #  - of : toute reprise ciblera tous les threads 
                        #         (défaut)

NON-STOP MODE ==>       #Et pour ce qui est de l'interruption de tous les 
                        #threads à chaque fois que l'un d'entre eux doit
                        #s'interrompre :
set target-a [on]       #Fait que seul ce thread s'interrompt (les autres 
set pa of               #continuent). Implique par ailleurs que toute reprise
set no [on]             #ne ciblera que le thread courant. On peut cependant
                        #faire reprendre tous les threads avec cont -a. Penser 
                        #à faire des reprises en backgrounds via &, pour éviter
                        #d'être bloqué par un deadlock.
                        #Lorsque le thread s'interrompant n'est pas le thread
                        #courant, on ne switche pas automatiquement vers lui :
                        #il faut le faire manuellement.
                        #Les trois commandes doivent être exécutées à la suite,
                        #et avant que le programme soit ru.
                        #Pour désactiver, faire le contraire avec 0, on et of
                        #N'est pas assuré de marcher à tous les coups.

BACKGROUND ==>          #De plus, il est possible de faire continuer le(s)
                        #threads en background, ce qui signifie que le prompt
                        #n'attend pas une nouvelle interruption pour être de
                        #nouveau dispo. Pour ce faire, il suffit de rajouter
                        #un & : COMMANDE &, et d'activer l'async-mode avant de
                        #lancer le programme :
set target-a [on]|of    #(Dés)active l'async-mode (par défaut désactivé)
interr [-a]             #Interrompt l'ensemble des threads. Utile seulement 
                        #avec des threads en backgrounds, ou avec set no.
                        #Cependant, avec set no, n'interrompt que le thread
                        #courant, sauf avec -a.

BREAKPOINTS SUR UN      #br et wa peuvent être suivis de : 
THREAD PRECIS ==>       #  - t NOMBRE
                        #qui indique le break/watchpoint ne marchera que s'il
                        #s'agit du thread NOMBRE. L'éventuel [if TEST] est après
                        #et non avant t NOMBRE. Sinon, par défaut, un hardware
                        #watchpoint concerne tous les threads, et un software
                        #watchpoint seulement le thread courant.

info th                 #Imprime la liste des threads, leurs numero, et celui 
                        #actif.
thr NOMBRE              #Le thread numero NOMBRE devient le thread actif.
thr a RANGE COMMANDE    #Exécute la COMMANDE GDB sur les threads contenus dans
                        #RANGE (RANGE peut être all pour désigner tous les
                        #threads)
$_thread                #Variable contenant le numero du thread courant.

LANCEMENT DU THREAD ==> #La bibliothèque permettant l'activation du thread
                        #lance du code avant le déroulement de ce thread.
                        #Pour examiner le début du "vrai thread", il peut
                        #être utile donc, après avoir switcher (ou non), de
                        #mettre un breakpoint au début de celui-ci dans son
                        #code.

                                  ┌──────────────┐
                                  │   INFERIOR   │
                                  └──────────────┘

INFERIORS ==>           #On peut debugguer plusieurs FILE/processes en même 
                        #temps, un peu comme les jobs d'un shell : ce sont les
                        #inferiors (chacun étant associé à un numero).
                        #Ils peuvent tourner en parallèle, mais seul un sera
                        #affecté par les commandes GDB courantes : l'inferior
                        #actif.
                        #Si deux inferiors ciblent le même fichier/process, ils
                        #partagent ses breakpoints, etc. ainsi que tout ce que
                        #GDB a mis.

info i                  #Affiche la liste des inferiors, leur PID, le FILE
                        #associé et le numero.
infe NOMBRE             #L'inferior actif devient le numéro NOMBRE.
add-i [-exec FILE]      #Rajoute un inferior, associé à FILE (par défaut associé
                        #à aucun FILE)
clo [NOMBRE]            #Rajoute un inferior associé au même FILE/PID que
                        #l'inferior numero NOMBRE (par défaut l'inferior actif)
remov NOMBRE            #Supprime l'inferior numero NOMBRE.
det i NOMBRE            #Kill l'inferior NOMBRE, sans le supprimer.
k i NOMBRE              #Même chose, mais l'inferior NOMBRE devient aussi
                        #l'inferior actif.

set pri i [on]|of       #(Dés)active le fait que le démarrage ou la fin de
                        #l'exécution d'un inferior est notifiée (par défaut off)
set schedule-m [on]|of  #(Dés)active le fait que reprendre après une 
                        #interruption reprend pour l'ensemble des inferiors
                        #(par défaut off)

set follow-f STRING     #Après un fork() ou vfork(), seul un des deux est suivi.
                        #Il s'agira (en fonction de STRING) du :
                        #  - "parent" (defaut)
                        #  - "child"
set det [on]|of         #Si on, le processus en trop après un fork ne sera plus
                        #traité par GDB, et recevra un SIGTRAP (interruption
                        #par défaut) s'il découvre un breakpoint laissé par GDB
                        #(defaut).
                        #Si off, le processus en trop sera un nouvel inferior,
                        #qui démarrera au prochain breakpoint ou au main si
                        #fork() est suivi d'exec*()
set follow-e STRING     #Après un exec*(), en fonction de STRING :
                        #  - "same" : la nouvelle image continue dans
                        #    l'inferior actuel (defaut)
                        #  - "new" : un nouvel inferior lié à la nouvelle image
                        #    est créé

                                  ┌────────────┐
                                  │   MACROS   │
                                  └────────────┘

FLAGS ==>               #Compiler avec -g3.

mac expand EXPRESSION   #Montre EXPRESSION (et non son résultat), après 
                        #expansion des éventuelles macros.
mac d MACRO ARGS        #Effectue un #define MACRO ARGS
mac u MACRO             #Effectue un #undef MACRO, à condition que MACRO ait été
                        #créée via mac d
mac l                   #Imprime toutes les macros définies via mac d
info ma MACRO           #Imprime des infos sur MACRO (endroit, définition)

                                  ┌──────────────────────┐
                                  │   REMOTE DEBUGGING   │
                                  └──────────────────────┘

set sta [on]|of         #(Dés)active le cache du stack pendant un remote 
                        #debuggage : bon pour la performance, mais peu induire
                        #des erreurs sur les variables volatiles, les mmap, etc.
                        #(défaut on)

                                  ┌──────────┐
                                  │   AIDE   │
                                  └──────────┘

he                      #Affiche l'aide.
he COMMANDE             #Affiche l'aide sur une commande de gdb

                                  ┌─────────────┐
                                  │   A FAIRE   │
                                  └─────────────┘

A FAIRE ==>             #-nx, -command, -batch, -batch-silent , pas fini les
                        #options.
                        #Utiliser un LABEL pour ENDROIT.
                        #compare-sections (10.6)
                        #set pri demangle, set print asm-demangle, 
                        #set demangle-style (10.8) (cf ASM)
                        #$_sdata : cf 10.11 (tracepoints)
                        #13. : Tracepoints
                        #14. : overlay (embarqué et ASM)
                        #16. : maint info [p]symtabs (connaitre table des      
                        #symboles, ASM)
                        #18.1 : add-symbol-file, add-symbol-file-from-memory,
                        #section, attributs de mai in se, [no]sharedlibrary,
                        #sysroot, reste en dessous
                        #me suis arrêté au chapitre 18.2 du manuel ici : 
                        #  http://sourceware.org/gdb/current/onlinedocs/gdb/Separate-Debug-Files.html#Separate-Debug-Files

