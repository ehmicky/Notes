
        
   CHAI  
        



MOCHA ==>                     #Usually used by Mocha, but does not have to


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERAL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


chai                          #Either:
                              #  - Server-side test: use Node module (test files must fire CHAI.should())
                              #  - Client-side test: use browser script (include <script> chai.js, then fire chai.should())
                              #Version 1.10.0
CHAI.should()                 #Must be fired to extend OBJ prototype with OBJ.should
                              #There are two other possible syntaxes:
                              #  - CHAI.expect(VAL).to... -> VAL.should...
                              #  - CHAI.assert... (other API not as good)
VAL.should                    #Returns SHOULD, an object wrapping VAL: access it with SHOULD._obj
                              #All members returns SHOULD, so can be chained, e.g. VAL.should.exist.and.be.ok
                              #There are two types of members along the chains:
                              #  - methods: assertion on SHOULD._obj, internally using SHOULD.assert()
                              #  - properties: add an internal "flag" along the chain, that will influence next methods
new CHAI.Assertion(VAL[, STR])#Like VAL.should except:
                              #  - VAL can be null|undefined
                              #  - can setup default "internal error message" STR, so:
                              #      new CHAI.Assertion(VAL, STR).should.equal(VAL2)
                              #    is same as:
                              #      new CHAI.Assertion(VAL).should.equal(VAL2, STR)
                              #    but is useful if STR is used for several following assertions

SHOULD.assert( BOOL, STR[()], #Internal assertion function used by all methods.
STR2[()][, VAL[, VAL2]] )     #Throws ASSERTIONERROR(ERRORMESSAGE) if false, doesn't do anything otherwise.
                              #  - STR is the the positive error message, STR2 the negative one.
                              #    Usually "expected ... to VERB ..."
                              #    An "internal error message" is prepended: it is the final optional argument of all methods,
                              #    i.e. all assertion functions can take an extra STR "internal error message" (déf: "")
                              #    The "internal error message" is specific to this assertion case (e.g. "player not a
                              #    magician"), the second message is the general assertion problem (e.g. "ID not equal 'mag'").
                              #  - VAL and VAL2 (expected value() and actual value) are used to be included in error message.
                              #    STR|STR2 can use following format codes:
                              #      - "#{this}": SHOULD._obj
                              #      - "#{exp}": VAL
                              #      - "#{act}": VAL2 (déf: SHOULD._obj)
CHAIUTILS.flag(SHOULD,        #Gets|sets a "flag"
VAR_STR[, VAL_STR]))          #Some flags used by most ASSERTION:
                              #  - "object" (see above): underlying VAL. Can also use SHOULD._obj
                              #  - "message": internal error message
                              #  - "negate" BOOL: flag .not
                              #  - "deep" BOOL: flag .deep
                              #  - "contains" BOOL: flag .include.*
                              #  - "length" BOOL: flag .length.*

CONFIG VAR ==>                #Can be used by Mocha reporters
CHAI.config.showDiff          #Show diff (déf: true)
CHAI.config.truncateThreshold #Truncates VAL length (def: 40, 0 to disable)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EXTENSIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CHAI.use(FUNC(CHAI,CHAIUTILS))#Fires FUNC(), which should extend SHOULD by using addMethod(), etc.
                              #FUNC are usually plugins MODULE

CHAI.Assertion.addProperty    #Makes SHOULD.VAR fire FUNC2():
(VAR_STR, FUNC2())            #  - this SHOULD, so can access CHAIUTILS.flag(this,...) and this._obj
                              #  - should:
                              #     - assert preconditions with this..., e.g. this.equal(3) or this._obj.VAR.equal(3)
                              #       Often check right type with SHOULD.be.an.instanceof()
                              #     - set up a flag with CHAIUTILS.flag(this, VAR, VAL), then overwrite/create
                              #       property/methods that check this.flag()
CHAI.Assertion.addMethod      #Same for SHOULD.FUNC(...). Should:
(FUNC_STR, FUNC2(...))        #  - also assert preconditions
                              #  - but finish with final this.assert(...)
CHAI.Assertion.               #Same as CHAI.Assertion.addMethod(FUNC); SHOULD.addProperty(FUNC2), except:
addChainableMethod            #  - it cannot be overwritten (case of a, an, include, length)
(STR, FUNC, FUNC2)            #  - method FUNC() also fire property FUNC2()

CHAI.Assertion.               #Overwrite SHOULD.FUNC(...):
overwriteMethod(FUNC_STR,     #  - FUNC3() should test it is right type first (if not call original property function):
FUNC2(SUPER)->FUNC3(...))     #      if ( this._obj && this._obj instanceof TYPE )
                              #      { ... } else { SUPER.call(this, ...); }
                              #  - CHAIUTILS.transferFlags(this, SHOULD, BOOL):
                              #     - adds current chain flags to SHOULD (excluding "object" and "message" if false, which is
                              #       usually wanted)
                              #     - to do:
                              #        - usually when final assertion use SHOULD..., and should be influenced by current flags
                              #        - not when final assertion use SHOULD.assert() (not affected by flags)
                              #        - usually not when checking preconditions
CHAI.Assertion.
overwriteProperty
(VARSTR,FUNC2(SUPER)->FUNC3())#Same for SHOULD.VAR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASSERTIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NULL|UNDEFINED ==>            #With .should assertion style:
                              #  - SHOULD works by extending OBJ, so null|undefined will throw TYPERROR with SHOULD.*
                              #  - can use CHAI.should().[not.]exist(VAL)
                              #With expect(...) assertion style:
                              #  - SHOULD.[be.]null|undefined
                              #  - SHOULD.exist: not null nor undefined

SHOULD.be                     #
SHOULD.have[.been]            #
SHOULD...that|which
[.is|has[.been]]              #
SHOULD...and                  #
SHOULD.with|at|of|same|to     #Same as SHOULD (doesn't do anything), provided only for BDD-style syntax

SHOULD.not                    #Negation

SHOULD.equal(VAL)             #===. Compare OBJ by reference.
SHOULD.deep.equal(VAL)        #===. Compare OBJ by copy (doesn't compare prototype)
SHOULD.[be.]like|jsonOf(VAL)  ##==. Compare OBJ by copy (doesn't compare prototype) (module chai-fuzzy 1.5.0)
                              ##jsonOf first does JSON.parse(JSON.stringify(VAL))

SHOULD.[be.]ok                #Is not: STR "", NUM 0, BOOL false, null|undefined
SHOULD_ARR|OBJ.[be.]empty     #Is: STR "", NUM 0, BOOL false, null|undefined, ARR [], OBJ {}
SHOULD.[be.]true|false        #Is BOOL and true|false

SHOULD.[be.]above|[at.]least|
below|[at.]most(NUM)          #> >= < <=
SHOULD.[be.]within(NUM, NUM2) #> and <
SHOULD.[be.]closeTo(NUM, NUM2)#>= NUM-NUM2 and <= NUM+NUM2

SHOULD.[be.a[n]](STR)         #Checks typeof (STR is case insensitive)
SHULD.[be.an.]instanceof(FUNC)#Checks TYPE (prototype)
SHOULD.[be.]arguments         #Is arguments object

SHOULD_ARR|OBJ.               #  - ARR: one element === VAL
include|contain(VAL|OBJ2)     #  - OBJ: members are === subset of OBJ
SHOULD_STR.[have.]string(STR2)#STR2 is inside STR
SHOUD_OBJ.containOneLike(VAL) ##One value of a first-level member of OBJ == VAL, by copy (module chai-fuzzy)
SHOULD_ARR.[deep.]include.
members(ARR2)                 #ARR2 is a subset of ARR (use [deep.]equal)

SHOULD_ARR.include.
some|one|any.item|thing|      ##Like SHOULD_ARR.FUNC(...), but passes if any element of ARR passes
something.FUNC(...)           ##(Node module chai-things 0.2.0)
SHOULD_ARR.all.FUNC(...)      ##Inverse: all element of ARR should pass

SHOULD_OBJ.[have.][deep.]     #Check property exist (if "ownProperty", non-inherited only).
[ownP|p]roperty(VAR_STR[,VAL])#If VAL, same as SHOULD.*(VAR_STR).that.equal(VAL)
[.that[.is]|with...]          #If "deep", VAR can contain indexes and OBJ members, e.g. "VAR[UINT].VAR2" or (for an ARR)
                              #"[UINT][UINT2].VAR"
                              #It also changes the assertion value from OBJ to OBJ[VAR_STR] for the rest of the chain, e.g.
                              #  OBJ.should have.property(...).that.is.true.with.property(...).that.is.false
SHOULD.[be.of.]length[(NUM)]  #Same as OBJ.should.have.property("length"[, NUM])
SHOULD_OBJ|ARR.have|contain.  #Contains those keys (use UINT_STR, starting at 0 for ARR):
any|all.keys(STR[_ARR]...)    #  - "any": at least one of the keys
                              #  - "all" + "contain": all the keys, must can have more
                              #  - "all" + "have": exactly same keys
SHOULD.[itself.]
respondTo(FUNC2_STR)          #Checks if VAR.[prototype.]FUNC2(...) (not prototype if "itself")

SHOULD_STR.match(REGEXP)      #
SHOULD_FUNC().throw
([ERROR|REGEXP|STR])          #
SHOULD.satisfy
(FUNC(VAL)->BOOL)             #
SHOULD_FUNC().change
(OBJ, "VAR")                  #OBJ.VAR should be different before|after FUNC() called
SHULD_FUNC().increase|decrease
(OBJ, "VAR")                  #OBJ.VAR should increase|decrease before|after FUNC() called

SHOULD_DATE.equal|before|
afterTime|Date(DATE2)         ##Module chai-datetime 1.4.0. With "Date": same but truncates after day.

CHAI-JQUERY ==>               ##Only in browser. Should be included. Version 2.0.0
SHOULD_JQ.[have.]attr|prop|
css|data(VAR[, VAL])          ##Checks with JQ.attr|prop|css|data()
SHOULD_JQ.[have.]class(CLASS) ##
SHOULD_JQ.[have.]id(ID)       ##
SHOULD_JQ.[have.]value(VAL)   ##Check with JQ.val()
SHOULD_JQ.match(CSS_SELECTOR) ##Check with JQ.is()
SHOULD_JQ.descendants
(CSS_SELECTOR)                ##Check with JQ.has()
SHOULD_JQ.[have.]
html|text(STR)                ##Check match entirely with JQ.html|text()
SHOULD_JQ.contain(STR)        ##Check match partially with CSS selector :contains(STR)
SHOULD_JQ.[be.]visible|hidden|
selected|checked|enabled|
disabled|empty                ##Check with CSS selector ":visible", etc.
SHOULD_JQ.exist               ##Not of length 0

CHAI-AS-PROMISED ==>          ##All return a CHAIPROMISE (module chai-as-promised 5.0.0), a PROMISE with only then() member.
                              ##To extend it, use CHAI-AS-PROMISED.transferPromiseness = FUNC(SHOULD, PROMISE), where
                              ##FUNC() assign SHOULD.NEWFUNC = PROMISE.FUNC.bind(PROMISE) (this is PROMISE not CHAIPROMISE)
                              ##For wd.js, can do it with:
                              ##  CHAI-AS-PROMISED.transferPromiseness = WD.transferPromiseness;
                              ##So BROWSER.should.eventually returns a BROWSER, not a CHAIPROMISE
                              ##Can also use CHAI-AS-PROMISED.transformAsserterArgs = FUNC(ARR)->ARR, which will modify
                              ##resolved VAL before VAL.should.FUNC2(...) is called.
SHOULD_PROMISE.[be.]fulfilled ##PROMISE should be resolved
SHOULD_PROMISE.eventually.
FUNC2(...)                    ##PROMISE should be resolved and resolve with VAL and VAL.should.FUNC2(...).
SHOULD_PROMISE.become(VAL)    ##Same as SHOULD_PROMISE.eventually.deep.equal(VAL)
SHOULD_PROMISE.[be.]rejected
SHOULD_PROMISE.[be.]
rejectedWith(VAL)             ##PROMISE should be rejected [with VAL]

