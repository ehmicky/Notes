
               
   DENO_BINARY  
               



VERSION ==>                       #See deno doc
                                  #Browser compatible


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            COMPARE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/crypto/timing_safe_equal.ts   #
timingSafeEqual
 (ARRBUFFER|DATAVIEW|TYPEDARR,
 ARRBUFFER|DATAVIEW|TYPEDARR2)    #Compare values.
 ->BOOL                           #Random performance to prevent timing attacks

std/bytes/mod.ts                  #
equals(UINT8ARR, UINT8ARR2)->BOOL #Like STR === STR2 but using UINT8ARR
                                  #Fast


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             FIND              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/mod.ts                  #
indexOfNeedle
 (UINT8ARR, UINT8ARR2[, NUM])     #Like STR.indexOf(STR2) but using UINT8ARR
 ->NUM2                           #Only start search at index NUM (def: 0)
lastIndexOfNeedle(...)            #Same but reverse
includesNeedle
 (UINT8ARR, UINT8ARR2[, NUM])
 ->BOOL                           #Like STR.includes() but using UINT8ARR

starts|endsWith
 (UINT8ARR, UINT8ARR2)->BOOL      #Like STR.starts|endsWith() but using UINT8ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GET/SET            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/encoding/binary.ts            #

TYPE                              #'[u]int8|16|32|64' or 'float32|64'
sizeof('TYPE')->1|2|4|8           #

varnum(UINT8ARR[, OPTS])->NUM|null#Reads a specific TYPE from UINTARR
                                  #null if too large
                                  #OPTS:
                                  #  - type 'TYPE' (def: 'int32')
                                  #  - endian 'big' or 'little' (def)
putVarnum(UINT8ARR, NUM[, OPTS])  #Like varnum() but sets instead
 ->NUM2                           #Returns sizeof('TYPE')
varnumBytes(NUM[, OPTS])->UINTARR #Like varnum() but creates a new UINTARR

varbig(...)                       #Same but:
putVarbig(...)                    #  - returns BIGINT
varbigBytes(...)                  #  - default OPTS.type 'int64'

std/io/slice_long_to_bytes.ts
sliceLongToBytes(NUM[, ARR])->ARR #Convert NUM into an ARR of 8 bytes (big-endian)
                                  #Can pass ARR to re-use it for memory allocation


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             COPY              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/mod.ts                  #
concat(UINT8ARR...)->UINTARR2     #Like STR + STR2 but using UINT8ARR

copy(UINT8ARR, UINT8ARR2[, NUM])  #Copy UINT8ARR bytes onto UINT8ARR2 at offset NUM (def: 0)
 ->NUM2                           #Returns NUM of bytes copied
                                  #  - this is < UINT8ARR.length if UINT8ARR2 was not big enough (at given offset)

repeat(UINT8ARR, NUM)->UINT8ARR2  #Like STR.repeat() but using UINT8ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           AGGREGATE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/mod.ts                  #
new BytesList()                   #BYTE_LIST. Group multiple UINT8ARRs

BYTE_LIST.add
 (UINT8ARR[, NUM[, NUM2]])        #Add a UINT8ARR, from start NUM (def: 0) to end NUM2 (def: end)
BYTE_LIST.getChunkIndex(NUM)->NUM2#Retrieve index of UINT8ARR containing byte at index NUM

BYTE_LIST.concat()->UINT8ARR      #Concatenate all UINT8ARRs
BYTE_LIST.size()->NUM             #Like concat().length
BYTE_LIST.get(NUM)->NUM2          #Like concat()[NUM]
BYTE_LIST.slice(NUM[, NUM2])
 ->UINT8ARR                       #Like concat().slice(...)

BYTE_LIST.iterator([NUM])
 ->ASYNC_ITERATOR                 #Iterate over all UINT8ARRs, starting with index NUM (def: 0)

BYTE_LIST.shift(NUM)              #Drop first NUM bytes
