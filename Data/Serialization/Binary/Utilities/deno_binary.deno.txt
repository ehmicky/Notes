
               
   DENO_BINARY  
               



VERSION ==>                       #See deno doc
                                  #Browser compatible


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            COMPARE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/crypto/timing_safe_equal.ts
timingSafeEqual
 (ARRBUFFER|DATAVIEW|TYPEDARR,
 ARRBUFFER|DATAVIEW|TYPEDARR2)    #Compare values.
 ->BOOL                           #Random performance to prevent timing attacks

std/bytes/equals.ts
equals(UINT8ARR, UINT8ARR2)->BOOL #Like STR === STR2 but using UINT8ARR
                                  #Fast


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             FIND              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/index_of_needle.ts
indexOfNeedle
 (UINT8ARR, UINT8ARR2[, NUM])     #Like STR.indexOf(STR2) but using UINT8ARR
 ->NUM2                           #Only start search at index NUM (def: 0)

std/bytes/last_index_of_needle.ts
lastIndexOfNeedle(...)            #Same but reverse

std/bytes/includes_needle.ts
includesNeedle
 (UINT8ARR, UINT8ARR2[, NUM])
 ->BOOL                           #Like STR.includes() but using UINT8ARR

std/bytes/starts|end_with.ts
starts|endsWith
 (UINT8ARR, UINT8ARR2)->BOOL      #Like STR.starts|endsWith() but using UINT8ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GET/SET            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/encoding/binary.ts            #

TYPE                              #'[u]int8|16|32|64' or 'float32|64'
sizeof('TYPE')->1|2|4|8           #

varnum(UINT8ARR[, OPTS])->NUM|null#Reads a specific TYPE from UINTARR
                                  #null if too large
                                  #OPTS:
                                  #  - type 'TYPE' (def: 'int32')
                                  #  - endian 'big' or 'little' (def)
putVarnum(UINT8ARR, NUM[, OPTS])  #Like varnum() but sets instead
 ->NUM2                           #Returns sizeof('TYPE')
varnumBytes(NUM[, OPTS])->UINTARR #Like varnum() but creates a new UINTARR

varbig(...)                       #Same but:
putVarbig(...)                    #  - returns BIGINT
varbigBytes(...)                  #  - default OPTS.type 'int64'

std/io/slice_long_to_bytes.ts
sliceLongToBytes(NUM[, ARR])->ARR #Convert NUM into an ARR of 8 bytes (big-endian)
                                  #Can pass ARR to re-use it for memory allocation


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             COPY              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/concat.ts
concat(UINT8ARR...)->UINTARR2     #Like STR + STR2 but using UINT8ARR

std/bytes/copy.ts
copy(UINT8ARR, UINT8ARR2[, NUM])  #Copy UINT8ARR bytes onto UINT8ARR2 at offset NUM (def: 0)
 ->NUM2                           #Returns NUM of bytes copied
                                  #  - this is < UINT8ARR.length if UINT8ARR2 was not big enough (at given offset)

std/bytes/repeat.ts
repeat(UINT8ARR, NUM)->UINT8ARR2  #Like STR.repeat() but using UINT8ARR
