
                                  ┏━━━━━━━━━━━━━┓
                                  ┃   JSONATA   ┃
                                  ┗━━━━━━━━━━━━━┛

jsonata (Node module)
Node/browser

Version 2.0.6

JSONATA('QUERY')->QUERY
  - throws on syntax ERROR: code 'CODE', position NUM, token 'CHAR'[, value STR]

QUERY.evaluate(VAL)->>VAL2
  - VAL is $$
  - can throw same ERROR as above, e.g. unknown $FUNC or invalid args

$eval("JSON|JSONATA"[, $])->VAL

On JSON data
If no match, returns undefined, but no error

$$: Initial|root context
%.%: grandparent context (and so on)
%: parent context
$: context. Initially same as $. $.VAR can be shortened as VAR, but not $[...]. Set as left hand inside OBJ.(...), OBJ.{...}, ARR[...], | ... | ... |, etc. I.e. each new part of query creates child contexts

OBJ.VAR
OBJ.`VAR`: escape space (other chars???)
$lookup(OBJ[_ARR], 'VAR')->VAL[_ARR]
OBJ.('VAR'): dynamic
OBJ.(VAL): VAL but using OBJ as $

OBJ.*: all direct values, as ARR
OBJ.**: all deep values, as flattened ARR

OBJ.{KEY: VAL,...}: transforms OBJ

OBJ_ARR{KEY: VAL,...}: groups by KEY, resulting in a single OBJ2 with ARR values (or not ARR if single item, unless using VAL[]). If VAL is {...} or [...] template
  - ARR values are nested ones, i.e. each leaf value is ARR of same length (or not ARR if single item)
  - can avoid this using $.{...} and $.[...] instead
  - difference between using (VAR*VAR2) and $.(VAR*VAR2)???
When grouping, VAL can be $FUNC($.(...)) with ARR argument, to aggregate
Grouping must be last in query

$keys(OBJ[_ARR])->'VAR'_ARR: unique
$spread(OBJ[_ARR])->OBJ2_ARR: each OBJ2 contains single key|value
$merge(OBJ_ARR)->OBJ. Shallow merge
$each(OBJ, FUNC(VAL, 'VAR')->{VAR: VAL})->OBJ2. Maps
OBJ.$sift(FUNC(VAL, 'VAR', OBJ)->BOOL): only include VARs that return true

ARR[NUM]: 0-based. Can be negative (from end). Can be float (rounded down).
ARR[NUM_ARR]
[NUM..NUM2[, ...]]: NUM3_ARR sfrom NUM (included) to NUM2 (included). Can concat several ones using ...
ARR[BOOL]: filters. Does not return as ARR2 if single match. Arg typecast to BOOL

OBJ_ARR^(VAL,...): order by VAL. VAL is EXPR using each OBJ as $. Values must be STR|NUM. Can precede VAR with < (asc, def) or > (desc)

ARR...: other operators iterate over each item, and result is an ARR2.
(ARR): prevents iteration, i.e. use a whole

Single item ARRs converted to non-ARRs
VAL[]: wrap as single item ARR if not already an ARR

ARR...: If not ARR, converted to single-item ARR.
$FUNC(ARR, ...): same???
ARR.$FUNC(...): same

Empty ARR converted to undefined???

ARR_ARR flattened automatically
ARR.[...]: like ARR.... but does not flatten, if results in ARR_ARR

ARR.$count()->NUM: length
ARR.$concat(VAL[_ARR]): concat
$distinct(ARR)->ARR2: only keep unique values
$reverse(ARR)->ARR2
$shuffle(ARR)->ARR2
$sort(ARR[, FUNC(VAL, VAL2)->BOOL])->ARR2: def FUNC is > (i.e. ARR must STRs or NUMs)
$zip(ARR,...)->ARR2: ARR2[m][n] is args[n][m]

$map(ARR, FUNC(VAL, NUM, ARR)->VAL)->ARR2
$filter(ARR, FUNC(VAL, NUM, ARR)->BOOL)->ARR2
$single(ARR, FUNC(VAL, NUM, ARR)->BOOL)->VAL: like $filter(...)[0] but throws if more than one match
$reduce(ARR, FUNC(MEMO, VAL, NUM, ARR)->MEMO[, MEMO])->ARR2. Def MEMO: first VAL

BOOL|STR|NUM|null|OBJ|ARR: same format as JSON. Superset of JSON
'STR': same as "STR" except must escape " instead of '

/* COMMENT */: can be inline

(VAL): operator precedence
  - . before [], i.e. must do (ARR[0]).VAR???
  - uses precedence not left to right, i.e. must do (OBJ_ARR^(VAL,...)).VAR???
  - precedence: . [] ^ # @ grouping
(VAL;...): evaluates all VALs, returns last one
  - e.g. VAL can be $VAR assignment
  - including in OBJ.(VAL;...)

$type(VAL)[->STR]. 'null|number|string|boolean|array|object|function' or undefined

$exists(VAL)->BOOL: not undefined

VAL = != VAL2. Deep equal
VAL in ARR

BOOL and BOOL2
BOOL or BOOL2
$not(BOOL): typecast to BOOL
BOOL ? VAL : VAL2. typecast to BOOL
$boolean(VAL)->BOOL: false if false, empty STR|ARR|OBJ, 0, null, FUNC, ARR with only falsy values

VAL & VAL2: STR concat. Typecast to STR with $string()
STR < <= > >= STR2: by Unicode codepoint
VAL.$string([BOOL])->STR:
  - Inf|NaN: error
  - FUNC: empty STR
  - else: JSON.stringify(VAL)
     - if BOOL true (def false): JSON.stringify(VAL, null, 2)
STR.$length()->NUM: NUM of chars
$contains(STR, STR2)->BOOL
STR.$substring(NUM[, NUM2])->STR2: from index NUM (included) (can be negative from end), for NUM2 chars (def all)
STR.$substringBefore(STR2)->STR3: from beginning to first occurence of STR2 (excluded) (if any)
STR.$substringAfter(STR2)->STR3: from first occurence of STR2 (excluded) (if any) to end
STR.$uppercase|$lowercase()->STR2
STR.$trim()->STR2: trim whitespaces. Also squash multiple whitespaces into single spaces.
STR.$pad(NUM[, 'CHAR']): pad to right (of left if NUM negative), if needed, using CHAR (def: space)
STR.$split(STR2|REGEXP[, NUM])->STR3_ARR: STR2 can be empty, to split char by char. NUM truncates resulting ARR length
STR_ARR.$join([STR2])->STR3: def STR3 is ''

VAL.$number()->NUM
  - 'NUM' -> NUM
  - BOOL -> 0|1
  - else error
$formatBase(NUM[, NUM2])->STR. NUM2 is radix (def 10)
$parseInteger(STR, 'FORMAT')->INT
$formatNumber(NUM, 'FORMAT'[, OBJ])->STR. FORMAT|OBJ: see online doc???
$formatInteger(INT, 'FORMAT')->STR

NUM + - * / % NUM2
NUM < <= > >= NUM2
NUM.$power(NUM2)->NUM3
NUM.$sqrt()->NUM2
$abs(NUM)->NUM2
NUM.$floor|$ceil()->NUM2
$round(NUM[, NUM2])->NUM3: NUM2 is number of decimals (can be negative).
$random()->NUM: 0 to 1, pseudo-random

(...): creates scope for $VARs. Including OBJ.(...)
$VAR := VAL: assignment
$VAR: using
ARR#$VAR: assigns $VAR := ARR item's index NUM in ARR
ARR@$VAR: assigns $VAR := ARR item's VAL. Last operator must have been . (dot)
What if unknown $VAR???
QUERY.evaluate(..., {VAR: VAL, ...})
QUERY.assign('VAR', VAL)

function($ARG,...) [TYPES] { VAL;... }: FUNC value. Can be assigned to $VAR. Can be passed as argument. Can be called as anonymous FUNC. Uses lexical scoping and closure, i.e. can use outer scope's $VAR, including $.
Can be recursive. Can use tail call optimization
VAL.$FUNC(...)
  - when FUNC uses `this`
  - possible with every builtin FUNC, even when not documented???
  - can always also run as $FUNC(VAL, ...)
TYPES is <T...:T> where first part is concatenation of ARG types, and second is return type. E.g. <a(an):n>
T is:
  - one of l (null), b (BOOL), n (NUM), s (STR), a (ARR) o (OBJ), f (FUNC), u (any but ARR|OBJ|FUNC), j (any but FUNC), x (any)
  - a<T> (ARR of T)
  - (T...): union (or)
  - T?: optional
  - T+: variadic (>=1)
  - T-: `this`, in first arg only
   - VAL can be ?, to bind other arguments, returning a new FUNC2
VAL ~> $FUNC[(...)]: same as $FUNC(VAL, ...)
$FUNC ~> $FUNC2[(...)]: same as function(...) { $FUNC2($FUNC(...), ...) }

QUERY.registerFunction('FUNC', FUNC[, '<TYPES>'): same as QUERY.assign() except can specify TYPES

| QUERY | OBJ[, "PROP"[_ARR]] |
  - FUNC(OBJ2) which returns OBJ2.QUERY but with:
    - $merge() of OBJ
    - deletions of PROPs
  - $ in OBJ and "PROP" is relative to OBJ2.QUERY, which all is ws transforming instead of just setting
  - usually called as OBJ2 ~> | QUERY | OBJ |

"DATE": "YYYY-MM-DDThh:mm:ssZ"
$now() and $millis(): same DATE inside same expression (not outside of (...)???)
$now(['FORMAT'[, 'TZ']])->"DATE"
$millis()->DATE_NUM (Epoch in ms)
$fromMillis(DATE_NUM[, 'FORMAT'[, 'TZ']])->'DATE'. FORMAT undocumented for the moment. Def TZ UTC. Def FORMAT same as above (ISO 8601)
$toMillis('DATE'[, 'FORMAT'])->DATE_NUM

/REGEXP/[FLAGS]: REGEXP. Not a STR, i.e. no quotes. FLAGS i or m.
REGEXP is actually a FUNC, as follows. FUNCs that expect REGEXP as argument can pass a FUNC2 with same signature instead, i.e. custom REGEXP "class".
REGEXP(STR)[->OBJ]
STR ~> REGEXP: Returns undefined if no matches. Else returns next match OBJ:
  - match STR
  - start|end NUM
  - groups STR_ARR: (?<...>) groups
  - next FUNC(): recursion for next item
STR.$match(REGEXP[, NUM])->OBJ_ARR: same logic, iterating until end. NUM truncates resulting ARR length
STR.$contains(REGEXP)->BOOL
STR.$replace(STR2|REGEXP, STR3|FUNC(OBJ)->STR4[, NUM]): replace all. NUM truncates NUM of replacements. STR3 can use $0 (whole match), $NUM (parenthesis groups), $$ (escaped $). OBJ is same as for $match()

$min|max(NUM_ARR)->NUM2
$sum|average(NUM_ARR)->NUM2

$base64encode|decode(STR)->STR2
$encode|decodeUrl[Component](STR)->STR2

$error('MESSAGE'): throw error

Everything can be an EXPR, in principle. Including KEYs or [BOOL]. See which case might not be??? E.g. ARR[1 + 1]
ARR|OBJ: can contain EXPRs as keys|values. This allows templating

==CLI==

Alternatives:
  - jfq: more features. Better maintained. More high profile
  - jsonata-cli

Version 1.2.11

jfq ['QUERY'] [PATH...]: def QUERY '$'. $ value is PATH (def: stdin), as JSON. If multiple $ values, each is evaluated and its result printed. Evaluates QUERY and print its result
--query-file|-q PATH to QUERY (instead of argv)
--accept-yaml|-a: input YAML instead
--json|-j: unless set, if result is STR, printed as is (not JSON), and if result is STR_ARR|NUM_ARR, printed as newline-separated list (not JSON)
--ndjson|-n: outout one JSON VAL per line, instead of prettifying each JSON VAL over multiple lines
--yaml|-y: output YAML
--plain-text|-p: no colors

VSCode extension: exists for JSONata

https://github.com/Stedi/prettier-plugin-jsonata

Compare with jq???

Add alternatives with jsonpath, jmespath, etc.???

https://docs.aws.amazon.com/step-functions/latest/dg/transforming-data.html#jsonata-functions-provided-by-sfn
  - document in "TODO" in Step Functions doc
