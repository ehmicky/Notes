
                                  ┏━━━━━━━━━━━━━━┓
                                  ┃   JMESPATH   ┃
                                  ┗━━━━━━━━━━━━━━┛

ALTERNATIVES ==>                  #???

VERSION ==>                       #2024-10-05

JSON ==>                          #Values are JSON only

'...'                             #STR, as is
                                  #' and \ must be \-escaped
                                  #No backslash sequence
                                  #No C0 control chars

`...`                             #Any JSON value
                                  #` must be escaped as \u0060

VAR                               #If no [:alnum:]_, must "-quoted
                                  #If "-quoted, can use JSON backslash sequence like \n or \uUUUU

null                              #Result if either:
                                  #  - no value found, or out-of-bound
                                  #  - EXPR has wrong type, e.g. using a slice on an OBJ
                                  #  - using an EXPR|operator on undefined|null value

EXPR                              #Chainable. List is below

PROJECTION ==>                    #When result of EXPR is an OBJ|ARR, subsequent EXPRs in the chain iterate over each member|item

@                                 #Current OBJ
                                  #At the beginning, it is the root
                                  #In sub-EXPR or in FUNC arguments, it is the previous EXPR
                                  #It is implied, i.e. can always omit @[.]
                                  #  - e.g. [0][?a == 1] instead of @[0][?@.a == 1]

EXPR | EXPR2                      #Like EXPR2, but @ is EXPR
                                  #Similar to just chaining except no projection
                                  #  - e.g. if EXPR contains *, EXPR2 does not iterate over each item

OBJ_EXPR.VAR                      #
OBJ_EXPR.*                        #All OBJ members

ARR_EXPR[NUM]                     #NUM is 0-based, can be negative (from end)
ARR_EXPR[*]                       #All ARR items
ARR_EXPR[]                        #Same but flattens sub-ARRs
ARR_EXPR[[NUM]:[NUM2][:[NUM3]]]   #Sliced ARR
                                  #NUM|NUM2: def start|end, negative NUM is from end
                                  #NUM3 is step: def 1, negative NUM reverses

OBJ[_ARR]_EXPR.[EXPR,...]         #ARR with items EXPR
OBJ[_ARR]_EXPR.{VAR: EXPR,...}    #OBJ with keys VAR and values EXPR

OBJ_ARR_EXPR[?EXPR OP EXPR2]      #OBJ_ARR, filtered
                                  #OP is:
                                  #  - == != for any type (deep comparison)
                                  #  - < <= >= > for NUM only

EXPR || && EXPR2                  #Either BOOL logic, or chaining
!EXPR                             #EXPR is transtyped to BOOL with false for empty ARR|OBJ|STR and null
(EXPR)                            #Parenthesis for operator priority

FUNC(EXPR,...)                    #For all the FUNCs below
                                  #EXPR's type is FUNC-specific
                                  #Some FUNCs take &EXPR as argument, which is lazily evaluated, similar to a JavaScript FUNC
EXPR.FUNC(EXPR,...)               #Same but @ is EXPR

not_null(VAL,...)->VAL            #First VAL not null. Else returns null
to_array(VAL)->ARR                #If VAL is not ARR, returns [VAL]
to_string(VAL)->STR               #If VAL is not STR, returns JSON.stringify(VAL)
to_number(VAL)->NUM               #If VAL is not NUM or 'NUM', returns null

type(VAL)->'null|string|boolean|
 number|array|object'             #

abs(NUM)->NUM                     #
ceil(NUM)->NUM                    #
floor(NUM)->NUM                   #

avg(NUM_ARR)->NUM                 #
sum(NUM_ARR)->NUM                 #

min(NUM_ARR|STR_ARR)->NUM|STR     #
max(NUM_ARR|STR_ARR)->NUM|STR     #
min_by(NUM_ARR|STR_ARR, &EXPR)
 ->NUM|STR                        #
max_by(NUM_ARR|STR_ARR, &EXPR)
 ->NUM|STR                        #

contains(ARR|STR, VAL)->BOOL      #

starts_with(STR, STR2)->BOOL      #
ends_with(STR, STR2)->BOOL        #

join(STR, STR2_ARR)->STR3         #

keys(OBJ)->STR_ARR                #Unordered
values(OBJ)->ARR                  #Unordered

length(OBJ|ARR|STR)->NUM          #STR length is in code points

merge(OBJ,...)->OBJ2              #Deep merge

reverse(ARR|STR)->ARR2|STR2       #

sort(NUM_ARR|STR_ARR)->ARR2       #
sort_by(NUM_ARR|STR_ARR, &EXPR)
 ->ARR2                           #

map(&EXPR, ARR)->ARR2             #
