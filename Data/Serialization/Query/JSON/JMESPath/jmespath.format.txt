
                                  ┏━━━━━━━━━━━━━━┓
                                  ┃   JMESPATH   ┃
                                  ┗━━━━━━━━━━━━━━┛

ALTERNATIVES ==>                  #???

VERSION ==>                       #2024-10-05

JSON ==>                          #Values are JSON

OBJ.VAR                           #

ARR[NUM]                          #

ARR[*]                            #All ARR members
ARR[*].ARR[]                      #Like ARR[*].ARR[*], but flattened

ARR[[NUM]:[NUM2]:[STEP]]          #Slice
                                  #Def: start, end, 1
                                  #Can be negative NUM (from end)

OBJ_ARR[?VAR==`STR|NUM`]          #FILTER
                                  #== can also be != <= < > >=

OBJ[_ARR].[VAR,...]               #Each OBJ.VAR, as ARR
                                  #VAR can be FILTER

OBJ[_ARR].{NEW:OLD,...}           #Like OBJ.OLD, but rename to OBJ.NEW
                                  #OLD can be FILTER

FILTER | FILTER2                  #Pipe

abs(NUM)->NUM                     #
ceil(NUM)->NUM                    #
floor(NUM)->NUM                   #

avg(NUM_ARR)->NUM                 #
sum(NUM_ARR)->NUM                 #
min(NUM_ARR)->NUM                 #
max(NUM_ARR)->NUM                 #

contains(ARR|STR, STR2)->BOOL     #

starts_with(STR, STR2)->BOOL      #
ends_with(STR, STR2)->BOOL        #

join(STR, ARR)->STR2              #

keys(OBJ)->STR_ARR                #
values(OBJ)->ARR                  #

length(OBJ|ARR|STR)->NUM          #

reverse(ARR)->ARR2                #
sort(ARR)->ARR2                   #
sort_by(ARR, FILTER)->ARR2        #

EXPR

VAR: [:alnum:]_
"VAR": can use JSON backslash sequence like \n or \uUUUU

EXPR.VAR
EXPR.[...]
EXPR.{...}
EXPR.*
EXPR.FUNC(...)

EXPR[NUM]
EXPR[]
EXPR[*]
EXPR[[NUM]:[NUM2]:[NUM3]]
EXPR[?"EXPR"]
[...]: like EXPR[...]

(EXPR)

EXPR == != < <= >= > EXPR2

EXPR || && EXPR2

EXPR | EXPR2






















