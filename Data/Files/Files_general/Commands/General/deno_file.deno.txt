
             
   DENO_FILE  
             




VERSION ==>                       #See deno doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERAL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Blob
File
FileReader                        #Like DOM

FILE|Deno.*Sync(...)
ensureFileSync(...)
ensureSymlinkSync(...)
ensureLinkSync(...)
ensureDirSync(...)
moveSync(...)                     #Same but sync
                                  #For all but: umask|watchFs

Deno.fstat|ftruncate|futime       #Like Deno.stat|truncate|utime(UPATH, ...) but with a RID
 (RID, ...)                       #Does not require permission, since it is already checked when opening the RID


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             OPEN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Deno.FsFile(RID)              #FILE. Inherits CLOSER|READER[_SYNC]|WRITER[_SYNC]
                                  #Ref'd by the process
FILE.rid                          #RID
FILE.readable                     #RSTREAM
FILE.writable                     #WSTREAM

Deno.open(UPATH[, OPTS])->>FILE   #Open a FILE.
                                  #OPTS:
OPTS.read                        R#BOOL (def: true). Read access
OPTS.write                       W#BOOL (def: false). Write access
OPTS.append                      W#BOOL (def: false). Write access + append
OPTS.truncate                     #BOOL (def: false). Truncate file
                                  #Requires OPTS.write true
OPTS.create                       #BOOL (def: false). On non-existing file, create it instead of throwing
                                  #Requires OPTS.write|append true
OPTS.createNew                    #BOOL (def: false). On existing file, throw
                                  #Requires OPTS.write|append true
OPTS.mode                         #NUM (def: 0o666 + umask). Does chmod if file is created
                                  #Not on Windows
                                  #Follows symlinks.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CREATE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.create(UPATH)->>FILE       RW#Creates file. If already exists, truncates it

Deno.makeTempFile([OPTS])        W#Create a temp file.
 ->>'PATH'                        #Filename is 8 random hex chars.
OPTS.dir                          #'DIR'. Def: ENVVAR TMPDIR, or system default (/tmp on Linux)
                                  #Return 'PATH' is relative or absolute (def) depending on whether 'DIR' is
OPTS.prefix|suffix                #STR (def: ''). To the filename
Deno.makeTempDir([OPTS])->>'PATH'W#Same with a temp DIR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ENSURE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/fs/ensure_file.ts
ensureFile(UPATH)->>            WR#If UPATH does not exist, creates it empty
                                  #Throws if UPATH exists but is not a regular file, or if parent is not a DIR
                                  #Throws if new file's parent is not a DIR
                                  #Creates parent DIRs
std/fs/ensure_dir.ts
ensureDir(DIR_UPATH)->>         WR#If DIR does not exist, creates it empty
                                  #Throws if UPATH exists but is not a DIR
                                  #Throws if new file's parent is not a DIR
                                  #Creates parent DIRs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            DELETE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FILE.truncate([NUM])->>           #
Deno.truncate(UPATH[, NUM])->>   W#Truncate file to NUM (def: 0) bytes. If larger, filled with \0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MOVE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.rename(UPATH, UPATH2)->>   RW#Rename file|DIR

std/fs/move.ts
move(UPATH, UPATH2[, OPTS])->>  WR#Like Deno.rename() except:
                                  #  - throws if UPATH2 exists unless OPTS.overwrite true (def: false)
                                  #  - throw SubdirectoryMoveError if UPATH === UPATH2 or is a parent


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LINKS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SYMLINKS ==>                      #Unless the operation is about symlinks, symlinks are usually followed

Deno.readLink(UPATH)->>'PATH'    R#Return symlink destination. Throw if not symlink
Deno.realPath(UPATH)->>'PATH'    R#Normalize PATH: follow symlinks, absolute path

Deno.link
 (OLD_UPATH, NEW_UPATH)->>      RW#Create hard link
Deno.symlink(OLD_UPATH,         RW#Create symlink
 NEW_UPATH[, OPTS])->>            #OPTS:
                                  #  - type 'file' (def) or 'dir' (Windows only)

std/fs/ensure_link.ts
ensureLink(UPATH, UPATH2)->>    WR#If UPATH2 does not exist, creates it as a hard link to UPATH
                                  #Throws if UPATH does not exist
                                  #Throws if UPATH2 exists, unless it is a hard link to UPATH
                                  #Throws if new file's parent is not a DIR
                                  #Creates parent DIRs
std/fs/ensure_symlink.ts
ensureSymlink(UPATH, UPATH2)->> WR#If UPATH2 does not exist, creates it as a symlink pointing to UPATH
                                  #Throws if UPATH does not exist
                                  #Noop if UPATH2 exists
                                  #Throws if new file's parent is not a DIR
                                  #Creates parent DIRs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             READ              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.readFile                    R#Read FILE contents.
 (UPATH[, OPTS])->>UINT8ARR       #OPTS:
                                  #  - signal ABORT_SIGNAL
                                  #If DIR, returns empty UINT8ARR
Deno.readTextFile
 (UPATH[, OPTS])->>STR            #Same with STR (UTF-8) instead of UINT8ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             WRITE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.writeFile(UPATH,            W#Write FILE contents.
 UINT8ARR|RSTREAM[, OPTS])->>     #OPTS:
                                  #  - signal ABORT_SIGNAL
                                  #  - create BOOL (def: true): like Deno.open()
                                  #  - append|createNew|mode: like Deno.open()
Deno.writeTextFile
 (UPATH, STR|RSTREAM[, OPTS])->>  #Same with STR (UTF-8) instead of UINT8ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LIST              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.readDir(DIR_UPATH)
 ->DIR_ENTRY_ASYNC_ITERABLE      R#List DIR files
DIR_ENTRY.name                    #'FILENAME'
DIR_ENTRY.isFile|Directory|Symlink#Like FILE_INFO.*


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           METADATA            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FILE.stat()->>FILE_INFO           #
Deno.[l]stat(UPATH)->>FILE_INFO  R#Follows symlinks unless "lstat"
FILE_INFO.ino                     #Inode NUM. null on Windows.
FILE_INFO.dev                     #Partition NUM that current file belongs to. Cross-OS
FILE_INFO.rdev                    #Partition NUM if current file is that partition. null on Windows
FILE_INFO.size                    #NUM (in bytes). Cross-OS
FILE_INFO.blocks                  #NUM (in blocks) allocated. null on Windows
FILE_INFO.blksize                 #NUM of bytes per block in current filesystem. null on Windows
FILE_INFO.mtime|atime|birthtime   #DATE. Cross-OS. Can be null for multiple reasons
FILE_INFO.uid|gid                 #NUM. null on Windows
FILE_INFO.nlink                   #NUM of hard links (in addition to self). null on Windows
FILE_INFO.mode                   !#Or'd NUM with permissions and file type. null on Windows
FILE_INFO.isFile|Directory|Symlink#BOOL. Mutually exclusive. Cross-OS
                                  #Can be all false, e.g. for block|character device, including stdin|stdout|stderr

Deno.utime(UPATH,
 DATE[_NUM], DATE2[_NUM])->>     W#Change atime|mtime. DATE_NUM is in secs.

Deno.chmod(UPATH, NUM)->>        W#Change file permission. Throws on Windows
Deno.chown(UPATH, UID, GID)->>   W#Change UID|GID NUM or null (no change). Throws on Windows

Deno.umask([NUM])->NUM2          !#Set process umask to NUM (def: same).
                                  #Return umask before being set.
                                  #Throws on Windows


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             LOCK              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.flock(RID[, BOOL])->>       !#Acquire lock on RID.
                                  #BOOL (def: false) is whether lock is exclusive, as opposed to shared, to a single process.
                                  #Waits if either:
                                  #  - another process has an exclusive lock
                                  #  - another process has a shared lock, and current process wants an exclusive lock
                                  #Based on underlying syscall flock.
                                  #It is advisory-only: it only works if other processes also acquire lock with flock.
Deno.funlock(RID)->>             !#Release lock
