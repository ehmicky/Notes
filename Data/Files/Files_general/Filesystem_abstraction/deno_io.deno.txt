
           
   DENO_IO  
           



VERSION ==>                       #See deno doc
                                  #Browser compatible except readShort|Int|Long|Varnum|Varbig(), readExact|getNBytes(), readRange[Sync]()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MAIN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TextDecoder|Encoder[Stream]       #Like DOM

CLOSER|READER|WRITER|SEEKER       #Abstract class to implement
std/types.d.ts                    #Has Closer|Reader[Sync]|Writer[Sync] types

CLOSER.close()                    #Close underlying RESOURCE

READER.read(UINT8ARR)->>NUM|null  #Reads available bytes from underlying RESOURCE and writes them into UINT8ARR.
                                  #Usually does not wait i.e. might read:
                                  #  - 0 bytes
                                  #  - less than UINT8ARR.length
                                  #     - rest of UINT8ARR might be used for internal purposes though
                                  #Only read up to UINT8ARR.length bytes.
                                  #Returns NUM of bytes read, or null if EOF

WRITER.write(UINT8ARR)->>NUM      #Reads all of UINT8ARR and writes it to underlying RESOURCE.
                                  #Returns UINT8ARR.length

SEEKER.seek(NUM|BIGINT, ENUM)     #Changes position used by READER.read() and WRITER.write()
 ->>NUM2                          #NUM|BIGINT is relative offset in bytes
                                  #ENUM is reference position among Deno.Seeker.Start|Current|End
                                  #Before-start position is error. After-end position is implementation-dependent.
                                  #NUM2 is new position.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BUFFER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/buffer.ts                  #
new Buffer                        #UINT8ARR that:
 ([ARRAYLIKE|ARRBUFFER|TYPED_ARR])#  - keeps track of read offset
                                  #  - can decrease|increase size
                                  #If argument passed, sets its contents

BUFFER.capacity                   #NUM of bytes read|unread
BUFFER.length                     #NUM of bytes unread
BUFFER.empty()->BOOL              #BUFFER.length === 0

BUFFER.bytes([OPTS])->UINTARR     #Retrieve underlying UINTARR
                                  #If OPTS.copy true (def), return a copy of it instead of a reference

BUFFER.grow(NUM)                  #Increase BUFFER.length to at least NUM bytes
BUFFER.truncate(NUM)              #Decrease BUFFER.length to exactly NUM bytes, erasing data
BUFFER.reset()                    #Like BUFFER.truncate(0)

BUFFER.readSync(UINT8ARR)         #Inherited from READER
 ->NUM|null                       #Reads and moves the read offset
                                  #Automatically call BUFFER.reset() when done reading to free memory
BUFFER.writeSync(UINT8ARR)->NUM   #Inherited from WRITER
                                  #Writes and BUFFER.grow() if needed
BUFFER.read(UINT8ARR)->>NUM|null
BUFFER.write(UINT8ARR)->>NUM      #Same but artificially async. Prefer sync.

BUFFER.readFrom(READER)->>NUM     #Append READER data onto BUFFER
                                  #Call BUFFER.grow() when needed
                                  #Returns NUM of bytes appended
BUFFER.readFromSync(READERSYNC)
 ->NUM                            #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/string_reader.ts           #
new StringReader(STR)             #Like BUFFER, except initialized with a STR instead

std/io/string_writer.ts           #
new StringWriter([STR])           #If STR, passed to writeSync()
STRING_WRITER.writeSync
 (UINT8ARR)->NUM                  #Add a chunk
STRING_WRITER.write
 (UINT8ARR)->>NUM                 #Same but artificially async. Prefer sync.
STRING_WRITER.toString()->STR     #Returns all chunks concatenated. Does not reset them.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          BUF_READER           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/buf_reader.ts              #
new BufReader(READER[, NUM])      #READER with a buffer, i.e. an UINT8ARR buffering bytes returned by READER.read()
                                  #NUM is buffer size (def: 4096, min: 16)
BufReader.create(READER[, NUM])
 ->BUF_READER                     #Like new BufReader(...) except return READER as is if it is already a BUF_READER

BUF_READER.size()->NUM            #Buffer total size
BUF_READER.buffered()->NUM        #Buffer's bytes left to read
BUF_READER.reset(READER)          #Changes READER

BUF_READER.readByte()->>NUM|null  #Reads from the buffer 1 byte
                                  #Returns null if EOF
                                  #If the buffer has no more bytes to read, first fills it with exactly one READER.read()
std/io/read_short.ts
readShort(BUF_READER)->>NUM|null  #Same but reads 2 bytes, returned as NUM (big endian)
                                  #Throws Deno.errors.UnexpectedEof if READER is not EOF but has <2 bytes available
std/io/read_int.ts
readInt(BUF_READER)->>NUM|null    #Same with 4 bytes
std/io/read_long.ts
readLong(BUF_READER)->>NUM|null   #Same with 8 bytes
                                  #Throws if > Number.MAX_SAFE_INTEGER

BUF_READER.read(UINT8ARR)         #Inherited from READER
 ->>NUM|null                      #Reads from the buffer at most UINT8ARR.length bytes
                                  #Returns null if EOF, NUM of bytes read otherwise
                                  #If the buffer has no more bytes to read, first fills it with exactly one READER.read()
                                  #If UINT8ARR is larger than buffer, skip buffer and do exactly one READER.read()
BUF_READER.readFull(UINT8ARR)     #Same as read() but with exactly UINT8ARR.length bytes
 ->>UINT8ARR|null                 #Does so with multiple BUF_READER.read(UINT8ARR)
                                  #Throws PartialReadError if READER is not EOF but has < UINT8ARR.length bytes available
                                  #Returned UINT8ARR is same as argument

BUF_READER.peek(NUM)              #Reads from the buffer until either:
 ->>UINT8ARR|null                 #  - NUM bytes read
                                  #  - EOF after reading some bytes
                                  #Returns null if EOF (before reading any bytes)
                                  #Unlike other methods, does not move the read offset
                                  #If the buffer needs more bytes to read, fills it with exactly one READER.read()
                                  #Throws BufferFullError if NUM > BUF_READER.size()

BUF_READER.readSlice(NUM)         #Reads from the buffer until either:
 ->>UINT8ARR|null                 #  - byte with value NUM is found
                                  #  - EOF after reading some bytes
                                  #Returns null if EOF (before reading any bytes)
                                  #If the buffer needs more bytes to read, fills it with exactly one READER.read()
                                  #Throws BufferFullError if could not find byte NUM nor EOF in the next BUF_READER.size() bytes

PARTIAL_READ_ERROR
 |BUFFER_FULL_ERROR.partial       #UINT8ARR2 with bytes read so far


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             RANGE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/read_range.ts              #
readRange(READER_SEEKER, OBJ)     #Read READER from offset OBJ.start NUM (included) to OBJ.end NUM (included)
 ->>UINT8ARR                      #Does in in chunks of 32KB
readRangeSync
 (READER_SEEKER_SYNC, OBJ)
 ->UINT8ARR                       #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          DELIMITERS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/buf_reader.ts              #
BUF_READER.readString('CHAR')
 ->>STR|null                      #Like BUF_READER.readSlice() but using a 'CHAR' and returning a UTF8 STR
BUF_READER.readLine()->>OBJ|null  #Like BUF_READER.readSlice() except:
                                  #  - use \n or \r\n
                                  #     - stripped from return value
                                  #  - returns OBJ.more true instead of throwing BufferFullError
                                  #Returned OBJ: line UINT8ARR, more BOOL

std/io/read_delim.ts
readDelim(READER, UINT8ARR)
 ->UINT8ARR2_ASYNC_ITERABLETOR    #Iterate over READER's chunks, delimited by UINT8ARR

std/io/read_string_delim.ts
readStringDelim
 (READER, STR[, TEOPTS])
 ->STR_ASYNC_ITERABLETOR          #Same but using a STR

std/io/read_lines.ts
readLines(READER[, TEOPTS])
 ->STR_ASYNC_ITERABLETOR          #Iterate over READER's lines, delimited by LF|CRLF
TEOPTS                            #encoding|fatal|ignoreBOM passed to TextDecoder()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           READ ALL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/encoding/binary.ts            #
readExact(READER, UINT8ARR)->>    #Like READER.read(UINT8ARR) but repeats it until UINT8ARR.length bytes read
getNBytes(READER, NUM)->>UINT8ARR #Like readExact(READER, new Uint8Array(NUM))


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            COMBINE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/multi_reader.ts
new MultiReader(READER_ARR)       #Like READER, except read concatenation of READERs, one at a time

std/io/limited_reader.ts
new LimitedReader(READER, NUM)    #Like READER, except EOF after NUM bytes read


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           ITERABLE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/streams/
 reader_from_iterable.ts          #
readerFromIterable                #Turn READER into [ASYNC_]ITERABLE
 (UINT8ARR_[ASYNC_]ITERABLE)      #Create a READER with read() iterating over ITERABLE
 ->READER                         #If iterated value < READER's size:
                                  #  - do not do another iteration
                                  #  - i.e. READER.read(UINT8ARR) returns NUM that is < UINT8ARR.length
                                  #If iterated value > READER's size:
                                  #  - buffer it
                                  #  - i.e. spread over multiple READER.read()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          BUF_WRITER           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/buf_writer.ts              #
new BufWriter(WRITER[, NUM])      #WRITER with a buffer, i.e. a UINT8ARR buffering bytes to pass to WRITER.write()
                                  #NUM is buffer size (def: 4096, min: 1)
BufWriter.create(WRITER[, NUM])
 ->BUF_WRITER                     #Like new BufWriter(...) except return WRITER as is if it is already a BUF_WRITER

BUF_WRITER.size()->NUM            #Buffer total size
BUF_WRITER.buffered()->NUM        #Buffer's bytes not written yet
BUF_WRITER.available()->NUM       #Buffer's bytes, excluding bytes not written yet
BUF_WRITER.reset(WRITER)          #Changes WRITER

BUF_WRITER.write(UINT8ARR)->>NUM  #Inherited from WRITER
                                  #Writes all of UINT8ARR to the buffer
                                  #If buffer is full, call BUF_WRITER.flush()
                                  #If UINT8ARR is larger than buffer, skip buffer and do multiple WRITER.write()
                                  #Returns UINT8ARR.length
BUF_WRITER.flush()->>             #Writes the buffer to WRITER using multiple WRITER.write()
                                  #Resets the buffer

new BufWriterSync(...)            #Same but sync, using a WRITERSYNC


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           WRITE ALL           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/streams/write_all.ts          #
writeAll(WRITER, UINT8ARR)->>
writeAllSync(WRITER_SYNC,UINT8ARR)#Write all bytes

std/io/copy_n.ts                  #
copyN(READER, WRITER, NUM)->>NUM2 #Copy at most NUM bytes from READER to WRITER
                                  #Does it in chunks of 32KB
                                  #Returns NUM2 of bytes written, i.e. of available bytes in READER
