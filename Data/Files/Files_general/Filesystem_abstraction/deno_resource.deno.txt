
                 
   DENO_RESOURCE  
                 



VERSION ==>                       #See deno doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MAIN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TextDecoder|Encoder[Stream]       #Like DOM

RESOURCE                          #Abstraction of a file, including socket, etc.
                                  #Usually ref'd by the process

CLOSER|READER|WRITER|SEEKER       #Abstract class to implement
std/types.d.ts                    #Has Closer|Reader[Sync]|Writer[Sync] types

CLOSER.close()                    #Close underlying RESOURCE

READER.read(UINT8ARR)->>NUM|null  #Reads available bytes from underlying RESOURCE and writes them into UINT8ARR.
                                  #Usually does not wait i.e. might read:
                                  #  - 0 bytes
                                  #  - less than UINT8ARR.length
                                  #     - rest of UINT8ARR might be used for internal purposes though
                                  #Only read up to UINT8ARR.length bytes.
                                  #Returns NUM of bytes read, or null if EOF

WRITER.write(UINT8ARR)->>NUM      #Reads all of UINT8ARR and writes it to underlying RESOURCE.
                                  #Returns UINT8ARR.length

SEEKER.seek(NUM|BIGINT, ENUM)     #Changes position used by READER.read() and WRITER.write()
 ->>NUM2                          #NUM|BIGINT is relative offset in bytes
                                  #ENUM is reference position among Deno.Seeker.Start|Current|End
                                  #Before-start position is error. After-end position is implementation-dependent.
                                  #NUM2 is new position.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          DESCRIPTOR           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RID                               #RESOURCE ID NUM. Abstraction of a file descriptor.

Deno.close(RID)
Deno.read(RID, ...)
Deno.write(RID, ...)
Deno.seek(RID, ...)               #Same but on a RID



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SYNC              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.fdatasync(RID)->>            #Flushes data to disk
Deno.fsync(RID)->>                #Flushes data + inode modification (timestamps, permissions, etc.) to disk

READER_SYNC.readSync(...)
WRITER_SYNC.writeSync(...)
SEEKER_SYNC.seekSync(...)
Deno.readSync(...)
Deno.writeSync(...)
Deno.seekSync(...)
Deno.fdatasyncSync(...)
Deno.fsyncSync(...)               #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DEBUG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.resources()->OBJ             #Returns all RESOURCEs as { RID: VAL, ... }
                                  #VAL is internal|undocumented


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ERRORS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.errors.AlreadyExists         #Create RESOURCE that already exists
Deno.errors.NotFound              #RESOURCE not found

Deno.errors.InvalidData           #Invalid IO read
Deno.errors.UnexpectedEof         #IO read an EOF unexpectedly
Deno.errors.WriteZero             #IO write 0 bytes
Deno.errors.BrokenPipe            #IO write to a pipe done reading (SIGPIPE)

Deno.errors.TimedOut              #IO timeout (ETIMEDOUT)
Deno.errors.Busy                  #RESOURCE locked by another RESOURCE
Deno.errors.BadResource           #RESOURCE is in bad state


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ITERATE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/encoding/binary.ts            #

readVarnum(READER[, OPTS])
 ->>NUM|null
writeVarnum(WRITER, NUM[, OPTS])
 ->>NUM2                          #Same as varnum|putVarnum() (std/encoding/binary.ts) but on a READER|WRITER

readVarbig(...)                   #Same but:
writeVarbig(...)                  #  - returns BIGINT
                                  #  - default OPTS.type 'int64'

readExact(READER, UINT8ARR)->>    #Like READER.read(UINT8ARR) but repeats it until UINT8ARR.length bytes read
getNBytes(READER, NUM)->>UINT8ARR #Like readExact(READER, new Uint8Array(NUM))


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BUFFER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/io/mod.ts                     #
new Buffer                        #UINT8ARR that:
 ([ARRAYLIKE|ARRBUFFER|TYPED_ARR])#  - keeps track of read offset
                                  #  - can decrease|increase size
                                  #If argument passed, sets its contents
BUFFER.capacity                   #NUM of bytes read|unread
BUFFER.length                     #NUM of bytes unread
BUFFER.empty()->BOOL              #BUFFER.length === 0

BUFFER.bytes([OPTS])->UINTARR     #Retrieve underlying UINTARR
                                  #If OPTS.copy true (def), return a copy of it instead of a reference

BUFFER.grow(NUM)                  #Increase BUFFER.length to at least NUM bytes
BUFFER.truncate(NUM)              #Decrease BUFFER.length to exactly NUM bytes, erasing data
BUFFER.reset()                    #Like BUFFER.truncate(0)

BUFFER.readSync(UINT8ARR)         #Inherited from READER
 ->NUM|null                       #Reads and moves the read offset
                                  #Automatically call BUFFER.reset() when done reading to free memory
BUFFER.writeSync(UINT8ARR)->NUM   #Inherited from WRITER
                                  #Writes and BUFFER.grow() if needed
BUFFER.read(UINT8ARR)->>NUM|null
BUFFER.write(UINT8ARR)->>NUM      #Artificially async, since underlying action is sync. I.e. prefer sync

BUFFER.readFrom(READER)->>NUM     #Append READER data onto BUFFER
                                  #Call BUFFER.grow() when needed
                                  #Returns NUM of bytes appended
BUFFER.readFromSync(READERSYNC)
 ->NUM                            #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          BUF_READER           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new BufReader(READER[, NUM])      #READER with a buffer, i.e. an UINT8ARR buffering bytes returned by READER.read()
                                  #NUM is buffer size (def: 4096, min: 16)
BufReader.create(READER[, NUM])
 ->BUF_READER                     #Like new BufReader(...) except return READER as is if it is already a BUF_READER

BUF_READER.size()->NUM            #Buffer total size
BUF_READER.buffered()->NUM        #Buffer's bytes left to read
BUF_READER.reset(READER)          #Changes READER

BUF_READER.readByte()->>NUM|null  #Reads from the buffer 1 byte
                                  #Returns null if EOF
                                  #If the buffer has no more bytes to read, first fills it with exactly one READER.read()
BUF_READER.read(UINT8ARR)         #Inherited from READER
 ->>NUM|null                      #Same but with at most UINT8ARR.length bytes
                                  #If UINT8ARR is larger than buffer, skip buffer and do exactly one READER.read()
BUF_READER.readFull(UINT8ARR)     #Same but with exactly UINT8ARR.length bytes
 ->>UINT8ARR|null                 #Does so with multiple BUF_READER.read(UINT8ARR)
                                  #Throws PartialReadError if READER is not EOF but has < UINT8ARR.length bytes available
                                  #Returned UINT8ARR is same as argument

BUF_READER.peek(NUM)              #Reads from the buffer until either:
 ->>UINT8ARR|null                 #  - NUM bytes read
                                  #  - EOF after reading some bytes
                                  #Returns null if EOF (before reading any bytes)
                                  #Unlike other methods, does not move the read offset
                                  #If the buffer needs more bytes to read, fills it with exactly one READER.read()
                                  #Throws BufferFullError if NUM > BUF_READER.size()

BUF_READER.readSlice(NUM)         #Reads from the buffer until either:
 ->>UINT8ARR|null                 #  - byte with value NUM is found
                                  #  - EOF after reading some bytes
                                  #Returns null if EOF (before reading any bytes)
                                  #If the buffer needs more bytes to read, fills it with exactly one READER.read()
                                  #Throws BufferFullError if could not find byte NUM nor EOF in the next BUF_READER.size() bytes
BUF_READER.readString('CHAR')
 ->>STR|null                      #Like BUF_READER.readSlice() but using a 'CHAR' and returning a UTF8 STR
BUF_READER.readLine()->>OBJ|null  #Like BUF_READER.readSlice() except:
                                  #  - use LF|CRLF
                                  #     - stripped from return value
                                  #  - returns OBJ.more true instead of throwing BufferFullError
                                  #Returned OBJ: line UINT8ARR, more BOOL

PARTIAL_READ_ERROR
 |BUFFER_FULL_ERROR.partial       #UINT8ARR2 with bytes read so far

new BufWriter(WRITER[, NUM])      #WRITER with a buffer, i.e. a UINT8ARR buffering bytes to pass to WRITER.write()
                                  #NUM is buffer size (def: 4096, min: 1)
BufWriter.create(WRITER[, NUM])
 ->BUF_WRITER                     #Like new BufWriter(...) except return WRITER as is if it is already a BUF_WRITER

BUF_WRITER.size()->NUM            #Buffer total size
BUF_WRITER.buffered()->NUM        #Buffer's bytes not written yet
BUF_WRITER.available()->NUM       #Buffer's bytes, excluding bytes not written yet
BUF_WRITER.reset(WRITER)          #Changes WRITER

BUF_WRITER.write(UINT8ARR)->>NUM  #Inherited from WRITER
                                  #Writes all of UINT8ARR to the buffer
                                  #If buffer is full, call BUF_WRITER.flush()
                                  #Returns UINT8ARR.length
BUF_WRITER.flush()->>             #Writes the buffer to WRITER using multiple WRITER.write()
                                  #Resets the buffer
