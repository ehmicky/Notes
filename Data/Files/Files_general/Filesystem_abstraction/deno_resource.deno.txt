
                 
   DENO_RESOURCE  
                 



VERSION ==>                       #See deno doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MAIN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TextDecoder|Encoder[Stream]       #Like DOM

RESOURCE                          #Abstraction of a file, including socket, etc.
                                  #Usually ref'd by the process

CLOSER|READER|WRITER|SEEKER       #Abstract class to implement
std/types.d.ts                    #Has Closer|Reader[Sync]|Writer[Sync] types

CLOSER.close()                    #Close underlying RESOURCE

READER.read(UINT8ARR)->>NUM|null  #Reads available bytes from underlying RESOURCE and sets them into UINT8ARR.
                                  #Usually does not wait i.e. might read:
                                  #  - 0 bytes
                                  #  - less than UINT8ARR.length
                                  #     - rest of UINT8ARR might be used for internal purposes though
                                  #Only read up to UINT8ARR.length bytes.
                                  #Returns NUM of bytes read, or null if no more bytes to read.

WRITER.write(UINT8ARR)->>NUM      #Reads all of UINT8ARR and sets it to underlying RESOURCE.
                                  #Returns UINT8ARR.length

SEEKER.seek(NUM|BIGINT, ENUM)     #Changes position used by READER.read() and WRITER.write()
 ->>NUM2                          #NUM|BIGINT is relative offset in bytes
                                  #ENUM is reference position among Deno.Seeker.Start|Current|End
                                  #Before-start position is error. After-end position is implementation-dependent.
                                  #NUM2 is new position.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          DESCRIPTOR           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RID                               #RESOURCE ID NUM. Abstraction of a file descriptor.

Deno.close(RID)
Deno.read(RID, ...)
Deno.write(RID, ...)
Deno.seek(RID, ...)               #Same but on a RID



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SYNC              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.fdatasync(RID)->>            #Flushes data to disk
Deno.fsync(RID)->>                #Flushes data + inode modification (timestamps, permissions, etc.) to disk

READER_SYNC.readSync(...)
WRITER_SYNC.writeSync(...)
SEEKER_SYNC.seekSync(...)
Deno.readSync(...)
Deno.writeSync(...)
Deno.seekSync(...)
Deno.fdatasyncSync(...)
Deno.fsyncSync(...)               #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DEBUG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.resources()->OBJ             #Returns all RESOURCEs as { RID: VAL, ... }
                                  #VAL is internal|undocumented


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ERRORS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.errors.AlreadyExists         #Create RESOURCE that already exists
Deno.errors.NotFound              #RESOURCE not found

Deno.errors.InvalidData           #Invalid IO read
Deno.errors.UnexpectedEof         #IO read an EOF unexpectedly
Deno.errors.WriteZero             #IO write 0 bytes
Deno.errors.BrokenPipe            #IO write to a pipe done reading (SIGPIPE)

Deno.errors.TimedOut              #IO timeout (ETIMEDOUT)
Deno.errors.Busy                  #RESOURCE locked by another RESOURCE
Deno.errors.BadResource           #RESOURCE is in bad state


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         ITERATE READ          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/encoding/binary.ts            #

readExact(READER, UINT8ARR)->>    #Like READER.read(UINT8ARR) but repeats it until UINT8ARR.length bytes read
getNBytes(READER, NUM)->>UINT8ARR #Like readExact(READER, new Uint8Array(NUM))

TYPE                              #'[u]int8|16|32|64' or 'float32|64'
sizeof('TYPE')->1|2|4|8           #

varnum(UINT8ARR[, OPTS])->NUM|null#Reads a specific TYPE from UINTARR
                                  #null if too large
                                  #OPTS:
                                  #  - type 'TYPE' (def: 'int32')
                                  #  - endian 'big' or 'little' (def)
putVarnum(UINT8ARR, NUM[, OPTS])  #Like varnum() but sets instead
 ->NUM2                           #Returns sizeof('TYPE')
varnumBytes(NUM[, OPTS])->UINTARR #Like varnum() but creates a new UINTARR

readVarnum(READER[, OPTS])
 ->>NUM|null
writeVarnum(WRITER, NUM[, OPTS])
 ->>NUM2                          #Same but on a READER|WRITER

varbig(...)
putVarbig(...)
readVarbig(...)                   #Same but:
writeVarbig(...)                  #  - returns BIGINT
varbigBytes(...)                  #  - default OPTS.type 'int64'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            COMPARE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/crypto/timing_safe_equal.ts   #
timingSafeEqual
 (ARRBUFFER|DATAVIEW|TYPEDARR,
 ARRBUFFER|DATAVIEW|TYPEDARR2)    #Compare values.
 ->BOOL                           #Random performance to prevent timing attacks

std/bytes/mod.ts                  #
equals(UINT8ARR, UINT8ARR2)->BOOL #Like STR === STR2 but using UINT8ARR
                                  #Fast


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             FIND              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/mod.ts                  #
indexOfNeedle
 (UINT8ARR, UINT8ARR2[, NUM])     #Like STR.indexOf(STR2) but using UINT8ARR
 ->NUM2                           #Only start search at index NUM (def: 0)
lastIndexOfNeedle(...)            #Same but reverse
includesNeedle
 (UINT8ARR, UINT8ARR2[, NUM])
 ->BOOL                           #Like STR.includes() but using UINT8ARR

starts|endsWith
 (UINT8ARR, UINT8ARR2)->BOOL      #Like STR.starts|endsWith() but using UINT8ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             COPY              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/mod.ts                  #
concat(UINT8ARR...)->UINTARR2     #Like STR + STR2 but using UINT8ARR

copy(UINT8ARR, UINT8ARR2[, NUM])  #Copy UINT8ARR bytes onto UINT8ARR2 at offset NUM (def: 0)
 ->NUM2                           #Returns NUM of bytes copied

repeat(UINT8ARR, NUM)->UINT8ARR2  #Like STR.repeat() but using UINT8ARR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           AGGREGATE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


std/bytes/mod.ts                  #
new BytesList()                   #BYTE_LIST. Group multiple UINT8ARRs

BYTE_LIST.add
 (UINT8ARR[, NUM[, NUM2]])        #Add a UINT8ARR, from start NUM (def: 0) to end NUM2 (def: end)
BYTE_LIST.getChunkIndex(NUM)->NUM2#Retrieve index of UINT8ARR containing byte at index NUM

BYTE_LIST.concat()->UINT8ARR      #Concatenate all UINT8ARRs
BYTE_LIST.size()->NUM             #Like concat().length
BYTE_LIST.get(NUM)->NUM2          #Like concat()[NUM]
BYTE_LIST.slice(NUM[, NUM2])
 ->UINT8ARR                       #Like concat().slice(...)

BYTE_LIST.iterator([NUM])
 ->ASYNC_ITERATOR                 #Iterate over all UINT8ARRs, starting with index NUM (def: 0)

BYTE_LIST.shift(NUM)              #Drop first NUM bytes
