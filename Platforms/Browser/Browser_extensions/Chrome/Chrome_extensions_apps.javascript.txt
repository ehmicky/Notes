
                          
   CHROME EXTENSIONS APPS  
                          


TO FINISH ==>                                   #  - Chrome apps: webstore, identity/OAuth/Licensing API, pushMessaging.
                                                #  - Looking at Angular chrome app example


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MAIN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NOTATION ==>                                   ##Chrome extension
                                               !#Chrome app
                                                #Both app and extension.

PRINCIPLE ==>                                   #Ensemble de JavaScript/CSS/HTML and resources zipped in a .crx file.
                                                #Main components :
                                                #  - manifest.json, declares where files are and what they do/can do
                                                #  - files. In javascript, and can use functions starting with chrome.*
                                                #    (I don't put prefix in this doc).
                                                #     - background script implements main logic
                                                #     - content script is to inject HTML/CSS/JavaScript into specific webpages
                                                #     - connect background script functions to event handlers with events
                                                #       launched by:
                                                #         - browser events: startup, etc.
                                               ##         - UI views:
                                               ##            - bouton (browsingAction et pageAction)
                                               ##         - entrée dans context menu
                                               ##         - input keywords in omnibox
                                               ##         - HTML5 notifications
                                               !#         - app launch (cf ci-dessous)

VERSION ==>                                     #Current Chrome version : 31
                                                #Use minimum_chrome_version for the API with the max. Chrome version (can be
                                                #seen online)

CALLBACK ==>                                    #Many fonctions have a FUNC, which executes async.
                                                #I call this CALLBACK.
                                                #Even if the CALLBACK is optionnal, the FUNC will be async.

runtime.lastError                               #{ message: STR } dans un CALLBACK si erreur est intervenue.
                                                #undefined otherwise
TIMESTAMP                                       #DOUBLE: ms depuis Epoch (1970). Can use new Date().getTime()
                                                #Can compare TIMESTAMP between each other, but not with system time
                                                #(like new Date())


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             APPS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CHROME APP ==>                                 !#As opposed to Chrome extensions:
                                               !#  - use a separate window
                                               !#     - The HTML page of the window is a background page, so can use same APIs.
                                               !#     - some APIs are only available to this background page, not the one that
                                               !#       opened it, I note "Only app page"
                                               !#  - restricted on most APIs, but have some of its own too (access to real
                                               !#    filesystem, USB, sockets, ...)
                                               !#  - 2GB size limit (after zip)
                                               !#  - should be thought offline first
                                               !#  - content/background scripts:
                                               !#     - can't use content scripts, but can use <webview>
                                               !#     - declare background scripts (no pages) with:
                                               !#        "app": { "background": { "scripts": STR_ARR } }
                                               !#       instead of "background*"
                                               !#     - background scripts are opened by:
                                               !#        - install|update
                                               !#        - launch event:
                                               !#           - going to chrome://extensions -> launch
                                               !#           - new tab page
                                               !#           - using the App Launcher (not Linux)
                                               !#           - using Unity (Linux) (meta command)
                                               !#           - from command line with --load-and-launch=DIR (not already
                                               !#             loaded) or with --app-id=EXTENSION_ID (already loaded)
                                               !#           - navigating to a specific URL pattern
                                               !#              - must put in manifest.json:
                                               !#                 url_handlers
                                               !#                   any_STR
                                               !#                     matches: CSP_URL_ARR (domain must match one registered on
                                               !#                               Chrome webstore)
                                               !#                     title STR
                                               !#              - launch event will pass OBJ, with members:
                                               !#                 - id STR (any_STR)
                                               !#                 - url|referrerUrl STR
                                               !#                 - isKioskSession BOOL (cf kiosk_enabled)
                                               !#     - background scripts are only closed by closing sous-jacent Chrome
                                               !#        - so put window creation etc. in launch event, not in
                                               !#          background scripts (closing and reopening the app would
                                               !#          not reread the background script, but triggers the launch event
                                               !#          again)

app.runtime.onLaunched                         !#Event handler is FUNC(OBJ): cf url_handlers for OBJ.
app.runtime.onRestarted                        !#Fired at Chrome startup when apps when opened when Chrome last shut down.
                                               !#Event handler is FUNC()

app.window.create(STR[, OBJ][, CALLBACK])      !#Opens a window with an HTML page STR (local to app package).
                                               !#Can use devtools on it by right clicking, or using
                                               !#chrome-extension://EXTENSION_ID/STR
                                               !#OBJ has members:
                                               !#  - id STR (déf: "")
                                               !#  - min|maxWidth|Height NUM: of window content
                                               !#  - bounds { left, top, width, height }
                                               !#    If id is specified and already exist, move that window instead.
                                               !#  - resizable BOOL (déf: true)
                                               !#  - focused BOOL (déf: true)
                                               !#  - frame "none": remove frames.
                                               !#    Use CSS -webkit-app-region: drag on body to be able to drag the window
                                               !#    using the zone on top.
                                               !#  - state STR: "normal" (déf), "fullscreen", "maximized" or "minimized"
                                               !#  - hidden BOOL: call AWINDOW.hide()
                                               !#Fires CALLBACK(WINDOW), before the load event.
app.window.current()                           !#Returns current AWINDOW.
                                               !#Only app page.
app.window.getAll()                            !#Same but for all AWINDOW
app.window.get(STR)                            !#Same but with id STR
AWINDOW.id                                     !#
AWINDOW.close()                                !#
app.window.onClosed                            !#Event handler is FUNC()
AWINDOW.focus()                                !#
AWINDOW.hide()                                 !#
AWINDOW.show([BOOL])                           !#Inverse of hide(). If false, don't focus.
AWINDOW.fullscreen|minimize|maximize|restore() !#
AWINDOW.isFullscreen|Minimized|Maximized()     !#
app.window.onFullScreened|Minimized|Maximized|
Restored                                       !#Event handler is FUNC()
AWINDOW.moveTo(INT, INT2)                      !#
AWINDOW.resizeTo(WIDTH, HEIGHT)                !#
AWINDOW.draw|clearAttention()                  !#
AWINDOW.setBounds(OBJ)                         !#Same OBJ as in app.window.create()
AWINDOW.getBounds()                            !#
app.window.onBoundsChanged                     !#Event handler is FUNC()
AWINDOW.getMin|MaxWidth|Height()               !#
AWINDOW.setMin|MaxWidth|Height(NUM)            !#
AWINDOW.contentWindow                          !#The underlying WINDOW

<webview>                                      !#Permission: "webview"
                                               !#Like an iframe, but more secure.
                                               !#Can communicate with postMessage, listen to some events and inject CSS|script.
                                               !#DOM events:
                                               !#  - consolemessage: FUNC({ level: INT, message: STR, line: INT2,
                                               !#    sourceId: STR2 })
                                               !#  - sizechanged: FUNC({ old|newHeight|Width: NUM }): only with autosize="on"
                                               !#  - close: FUNC(). For example WINDOW.close()
                                               !#  - exit: FUNC(PROCESS_ID_NUM, "normal|abnormal|crash|kill")
                                               !#  - [un]responsive: FUNC(PROCESS_ID_NUM): when becomes [un]responsive
                                               !#  - dialog: FUNC(OBJ). Fires when WINDOW opens a popup. OBJ has members:
                                               !#     - messageType "alert|confirm|prompt"
                                               !#     - messageText STR
                                               !#     - dialog.ok([STR])|cancel()
                                               !#  - newwindow: FUNC(OBJ), with members:
                                               !#     - window.attach(WEBVIEW)|detach()
                                               !#     - targetUrl STR
                                               !#     - name STR
                                               !#     - initialWidth|Height NUM
                                               !#     - windowOpenDisposition "ignore|save_to_disk|current_tab|
                                               !#       new_background_tab|new_foreground_tab|new_window|new_tab"
                                               !#  - contentload: FUNC(). Fired at WINDOW load event.
                                               !#  - loadabort: FUNC({ url: STR, isTopLevel: BOOL, reason:
                                               !#    "networkError|download|canceled|sslError|safeBrowsingError" })
                                               !#  - loadcommit|start: FUNC({ url: STR, isTopLevel: BOOL })
                                               !#  - loadredirect: FUNC({ old|newUrl: STR, isTopLevel: BOOL })
                                               !#  - loadstop: FUNC()
                                               !#  - permissionrequest: FUNC(OBJ), with members:
                                               !#     - requestId NUM
                                               !#     - STR among "media", "geolocation", "pointerLock", "download",
                                               !#       "loadplugin"
                                               !#     - request.allow|deny()
                                               !#     - request.url STR
                                               !#     - request.userGesture BOOL (only "pointerLock")
                                               !#     - request.lastUnlockedBySelf BOOL (only "pointerLock")
                                               !#     - request.requestMethode STR (only "download")
                                               !#     - request.identifier STR (only "loadplugin")
  id=STR
  name=STR                                     !#Sets the underlying WINDOW.name
  src=STR
  min|maxheight|width=NUM                      !#Must use attribute autosize="on" for this to work.
                                               !#To specify width|height, use CSS
  .contentWindow                               !#Retrieves the CONTENTWINDOW.
  CONTENTWINDOW.postMessage(...)               !#Post message to WEBVIEW using same API as DOM postMessage()
                                               !#Only available after contentload event.
  CONTENTWINDOW.request                        !#Provides same events as webRequest, e.g. CONTENTWINDOW.request.onBeforeRequest
                                               !#or declarativeWebRequest, e.g. CONTENTWINDOW.request.onRequest
  .executeScript|insertCSS(OBJ[, CALLBACK])    !#Similar as executeScripts|insertCSS(), but without tabId, not runAt|allFrames
  .go(INT)                                     !#Go in history (can go back)
  .canGoBack|Forward()                         !#
  .clearData({[since: DOUBLE]}, OBJ[, CALLBACK])#OBJ is same as OBJ2 in browsingData.remove()
                                               !#Fires CALLBACK()
  .reload()                                    !#
  .stop()                                      !#Stops loading.
  .getProcessId()                              !#
  .terminate()                                 !#Kills process.
  .getUserAgent()                              !#
  .setUserAgentOverride(STR)                   !#
  .isUserAgentOverriden()                      !#

webstore.install(STR[, CALLBACK                 #Install app à l'URL STR. CALLBACK() est succes, CALLBACK2(STR) failure.
[, CALLBACK2]])                                 #Must be done on a content script, et dans un event handler.
                                                #Only if has been enabled in Chrome developer console (delay app approval).


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          HOSTED APPS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HOSTED APPS ==>                                 #Different from chrome apps and extensions, this is a website, that loads in
                                                #a normal tab, but:
                                                #  - can also load in a panel
                                                #  - ca, use some APIs: permissions are "background", "clipboardRead|Write",
                                                #    "geolocation", "notifications" and "unlimitedStorage"
                                                #  - can open a background page (same as persistent background pages in
                                                #    Chrome extensions)
                                                #It loads when opened from new tab window, or when visited URL matches a
                                                #pattern.
                                                #Uses a .crx and a manifest like extensions but with only name, description,
                                                #version, icons: { 128: STR }, key, minimum_chrome_version, permissions,
                                                #update_url and:
                                                #  - background_page STR
                                                #  - app: {
                                                #      urls: CSP_URL_ARR:
                                                #        - append a * in the end. Avoid double matching.
                                                #        - only one domain allowed: the one from the app on Chrome webstore
                                                #      launch: {
                                                #        web_url STR: URL to launch
                                                #        container: "panel"
                                                #        height|width: with "panel"
                                                #      }
                                                #    }


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           PACKAGING           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PACKAGING ==>                                   #Packaged as .crx file (actually .zip file with extra header)
                                                # + private key .pem
                                                #Can be tested unpackaged by going in chrome://extensions in Google Chrome
                                                # > extensions > click on Developer mode > Load unpackaged extension
                                                #To package, choose Pack extension instead :
                                                #  - private key is created first time, then needs to supply it for updates
                                                #  - private key permits only creator to update it, so keep it secret
                                                #To install .crx :
                                                #  - send it by HTTP :
                                                #    - with MIME type application/x-chrome-extension
                                                #    - or with any MIME type but without header X-Content-Type-Options: nosniff
                                                #  - drag it to the chrome://extensions middle of page
                                                #  - click on it locally on Windows :
                                                #    - put .crx on a shared location if shared
                                                #    - create key HKEY_LOCAL_MACHINE\Software[\Wow6432Node]\Google\Chrome\
                                                #      Extensions\EXTENSION_ID\ (middle part only if 64 bits)
                                                #    - under this folder, create two string (REG_SZ) called path and version
                                                #      with location of .crx file, and version of extension
EXTENSION ID ==>                                #Each extension on a specific machine has an extension ID : 32 [:lower:]
                                                #It is shown in the extension tab.
                                                #Can change if still unpackaged.
runtime.id                                      #Renvoie EXTENSION_ID
"__MSG_@@extension_id__"                        #Same but for CSS et manifest.json.
                                                #Faire "chrome-extension://__MSG_@@extension_id__"

UPDATING ==>                                    #Can :
                                                #  - use Chrome Developer Dashboard
                                                #  - or put "update_url": STR in manifest.json, where STR est un fichier XML,
                                                #    usually called updates.xml
                                                #    Should look like :
                                                #      <?xml version='1.0' encoding='UTF-8'?>
                                                #      <gupdate xmlns='http://www.google.com/update2/response' protocol='2.0'>
                                                #        <app appid='EXTENSION_ID'>
                                                #          <updatecheck codebase='STR' version='STR2' />
                                                #        </app>
                                                #      </gupdate>
                                                #    Where STR est le dernier package CRX, et STR2 sa version. Compare with
                                                #    version in manifest.json to know if update.
                                                #    In <updatecheck>, there can be attribute prodversionmin="STR3" pour
                                                #    spécifier une version minimum de Chrome.
                                                #    - can runtime.requestUpdateCheck(CALLBACK) manually, with
                                                #      CALLBACK(STR, OBJ), where :
                                                #      - STR is "throttled" (can't check), "no_update" or "update_available"
                                                #      - OBJ is { status: STR2, details.version: STR3 }, where STR2 is same
                                                #        as STR, et STR3 la new version
                                                #      Checks only, doesn't update.
                                                #    - otherwise Chrome checks automatically every few hours
                                                #      - if update found while app is running, can't update now, but fires
                                                #        runtime.onUpdateAvailable, with event handler FUNC({ details.version})
                                                #        If impatient, can runtime.reload()
                                                #Updates must sign with same private key
                                                #Current version is in manifest.json, as "version". Must be STR with 1 à 4
                                                #UINT, de 0 à 65535, with no leading 0.

management.*                                   ##Permission: "management", except getPermissionWarningsByManifest() and
                                               ##uninstallSelf()
management.get(STR, CALLBACK)                  ##Invoque CALLBACK(EXTENSIONINFO) pour l'extension dont l'EXTENSION_ID est STR.
                                               ##EXTENSIONINFO a membres :
                                               ##  - id : EXTENSION_ID
                                               ##  - name, description, version, homepageUrl, appLaunchUrl, updateUrl,
                                               ##    offlineEnabled, optionsUrl : like in manifest.json
                                               ##  - icons : like in manifest.json, but as { size: UINT, url: STR }...
                                               ##  - hostPermissions, permissions : for "permissions" in manifest.json.
                                               ##    The first are the host permissions, the other the APIs ones.
                                               ##  - type : "extension", "hosted_app", "packaged_app" or "theme"
                                               ##  - mayDisable BOOL : si false, can't be disabled
                                               ##  - enabled BOOL
                                               ##  - disabledReason STR : si disabled à cause d'update avec nouvelles
                                               ##    permissions, "permissions_increase". Sinon "unknown"
                                               ##  - installType STR :
                                               ##    - "development" : through chrome://extensions developer mode
                                               ##    - "normal" : via .crx file
                                               ##    - "admin" : via admin installation
                                               ##    - "sideload" : installed via other software
                                               ##    - "other"
management.getAll(CALLBACK)                    ##Pareil mais toutes extensions via CALLBACK(EXTENSIONINFO_ARR)
runtime.getManifest()                          ##Get current manifest.json, as OBJ.
management.getPermissionWarningsByManifest|Id   #Invoque CALLBACK(STR_ARR), où STR_ARR sont les message de demande de
(STR, CALLBACK)                                 #permissions lors installation/update, pour extensions dont l'EXTENSION_ID
                                                #(Id) est STR ou le manifest.json file se situe (Manifest) à STR.
management.setEnable(STR, BOOL[, CALLBACK])    ##Enable|Disable (selon BOOL) l'extension dont l'EXTENSION_ID est STR.
                                               ##Invoque ensuite CALLBACK()
management.onEnabled|Disabled                  ##Event handler is FUNC(EXTENSIONINFO)
management.uninstall(STR[, OBJ][, CALLBACK])   ##Désinstalle extension dont EXTENSION_ID est STR.
                                               ##OBJ can be { showConfirmDialog: true } (déf: false).
                                               ##Invoque ensuite CALLBACK()
management.uninstallSelf([OBJ][, CALLBACK])     #Pareil pour extension courante.
management.onInstalled                         ##Fired at any extension installation/update.
                                               ##Event handler is FUNC(EXTENSIONINFO)
management.onUninstalled                       ##Event handler is FUNC(EXTENSION_ID)
management.launchApp(STR[, CALLBACK])          ##Launch app ayant EXTENSION_ID STR.
                                               ##Invoque ensuite CALLBACK()

runtime.onInstalled                             #Fired by extension at its own installation/update, or update of Chrome.
                                                #Event handler is FUNC({ reason: STR, previousVersion: STR2 }), where STR is
                                                #among "install", "update", "chrome_update"
runtime.setUninstallUrl(STR)                    #URL to be visited on uninstallation (max 255 chars)
runtime.onStartup                               #Fired at startup. Event handler is FUNC()
runtime.reload()                                #Reload the extension


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EVENT ==>                                       #Don't put event handlers in runtime.onInstalled.
VAR.onEVENT.add|removeListener(FUNC[, OBJ])     #Like VAR.add|removeEventListener("EVENT", FUNC), but for Chrome extensions
                                                #events.
                                                #OBJ is a filter. Works not on all events : currently only WebNavigation and
                                                #webRequest events. It makes the event handler only triggers in specific
                                                #conditions, like if a if ( TEST ) was present in the handler, but more
                                                #efficient.
VAR.onEVENT.hasListener(FUNC)                   #
VAR.onEVENT.hasListeners()                      #
VAR.onEVENT.addRules(RULE_ARR[, CALLBACK])      #Alternative and efficient way to register event handler for some events :
                                                #declarativeWebRequest only for the moments.
                                                #Rules persist accross browser sessions. Only manual removal or install/update
                                                #of the extension remove them, so they should be registered in the onInstalled
                                                #event handler.
                                                #RULE est OBJ dont membres sont :
                                                #  - conditions (mandatory) VAR_ARRAY
                                                #  - actions (mandatory) VAR_ARRAY
                                                #  - id STR
                                                #  - priority UINT (déf 100)
                                                #  - tags STR_ARR: not used
                                                #Invoque "actions" si "conditions" fulfilled.
                                                #Ex: addRules([{ conditions:[ new VAR({...}) ], actions:[ new VAR({...}) ] }])
                                                #Arguments de "conditions" et "actions" sont souvent :
                                                #  - construits via new
                                                #  - Leur construction arg est un OBJ, dont membres sont aussi membres de
                                                #    l'object construit
                                                #Invoque ensuite CALLBACK(RULE_ARR)
                                                #Can set runtime.lastError
                                                #Should do as few addRules() as possible (using ARRAY arguments instead)
VAR.onEVENT.getRules(STR_ARR[, CALLBACK])       #Invoque CALLBACK(RULE_ARR) for RULE with id parmi STR_ARR
VAR.onEVENT.removeRules([STR_ARR[, CALLBACK]])  #Remove les RULE with id parmi STR_ARR (déf: all)
                                                #Invoque ensuite CALLBACK()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       FILES ET MANIFEST       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DONNEES ==>                                     #localStorage/sessionStorage or chrome.storage can be used for a given
                                                #extension.
FILE ==>                                        #Relative path refer to extension root directory.
                                                #Can also use chrome-extension://EXTENSION_ID/PATH_TO_FILE.
                                                #External websites must include the PROTOCOL://, and the trailing slash if
                                                #relevant.
                                                #chrome-extension:// JavaScript files have access to chrome.*
extension.getURL(STR)                          ##Renvoie chrome-extension://EXTENSION_ID/STR
chrome://favicon/URL                            #Renvoie URL2 du favicon d'URL.
                                                #Permission: "chrome://favicon/"

CSP_URL                                         #STR designant une URL following same rules as CSP, + possible "<all_urls>"
                                                #for PROTOCOL://*/*, where PROTOCOL is http, https, file or ftp (not
                                                #chrome-extension)

manifest.json                                   #JSON file declaring the application (permissions, files, etc.).
                                                #The following VAR are possible (other are mentioned in other part of the
                                                #document) :
  manifest_version                              #NUM, devant être 2
  name                                          #Name STR de l'application (max 45 chars), shown in Extensions page, Chrome
                                                #web store and install dialog.
  short_name                                    #Same but only max 12 chars, shown in App launcher and New tab page.
  description                                   #Description STR de l'application, shown in Extensions page and Chrome web
                                                #store (max 132 chars).
  author                                        #STR
  homepage_url                                 ##STR
  version                                       #Of the extension (cf ci-dessus)
  minimum_chrome_version                        #Same format
  requirements                                  #OBJ :
                                                #  - "3D" : { ["features": "webgl"] } (3D seul means hardware acceleration)
                                                #  - "plugins": { "npapi": true }
  icons                                         #Icones as { VAR:STR... }, où VAR est la size et VAL l'image :
                                                #  - "16" : favicon on Extensions page, on omnibox and on context menus.
                                                #  - "48" : main image on Extensions page
                                                #  - "128" : in installation and Chrome webstore
                                                #Any format supported by Chrome, including JPEG and PNG.
  kiosk_enabled|only                           !#Could|should be fullscreen (Chrome OS only)
  display_in_launcher|new_tab_page             !#Déf: true
  offline_enabled                              !#Whether it is expect to work offline. If not, icon will be dimed when offline.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           SECURITY            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


  content_security_policy                      ##In manifest.json.
                                               ##CSP as STR (see doc). Default is script-src 'self'; object-src 'self'
                                               ##As such : no inline script/style, and no eval()
                                               ##script-src et object-src only allowed from local source, or from HTTPS.
                                               ##Be careful with grammar : ";" not ",", spaces between VAL, '' only around
                                               ##special words, not URL.
                                               ##Also :
                                               ##  - script-src et object-src doivent être specified (or default-src)
                                               ##  - only https://..., chrome-extension:// or 'self' in those two.
  sandbox                                       #In manifest.json
                                                #Put pages of the extension in sandbox mode (like HTML5). Usually when page
                                                #uses eval(), etc.
                                                #OBJ :
                                                #  - "pages": STR_ARR
                                                #  - "content_security_policy" (déf: "sandbox allow-scripts allow-forms") : STR
                                                #Can't use chrome.*, but can communicate with postMessage()
  permissions                                   #In manifest.json.
                                                #STR_ARRAY de permissions, parmi :
                                                #  - host permissions : any external websites accédés (because of default CSP)
                                                #    as CSP_URL. Revient à changer CSP default-src.
                                                #  - "background", "chrome://favicon/", "notifications", "contextMenus" :
                                                #    see this doc.
                                                #  - "unlimitedStorage" : infinite storage for ApplicationCache,
                                                #    localStorage, databases, chrome.storage
                                                #  - "activeTab" : restricted version of "tabs" permission :
                                                #     - only for current tab, when user active extension by clicking
                                                #       browser|page action, contextMenus, omnibox ou chrome.commands.
                                                #  - "clipboardRead|Write" : using DOCUMENT.execCommand("paste|copy|cut")
                                                #  - "geolocation" : allows using HTML5 geolocation without browser prompting
                                                #  - "STR" : several chrome.STR APIs, noted in this doc.
                                                #The following permissions don't cause a warning when installing/updating :
                                                #  - "chrome://favicon/", "contextMenus", "notifications"
                                                #  - "unlimitedStorage"
                                                #  - "activeTab"
                                                #  - "clipboardWrite"
                                                #  - "browsingData", "cookies", "experimental", "idle", "storage",
                                                #    "webRequest[Blocking]"
  optional_permissions                          #In manifest.json.
                                                #Pareil, mais request permission non une fois à l'installation/update, mais à
                                                #chaque fois que requis, et seulement lorsque que requis.
                                                #Seulement suivants sont possibles :
                                                #  - host permissions
                                                #  - "background", "contextMenus", "notifications"
                                                #  - "clipboardRead|Write"
                                                #  - "bookmarks", "contentSettings", "cookies", "debugger", "history", "idle"
                                                #    "management", "pageCapture", "tabs", "topSites", "webNavigation"
                                                #    "webRequest[Blocking]"
                                                #Needs to use permissions.request|remove() runtime.
permissions.getAll(CALLBACK)                    #Invoque CALLBACK(PERMISSIONS) pour PERMISSIONS courantes. Membres :
                                                #  - permissions STR_ARR : for non-host permissions
                                                #  - origins STR_ARR : for host permissions
permissions.contains(PERMISSIONS, CALLBACK)     #CALLBACK(BOOL)
permissions.request(PERMISSIONS, CALLBACK)      #CALLBACK(BOOL). Must be called during a user gesture.
                                                #Can set runtime.lastError
permissions.remove(PERMISSIONS, CALLBACK)       #CALLBACK(BOOL) : true if removed.
permissions.onAdded|Removed(PERMISSIONS)        #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        MAIN STRUCTURE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


BACKGROUND PAGES ==>                           ##Put "background: { VAR:VAL... }" in manifest.json.
                                               ##Hidden WINDOW (single page), optionnaly with scripts.
                                               ##Are read:
                                               ##  - always: when installed|updated
                                               ##  - no permission "background": at browser launch (only once if multiple
                                               ##    windows)
                                               ##  - permission "background": when user logs in computer (by launching Chrome
                                               ##    as a daemon)
                                               ##  - not persistent: extension.getBackgroundPage()
                                               ##Are closed:
                                               ##  - persistent + permission "background": when OS logs out
                                               ##  - persistent + no permission "background": when last window closed
                                               ##  - not persistent (prefer, more efficient): as soon as finished reading:
                                               ##     - close all views and PORT, or it will be persistent.
                                               ##       However setTimeout() and similar functions don't keep it persistent,
                                               ##       and will be cancelled (use alarms.*)
                                               ##     - Fires runtime.onSuspend event shortly before closing. If event
                                               ##       handler lasts more than few seconds, it will not close anymore,
                                               ##       and runtime.onSuspendCanceled will be fired.
                                               ##       If some views like opening the background page in a tab for
                                               ##       debugging, onSuspend will not be fired.
                                               ##To use a library in a background page or content script, put the library as
                                               ##another background page or content script before it.
                                               ##Has following VAR :
    page                                       ##HTML file, as STR.
    scripts                                    ##JavaScript files, as STR_ARRAY. Cannot be used in same time as page.
                                               ##Creates a HTML page with only DOCTYPE, blank BODY and HEAD, except
                                               ##<script src="STR"></script> for each script.
    persistent                                 ##Déf: true.
extension.getBackgroundPage()                  ##Renvoie la WINDOW de la background page, ou null si aucune.
runtime.getBackgroundPage(CALLBACK)            ##Pareil mais async. with CALLBACK(WINDOW).
                                               ##If no background page, set runtime.lastError

CONTENT SCRIPTS ==>                            ##Put "content_scripts : [ { VAR:VAL... }... ]" in manifest.json.
                                               ##Scripts/pages loaded with the webpage the user is browsing, when URL matches a
                                               ##given pattern.
                                               ##Is viewed like if it was part of the webpage, except :
                                               ##  - no access to JavaScript files between page and content script (only DOM)
                                               ##    - libraries loaded by the webpage and the extensions will never conflict
                                               ##What can be done :
                                               ##  - manipulating the DOM of the webpage
                                               ##  - sending/receiving messages to webpage with standard postMessage() and
                                               ##    message event
                                               ##  - sending/receiving messages to background page with
                                               ##    runtime.send|onMessage(), runtime.[onC]connect()
                                               ##  - using extension resources with extension.getURL() et
                                               ##    "__MSG_@@extension_id__", runtime.id and runtime.getManifest()
                                               ##    They must be declared in manifest.json "web_accessible_resources": STR_ARR
                                               ##  - check update with runtime.requestUpdateCheck(), runtime.reload() and
                                               ##    setUninstallUrl()
                                               ##  - using storage.*, i18n.* and permissions.*
                                               ##  - can't use other chrome.*
                                               ##To create dynamically content scripts, e.g. not only according to URL, but
                                               ##also page content or user interaction, do instead :
                                               ##  - chrome.tabs.executeScripts|insertCSS([UINT, ]OBJ[, CALLBACK])
                                               ##    - UINT est le TAB id (déf: active TAB of current CWINDOW)
                                               ##    - OBJ :
                                               ##      - file STR or code STR : JavaScript/CSS to inject
                                               ##      - allFrames, runAt : like for content scripts
                                               ##    - CALLBACK is FUNC() for CSS et FUNC(VAL) for Scripts, ou VAL est la
                                               ##      value de la dernière ligne de code du script injecté (VAL; et non
                                               ##      return VAL;, qui est interdit)
                                               ##  - Permissions: "tabs" and the URL where it will be injected
                                               ##Has following VAR :
    matches                                    ##CSP_URL_ARR of the webpages which will use the content scripts.
                                               ##This field is required.
    exclude_matches                            ##Inverse
    include|exclude_globs                      ##Like *_matches, but no restriction, can be any STR with * and ? wildcards
                                               ##(matches entire word).
    css                                        ##CSS files, as STR_ARR
    js                                         ##JavaScript files as STR_ARR
    run_at                                     ##When javascript files are injected, according to DOCUMENT.readyState
                                               ##("loading", "interactive", "complete") : "document_start|end|idle"
                                               ##(déf: document_idle)
                                               ##Always after CSS injection.
    all_frames                                 ##If false (déf), injection only in top frame of the page.

MESSAGE PASSING ==>                             #Between :
                                                #  - app|content_script et background page : sendMessage() and connect()
                                                #  - content_script et web page : DOM postMessage()
                                                #  - two extensions|app : sendMessageExternal() and connectExternal()
                                                #      - must declare in manifest.json:
                                                #         "externally_connectable": {
                                                #           "ids": [ "EXTENSION_ID" ... ] (can use "*")
                                                #           "matches": CSP_URL_ARR
                                                #           "accept_tsl_channel_id": true:
                                                #             - use it if want to use HTTPS.
                                                #             - Should also use then:
                                                #                 runtime.connect(ID, { includeTslChannelId: true, name })
                                                #                 runtime.sendMessage(ID, VAL, {includeTslChannelId: true},...)
                                                #         }
                                                #  - background page et native application : see doc online.
                                                #"Background page" refers here also to chrome-extension:// files opened.
runtime.onMessage[External]                     #Fired at send|postMessage() from the other end (but not at standard DOM
                                                #WINDOW.postMessage())
                                                #Event listener is FUNC(VAL, MESSAGESENDER, FUNC2) :
                                                #  - VAL is the message received
                                                #  - use FUNC2(VAL2) activates the CALLBACK of sendMessage() (mais n'envoie
                                                #    pas de Message event). Can do only once.
                                                #    Event listener must return true to be able to use FUNC2 event after
                                                #    listener ends.
                                                #  - MESSAGESENDER a les properties :
                                                #    - tab : TAB ayant *Message(), or undefined if background page.
                                                #    - url : same but TAB.url, or undefined if background page.
                                                #    - id : EXTENSION_ID of sender
                                                #onMessageExternal is fired if runtime.sendMessage(EXTENSION_ID, ...)
runtime.sendMessage([STR, ]VAL[, CALLBACK])     #Sends VAL from content script or app to background page.
                                                #STR is the EXTENSION_ID of the extension of the background page (déf: current)
                                                #Executes CALLBACK(VAL2) when receiving message back.
tabs.sendMessage(UINT, VAL[, CALLBACK])        ##Same for background page to tab dont id est UINT.
                                               ##Permission: "tabs"
                                               ##Can set runtime.lastError

runtime.connect([STR,][OBJ])                    #Returns a PORT.
                                                #Must be done from a content script or app, but seems to send to everyone.
                                                #It is a two-way connection :
                                                #  - first end:
                                                #    - var PORT = *.connect()
                                                #    - PORT.onMessage event registration
                                                #  - second end: on.Connect( port ):
                                                #    - var PORT = port
                                                #    - PORT.onMessage event registration
                                                #  - both ends can then use PORT.postMessage()
                                                #OBJ is { name: STR2 (déf: "") }, where STR2 is the PORT name.
                                                #STR is EXTENSION_ID (comme pour runtime.sendMessage())
                                                #Prefer to sendMessage() when there are multiple messages.
tabs.connect(UINT[, OBJ])                      ##Same as runtime.connect(), except must be done on a background page, towards
                                               ##the content script in TAB dont id est UINT.
                                               ##Permission: "tabs"
runtime.onConnect[External]                     #Fired with runtime|tabs.connect() from other end. Might be fired several
                                                #times.
                                                #Event listener is FUNC(PORT)
                                                #onConnectExternal is fired if runtime.connect(EXTENSION_ID, ...)
PORT.postMessage(VAL)                           #Sends Message event with VAL message. Only for sender.
PORT.name                                       #
PORT.sender                                     #MESSAGESENDER (cf ci-dessus). Only for receiver.
PORT.onMessage                                  #Event handler is FUNC(VAL).
                                                #Different de runtime.onMessage : only listens to PORT.postMessage()
PORT.disconnect()                               #Close le PORT. Toujours le faire. Only for sender.
PORT.onDisconnect                               #Event handler is FUNC(PORT). Only for receiver.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             VIEWS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VIEWS ==>                                       #Can be :
                                                #  - background pages
                                                #  - popups of page icons or browser actions
                                                #Can be accessed on a dedicated tab via :
                                                #  - chrome-extension://EXTENSION_ID/STR.html. STR is :
                                                #    - name of background pages si "page", _generated_background_page si
                                                #      "scripts"
                                                #    - chemin of popups for page icons/browser actions
                                                #  - also by clicking in Inspect views in chrome://extensions
extension.getViews(OBJ)                        ##Renvoie les WINDOW_ARR des views. OBJ peut filtrer selon :
                                               ##  - { [type: STR][, windowId: INT] }, où STR est "tab" ou "popup"

BROWSER ACTION ==>                             ##Bouton on the address bar, triggering an onClicked event.
                                               ##To use when makes sense on most webpages, as opposed to page actions.
                                               ##Declare it with "browser_action" in manifest.json, with following members :
    default_icon                               ##Icone just like icons of manifest.json, but for browser_action bouton.
                                               ##Should provide both "19" and "38".
    default_popup                              ##Fichier HTML STR affiché lors d'un clic sur le bouton.
                                               ##Annule onClicked event.
                                               ##Optionnel : browserAction.onClicked provides better functionnality.
    default_title                              ##Tooltip STR
browserAction.onClicked                        ##Event handler is FUNC(TAB)
browserAction.setTitle(OBJ)                    ##OBJ is { title: STR[, tabId: UINT] }. Modifie default_title.
                                               ##If tabId, is limited to a single tab.
browserAction.getTitle({ tabId }, CALLBACK)    ##CALLBACK is FUNC(STR)
browserAction.*etPopup(...)                    ##Like *etTitle(), sauf que STR est le fichier HTML de default_popup, et
                                               ##OBJ est { popup[, tabId] }
browserAction.*etBadgeText(...)                ##Pareil, mais pour le badge, une STR de 4 characters max en bas de l'icone.
                                               ##OBJ est { text[, tabId] }
browserAction.*etBadgeBackgroundColor(...)     ##Pareil, mais pour le badge background color. color can be UINT_ARR (4 UINT de
                                               ##0 à 255) ou STR like "#fff" ou "#ffffffff"
                                               ##OBJ est { color[, tabId] }
browserAction.setIcon(OBJ[, CALLBACK])         ##Pareil mais pour default_icon. OBJ :
                                               ##  - each is optional and is VAR: { "19": VAL, "38": VAL }
                                               ##  - members are :
                                               ##    - path STR
                                               ##    - imageData IMAGEDATA (from CANVAS.getImageData()).
                                               ##    - tabId UINT (comme setTitle())
                                               ##  - can animate icon then, but avoid it if unnecessary.
                                               ##CALLBACK is FUNC()
browserAction.enable|disable([UINT])           ##Disable/enable (but still visible) le bouton.
                                               ##Si UINT, seulement pour TAB dont id est UINT.

PAGE ACTION ==>                                ##Like browser_action but :
                                               ##  - use "page_action" in manifest.json
                                               ##  - should be shown|hidden only for specific webpages
                                               ##  - appears inside omnibox
                                               ##  - no badge, et no enable|disable
pageAction.show|hide(UINT)                     ##Show/Hide pour TAB dont id est UINT (déf: hidden)

NOTIFICATIONS ==>                               #Use HTML5 Notifications.
                                                #To whitelist permissions :
                                                #  - permission "notifications"
                                                #  - declare images/resources in manifest.json in "web_accessible_resources",
                                                #    with STR_ARRAY (due to a bug).

CONTEXT MENU ==>                                #Needs to :
                                                #  - create a new element in usual context menu with ContextMenus.create().
                                                #    Can add children, but not second element.
                                                #  - Use contextMenus.onClicked to react to choices.
                                                #  - creates a "16" icons in manifest.json
                                                #Permission: "contextMenus"
contextMenus.create(OBJ[, CALLBACK])            #Creates a new element in the context menu :
                                                #  - id STR : unique ID (required)
                                                #  - parentId STR : si enfant, ID du parent
                                                #  - title STR : label (required except for separators).
                                                #    Can include "%s" for the selectionText ("" si pas sélection)
                                                #  - type : "normal" (déf), "checkbox", "radio" or "separator"
                                                #  - checked BOOL : for checkbox (déf: true for first)
                                                #  - enabled BOOL : si true, disabled (déf: false)
                                                #  - contexts STR_ARR : targets où l'élement apparaîtra parmi "all", "page"
                                                #    (tout sauf ce qui suit), "frame", "selection", "link", "editable",
                                                #    "image", "video", "audio", or "launcher" (for apps) (déf: "page")
                                                #  - documentUrlPatterns STR_ARR : élément apparaîtra seulement si URL matche
                                                #    l'un des CSP_URL
                                                #  - targetUrlPatterns STR_ARR : pareil, mais pour les attributs src|href des
                                                #    targets
                                                #CALLBACK is FUNC()
                                                #Can set runtime.lastError
contextMenus.update(STR, OBJ[, CALLBACK])       #Met à jour properties OBJ d'élément dont id est STR. All properties except id.
                                                #CALLBACK is FUNC()
contextMenus.remove(STR[, CALLBACK])            #Remove élément dont id est STR.
                                                #CALLBACK is FUNC()
contextMenus.removeAll([CALLBACK])              #Remove all. CALLBACK is FUNC()
contextMenus.onClicked                          #Fired when clicking on an element.
                                                #Event listener is FUNC(OBJ, TAB), où OBJ a membres :
                                                #  - menuItemId STR : item cliqué
                                                #  - parentMenuItemId STR
                                                #  - wasChecked|Checked BOOL : state of the checkbox/radio
                                                #  - mediaType STR : si target est "image", "video", "audio" ou "" (autres)
                                                #  - editable BOOL : true if target is editable
                                                #  - pageUrl STR : URL de la page de la target
                                                #  - frameUrl STR : pareil pour une IFRAME (null sinon)
                                                #  - srcUrl STR : si target a élément src
                                                #  - linkUrl STR : si target a élément href

OMNIBOX ==>                                    ##When a specific STR is typed in omnibox, show suggestions, instead of normal
                                               ##suggestions.
                                               ##  - put in manifest.json, omnibox: { "keyword":STR... } where STR is the one
                                               ##    to type in omnibox.
                                               ##  - use setDefaultSuggestion() on omnibox event handlers
                                               ##  - creates a "16" icons in manifest.json
                                               ##But est d'envoyer des commandes via l'omnibox.
omnibox.setDefaultSuggestion(OBJ)              ##Modify first entry of search.
                                               ##OBJ is { description: STR } can contain following markups :
                                               ##  - <url></url> : link
                                               ##  - <match></match> : matche ce que l'user tappe
                                               ##  - <dim></dim> : text atténué, d'aide
omnibox.onInputStarted                         ##Event handler is FUNC()
omnibox.onInputChanged                         ##Event handler is FUNC(STR, CALLBACK(OBJ_ARR)), où STR est le texte entré et
                                               ##OBJ les suggestions courantes avec comme membres :
                                               ##  - content STR : value entrée
                                               ##  - description STR : value displayed (same markup as setDefaultSuggestion())
                                               ##Il faut donc invoquer setDefaultSuggestion() pour changer suggestion
                                               ##principale et CALLBACK([{ ... }...]) pour les autres
omnibox.onInputEntered                         ##Event handler is FUNC(STR, STR2). STR est le texte validé et STR2 la target
                                               ##parmi "currentTab", "newForegroundTab" or "newBackgroundTab"
omnibox.onInputCancelled                       ##Event handler is FUNC()

OVERRIDE PAGE ==>                              ##HTML page that overrides the default Chrome one.
                                               ##Put in manifest.json, chrome_url_overrides: { STR:STR2 }, where STR2 is the
                                               ##HTML page and STR is :
                                               ##  - "bookmarks", overrides chrome://bookmarks
                                               ##  - "history", overrides chrome://history
                                               ##  - "newtab", overrides chrome://newtab (doesn't work if incognito)
                                               ##If incognito : newtab doesn't work, and bookmarks/history only if
                                               ##icognito: "spanning".

OPTION PAGE ==>                                ##Options for the extensions.
                                               ##Put in manifest.json, options_page: STR, where STR is the HTML file.
                                               ##Should save preferences in localStorage.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     INTERNATIONALIZATION      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INTERNATIONALIZATION ==>                        #Translation files :
                                                #  - under _locales/LOCALE/messages.json
                                                #    LOCALE is usually only first two letters, but supported some .._.., like
                                                #    en_US et zh_CN. Check Chrome Web Store doc for supported locale.
                                                #  - It is chosen by WINDOW.navigator.language
                                                #  - Current locale is first used, then default_locale : manifest.json must
                                                #    define a "default_locale": STR. If missing KEY, returns "".
                                                #  - messages.json est:
                                                #    {
                                                #      "VAR": {
                                                #        "message": STR,
                                                #        ["description": STR2,]
                                                #        ["placeholders": {
                                                #          VAR2: {
                                                #            "content": STR3
                                                #            "example": STR4
                                                #          }
                                                #        }...]
                                                #      }...
                                                #    }
                                                #    VAR est la KEY (STR, only [[:alnum:]_]), STR la traduction. Can use the
                                                #    same.
                                                #    STR2 is for translators.
                                                #    placeholders :
                                                #      - STR can use $VAR2$ qui sera remplacé par STR3.
                                                #      - STR3 can include $NUM, qui sera remplacé par la STR numéro NUM de
                                                #        STR_ARR in getMessage()
                                                #      - STR4 est un example pour aider traducteur.
                                                #    STR needs to escape dollars : $$
                                                #JavaScript :
                                                #  - use i18n.getMessage(KEY[, STR_ARR])
                                                #manifest.json and CSS :
                                                #  - use __MSG_KEY__ ("..." if STR, ... if CSS keyword)
                                                #Predefined KEY :
                                                #  - @@ui_locale : current locale
                                                #  - @@bidi_[reversed_]dir : "ltr" or "rtl" (should always be in CSS)
                                                #  - @@bidi_start|end_edge : "left" or "right"
i18n.getAcceptLanguages(CALLBACK)               #Invoque CALLBACK(STR_ARR), pour la liste des accepted languages (différent
                                                #de LOCALE)

WEBSTORE TRANSLATION ==>                        #In the Developer Dashboard, can pick the language for texts and screenshots.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         WINDOWS/TABS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CWindow                                        ##CWindow is a browser window, not a DOM WINDOW.
Tab                                            ##Permission : "tabs" for all tabs.* et windows.* except
                                               ##tabs.create|update|[on]remove().
                                               ##However, TAB.[favicon]url will not be accessible.

CWINDOW.id                                     ##UINT.
                                               ##Can also be :
                                               ##  - windows.WINDOW_ID_NONE if no CWINDOW has focus.
                                               ##  - windows.WINDOW_ID_CURRENT (current CWINDOW) :
                                               ##    - same CWINDOW than calling code
                                               ##    - if no CWINDOW (background page) : last active CWINDOW
CWINDOW.focused                                ##BOOL
CWINDOW.top|left                               ##Number of pixels from screen top|left
CWINDOW.width|height                           ##UINT
CWINDOW.tabs                                   ##TAB_ARR
CWINDOW.incognito                              ##True if incognito mode
CWINDOW.alwaysOnTop                            ##True if set to be always on top
CWINDOW.state                                  ##"normal", "minimized", "maximized" or "fullscreen"
CWINDOW.type                                   ##"normal" (with chrome), "popup", "panel" (both without chrome) or "app"
                                               ##(only for apps).
windows.getAll([OBJ, ]CALLBACK)                ##Exécute CALLBACK(CWINDOW_ARR) for all current CWINDOW.
                                               ##If OBJ is not { populate: true }, doesn't fill CWINDOW.tabs
windows.getCurrent(...)                        ##Same but only for the CWINDOW dont id est WINDOW_ID_CURRENT
windows.getLastFocused(...)                    ##Same but only for the focused CWINDOW.
windows.get(UINT, ...)                         ##Same but only for the CWINDOW dont id est UINT.
windows.create(OBJ[, CALLBACK])                ##Crée une CWINDOW, où OBJ sont les properties :
                                               ##  - except tabs, alwaysOnTop and state
                                               ##  - but with tabId UINT, étant un TAB to move to new CWINDOW
                                               ##Invoque ensuite CALLBACK(CWINDOW)
windows.onCreated                              ##Fired when new CWINDOW. Programatically or with GUI.
                                               ##Event handler is FUNC(CWINDOW)
windows.update(UINT,...[, CALLBACK])           ##Same, but doesn't create but change properties for CWINDOW dont id est UINT :
                                               ##  - except incognito and type
                                               ##  - with drawAttention : if true, makes the CWINDOW blinks, but doesn't give
                                               ##    it the focus
                                               ##Invoque ensuite CALLBACK(CWINDOW)
windows.remove(UINT[, CALLBACK])               ##Removes CWINDOW dont id est UINT, et invoque CALLBACK(CWINDOW)
windows.onRemoved                              ##Programatically or with GUI. Event handler is FUNC(UINT)
windows.onFocusChanged                         ##Event handler is FUNC(UINT). Can be window.WINDOW_ID_NONE.

TAB.id                                         ##UINT unique.
TAB.active                                     ##True if the current tab
TAB.highlighted                                ##Comme active, sauf que peut être plusieurs TAB à la fois (pour les
                                               ##bouger/manipuler tous à la fois). En GUI : Shift+Click on tabs.
TAB.pinned                                     ##True if pinned (right-click > Pin tab)
TAB.status                                     ##"loading" or "complete"
TAB.title                                      ##STR
TAB.url                                        ##STR
TAB.faviconUrl                                 ##STR
TAB.index                                      ##Index UINT au sein de la CWINDOW
TAB.openerTabId                                ##TAB.index du tab opener. If gone, null.
TAB.windowId                                   ##UINT : for CWINDOW.id
TAB.incognito                                  ##True if in an incognito CWINDOW

tabs.query(OBJ, CALLBACK)                      ##Invoque CALLBACK(TAB_ARR) pour les tabs répondant à OBJ (déf: all TAB for all
                                               ##CWINDOW).
                                               ##OBJ a same members than TAB, except openerTabId, faviconUrl, incognito, but
                                               ##with also :
                                               ##  - currentWindow BOOL : if CWINDOW.id == windows.WINDOW_ID_CURRENT
                                               ##  - lastFocusedWindow BOOL : if focused CWINDOW
                                               ##  - windowType STR : for CWINDOW.type
                                               ##  - title can use globbing, and url is CSP_URL
tabs.get(UINT, CALLBACK)                       ##Invoque CALLBACK(TAB) pour le TAB dont id est UINT.
tabs.getCurrent(CALLBACK)                      ##Invoque CALLBACK(TAB) pour le TAB invoquant ce code.
                                               ##Pour avoir le TAB actif, faire tabs.query({ active: true })
tabs.highlight(OBJ, CALLBACK)                  ##Highlight TAB désigné par { [windowId: UINT, ]tabs: [ UINT2[_ARR] ] }, où
                                               ##UINT est window.WINDOW_ID_CURRENT par déf, et UINT2 la TAB position.
                                               ##Active ensuite le premier UINT2 TAB.
                                               ##If different CWINDOW, use windows.update() too.
                                               ##Exécute ensuite CALLBACK(CWINDOW)
tabs.onActivated                               ##Event handler is FUNC({ tabId, windowId })
tabs.onHighlighted                             ##Event handler is FUNC({ tabIds, windowId })
tabs.create(OBJ[, CALLBACK])                   ##Crée un TAB et invoque CALLBACK(TAB) ensuite. OBJ a membres active, pinned,
                                               ##url, index, openerTabId et windowId.
tabs.onCreated                                 ##Event handler is FUNC(TAB). Programatically or GUI.
tabs.update([UINT, ]OBJ[, CALLBACK])           ##Modifie properties OBJ (parmi url, active, hightlighted, pinned, openerTabId)
                                               ##de TAB dont id est UINT (déf: active TAB of current CWINDOW).
                                               ##Invoque ensuite CALLBACK(TAB)
tabs.onUpdated                                 ##Event handler is FUNC(UINT, OBJ, TAB) : only when change of url, status,
                                               ##pinned and faviconUrl. Includes creation of TAB.
tabs.duplicate(UINT[, CALLBACK])               ##Duplicates un TAB dont id est UINT, et invoque CALLBACK(TAB)
tabs.move(UINT[_ARR], OBJ[, CALLBACK])         ##Move TAB dont id est UINT[_ARR] après TAB désigné par { [windowId, ]index }
                                               ##(index can be -1 for last TAB). Index est la position, non l'id.
                                               ##Invoque ensuite CALLBACK(TAB[_ARR])
tabs.onMoved                                   ##Event handler is FUNC(UINT, { windowId, fromIndex, toIndex })
                                               ##Index est la position, non l'id.
                                               ##Not fired when detached.
tabs.onDetached|Attached                       ##Event handler is FUNC(UINT, { new|oldWindowId, new|oldPosition })
                                               ##Both fired when detached (moved to another CWINDOW)
tabs.reload([UINT[, OBJ][, CALLBACK]])         ##Rafraîchit TAB dont id est UINT (déf: current TAB).
                                               ##Si OBJ est { bypassCache: true }, n'utilise pas de cache.
                                               ##Invoque ensuite CALLBACK().
tabs.remove(UINT[_ARR][, CALLBACK])            ##Close les TAB dont id est UINT[_ARR].
                                               ##Invoque ensuite CALLBACK().
tabs.onRemoved                                 ##Event handler is FUNC(UINT, { windowId, isWindowClosing })
                                               ##isWindowClosing : true if TAB closed because CWINDOW is being closed.
tabs.onReplaced                                ##Fired when page is prerendered due to Google Instant.
                                               ##Event handler is FUNC(UINT, UINT2)
tabs.detectLanguage([UINT, ]CALLBACK)          ##Invoque CALLBACK(STR), où STR est le language du TAB dont id est UINT
                                               ##(déf: current TAB)
tabs.captureVisibleTab([UINT, ][OBJ, ]CALLBACK)##Invoque CALLBACK(STR), où STR est une capture d'écran de la CWINDOW dont id
                                               ##est UINT (déf: current CWINDOW), utilisant le Data URI Scheme.
                                               ##OBJ a comme paramètres :
                                               ##  - format : "jpeg" (déf) ou "png"
                                               ##  - quality UINT (only for "jpeg"), 0 to 100 (déf: 90)
                                               ##Permission : URL de la page dont on fait capture d'écran.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           NAVIGATION          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


URLFILTER                                      ##Used in WebNavigation events and declarativeWebRequest.
                                               ##Filter event according to URL.
                                               ##OBJ with members :
                                               ##  - host|path|query|urlContains|Equals|Prefix|Suffix STR (no globbing, no
                                               ##    regex) :
                                               ##    - Can be on different parts of PROTOCOL://HOST[:PORT]/PATH?QUERY#ID.
                                               ##      url doesn't include #ID nor PORT (unless non-default port), but include
                                               ##      PROTOCOL.
                                               ##    - Can be :
                                               ##      - Contains : == "*STR*"
                                               ##      - Equals : == "STR"
                                               ##      - Prefix : == "STR*"
                                               ##      - Suffix : == "*STR"
                                               ##  - urlMatches STR : same as urlEquals, but use regex.
                                               ##  - originAndPathMatches : same but without QUERY.
                                               ##  - schemes STR_ARR : list of PROTOCOL
                                               ##  - ports UINT[_ARR]_ARR : ports accepted, as UINT, or as
                                               ##    [ UINT_BEGIN, UINT_END ]

WEBREQUEST ==>                                 ##Permission : "webRequest[Blocking]"
                                               ##Prefer declarativeWebRequest.
                                               ##Can only access :
                                               ##  - requests which are not blocked by CSP or host permissions.
                                               ##  - http[s]://, ftp:// or chrome-extension:// requests
                                               ##As opposed to webNavigation, includes request of resources on web pages.
                                               ##Also purpose can be to change requests with sync. events.
                                               ##Doesn't show requests :
                                               ##  - related to dividing big resource in multiple requests,
                                               ##  - related to caching.
                                               ##  - cached by the current tab, unless
                                               ##    webRequest.handlerBehaviorChanged(CALLBACK()) is called (avoid because
                                               ##    slow and can be called only every 30 secondes)
                                               ##addListener() have two extra arguments :
                                               ##  - OBJ (required) : filter url parmi :
                                               ##    - urls (required) : CSP_URL_ARR
                                               ##    - types STR_ARR, parmi ceux du premier argument de l'event handler
                                               ##      (cf ci-dessous)
                                               ##    - tabId or windowId UINT
                                               ##  - STR_ARR (optionnel) parmi :
                                               ##    - "blocking"
                                               ##      - means the event handler is synchronous (blocks the request)
                                               ##      - only for Before*, HeadersReceived and AuthRequired
                                               ##      - it can return an OBJ to change current request (see events)
                                               ##    - "requestBody" : gives argument to BeforeRequest event handler
                                               ##    - "responseHeaders" : gives argument to HeadersReceived event handler
                                               ##Event handler is FUNC(OBJ), dont members :
                                               ##  - all events:
                                               ##    - requestId UINT : unique within a browsing session
                                               ##    - url STR
                                               ##    - method STR, e.g. "GET"
                                               ##    - tabId
                                               ##    - [parentF|f]rameId : see webRequest
                                               ##    - type STR, parmi "main_frame", "sub_frame", "stylesheet", "script"
                                               ##      "image", "object", "xmlhttprequest", "other"
                                               ##    - timeStamp TIMESTAMP
                                               ##  - [Before]SendHeaders:
                                               ##    - requestHeaders HTTPHEADERS, which are plain OBJ.
                                               ##      Not all are provided (can be undefined then).
                                               ##  - BeforeSendHeaders :
                                               ##    - as sync. event, can return :
                                               ##      - requestHeaders HTTPHEADERS : the headers to use for asking request
                                               ##  - HeadersReceived, AuthRequired, ResponseStarted:
                                               ##    - statusLine STR
                                               ##    - responseHeaders HTTPHEADERS : not all are provided (can be undefined
                                               ##      then)
                                               ##  - BeforeRedirect, ResponseStarted, Completed, ErrorOccured:
                                               ##    - ip STR : can be IPv4 or IPv6
                                               ##    - fromCache BOOL
                                               ##  - BeforeRedirect, ResponseStarted, Completed:
                                               ##    - statusCode UINT
                                               ##  - others : see events.
webRequest.BeforeRequest                       ##Fired before the request. Use to cancel or redirect requests.
                                               ##Event handler OBJ members :
                                               ##  - requestBody : only if "requestBody" as third argument.
                                               ##    undefined if GET. OBJ avec (optionnel, undefined otherwise) :
                                               ##    - formData OBJ : data POSTed
                                               ##    - raw { bytes: ARRBUFFER, file: STR }: if PUT or POST
                                               ##    - error STR : if error while retrieving it
                                               ##  - as sync. event, can return :
                                               ##    - cancel BOOL : if true, cancel current request
                                               ##    - redirectUrl STR : redirect to URL STR
webRequest.BeforeSendHeaders                   ##Fired when headers are ready. Use to modify headers to be sent.
webRequest.SendHeaders                         ##Fired when headers are ready, and have potentially be modified by
                                               ##BeforeSendHeaders handlers. Use to read final headers to be sent
webRequest.HeadersReceived                     ##Fired each time headers are received from servers (can be several times if
                                               ##redirection). Use to modify headers received.
                                               ##Event handler OBJ members :
                                               ##  - as sync. event, can return :
                                               ##    - responseHeaders HTTPHEADERS : the headers to interpret as reponse of
                                               ##      the request. Only if "responseHeaders" as third argument.
webRequest.AuthRequired                        ##Fired if response ask for credentials. Use to modify credentials.
                                               ##Authentication fires a new [Before]SendHeaders loop.
                                               ##Event handler OBJ members :
                                               ##  - scheme STR, e.g. "Basic" or "Digest"
                                               ##  - realm STR
                                               ##  - challenger { host: STR, port: UINT }
                                               ##  - isProxy BOOL : true if "Proxy-Authenticate", false if "WWW-Authenticate"
                                               ##  - as sync. event, can return :
                                               ##    - authCredentials { username: STR, password: STR }
webRequest.BeforeRedirect                      ##Fired when response ask for redirection. Use to read redirection.
                                               ##Redirection fires a new BeforeRequest/[Before]SendHeaders loop.
                                               ##Event handler OBJ members :
                                               ##  - redirectUrl STR
webRequest.ResponseStarted                     ##Fired when final response line et headers are received. Use to read them.
webRequest.Completed                           ##Fired when final content body has also been received. Use to read it.
webRequest.ErrorOccured                        ##Fired if error.
                                               ##Event handler OBJ members :
                                               ##  - error STR

DECLARATIVE WEBREQUEST ==>                     ##Permission: "declarativeWebRequest"
                                               ##Permission: hosts permissions, ex¢ept for CancelRequest, IgnoreRules,
                                               ##RedirectTo*
                                               ##Like webRequest, but more efficient.
declarativeWebRequest.onRequest.*Rules(...)    ##Event triggered when webRequest is made. What stage of webRequest: depends on
                                               ##conditions and actions. Each condition and action works only for specific
                                               ##webRequest stages (e.g. contentType is triggered with on HeadersReceived
                                               ##events)
                                               ##Supports only rules, no listeners.
                                               ##Cf rules ci-dessus.
                                               ##Conditions are :
                                               ##  - declarativeWebRequest.REQUESTMATCHER, construction OBJ members :
                                               ##    - url: URLFILTER
                                               ##    - firstPartyForCookiesUrl: URLFILTER for first-party cookies
                                               ##    - thirdPartyForCookies BOOL
                                               ##    - resourceType STR_ARR, like types in webRequest
                                               ##    - [exclude]ContentType STR_ARR
                                               ##    - [exclude]Request|ResponseHeaders OBJ_ARR, where OBJ has members :
                                               ##      - name|valueEquals|Prefix|Suffix STR
                                               ##      - name|valueContains STR_ARR
                                               ##    - stages STR_ARR, parmi "onBeforeRequest", "onBeforeSendHeaders",
                                               ##      "onHeadersReceived", "onAuthRequired"
                                               ##Actions are :
                                               ##  - declarativeWebRequest.CANCELREQUEST
                                               ##  - declarativeWebRequest.REDIRECTREQUEST, construction OBJ members :
                                               ##    - redirectUrl STR
                                               ##  - declarativeWebRequest.REDIRECTBYREGEX, construction OBJ members :
                                               ##    - from STR (regex pour transformer current URL)
                                               ##    - to STR (can use "\1", etc.)
                                               ##  - declarativeWebRequest.REDIRECTTOTRANSPARENTIMAGE
                                               ##  - declarativeWebRequest.REDIRECTTOEMPTYDOCUMENT
                                               ##  - declarativeWebRequest.SETREQUEST|RESPONSEHEADER, members :
                                               ##    - name STR
                                               ##    - value STR
                                               ##  - declarativeWebRequest.REMOVEREQUEST|RESPONSEHEADER, members :
                                               ##    - name STR
                                               ##  - declarativeWebRequest.IGNORERULES. Ignore other RULE, if has lower
                                               ##    priority than current RULE and if :
                                               ##    - lowerPriorityThan UINT
                                               ##    - hasTag STR
                                               ##  - declarativeWebRequest.SENDMESSAGETOEXTENSION. Sends message event to
                                               ##    current extension with :
                                               ##      - message STR
                                               ##    It's not runtime.onMessage, but declarativeWebRequest.onMessage, with
                                               ##    event handler FUNC(OBJ), with members :
                                               ##      - message STR
                                               ##      - stage STR
                                               ##      - requestId, url, method, [parentf|F]rameId, tabId, type, timeStamp
                                               ##Example :
                                               ##  chrome.declarativeWebRequest.onRequest.addRules([
                                               ##    {
                                               ##      conditions: [
                                               ##        new chrome.declarativeWebRequest.RequestMatcher({
                                               ##          url: { hostContains: STR }
                                               ##        })
                                               ##      ], actions: [
                                               ##        new chrome.declarativeWebRequest.CancelRequest()
                                               ##      ]
                                               ##    }
                                               ##  ]);

WEBNAVIGATION ==>                              ##Permission: "webNavigation"
                                               ##Sometimes similar to DOM events, but for all tabs/windows.
                                               ##As opposed to webRequest, correspond to a full changement et chargement de
                                               ##page.
                                               ##Event handler of those events is FUNC(OBJ), where OBJ members are :
                                               ##  - all (CreatedNavigationTarget also has source*Id for source)
                                               ##    - frameId UINT : 0 if main frame, positive if IFRAME
                                               ##    - tabId UINT
                                               ##    - processId UINT : 1 processId == 1 tabId, except when tabId is -1
                                               ##      (hidden tabs like with Google Instant)
                                               ##  - all :
                                               ##    - url STR
                                               ##    - timeStamp TIMESTAMP
                                               ##  - Committed, ReferenceFragmentUpdated and HistoryStateUpdated :
                                               ##    - transitionType STR : same as VISITITEM.transition
                                               ##    - transitionQualifiers STR_ARR, parmi :
                                               ##      - "server_redirect" : redirect by HTTP headers sent by server
                                               ##      - "client_redirect" : redirect by JavaScript or HTML client-side
                                               ##      - "forward_back" : user history Forward/Back
                                               ##      - "from_address_bar" : typed in omnibox
                                               ##  - only BeforeNavigate :
                                               ##    - parentFrameId UINT : -1 if not an IFRAME
                                               ##  - TabReplaced has :
                                               ##    - only tabId et timeStamp
                                               ##    - and also replacedTabId (old tabId)
                                               ##All events can have an event filter (cf ci-dessus) { url: URLFILTER_ARR },
                                               ##but without schemes and ports members (en théorie, car en pratique, cela
                                               ##marche)
webNavigation.onBeforeNavigate|Committed|      ##Three last ones are like DOM readyState, and BeforeNavigate is done just
DOMContentLoaded|Completed                     ##before Committed.
                                               ##If redirections, there can be several Committed, onErrorOccured or
                                               ##BeforeNavigate selon la redirection.
                                               ##If Google Instant is enabled, a hidden tab is created when moving from tabs,
                                               ##creating tabs, etc.
                                               ##I think Chrome extensions views are also taken into account, with tabId -1.
webNavigation.onErrorOccured                   ##Fired if error while loading :
                                               ##  - network failure or server error
                                               ##  - user abort (closing tab while loading)
webNavigation.onReferenceFragmentUpdated       ##Like DOM hashchange.
webNavigation.onHistoryStateUpdated            ##Fired when HISTORY.push|replaceState(), or when erasing history via
                                               ##chrome://history
webNavigation.onCreatedNavigationTarget        ##Fired when new tab created by CTRL-clicking on a link.
webNavigation.onTabReplaced                    ##Fired when Google Instant loads a tab.

webNavigation.getFrame(OBJ, CALLBACK)          ##Invoque CALLBACK(OBJ2) pour donner des informations sur la frame (main
                                               ##frame ou IFRAME) désignée par OBJ dont membres sont tabId, processId and
                                               ##frameId. Membres d'OBJ2 sont :
                                               ##  - url
                                               ##  - parentFrameId
                                               ##  - errorOccured BOOL : true if ErrorOccured event fired for this frame
                                               ##OBJ2 est null si frame doesn't exist.
webNavigation.getAllFrames({ tabId }, CALLBACK)##Invoque CALLBACK(OBJ_ARR), où OBJ_ARR est l'ensemble des frames de TAB avec
                                               ##tabId. Membres sont errorOccured, url, parentFrameId, processId et frameId.

CHROMESETTING                                   #Used by other modules.
CHROMESETTING.get(OBJ, CALLBACK)                #Fires CALLBACK(OBJ2), where OBJ2 has members:
                                                #  - value VAL
                                                #  - levelOfControl STR: among "not_controllable",
                                                #    "controlled_by_this|other_extension", "controllable_by_this_extension"
                                                #    Must check it before using CHROMESETTING.set(): useless if not
                                                #    controllable (overrider by a policy), or contolled by other extension.
                                                #  - incognitoSpecific BOOL
                                                #OBJ is { incognito: BOOL }
CHROMESETTING.set(OBJ[, CALLBACK])              #Sets the setting with OBJ:
                                                #  - value VAL
                                                #  - scope: either "regular", "regular_only", "incognito_persistent" or
                                                #    "incognito_session_only"
                                                #Fires CALLBACK(), where runtime.lastError will be set if error.
CHROMESETTING.clear(OBJ[, CALLBACK])            #OBJ is { levelOfControl STR }
                                                #Fires CALLBACK()
CHROMESETTING.onChange                          #Event handler is FUNC(OBJ2) (same OBJ2 as CHROMESETTING.get())

proxy.*                                        ##Permission: "proxy"
proxy.settings                                 ##CHROMESETTING whose value is an OBJ with members:
                                               ##  - mode STR, among:
                                               ##     - "direct": don't use any proxy
                                               ##     - "system": use default proxy
                                               ##     - "fixed_servers": use manual proxy settings (see rules below)
                                               ##     - "pac_script": use Proxy Auto Config (see pacScript below)
                                               ##     - "auto_detect": use a PAC file that can be downloaded at
                                               ##       http://wpad/wpad.dat
                                               ##  - rules OBJ, with members:
                                               ##     - singleProxy OBJ, proxy for HTTP, HTTPS and FTP, with members:
                                               ##        - scheme STR, among "http" (déf), "https", "socks4", "socks5"
                                               ##        - host STR: in Punicode. IDNA not supported.
                                               ##        - port INT (def: default ports)
                                               ##     - proxyForHttp|Https|Ftp: same OBJ
                                               ##     - fallbackProxy: proxy for other protocols
                                               ##     - bypassList STR_ARR: list of servers to connect to without a proxy.
                                               ##       STR is:
                                               ##         - [PROTOCOL://]HOST|IP[:PORT]: can contain *
                                               ##         - IP/MASK
                                               ##  - pacScript OBJ, with members:
                                               ##     - url|data STR
                                               ##     - mandatory BOOL: if false (déf), an error will provoke a direct
                                               ##       connection without proxy
proxy.onProxyError                             ##Event handler is FUNC({ fatal BOOL, error STR, details STR })


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STORAGE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STORAGE ==>                                     #Permission: "storage"
                                                #Avantages par rapport à localStorage :
                                                #  - store OBJ, non STR. FUNC still can't be stored.
                                                #  - async.
                                                #  - can be used by content scripts
                                                #  - better storage event
                                                #  - Cloud sync
                                                #Limites :
                                                #  - storage.local.QUOTA_BYTES (ignored if unlimitedStorage) : 5MB
                                                #  - storage.sync.QUOTA_BYTES : 100KB
                                                #  - storage.sync.QUOTA_BYTES_PER_ITEM : 4KB
                                                #  - storage.sync.MAX_ITEMS : 512
                                                #  - storage.sync.MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE : 10
                                                #  - storage.sync.MAX_WRITE_OPERATIONS_PER_HOUR : 1000
                                                #Extensions data are kept through GUI private data erasing.
storage.local.set(OBJ[, CALLBACK])              #Store VAR valant VAL pour { VAR:VAL... }.
                                                #Invoque CALLBACK() à la fin. runtime.lastError si échec, sinon succès.
storage.local.remove(STR[_ARR][, CALLBACK])     #Clear les VAR désigné par STR[_ARR]. Same CALLBACK que set()
storage.local.clear([CALLBACK])                 #Same but for all VAR.
storage.local.get(OBJ|STR[_ARR][, CALLBACK])    #Retrieve VAR en invoquant CALLBACK(OBJ). If STR is null, retrieve all.
                                                #Renvoie en fait { VAR: VAL }, donc il faut faire OBJ.VAR.
                                                #Can also use a { VAR2:VAL2... }, where VAR2 est la VAR recherché, et VAL2 la
                                                #valeur par défaut (valeur à renvoyer si absent).
                                                #runtime.lastError si échec, sinon succès.
storage.local.getBytesInUse(STR[_ARR][,CALBACK])#Same mais invoque CALLBACK(UINT[_ARR]) pour nombre d'octets.
storage.sync.*                                  #Comme storage.local.*, mais use Chrome sync (saved on the Cloud, not locally)
                                                #So keeps the same for a given user logged in on Chrome on different computers.
storage.managed.*                               #Comme storage.local.*, mais use Chrome policies.
                                                #Policies are admin settings found in /etc/opt/chrome/policies
                                                #(must be only accessible by network admin not network users)
                                                #storage.managed.* allow to create custom policies, and manipulate like
                                                #storage.local.*. Custom policies are defined in a JSON file pointed in
                                                #manifest.json by: "storage": { "managed_schema": "FILE" }
                                                #Each member of the JSON file has:
                                                #  - type: "object|boolean|integer|number|string|array"
                                                #          Top object is "object", with properties being the policies.
                                                #  - properties|additionalProperties OBJ: for object type
                                                #  - items OBJ: for array type
                                                #  - title|description|id: for the policies
storage.onChange                                #Fired when set|remove|clear().
                                                #Event handler is FUNC(OBJ, STR), where STR is "local" ou "sync", and OBJ is
                                                #{ oldValue, newValue }

runtime.getPackageDirectoryEntry(CALLBACK)      #Invoque CALLBACK(DIRECTORYENTRY), avec le root d'un FILESYSTEM "/crxfs"
                                                #(cf DOM doc) pointant vers le root DIR de l'extension.
                                                #Est read-only.

fileSystem.*                                   !#Permissions: { "fileSystem": [ "write"[, "retainEntries", "directory" ] ] }
                                               !#Manipulate real filesystem using the DOM filesystem API.
                                               !#All failures notified with runtime.lastError
fileSystem.chooseEntry(OBJ, CALLBACK)          !#File choose popup. Fired CALLBACK(FILE|DIRECTORYENTRY[_ARR]).
                                               !#ARR if acceptsMultiple. undefined if cancelled.
                                               !#OBJ membes are:
                                               !#  - type:
                                               !#     - "open[Writable]File": picks a FILEENTRY.
                                               !#       If no "write" permissions: error if "Writable", readonly otherwise.
                                               !#     - "saveFile": same as openWritableFile but if file does not exist,
                                               !#       create it.
                                               !#     - "openDirectory": picks a DIRECTORYENTRY.
                                               !#       Must have "directory" permission.
                                               !#       If no "write" permission, will be readonly.
                                               !#  - suggestedName STR
                                               !#  - accepts OBJ_ARR: each file type box:
                                               !#     - description STR
                                               !#     - mimeTypes STR_ARR
                                               !#     - extensions STR_ARR
                                               !#  - acceptsAllTypes BOOL: if false and accepts is set, only accept the formats
                                               !#    of accepts
                                               !#  - acceptsMultiple BOOL (déf: true)
                                               !#Only app page.
fileSystem.retainEntry(ENTRY)                  !#Returns an ID_STR, so that ENTRY can be retrieved later with only the ID_STR
                                               !#using fileSystem.restoreEntry(ID_STR, CALLBACK(ENTRY)).
                                               !#ID_STR will be throws either:
                                               !#  - after 500 retainEntry()
                                               !#  - after app closes, unless "retainEntries" permission.
fileSystem.isRestorable(ID_STR, CALLBACK)      !#Fires CALLBACK(BOOL)
fileSystem.isWritableEntry(ENTRY, CALLBACK)    !#Fires CALLBACK(BOOL)
fileSystem.getDisplayPath(ENTRY, CALLBACK)     !#Fires CALLBACK()

syncFileSystem.*                               !#Permissions: "syncFileSystem"
                                               !#Creates and manages a FILESYSTEM inside Google Drive for this app.
                                               !#Cannot change quota.
syncFileSystem.requestFileSystem(CALLBACK)     !#Fires CALLBACK(FILESYSTEM)
                                               !#DIRECTORYENTRY can't do everything, such as create new directory.
syncFileSystem.setConflictResolutionPolicy     !#If several writes at same times, either "last_write_win" (déf) or "manual"
(STR[, CALLBACK])                              !#Fires CALLBACK()
syncFileSystem.getConflictResolutionPolicy
(CALLBACK)                                     !#Fires CALLBACK(STR)
syncFileSystem.getUsageAndQuota(FILESYSTEM,
CALLBACK)                                      !#Fires CALLBACK({ usageBytes, quotaBytes })
syncFileSystem.getFileStatus[es]               !#Fires CALLBACK(STR[_ARR]), where STR can be "synced", "pending" or
(FILEENTRY[_ARR],CALLBACK)                     !#"conflicting".
syncFileSystem.onFileStatusChanged             !#Event handler is FUNC({ fileEntry: FILEENTRY, status: STR
                                               !#[ action: "added|updated|deleted",
                                               !#direction: "local_to_remote|remote_to_local" })
syncFileSystem.getServiceStatus(CALLBACK)      !#Fires CALLBACK(STR), among "initializing", "running",
                                               !#"authentication_required", "temporary_unavailable" and "disabled".
syncFileSystem.onServiceStatusChanged          !#Event handler is FUNC(STR, STR2), where STR2 is the description.

mediaGalleries.*                               !#Permission: { "mediaGalleries": "read"[, "delete"][, "copyTo"]
                                               !#[, "allAutoDetected"] }
                                               !#Gets FILESYSTEM from typical media DIR, such as iTunes, Picasa or
                                               !#My documents folders.
mediaGalleries.getMediaFileSystems             !#Fires CALLBACK(FILESYSTEM_ARR)
({ interactive: "yes|no|if_needed" }, CALLBACK)!#interactive only for app page (user can ask other folders, or uncheck some)
mediaGalleries.getMediaFileSystemMetadata      !#Returns OBJ with members:
(FILESYSTEM)                                   !#  - name STR (path)
                                               !#  - galleryId STR
                                               !#  - isRemovable BOOL (is it on removable device)
                                               !#  - deviceId STR (if on removable device)
                                               !#  - isMediaDevice BOOL (if on removable device, e.g. a camera DCIM directory)
                                               !#  - isAvailable BOOL (if on removable device)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            HISTORY            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HISTORY ==>                                    ##Permission: "history"
history.search(OBJ, CALLBACK)                  ##Invoque CALLBACK(HISTITEM_ARR), pour les HISTITEM matchant OBJ :
                                               ##  - text : a STR contained in url, title of content of the page (required)
                                               ##    (no globbing/regexp) ("" for any)
                                               ##  - start|endTime TIMESTAMP : only take entries after|before TIMESTAMP
                                               ##  - maxResults UINT : only retrieves UINT most recent results
                                               ##HISTITEM est une ou plusieurs visites d'une url donnée, par opposition à
                                               ##VISITITEM qui est une seule visite.
                                               ##HISTITEM a membres :
                                               ##  - id UINT
                                               ##  - url STR
                                               ##  - title STR : of the page
                                               ##  - visitCount UINT
                                               ##  - typedCount : number of visitCount done by typing the URL
                                               ##  - lastVisitTime : TIMESTAMP
history.getVisits({ url: STR }, CALLBACK)      ##Invoque CALLBACK(VISITITEM_ARR), pour les visites de STR.
                                               ##Membres de VISITITEM :
                                               ##  - id UINT : HISTITEM id
                                               ##  - visitId UINT : VISITITEM id
                                               ##  - referringVisitId UINT : 0 if none
                                               ##  - visitTime : TIMESTAMP
                                               ##  - transition STR : how did it came from :
                                               ##    - "link" : click on a link
                                               ##    - "typed" : typed URL
                                               ##    - "auto_bookmark" : by clicking on browser UI item (like bookmark)
                                               ##    - "auto|manual_subframe" : navigation in a IFRAME, either loaded by
                                               ##      main DOCUMENT (auto), or navigated by user (manual)
                                               ##    - "start_page"
                                               ##    - "form_submit"
                                               ##    - "reload"
                                               ##    - "generated", "keyword[_generated]" : I don't know
history.onVisited                              ##Event handler is FUNC(HISTITEM)
history.add|deleteUrl({ url: STR }[, CALLBACK])##Add or remove HISTITEM + VISITITEM avec url STR.
                                               ##Invoque ensuite CALLBACK()
history.deleteRange(OBJ, CALLBACK)             ##Remove HISTITEM + VISITITEM repondant à OBJ où OBJ est
                                               ##{ [start|endTime]: DOUBLE }
                                               ##Invoque ensuite CALLBACK()
history.deleteAll(CALLBACK)                    ##Same for all
history.onVisitsRemoved                        ##Event handler is FUNC({ allHistory: BOOL, urls: STR_ARR })
topSites.get(CALLBACK)                         ##Permissions: "topSites"
                                               ##Invoque CALLBACK([ { url: STR, title: STR }... ]) des 10 URL les plus visitées

pageCapture.saveAsMHTML({ tabId }, CALLBACK)   ##Invoque CALLBACK(BLOB), où BLOB est le TAB sous forme MHTML (archive HTML).
                                               ##Can only be loaded via file://
                                               ##Permissions: "pageCapture"

downloads.*                                    ##Permission: downloads
downloads.download(OBJ[, CALLBACK])            ##Download a URL, then fires CALLBACK(ID_INT) (undefined if error, and
                                               ##runtime.lastError will be set).
                                               ##OBJ is:
                                               ##  - url STR
                                               ##  - filename STR: of the saved file
                                               ##  - conflictAction STR: if file already exists, either "uniquify" (adds a
                                               ##    counter), "overwrite" or "prompt"
                                               ##  - saveAs BOOL: use a file dialog
                                               ##  - method "GET|POST"
                                               ##  - headers OBJ_ARR: HTTP headers { name, value|binaryValue }
                                               ##  - body STR: HTTP body
downloads.setShelfEnabled(BOOL)                ##Permission: "downloads.shelf"
                                               ##If false, disable download bar at bottom. If error, sets runtime.lastError.
downloads.search(OBJ, CALLBACK)                ##Queries downloaded items by firing CALLBACK(DOWNLOADITEM_ARR), where
                                               ##DOWNLOADITEM is a OBJ with members:
                                               ##  - id UINT
                                               ##  - url STR
                                               ##  - referrer STR: referrer URL
                                               ##  - filename STR
                                               ##  - mime STR
                                               ##  - start|endTime STR: iso 8601 format, can be passed to Date(STR)
                                               ##  - estimatedEndTime STR
                                               ##  - state: "in_progress", "interrupted" or "complete"
                                               ##  - error: if "interrupted", reasons among "FILE_FAILED",
                                               ##    "FILE_ACCESS_DENIED", "FILE_NO_SPACE", "FILE_NAME_TOO_LONG",
                                               ##    "FILE_TOO_LARGE", "FILE_VIRUS_INFECTED", "FILE_TRANSIENT_ERROR",
                                               ##    "FILE_BLOCKED", "FILE_SECURITY_CHECK_FAILED", "FILE_TOO_SHORT",
                                               ##    "NETWORK_FAILED", "NETWORK_TIMEOUT", "NETWORK_DISCONNECTED",
                                               ##    "NETWORK_SERVER_DOWN", "SERVER_FAILED", "SERVER_NO_RANGE",
                                               ##    "SERVER_PRECONDITION", "SERVER_BAD_CONTENT", "USER_CANCELED",
                                               ##    "USER_SHUTDOWN", "CRASH"
                                               ##  - paused BOOL
                                               ##  - canResume BOOL
                                               ##  - bytesReceived INT, totalBytes|fileSize INT: fileSize is after
                                               ##    decompression, totalBytes before. -1 if unknown.
                                               ##  - exists: still on filesystem. Not always accurate (only checked every 10
                                               ##    seconds, and only when downloads.search() is called)
                                               ##  - incognito BOOL: if downloaded while incognito
                                               ##  - danger OBJ, among:
                                               ##     - file: filename is suspicious
                                               ##     - host|url: domain|URL is suspicious
                                               ##     - content: content is suspicious
                                               ##     - uncommon
                                               ##     - unwanted
                                               ##     - safe
                                               ##     - accepted: dangerous, but accepted download
                                               ##  - byExtensionId|Name STR: the extension that initiated the download.
                                               ##Query is controlled by OBJ to limit to items that only:
                                               ##  - any DOWNLOADITEM member, except referrer, estimatedEndTime, canResume,
                                               ##    incognito, byExtensionId|Name
                                               ##  - query STR_ARR: contains all STR ("-STR" for one that does not contain it)
                                               ##  - filename|urlRegex STR
                                               ##  - started|endedBefore|After STR (ms since epoch)
                                               ##  - totalBytesGreater|Less INT
                                               ##  - limit INT (déf: 1000): limit max number of returned items
                                               ##  - orderBy STR_ARR: each STR sort according to a DOWNLOADITEM member,
                                               ##    "-STR" for descending order
downloads.erase(OBJ[, CALLBACK])               ##Erase from downloads history. Same OBJ as downloads.query()
                                               ##Fires CALLBACK(ID_INT_STR)
downloads.pause|resume(ID_INT[, CALLBACK])     ##If pause is unsuccessful, sets runtime.lastError.
                                               ##Fails if download not running|paused.
                                               ##Fires CALLBACK()
downloads.cancel(ID_INT[, CALLBACK])           ##Fires CALLBACK()
downloads.open(ID_INT)                         ##Open the file. Permission: "downloads.open"
                                               ##Sets runtime.lastError if echec (e.g. download not complete)
downloads.removeFile(ID_INT[, CALLBACK])       ##Removes the file. Sets runtime.lastError if error.
                                               ##Fires CALLBACK()
downloads.show(ID_INT)                         ##Show the file in its directory.
downloads.showDefaultFolder()                  ##Show downloads directory.
downloads.acceptDanger(ID_INT[, CALLBACK])     ##Prompts user to accept danger warning.
                                               ##Fires CALLBACK()
downloads.drag(ID_INT)                         ##Starts dragging the file.
downloads.getFileIcon(ID_INT[, { size: INT }], ##Returns DATA URI of icon with CALLBACK(STR).
CALLBACK)                                      ##Should be called after Created event has been fired.
downloads.onCreated                            ##Event handler is FUNC(DOWNLOADITEM)
                                               ##Fired when download begins.
downloads.onErased                             ##Event handler is FUNC(ID_INT)
                                               ##Fired when item erased from download history.
downloads.onChanged                            ##Fired when any of the DOWNLOADITEM members changes, except bytesReceived and
                                               ##estimatedEndTime.
                                               ##Event handler is FUNC(DOWNLOADITEM), where DOWNLOADITEM has few changes,
                                               ##including use { previous: VAL, current: VAL } instead of VAL.
downloads.onDeterminingFilename                ##Fired when download begins, in order to change the filename.
                                               ##Event handler is FUNC(DOWNLOADITEM, FUNC2)
                                               ##FUNC2([OBJ]):
                                               ##  - OBJ is the filename (déf: current default one), not sure about the members
                                               ##    to use
                                               ##  - can be called async., but then FUNC must return true.
                                               ##  - download will not complete until FUNC2 is called.
                                               ##Can only register one event handler.
                                               ##Useless if download initiated by downloads.download(), since could suggest
                                               ##filename in download() arguments.

bookmarks.*                                    ##Permission: "bookmarks"
                                               ##Restrictions:
                                               ##  - cannot add|remove bookmarks in root folder
                                               ##  - cannot rename, move or remove bookmarks in the Bookmark bar and the
                                               ##    Other Bookmarks
                                               ##  - cannot do more than bookmarks.MAX_WRITE_OPERATIONS_PER_HOUR|
                                               ##    MAX_SUSTAINED_WRITE_OPERATIONS_PER_MINUTE for move(), update(),
                                               ##    create() and remove() (déf: 100 and 2)
BOOKMARKTREENODE                               ##Either a bookmark or a bookmark folder
BOOKMARKTREENODE.id                            ##STR
BOOKMARKTREENODE.parentId                      ##undefined if in root folder
BOOKMARKTREENODE.children                      ##BOOKMARKTREENODE_ARR
BOOKMARKTREENODE.index                         ##Position INT within the folder
BOOKMARKTREENODE.url                           ##
BOOKMARKTREENODE.title                         ##Displayed title
BOOKMARKTREENODE.dateAdded                     ##DOUBLE (ms since Epoch)
BOOKMARKTREENODE.dateGroupModified             ##For bookmark folder, when its content has changed (DOUBLE)
bookmarks.create(OBJ[, CALLBACK])              ##OBJ has members parentId, index, title and url.
                                               ##Fires CALLBACK(BOOKMARKTREENODE)
bookmarks.move(ID_STR, OBJ[, CALLBACK])        ##OBJ is the destination { parentId, index }
                                               ##Fires CALLBACK(BOOKMARKTREENODE)
bookmarks.update(ID_STR, OBJ[, CALLBACK])      ##OBJ are the changes { title, url }
                                               ##Fires CALLBACK(BOOKMARKTREENODE)
bookmarks.remove[Tree](ID_STR[, CALLBACK])     ##Tree if bookmark folder.
                                               ##Fires CALLBACK()
bookmarks.search(STR|OBJ, CALLBACK)            ##Fires CALLBACK(BOOKMARKTREENODE_ARR)
bookmarks.get(ID_STR[_ARR], CALLBACK)          ##Fires CALLBACK(BOOKMARKTREENODE_ARR)
bookmarks.getChildren(ID_STR, CALLBACK)        ##Fires CALLBACK(BOOKMARKTREENODE_ARR)
bookmarks.getRecent(INT, CALLBACK)             ##Returns the max. INT most recent bookmarks, with
                                               ##CALLBACK(BOOKMARKTREENODE_ARR)
bookmarks.getTree(CALLBACK)                    ##Retrieves the whole bookmark hierarchy.
                                               ##CALLBACK(BOOKMARKTREENODE_ARR)
bookmarks.getSubTree(ID_STR, CALLBACK)         ##Retrieves part of the bookmark hierarchy.
                                               ##CALLBACK(BOOKMARKTREENODE_ARR)
bookmarks.onCreated                            ##Event handler is FUNC(ID_STR, BOOKMARKTREENODE)
bookmarks.onRemoved                            ##Event handler is FUNC(ID_STR, { parentId, index })
bookmarks.onChanged                            ##Event handler is FUNC(ID_STR, { title, url })
bookmarks.onMoved                              ##Event handler is FUNC(ID_STR, { parentId, index, oldParentId, oldIndex })
bookmarks.onChildrenReordered                  ##Event handler is FUNC(ID_STR, { childIds ID_STR_ARR })
bookmarks.onImportBegan|Ended                  ##Event handler is FUNC()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          AUDIO VIDEO          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


tabs.captureVisibleTab(...)                     #Capture d'écran: cf plus haut.

tabCapture.*                                   ##Permission: "tabCapture"
tabCapture.capture(OBJ, CALLBACK)              ##Makes a screencast. OBJ are options with members:
                                               ##  - audio|video BOOL
                                               ##  - audio|videoConstraints: OBJ, with members:
                                               ##     - mandatory OBJ
                                               ##     - optional OBJ
                                               ##Fires CALLBACK(LOCALMEDIASTREAM) (needs to learn WebRTC)
                                               ##Ne marche que lorque la FUNC englobante a été initié par l'user, par exemple
                                               ##un browsingAction.
tabCapture.getCapturedTabs(CALLBACK)           ##Fires CALLBACK(CAPTUREINFO), where CAPTUREINFO are info for each captured
                                               ##tab, a OBJ with members:
                                               ##  - tabId INT
                                               ##  - status: "pending", "active", "stopped" or "error"
                                               ##  - fullscreen BOOL
tabCapture.onStatusChanged                     ##Fired when CAPTUREINFO.status changes.
                                               ##Event handler is FUNC(CAPTUREINFO)

tts.*                                           #Permission: "tts"
tts.speak(STR[, OBJ][, CALLBACK])               #Makes a robotic voice pronounce STR (max 32768 chars).
                                                #STR can be SSML (still works if the ttsEngine don't support it), a XML
                                                #format allowing more control on the voice.
                                                #Can provide OBJ:
                                                #  - onEvent: event handler for any kind of event.
                                                #    Fires FUNC(OBJ), where OBJ has members:
                                                #      - type, among:
                                                #        - "start|end"
                                                #        - "word|sentence": word or sentence boundaries.
                                                #        - "marker": SSML markup boundaries
                                                #        - "interrupted"
                                                #        - "cancelled"
                                                #        - "error": can check OBJ.errorMessage
                                                #      - charIndex: position, for word|sentence|marker event
                                                #  - requiredEventTypes STR_ARR: TTSVOICE must implement those events
                                                #  - desiredEventTypes STR_ARR: only those events will be emitted
                                                #  - voiceName STR: TTSVOICE to use (see getVoices()). "" for any available.
                                                #  - lang STR
                                                #  - enqueue BOOL: waits for current voice to finish (déf: false)
                                                #  - extensionId STR: use the TTSEVENGINE of an extension
                                                #  - rate DOUBLE: speed (déf: 1). Can't be below 1/10 or above 10, but some
                                                #    voices are even lower range.
                                                #  - pitch DOUBLE: between 0 and 2 (déf: 1)
                                                #  - volume DOUBLE: between 0 and 1 (déf: 1)
                                                #Fires CALLBACK right away, inside which runtime.lastError will be set if error
tts.stop()                                      #
tts.pause|resume()                              #
tts.isSpeaking(CALLBACK)                        #Fires CALLBACK(BOOL). Doesn't work on Mac OS X
tts.getVoices(CALLBACK)                         #Gets all available voices by firing CALLBACK(TTSVOICE_ARR), where TTSVOICE
                                                #is OBJ with members:
                                                #  - voiceName STR
                                                #  - lang STR
                                                #  - gender: "male" or "female"
                                                #  - remote BOOL: true if voice over network
                                                #  - extensionId STR: extension providing the voice
                                                #  - eventTypes STR: events that this voice can emit

ttsEngine.*                                    ##Permission: "ttsEngine"
                                               ##Must create TTSVOICE... by putting in manifest:
  tts_engine                                   ##OBJ, with only member:
    voices                                     ##OBJ_ARR, where OBJ has members:
                                               ##  - voice_name STR
                                               ##  - lang STR
                                               ##  - gender STR
                                               ##  - event_types STR_ARR:
                                               ##     - at least "end" must be supported
                                               ##     - "interrupted" and "cancelled" can't be generated.
                                               ##     - use FUNC2(OBJ) to emit an event (see below), with OBJ having members
                                               ##       event_type STR, charIndex STR, errorMessage STR
ttsEngine.onSpeak                              ##Event handler is FUNC(STR, OBJ, FUNC2), where STR and OBJ are the first two
                                               ##arguments of tts.speak() (only voiceName, lang, gender, volume, pitch and
                                               ##rate members), and FUNC2 is used to send events.
ttsEngine.onStop|Resume|Pause                  ##Event handler is FUNC()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ALARMS/IDLE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ALARMS ==>                                      #Permissions: "alarms"
                                                #Like setTimeout|Interval(), but for event pages.
                                                #An ALARM fires alarms.onAlarm event (event handler is FUNC(ALARM)) et a
                                                #membres :
                                                #  - name STR
                                                #  - scheduledTime TIMESTAMP : current alarm
                                                #  - periodInMinutes DOUBLE : if not null, repeats every DOUBLE seconds
                                                #Persistent accross browser sessions : set up in Installed/Update event.
alarms.create([STR, ]OBJ)                       #Create ALARM dont name est STR (déf: "") et OBJ :
                                                #  - when TIMESTAMP ou delayInMinutes DOUBLE (current TIMESTAMP + DOUBLE
                                                #    seconds) (min: 1)
                                                #  - periodInMinutes DOUBLE (optionnel)
                                                #If ALARM STR exists, replace it.
alarms.get([STR, ]CALLBACK)                     #Invoque CALLBACK(ALARM) de l'ALARM dont name est STR (déf: "")
alarms.getAll(CALLBACK)                         #Invoque CALLBACK(ALARM_ARR)
alarms.clear([STR])                             #(déf: "")
alarms.clearAll()

power.*                                         #Permissions: "power"
power.requestKeepAwake(STR)                     #Makes the OS not activate the sleep mode if "system" and, if "display", also
                                                #doesn't dim/turn off the screen.
power.releaseKeepAwake()                        #Annule.

idle.*                                          #Permission: "idle"
idle.queryState(UINT, CALLBACK)                 #Invoque CALLBACK(STR), où STR est :
                                                #  - "locked" if screen is locked
                                                #  - "idle" if no user action in the last UINT seconds (déf: 60, min: 15)
                                                #  - "active" otherwise
idle.onStateChanged                             #Fired when change between "locked", "idle" and "active"
                                                #Event handler is FUNC(STR).
                                                #idle time is 60 sec. par déf, mais peut être modifié par
                                                #idle.setDetectionInterval(UINT) (min: 15)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           COMMANDS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


COMMANDS ==>                                   ##Keyboards bindings (maximum 4) firing onCommand event, anywhere while Chrome
                                               ##has the focus.
                                               ##Bindings can also be set via chrome://extension
                                               ##Declared in manifest.json :
                                               ##  "commands": {
                                               ##    STR: {
                                               ##      "suggested_key": {
                                               ##        OS: BINDING ...
                                               ##      }
                                               ##      [, "description": STR2]
                                               ##    }...
                                               ##  }
                                               ##STR est le name de la command. Can also be :
                                               ##  - "_execute_browser|page_action" (don't trigger onCommand, et pas de
                                               ##    "description" ("activate the extension"))
                                               ##OS can be "default", "windows", "mac", "linux", "chromeos"
                                               ##BINDING can be "Ctrl+Shift+E" par exemple.
                                               ##  - Lettres sont uppercases, mais peuvent être exécutées lowercase ou
                                               ##    uppercase.
                                               ##  - Ctrl, Alt, Shift, Option, MacCtrl. Specifier (autre que Shift) mandatory.
                                               ##  - Comma, Period, Home, End, PageUp|Down, Insert, Delete, Tab,
                                               ##    Up|Down|Left|Right
                                               ##  - can't override Chrome shortcuts.
commands.onCommand                             ##Event handler is FUNC(STR), où STR est le command name.
commands.getAll(CALLBACK)                      ##Invoque CALLBACK(COMMAND_ARR), pour l'extension courante, dont membres :
                                               ##  - name STR
                                               ##  - description STR
                                               ##  - shortcut STR : like BINDING


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:    PRIVATE DATA / SETTINGS    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


COOKIES ==>                                    ##Permission : "cookies" et host permissions des URLs des third-party cookies.
cookies.getAll(OBJ, CALLBACK)                  ##Invoque CALLBACK(COOKIE_ARR) des cookies matchant OBJ, same members as COOKIE,
                                               ##except :
                                               ##  - no httpOnly, hostOnly and expirationDate
                                               ##  - but has url STR
                                               ##COOKIE a membres :
                                               ##  - name, value, domain, path STR, secure BOOL
                                               ##  - expirationDate TIMESTAMP : undefined if session cookie.
                                               ##  - session BOOL : true if session cookie
                                               ##  - httpOnly BOOL
                                               ##  - hostOnly BOOL : true if host-only cookie (domain have to match, so can't
                                               ##    be use superdomains)
                                               ##  - storeId STR : COOKIESTORE id
                                               ##Can include expired cookies.
cookies.get(OBJ, CALLBACK)                     ##Pareil pour un seul COOKIE. OBJ has only url, name et storeId (optionnel).
cookies.set(OBJ[, CALLBACK])                   ##Crée COOKIE. Same members as for getAll(), except has httpOnly and
                                               ##expirationDate.
                                               ##Invoque ensuite CALLBACK(COOKIE)
cookies.remove(OBJ[, CALLBACK])                ##Supprime COOKIE. Même OBJ que get().
                                               ##Invoque ensuite CALLBACK(OBJ)
cookies.getAllCookiesStores(CALLBACK)          ##Invoque CALLBACK(COOKIESTORE_ARR), où COOKIESTORE est un emplacemnt de cookies
                                               ##Par exemple incognito windows have different COOKIESTORE. Membres :
                                               ##  - id STR
                                               ##  - tabIds UINT_ARR : TAB utilisant ce COOKIESTORE
cookies.onChanged                              ##Fired when création/suppression/modification of a COOKIE.
                                               ##Event handler is FUNC(OBJ) :
                                               ##  - cookie COOKIE
                                               ##  - removed BOOL
                                               ##  - cause STR :
                                               ##    - "overwrite" : modification (triggers then second event "explicit")
                                               ##    - "explicit" : création ou suppression (including via GUI)
                                               ##    - "expired" : removed because of expirationDate
                                               ##    - "overwrite_expired" : modification où new expirationDate est déjà
                                               ##      expired
                                               ##    - "evicted" : garbage collection

CONTENT SETTINGS ==>                           ##Permission : "contentSettings"
                                               ##Block cookies, images, popups, etc. for a specific CSP_URL.
contentSetting.PROP.get(OBJ, CALLBACK)         ##Invoque CALLBACK({ setting: STR }), où STR sont restrictions de site désigné
                                               ##par OBJ pour PROP.
                                               ##OBJ can be :
                                               ##  - primaryUrl CSP_URL (mandatory): main frame URL (except for cookies:
                                               ##    cookies URL). CSP_URL must use * for PATH.
                                               ##  - secondaryUrl CSP_URL : for cookies, main frame URL. for images, image URL.
                                               ##    not used for others. CSP_URL must use * for PATH.
                                               ##  - resourceIndentifier RESOURCEIDENTIFIER : for plugins, members are :
                                               ##     - id STR
                                               ##     - description STR
                                               ##    List can be returned by contentSetting.plugins.getResourceIndentifiers
                                               ##    (CALLBACK), with CALLBACK(RESOURCEIDENTIFIER_ARR)
                                               ##  - incognito BOOL (déf: false)
                                               ##PROP et STR can be :
                                               ##  - cookies : "allow" (déf), "block", "session_only" (only session cookies)
                                               ##  - images, javascript, plugins : "allow" (déf), "block"
                                               ##  - popups : "allow", "block" (déf)
                                               ##  - notifications : "allow", "block", "ask" (déf)
contentSetting.PROP.set(OBJ[, CALLBACK])       ##Pareil mais pour set. OBJ differences :
                                               ##  - use STR "regular" ou "incognito_session_only" instead of incognito BOOL.
                                               ##  - setting STR.
                                               ##  - primary|secondaryPattern instead of primary|secondaryUrl
                                               ##Invoque ensuite CALLBACK()
contentSetting.PROP.clear({ scope: STR }       ##Supprime les invocations de PROP.set() par current extension.
[, CALLBACK])                                  ##STR est "regular" ou "incognito_session_only".
                                               ##Invoque ensuite CALLBACK()

privacy.*                                      ##Permission: "privacy"
                                               ##All members are CHROMESETTING, with a BOOL value.
privacy.network.networkPredictionEnabled       ##Prerender websites (<link rel="prefetch"), DNS cache and preopen TCP/SSL
                                               ##ports.
privacy.services.alternateErrorPagesEnabled    ##Uses a web service to help resolve navigation errors.
privacy.services.autofillEnabled               ##Autofill forms
privacy.services.safeBrowsingEnabled           ##Protects from fishing and malware
privacy.services.searchSuggestEnabled          ##Search suggestion in Omnibox
privacy.services.spellingServiceEnabled        ##Correct spelling mistakes.
privacy.services.translationServiceEnabled     ##Offers to translate pages with Google translate
privacy.websites.thirdPartyCookiesAllowed      ##Allow third party website to put cookies (déf: false)
privacy.websites.hyperlinkAuditingEnabled      ##Can use <a ping>
privacy.websites.referrersEnabled              ##Sends HTTP referer headers.
privacy.websites.protectedContentEnabled       ##Provide unique ID to plugins to protect content (only Windows)

fontSettings.*                                 ##Permission: "fontSettings"
fontSettings.getFont(OBJ, CALLBACK)            ##OBJ has members:
                                               ##  - script STR, script code (see online doc), e.g. "Latn" or "Jpan"
                                               ##  - genericFamily STR: CSS font-family
                                               ##Fires CALLBACK(OBJ2), where OBJ2 has members:
                                               ##  - fontId STR: "" if none (fallback to general font)
                                               ##  - levelOfControl STR: like for CHROMESETTING
fontSettings.setFont(OBJ[, CALLBACK])          ##OBJ has members script STR, genericFamily STR and fontId STR.
                                               ##Fires CALLBACK()
fontSettings.clearFont(OBJ[, CALLBACK])        ##OBJ has members script STR, genericFamily STR.
                                               ##Fires CALLBACK()
fontSettings.getFontList(CALLBACK)             ##Fires CALLBACK(OBJ_ARR), where OBJ has members fontId STR and displayName STR
fontSettings.getDefault|
DefaultFixed|MinimumFontSize(CALLBACK)         ##Fires CALLBACK(OBJ), where OBJ has members pixelSize INT, levelOfControl STR
fontSettings.setDefault|                       ##OBJ is { pixelSize INT }
DefaultFixed|MinimumFontSize(OBJ[, CALLBACK])  ##Fires CALLBACK()
fontSettings.clearDefault|
DefaultFixed|MinimumFontSize([CALLBACK])       ##Fires CALLBACK()
fontSettings.onFontChanged                     ##Event handler is CALLBACK(OBJ), where OBJ has members fontId, script,
                                               ##genericFamily and levelOfControl.
fontSettings.onDefault|                        ##Event handler is CALLBACK(OBJ), where OBJ has members pixelSize and
DefaultFixed|MinimumFontSizeChanged            ##levelOfControl

BROWSINGDATA ==>                               ##Permission : browsingData
browsingData.remove(OBJ, OBJ2[, CALLBACK])     ##Remove private data désigné par OBJ2 :
                                               ##  - VAR: BOOL (déf: false), où VAR est appcache, cache, cookies, downloads,
                                               ##    fileSystems, formData (autofill), history, indexedDB, localStorage,
                                               ##    serverBoundCertificates, pluginData, passwords, webSQL
                                               ##Removing cookies can take some time.
                                               ##OBJ décrit les data à supprimer du point de vue de l'origine :
                                               ##  - since TIMESTAMP (déf: 0)
                                               ##  - originType OBJ3 :
                                               ##    - unprotectedWeb BOOL (déf: true) : websites normales
                                               ##    - protectedWeb BOOL (déf: false) : hosted apps
                                               ##    - extension BOOL (déf: false) : extensions et packaged apps
                                               ##GUI erasing private data use unprotectedWeb + protectedWeb, mais sans
                                               ##extension.
                                               ##Invoque CALLBACK() ensuite
browsingData.remove*(...)                      ##Same as browsingData.remove({*: true}, ...), e.g. removeAppcache()
browsingData.settings(CALLBACK)                ##Invoque CALLBACK(OBJ), où OBJ sont les removal options courantes de l'user :
                                               ##  - options : like OBJ de remove()
                                               ##  - dataToRemove : like OBJ2 de remove()
                                               ##  - dataRemovalPermitted : same, but false if not permitted par sysadmin to
                                               ##    be removed.

INCOGNITO ==>                                   #Disable extensions by déf, but can be enabled.
                                                #Doesn't fire startup event.
                                                #Can check if window is incognito before saving data, and respect user private
                                                #browsing.
                                                #manifest.json field "incognito", either :
                                                #  - "spanning" : can't access incognito TABS
                                                #  - "split" (déf):can't communicate between content script and background page
extension.inIncognitoContext                   ##True if content script or background page is in incognito tab/window.
extension.isAllowedIncognitoContext(CALLBACK)  ##Invoque CALLBACK(BOOL) where BOOL is if user allowed extension in incognito.
extension.isAllowedFileSchemeAccess(CALLBACK)  ##Same for "Allow access to file URLs" checkbox (déf: true), e.g. using file://

GOOGLE ANALYTICS ==>                            #To use it :
                                                #  - can specify Google Analytics ID in Chrome Developer Console
                                                #  - use URL https://ssl.google-analytics.com/ga.js in GA snippet (can only
                                                #    use HTTPS)
                                                #  - use "content_security_policy": "script-src 'self'
                                                #    https://ssl.google-analytics.com; object-src 'self'"
                                                #  - on a popup, 1 view == 1 popup opening.
                                                #    On a background script, 1 view == 1 browser session.
                                                #  - to track specific events, use :
                                                #    - _gaq.push([ STR, STR2, STR3 ]) : STR est l'event perso category,
                                                #      STR2 la cible (e.g. id de l'élément), STR3 le DOM event.

CHROME PLATFORM ANALYTICS ==>                   #Other way to include Google Analytics but provides:
                                                #  - work offline (buffer requests)
                                                #  - user can opt-out
                                                #How:
                                                #  - permission: "storage" and "https://www.google-analytics.com"
                                                #  - include google-analytics-bundle.js
analytics.getService(STR)                       #STR is the app name (used to hits scope in GA).
                                                #Returns a GOOGLEANALYTICS
GOOGLEANALYTICS.getTracker(STR)                 #STR is the GA ID, e.g "UA-XXXXX-X". Returns a TRACKER
GOOGLEANALYTICS.getConfig()                     #Returns a CONFIG.
TRACKER.sendAppView(STR)                        #STR is the "page" (like the URL for normal GA)
TRACKER.sendEvent(STR, STR2[, STR3][, NUM])     #STR is category, STR2 action, STR3 label.
TRACKER.sendException([STR[, BOOL]])            #STR is exception description, BOOL is whether fatal.
TRACKER.sendSocial(STR, STR2, STR3)             #STR is social network, STR2 is action, STR3 is content (e.g. "page")
TRACKER.sendTiming(STR, STR2, NUM[, STR3])      #STR is category, STR2 variable, NUM time spent.
TRACKER.startTiming(STR, STR2[, STR3])          #Same but returns a TIMING, that can call TIMING.send() to send timing.
CONFIG.setTrackingPermitted(BOOL)               #Put to false to opt out GA. In theory should always leaves the possibility.
CONFIG.isTrackingPermitted()                    #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            SYSTEM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


runtime.getPlatformInfo(CALLBACK)               #Returns info on OS, as CALLBACK({ os, arch, nacl_arch })

system.storage.*                                #Permission: "system.storage"
system.storage.getInfo(CALLBACK)                #Gets all devices|partitions by firing CALLBACK(OBJ_ARR), where OBJ has
                                                #members:
                                                #  - id STR: not persistent between applications
                                                #  - name STR
                                                #  - type: "fixed", "removable" or "unknown"
                                                #  - capacity DOUBLE: in bytes
system.storage.ejectDevice(ID_STR, CALLBACK)    #Fires CALLBACK(STR), where STR can be "success", "in_use", "no_such_device"
                                                #or "failure".
system.storage.getAvailableCapacity(ID_STR,
CALLBACK)                                       #Fires CALLBACK(ID_STR, DOUBLE)
system.storage.onAttached                       #Event handler is FUNC(OBJ) (same OBJ as getInfo()). Don't seem to work.
system.storage.onDetached                       #Event handler is FUNC(ID_STR). Don't seem to work.

system.display.*                               !#Permission: "system.display"
                                               !#Manage screen devices (including getting)
system.display.getInfo(CALLBACK)               !#Fires CALLBACK(OBJ_ARR), where OBJ members are:
                                               !#  - id STR
                                               !#  - mirrorSourceId STR: if mirroring display is used (Chrome OS only)
                                               !#  - name STR
                                               !#  - bounds { left, top, height, width }
                                               !#  - workArea: same but without OS bars (same as screen.avail*)
                                               !#  - isPrimary BOOL
                                               !#  - isInternal BOOL
                                               !#  - isEnabled BOOL
                                               !#  - dpiX|Y NUM: resolution (can be 0 if not available)
                                               !#  - rotation NUM: 0 if not available (Chrome OS only)
system.display.setDisplayProperties(ID_STR, OBJ!#Update properties, among mirrorSourceId, isPrimary, rotation and
[, CALLBACK])                                  !#boundsOriginX|Y.
                                               !#Fires CALLBACK() (can set runtime.lastError)
system.display.onDisplayChanged                !#Event handler is FUNC()

system.cpu.*                                    #Permission: "system.cpu"
system.cpu.getInfo(CALLBACK(OBJ))               #OBJ has members:
                                                #  - numOfProcessors UINT
                                                #  - archName STR
                                                #  - modelName STR
                                                #  - features STR_ARR
                                                #  - processors OBJ_ARR, where each OBJ has members:
                                                #     - usage OBJ with members user, kernel, idle and total DOUBLE

system.memory.*                                 #Permission: "system.memory"
system.memory.getInfo(CALLBACK(OBJ))            #OBJ has members:
                                                #  - capacity DOUBLE
                                                #  - availableCapacity DOUBLE

serial.*                                       !#Permission: "serial"
                                               !#Manage hardware devices (on serial ports)
serial.getPorts(CALLBACK)                      !#Fires CALLBACK(STR_ARR) of all paths.
serial.open(PORT_STR[{ bitrate: NUM }],CALBACK)!#Connects and fires CALLBACK(ID_STR)
serial.close(PORT_STR, CALLBACK)               !#Fires CALLBACK()
serial.read(ID_STR, UINT, CALLBACK)            !#Fires CALLBACK({ bytesRead: UINT, data: ARRBUFFER })
serial.write(ID_STR, ARRBUFFER, CALLBACK)      !#
serial.flush(ID_STR, CALLBACK)                 !#

socket.*                                       !#Permission: { "socket": [ STR... ] }
                                               !#STR is tcp-connect|listen|udp-bind|send-to:[HOST][:PORT], HOST can be * or
                                               !#*.HOST, PORT can be *
                                               !#Use TCP/UDP sockets.
socket.create("tcp|udp", OBJ, CALLBACK)        !#Fires CALLBACK({ socketId: NUM }). OBJ are options.
socket.destroy(ID_NUM)
socket.connect|bind(ID_NUM, HOST_STR, PORT_NUM,!#Fires CALLBACK(INT). connect for TCP, bind for UDP.
CALLBACK)                                      !#Can use connect for UDP to use write|read() without specifying address.
socket.disconnect(ID_NUM)
socket.read(ID_NUM[, INT], CALLBACK)           !#Fires CALLBACK({ resultCode: INT, data: ARRBUFFER })
socket.write(ID_NUM, ARRBUFFER, CALLBACK)      !#Fires CALLBACK({ bytesWritten: INT })
socket.recvFrom(ID_NUM[, INT], CALLBACK)       !#For UDP. Fires CALLBACK({ resultCode: INT, data: ARRBUFFER, address: STR,
                                               !#port: INT })
socket.sendTo(ID_NUM, ARRBUFFER, ADDRESS_STR,
PORT_INT, CALLBACK)                            !#For UDP. Fires CALLBACK({ bytesWritten: INT })
socket.listen(ID_NUM, ADDRESS_STR, PORT_INT    !#Makes the app a TCP server (cannot use read|write|connect() anymore)
[, INT2], CALLBACK)                            !#INT2 is the listen queue size.
                                               !#Fires CALLBACK(INT)
socket.accept(ID_NUM, CALLBACK)                !#CALLBACK to be fired when connection is accepted (after listen()).
                                               !#Fires CALLBACK({ resultCode: INT, socketId: ID_NUM })
socket.setKeepAlive(ID_NUM, BOOL[, INT], CALBK)!#Fires CALLBACK(BOOL)
socket.setNoDelay(ID_NUM, BOOL, CALLBACK)      !#Fires CALLBACK(BOOL)
socket.getInfo(ID_NUM, CALLBACK)               !#Fires CALLBACK({ socketType "tcp|udp", connected BOOL, peer|localAddress STR,
                                               !#peer|localPort INT })
socket.getNetworkList(CALLBACK)                !#Fires CALLBACK(OBJ_ARR), where OBJ has members name STR, address STR2 and
                                               !#prefixLength INT.
socket.joinGroup(ID_NUM, ADDRESS_STR, CALLBACK)!#Fires CALLBACK(INT). Join a multicast group (UDP)
socket.leaveGroup(ID_NUM, ADDRESS_STR, CALLBAK)!#Fires CALLBACK(INT). Automatically caled by destroy()
socket.getJoinedGroups(ID_NUM, CALLBACK)       !#Fires CALLBACK(STR_ARR)
socket.setMulticastTimeToLive(ID_NUM, INT,
CALLBACK)                                      !#Fires CALLBACK(INT)
socket.setMulticastLoopbackMode(ID_NUM, BOOL,
CALLBACK)                                      !#Fires CALLBACK(INT)

usb.*                                          !#Permission: "usb".
                                               !#Needs also to add in manifest.json:
                                               !#  "usbDevices": OBJ_ARR, with members vendorId INT and productId INT2
                                               !#Check online doc if need to use it.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           DEVTOOLS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


  devtools_page                                ##HTML page STR that behaves like a content script page, but used for devtools.*
                                               ##Only devtools_page can use devtools.*
                                               ##As opposed to regular content scripts, can:
                                               ##  - manipulate developer tools UI
                                               ##  - access JavaScript of the inspected page through inspectedWindow.eval()
                                               ##Needs to use inspectedWindow.eval() to either change the web page or use its
                                               ##console (e.g. console.log())

devtools.inspectedWindow.tabId                 ##Of the inspected page
devtools.inspectedWindow.eval(STR[, OBJ]       ##Performs eval(STR) using a different environment, specified by OBJ:
[, CALLBACK])                                  ##  - frameURL STR: target frame (def: main frame)
                                               ##  - contextSecurityOrigin STR
                                               ##  - useContentScriptContext BOOL: use content script environment, not
                                               ##    inspected page itself
                                               ##Then fires CALLBACK(OBJ2, BOOL), where BOOL is true if exception thrown,
                                               ##and OBJ2 the result of STR (must evaluate to OBJ) (doesn't seem to work).
devtools.inspectedWindow.reload([OBJ])         ##Reload page. Can take options OBJ, where members are:
                                               ##  - ignoreCache BOOL: reload resources even when cached
                                               ##  - userAgent STR
                                               ##  - injectedScript STR: load script STR before any script of the page.
devtools.inspectedWindow.getResources(CALLBACK)##Fires CALLBACK(RESOURCE_ARR).
                                               ##RESOURCE are all HTML pages, CSS pages, JavaScript, images, videos,
                                               ##fonts, indexedDB, localStorage, cookies, etc.
RESOURCE.url
RESOURCE.getContent(CALLBACK)                  ##CALLBACK(STR, "|base64"))
RESOURCE.setContent(STR, BOOL[, CALLBACK])     ##BOOL: sets to false if this is a minor changes that will be followed by other
                                               ##minor changes (not applied yet)
                                               ##Fires CALLBACK([{ error STR }])
devtools.inspectedWindow.onResourceAdded       ##Event handler is FUNC(RESOURCE)
devtools.inspectedWindow.
onResourceContentCommitted                     ##Event handler is FUNC(RESOURCE, STR): STR is the content

devtools.panels.create(STR, STR2, STR3         ##Creates a tab in the developer tools.
[, CALLBACK])                                  ##STR is title, STR2 iconPath, STR3 HTML page path.
                                               ##Fires CALLBACK(EXTENSIONPANEL).
EXTENSIONPANEL.createStatusBarButton(STR, STR2,##Creates a status bar button with:
BOOL)                                          ##  - iconPath STR: 64x24 pixels composed of two 32x24 pixels (inactive and
                                               ##    pressed
                                               ##  - tooltipText STR2
                                               ##  - disabled BOOL
                                               ##Returns BUTTON
BUTTON.update([STR[, STR2]][, BOOL])           ##
BUTTON.onClicked                               ##Event handler is FUNC()
EXTENSIONPANEL.onSearch                        ##Fired when using the developer tools search bar (start, results and cancel).
                                               ##Event handler is FUNC(STR[, STR2]), where STR is action performed
                                               ##and STR2 the query (only for "performSearch")
EXTENSIONPANEL.onShown                         ##Fired when user switches to the panel.
                                               ##Event handler is FUNC(WINDOW)
EXTENSIONPANEL.onHidden                        ##Inverse. Event handler is FUNC()
devtools.panels.elements.onSelectionChanged    ##Fired when an element is selected in the developer tools.
                                               ##Event handler is FUNC()
devtools.panels.elements.createSidebarPane(STR ##Creates a sidebar pane inside a tab (only for Elements tab) in the developer
[, CALLBACK])                                  ##tools.
                                               ##STR is the title, CALLBACK(EXTENSIONSIDEBARPANE)
EXTENSIONSIDEBARPANE.setHeight(STR)            ##CSS VAL
EXTENSIONSIDEBARPANE.setExpression(STR[, STR2] ##Evaluates STR in the inspected page environment, and display the result in
[, CALLBACK])                                  ##the sidebar pane.
                                               ##STR2 is the title.
                                               ##Fires CALLBACK()
EXTENSIONSIDEBARPANE.setObject(...)            ##Same but STR is a JSON object.
EXTENSIONSIDEBARPANE.setPage(STR)              ##Use HTML page STR in the panel.
EXTENSIONSIDEBARPANE.onShown|Hidden            ##Same as EXTENSIONPANEL
devtools.panels.setOpenResourceHandler         ##Sets a CALLBACK for when the user tries to open a resource from within the
(CALLBACK)                                     ##developer tools. Not called when resource is wrong URL.
                                               ##User should choose the handler in the developer tools settings.
                                               ##Sets CALLBACK to null to unset it.
                                               ##Must be CALLBACK(RESOURCE)

devtools.network.getHAR(CALLBACK)              ##Fires CALLBACK(OBJ), where OBJ is a HAR log.
devtools.network.onRequestFinished             ##Fired when a network request is finished.
                                               ##Event handler is FUNC(REQUEST)
REQUEST.getContent(CALLBACK)                   ##Fires CALLBACK(STR, "|base64")
devtools.network.onNavigated                   ##Fired when the page navigates to a new page.
                                               ##Event handler is FUNC(URL_STR)

debugger.*                                     ##Permission: "debugger"
                                               ##Debugger protocol use:
                                               ##  - some FUNC(ARGS...), with translate as STR(OBJ) with sendCommand()
                                               ##    Return value is { error OBJ, ... }, passed through sendCommand() callback.
                                               ##    (I don't mention error OBJ below)
                                               ##     - all *.FUNC() propose a *.enable|disable(): must be done first.
                                               ##  - some event with handlers FUNC(ARGS...) which translate as FUNC(OBJ) in
                                               ##    onEvent handler.
                                               ##Can do most things that are being done on each devtools pages (see online doc
                                               ##of the debugging protocol for precise functions), including manipulating
                                               ##breakpoints.
debugger.attach(DEBUGGEE, STR[, CALLBACK])     ##Starts to debug a tab.
                                               ##Can't start if devtools are opened on that tab. Detach when they are opened.
                                               ##STR is version, i.e. "1.0".
                                               ##Fires CALLBACK(): sets runtime.lastError if error.
debugger.detach(DEBUGGEE[, CALLBACK])          ##
debugger.sendCommand(DEBUGGEE, STR[, OBJ]      ##Fires FUNC_STR(ARGS_OBJ), which returns in CALLBACK(OBJ)
[, CALLBACK])                                  ##(sets runtime.lastError if error)
DEBUGGEE.tab|extensionId                       ##When tab is [not] an extension page
DEBUGGEE.targetId                              ##Opaque Id
debugger.getTargets(CALLBACK)                  ##Fires CALLBACK(TARGETINFO_ARR), where TARGETINFO has members:
                                               ##  - type: among "page", "background_page", "worker", "other"
                                               ##  - id|tabId|extensionId STR
                                               ##  - attached BOOL
                                               ##  - title STR
                                               ##  - url STR
                                               ##  - faviconUrl STR
debugger.onEvent                               ##Event handler is FUNC(DEBUGGEE, STR, OBJ)
debugger.onDetach                              ##Event handler is FUNC(DEBUGGEE, STR), where STR is among "target_closed",
                                               ##"canceled_by_user", "replaced_by_devtools"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OTHERS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NOT SUPPORTED ==>                               #In development :
                                                #  - system.cpu|memory, desktopCapture, infobars, gcm, location
                                               ##  - declarativeContent, processes, sessions, signedInDevices
                                               !#  - audio, bluetooth
                                                #Only on Chrome OS :
                                               ##  - fileBrowserHandler
                                               !#  - file_handlers: drag and drop files to the app to restart it
                                               !#  - wallpaper
                                                #Not on Linux:
                                                #  - notifications


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TO FINISH           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


pushMessaging.*                                 #Permission: "pushMessaging"
                                                #Channel ID: specific for extension + user Google account.
                                                #Subchannel ID: from 0 to 3, to give four different subchannels by user.
pushMessaging.getChannelId([BOOL, ]CALLBACK)    #Gets the channel ID by firing CALLBACK({ channelId STR })
                                                #If not logged in, if false, ???, if true, will ask user to log in.
pushMessaging.onMessage                         #Fired when a message has been pushed to user.
                                                #Event handler is FUNC({ subchannelId INT, payload STR })

identity.*                                      #Permission: "identity"
identity.getAuthToken([{ interactive: BOOL }, ] #Gets an OAuth2 token by firing CALLBACK(STR).
CALLBACK)                                       #If first time or last one expired, creates a new one. Otherwise, use cache.
                                                #Client ID:
                                                #  - is checked during OAuth2 requests
                                                #  - is obtained by registering the app in the Google APIs console, using the
                                                #    same account used to upload the app on the webstore
                                                #     - must provide an APP_ID:
                                                #        - different from EXTENSIONID
                                                #        - should never change after registration, so use a fixed key: STR in
                                                #          the manifest.json.
                                                #     - Create new OAuth2 ID -> installed app -> Chrome app
                                                #  - put in manifest.json:
                                                #      "oauth2": {
                                                #        "client_id": "CLIENT_ID",
                                                #        "scopes": [
                                                #          ["https://www.googleapis.com/auth/API"]
                                                #          ...
                                                #        ]
                                                #      }
                                                #Linked to a specific Google account.
                                                #If not signed in, if false, fails, if true, will prompt user to sign in.
identity.removeCachedAuthToken({ token: STR }   #Do it on invalid tokens.
[, CALLBACK])                                   #Fires CALLBACK()
identity.launchWebAuthFlow(OBJ, CALLBACK)       #Starts an OAuth auth flow by:
                                                #  - going to OBJ.url
                                                #  - when provider redirects to https://EXTENSIONID.chromiumapp.org/PATH
                                                #    it is passed to CALLBACK(STR)
                                                #OBJ.interactive???
identity.onSignInChanged(CALLBACK)              #Fired when signing in or out.
                                                #Event handler is FUNC({ id STR }, BOOL), where BOOL is whether is signed in.
                                                #id is unique for any Google account.

WEBSTORE ==>
  - upload app using the Chrome developer console
     - can see impressions and downloads
     - can publish to group of people or everyone.
     - needs to check OpenID to use assign users an Open ID
     - specify the URL owned by the developer (used in several APIs)
     - specify pricing
  - webstore:
     - description and nice URL
     - installing (is like drag and dropping the .crx)
     - payments:
        - in-app: Google Wallet (min. of either 5% or 2%+30c). Buyer can use any card. Can be subscriptions.
        - at purchase:
           - either one-time, or subscription (month or year) (5% fee)
           - Use Licensing API to check that user has paid (not 100% reliable for packaged apps)???
              - Needs App ID (find it on Developer Dashboard)
              - Need User ID (needs to check box in Developer Dashboard)
              - Needs to generate an OAuth access token
           - Good idea to provide free trial
