
       
   DOM  
       



TODO ==> split some of file into own files in my doc (e.g. fetch, URLPattern, etc.)

SUMMARY ==>                                     #Basic:
                                                #  - HTML: integrating with HTML, integrity
                                                #Architecture:
                                                #  - Rendering:
                                                #     - steps: preload parsing, parsing, cascading, layout, paint, composite
                                                #     - performance: avoid re-rendering, max 4ms JavaScript
                                                #  - Loading (async|sync)
                                                #Utilities:
                                                #  - Utilities: onerror|unhandledrejection|rejectionhandled()
                                                #  - Timeouts: setTimeout|Interval|Immediate(), requestAnimationFrame()
                                                #  - console: logs, trace, profile, timeStamp
                                                #  - performance: timing (initial network, document loading performance), user (custom)
                                                #Events:
                                                #  - Events
                                                #  - UIEvent: focus, input|change, keyboard, composition, scroll, resize
                                                #  - Mouse/touch events
                                                #  - Load events: and page visibility
                                                #Document:
                                                #  - Top-level: WINDOW, DOCUMENT
                                                #  - query
                                                #  - iteration: crawling
                                                #  - test
                                                #  - creation
                                                #  - manipulation
                                                #  - observing
                                                #  - content
                                                #  - attr|text|comment
                                                #  - range|selection
                                                #Browsing:
                                                #  - URI|location
                                                #  - history
                                                #Browser|device:
                                                #  - platform
                                                #  - geolocation
                                                #  - orientation|motion
                                                #Networking:
                                                #  - offline
                                                #  - HTTP headers
                                                #  - XHR, fetch, beacon
                                                #  - websocket, SSE
                                                #Storage:
                                                #  - streams
                                                #  - files
                                                #  - storage: localStorage, sessionStorage
                                                #  - indexedDB
                                                #  - encoding
                                                #  - compression
                                                #  - storage summary
                                                #Messaging/workers:
                                                #  - messaging
                                                #  - workers
                                                #UI components:
                                                #  - popup
                                                #  - drag&drop
                                                #  - RTF


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERAL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VERSION ==>                                     #4

STANDARD ==>                                    #W3C for most
                                                #But WHATWG (fork) has few specs

TYPES ==>                                       #  - DOM (Document Object Model): WINDOW.document.*
                                                #  - BOM (Browser Object Model): browser elements, i.e. frames, history, location, window
                                                #  - Web APIs: Usually on WINDOW, e.g. WebSocket, BatteryManager, SessionStorage, etc.

XML ==>                                         #This doc doesn't include objects, etc. related to XML: check XML doc.

INTEROPERABILITY ==>                            #See HTML doc for list of browsers


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTML              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INCLUDING IN HTML ==>                           #Priority is from top to bottom

LOADING|PARSING ORDER ==>                       #See DOM doc

<script>                                        #Loaded right away, sync (in same thread)
  src="FILE.js"                                 #From external file.
  type="STR"                                    #MIME type. Def: 'text/javascript'
  type="module"                                 #See JavaScript doc
  async                                         #Loaded right away, async (in a different thread)
                                                #"src" mandatory, not compatible with defer.
  defer                                         #Loaded on DOMContentLoaded, sync (in same thread)
                                                #"src" mandatory, not compatible with async.
  integrity="ALGO-HASH ..."                    $#See <link>
  charset="CHARSET"                             #Only works if Content-Type [S] does not provide the information (including when accessing files locally)
                                                #E.g. 'UTF-8' (def)
  withVAR="VAL"                                 #Like `import ... { with: { VAR: VAL} }`
  SCRIPT.text                                   #Like SCRIPT.textContent
DOCUMENT.scripts                                #SCRIPT_HTMLCOLL

<script>CODE</script>                           #Inline.

<a|area>
  href="JavaScript:CODE"                        #
<any>
  onEVENT="CODE"                                #Deprecated. EVENT lowercase.

<noscript>...</noscript>                        #When JavaScript not available.



                
   ARCHITECTURE  
                



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         BROWSER PARTS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PARTS ==>                                       #Browser chrome:
                                                #  - meta-information: history
                                                #  - tabs-related features
                                                #  - print, save
                                                #  - changing URL: address bar, back|forward|refresh|home button, bookmarks
                                                #  - changing loading state: stop button
                                                #  - changing document: zoom, privacy, autofil, default font size, language, accessibility
                                                #Extensions/addons
                                                #Devtools: treated like a document
                                                #Document: actual webpage


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        DOCUMENT PARTS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PARTS ==>                                       #Rendering engine:
                                                #  - parse and ask UI backend to paint HTML
                                                #UI backend:
                                                #  - does the pixel painting (a bit like Cairo)
                                                #JavaScript interpreter:
                                                #  - parse and execute JavaScript
                                                #Networking:
                                                #  - HTTP requests
                                                #Data storage:
                                                #  - localStorage, cookies, IndexedDB, etc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        RENDERING STEPS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STEPS ==>                                       #Event-driven
                                                #Done locally, i.e. to the parts that changed


PRELOAD PARSING ==>                             #Like parsing, but simplistic for early optimizations
                                                #  - e.g. starting to perform HTTP requests

PARSING ==>                                     #HTML:
                                                #  - creates DOM tree
                                                #  - context-sensitive language, whereas CSS and JavaScript are context-free, because HTML has forgiving syntax
                                                #CSS:
                                                #  - creates CSSOM tree
                                                #JavaScript:
                                                #  - also execute it, which will get|set DOM|CSSOM tree

CASCADING ==>                                   #Creates render tree:
                                                #  - by combining DOM tree + CSSOM tree
                                                #     - assign CSS rules to DOM nodes
                                                #     - decide CSS rules priority (specificity)
                                                #  - does not include DOM nodes:
                                                #     - with display: none
                                                #     - not attached to DOCUMENT
                                                #     - not visible in viewport

LAYOUT ==>                                      #Add layout information to render tree:
                                                #  - viewport position|dimensions to render tree elements
                                                #  - depends on CSS display, box model and positioning properties:
                                                #     - one element can have several areas, e.g. multiline inline element
                                                #     - one element can have no area, e.g. with display none

PAINT ==>                                       #Calculate pixel information from render tree

COMPOSITE ==>                                   #Mix several paint areas, e.g. transparency

UI BACKEND ==>                                  #Change the actual screen pixels


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     RENDERING PERFORMANCE     :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WHEN IS RENDERING TRIGGERED ==>                 #Cascading (recalculating style):
                                                #  - changing HTML|CSS
                                                #Layout (reflow):
                                                #  - changing element position|dimensions
                                                #  - viewport resizing|scrolling
                                                #  - does not trigger reflow (depends on browser):
                                                #     - stacking:               opacity|visibility, z-index
                                                #     - colors:                 border-color, color
                                                #     - images:                 background-*, border-image-*
                                                #     - non-layout decorations: border-radius, text-decoration
                                                #Paint (repaint):
                                                #  - changing UI but not positions|dimensions (e.g. colors)
                                                #  - does not trigger repaint nor reflow (depends on browser):
                                                #     - effects:                perspective*, transform*, backface-visibility
                                                #                               E.g. prefer translate() over positioning properties
                                                #     - browser UI:             pointer-events, resize, cursor
                                                #     - page breaks:            orphans|widows

GOOD PRACTICES ==>                              #Avoiding re-rendering:
                                                #  - re-rendering is deferred:
                                                #     - unless querying DOM|CSS info, which (to be calculated) requires reflow|repaint
                                                #     - so should do DOM|CSSOM getters before DOM|CSSOM setters
                                                #  - put NODE out of render tree temporarily while working on it
                                                #     - e.g. display: none or detach from DOCUMENT
                                                #  - change many things at once:
                                                #     - CSS classes > CSSSTYLEDEC.cssText > CSSSTYLEDEC.PROP
                                                #Limit re-rendering:
                                                #  - to small|simple UI parts
                                                #Limit DOM|CSSOM getters:
                                                #  - cache result instead of re-invoking function

TIMING ==>                                      #One frame at 60FPS is 17ms:
                                                #  - some time is for browser garbage collection, etc.
                                                #  - some time is for parsing, cascading, layout, painting, compositing, etc.
                                                #  - so JavaScript should not be more than 4ms per stack
                                                #     - otherwise use web worker to separate from rendering thread
                                                #     - if cannot use web worker (e.g. need DOM), break into several parts with requestAnimationFrame()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            LOADING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SUMMARY ==>                                     #Async:
                                                #  - JavaScript|CSS:
                                                #     - when dynamically added, <script async> or <link rel="preload">
                                                #     - problems:
                                                #        - using DOM|CSSOM -> DOMContentLoaded or <script defer>
                                                #        - FOUC
                                                #  - fonts: always. FOUT vs FOIT vs FOFT
                                                #  - other resources: always
                                                #Should group HTML|CSS|JavaScript into components

JAVASCRIPT ==>                                  #Sync:
                                                #  - inline <script>
                                                #  - <script src>
                                                #Async:
                                                #  - how:
                                                #     - <script src async>
                                                #     - dynamically adding <script src>
                                                #  - problem: when script uses DOM
                                                #  - fixes (aside from using sync):
                                                #     - <script src defer>
                                                #     - DOMContentLoaded
                                                #     - (deprecated) <script> at end of <body>

CSS ==>                                         #Sync:
                                                #  - <style>
                                                #  - CSS <link>:
                                                #     - parsing blocked at next <script>
                                                #     - rendering blocked right away
                                                #     - exceptions:
                                                #        - Safari: parsing blocked right away
                                                #        - Firefox:
                                                #           - rendering not blocked if in <body>
                                                #           - fix: adding empty <script> after CSS <link>
                                                #  - @import
                                                #Async:
                                                #  - how:
                                                #     - <link rel="preload" url="URL.css" as="style" onload="this.rel = 'stylesheet';"> (see HTTP doc)
                                                #     - dynamically adding CSS <link>
                                                #     - non-matching media="MEDIAQUERYLIST"
                                                #     - loadCSS (1.2.0):
                                                #        - loadCSS('URI.css'[, ELEM[, 'MEDIAQUERYLIST']])->LINK
                                                #           - dynamically adds CSS <link>, before ELEM (def: end of <head>)
                                                #        - polyfills <link rel="preload" as="style">
                                                #  - problems:
                                                #     - (parsing) when script uses CSSOM
                                                #     - (rendering) FOUC (Flash Of Unstyled Content):
                                                #        - shows unstyled HTML
                                                #        - makes DOM jumping around
                                                #        - only for HTML visible on viewport
                                                #  - fixes (aside from using sync):
                                                #     - (parsing) DOMContentLoaded
                                                #     - (rendering) emulate sync by temporarily display: none on related HTML

FONTS ==>                                       #@font-face always async
                                                #Problems:
                                                #  - FOUT (Flash Of Unstyled Text):
                                                #     - shows different font while download ongoing
                                                #     - def for IE
                                                #     - can be forced by adding web font to element once font loaded:
                                                #        - adding web font: by toggling CSS class
                                                #        - once font loaded: see below
                                                #        - should prioritize normal web fonts over variants (e.g. bold):
                                                #           - i.e. adding one CSS class per font
                                                #           - variants can be temporarily emulated using CSS
                                                #           - also called FOFT (Flash Of Faux Text)
                                                #  - FOIT (Flash of Invisible Text):
                                                #     - shows invisible font while download ongoing
                                                #     - best for icon fonts
                                                #     - def for Safari
                                                #     - can be forced by hiding text (visibility: hidden) until font loaded (using library
                                                #       like FontFaceObserver pr Google FontLoader, or CSS Font Loading spec)
                                                #  - FOFT (Flash of Fallback Text):
                                                #     - FOIT for 3 seconds, FOUT then
                                                #     - best for normal content
                                                #     - def for Firefox, Chrome, Opera
                                                #Font download only starts:
                                                #  - when some HTML is rendered and uses the web font
                                                #  - (except Firefox, IE) and only if HTML has text content
                                                #  - can add <link rel="preload"> to start download earlier instead

HTML ==>                                        #<link rel="import">:
                                                #  - async if <link async>
                                                #  - fixes (aside from using sync): DOMContentLoaded
                                                #<template>: always sync

OTHER RESOURCES ==>                             #Images, video, audio, svg, object, iframe: always async

PERFORMANCE ==>                                 #Async is best
                                                #Should defer sync by grouping HTML|CSS|JavaScript into components:
                                                #  - above the fold / critical path CSS:
                                                #     - (poorer) alternative to grouping into components
                                                #     - make first displayed DOM's CSS sync, other CSS async
                                                #     - usually use headless browser to load page and figure out which CSS is "above the fold"



             
   UTILITIES  
             



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           UTILITIES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOMError                                        #
DOMERROR.name                                   #STR

DOMException                                    #
DOMEXCEPTION.name                               #

WINDOW|WORKERGLOBAL.onerror =                   #On unhandled exception or runtime error.
  FUNC('MSG', 'URL', LINE_NUM, COL_NUM, ERROR)  #If the error comes from a <script> with a different origin:
                                                #  - same origin policy: the arguments will only be 'Script error', '', null, null
                                                #  - unless CORS is used, including <script crossorigin>
WINDOW|WORKERGLOBAL.addEventListener
 ('error', FUNC(ERROREVENT))                    #
ABSTRACTWORKER.onerror = FUNC(ERROREVENT)       #On unhandle exception or runtime error
ERROREVENT.message                              #STR
ERROREVENT.filename                             #STR
ERROREVENT.lineno                               #NUM
ERROREVENT.colno                                #NUM
ERROREVENT.error                                #ERROR

WINDW.onunhandledrejection = FUNC(PROMREJEVENT)$#When any PROMISE is rejected without call to catch() in the same microtask (i.e. sync)
                                               $#Not all browsers, but degrades gracefully if used as a debugging tool
WINDOW.onrejectionhandled = FUNC(PROMREJEVENT) $#When any PROMISE was rejected with a call to catch(), but not in the same microtask (i.e. async)
                                               $#Same compatibility as unhandledrejection
PROMREJEVENT.promise                           $#PROMISE
PROMREJEVENT.reason                            $#VAL

reportError(VAL)                               $#Like throw VAL, except cannot be caught, except by onerror handler


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TIMEOUTS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW|WORKERGLOBAL.setTimeout                  #Browsers actually enforce:
(FUNC(...), INT[, ...])->ID                     #  - adds 4ms if nesting if 5 levels deep or more
                                                #  - 1 FUNC per second on inactive tabs
                                                #Uses macrotask queue (see JavaScript doc)
WINDOW|WORKERGLOBAL.clearTimeout(ID)            #
WINDOW|WORKERGLOBAL.setInterval
(FUNC(...), INT[, ...])->ID                     #
WINDOW|WORKERGLOBAL.clearInterval(ID)           #
WNDW|WKRGLOBL.setImmediate(FUNC(...)[,...])->ID$#Similar to set|clearTimeout(..., 0) but faster and more efficient (e.g. no 4ms minimum)
WINDOW|WORKERGLOBAL.clearImmediate(ID)         $#'setImmediate' (YuzuJS) (1.0.4)

queueMicrotask(FUNC())                          #Add a new microtask (see JavaScript doc)

WINDOW.requestAnimationFrame(FUNC(FLOAT))->ID   #Similar to setImmediate() but:
                                                #  - before screen refresh:
                                                #     - usually 60 times/sec, but can be lower in inactive tabs
                                                #     - this avoids changing UI several times while screen is not refreshing
                                                #       (optimized and smoother results)
                                                #     - should be used for any visual change
                                                #  - FLOAT: PERFORMANCE.now() when current frame started
WINDOW.cancelAnimationFrame(ID)                 #

WINDOW.scheduler                               $#SCHEDULER
SCHEDULER.wait(NUM[, OPTS])->>                 $#Like setTimeout(NUM) and setImmediate() but:
SCHEDULER.yield()->>                           $#  - FUNC -> promisified
                                               $#  - clear*() -> OPTS.signal ABORT_SIGNAL
                                               $#  - higher priority


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONSOLE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW.console                                  #CONSOLE

CONSOLE.debug|info|log|warn|error(VAL...)       #Can use format strings:
                                                #  - %s: STR
                                                #  - %d, %i: NUM
                                                #  - %f: DOUBLE
                                                #  - %O: OBJ
                                                #  - %o: hyperlink
                                                #  - %c: CSS "PROP:VAL;..."
CONSOLE.dir(OBJ|ELEM)                           #Prints with accordion arrows
                                                #ELEM will be printed as a JavaScript object, as opposed to HTML representation
CONSOLE.dirxml(...)                             #Inverse
CONSOLE.table(OBJ_ARR|OBJ_OBJ[, STR[_ARR]])    $#Prints as a table.
                                               $#If STR[_ARR], only shows those columns.

CONSOLE.assert(BOOL, ...)                       #If false, like console.error(...), except cannot use format strings
CONSOLE.count([STR])                            #Increments a NUM for a given STR, then console.debug('STR: NUM')
                                                #Def: "default"
CONSOLE.countReset([STR])                       #

CONSOLE.clear()                                 #
CONSOLE.group[Collapsed](...)                   #console.log(...) then starts dropdown (if Collapsed: closed at start), incrementing level
CONSOLE.groupEnd()                              #Stops dropdown, decrementing level

CONSOLE.trace(...)                             $#console.log(...) then prints current stack.

CONSOLE.profile[End]([STR])                     #Start CPU profile (like clicking on 'Start' in devtools)
                                                #Def STR for profileEnd(): the most recent one.

CONSOLE.timeStamp(STR)                          #Add a marker, e.g. in devtool Performance tab

CONSOLE.time(['LABEL'])                         #timeEnd() do console.debug('LABEL: TIMEms') (microsecs precise) with TIME between both calls
CONSOLE.timeEnd(['LABEL'])                      #Also add marker in Timeline view
                                                #Def: "default"
CONSOLE.timeLog(['LABEL'][, ...])              $#Same but in-between time() and timeEnd(), then log(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PERFORMANCE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GLOBAL.performance                              #PERFORMANCE
DOMTIMESTAMP                                    #DOUBLE in ms
                                                #Precision is software|hardware-dependent
DOMLOCALTIME                                    #DOMTIMESTAMP representing time since PERFORMANCE.timeOrigin
                                                #I.e. not affected by clock OS (as opposed to new Date())
DOMGLOBALTIME                                   #DOMTIMESTAMP representing time since Unix
DOMDURATION                                     #DOMTIMESTAMP representing a duration

PERFORMANCE.timeOrigin                          #DOMGLOBALTIME when global scope started
PERFORMANCE.now()->DOMLOCALTIME                 #Current DOMLOCALTIME
PERFORMANCE.toJSON()->OBJ                       #

PERFORMANCE|PERFLIST.getEntries()->PERFENTRY_ARR#Sorted by PERFENTRY.startTime
PERFORMANCE|PERFLIST.getEntriesByType('TYPE')
 ->PERFENTRY_ARR                                #
PERFORMANCE|PERFLIST.getEntriesByName
 ('NAME'[, 'TYPE'])->PERFENTRY_ARR              #
PERFORMANCE.clearMarks|Measures|ResourceTimings
 (['NAME'])                                     #

new PerformanceObserver
 (FUNC(PERFLIST, PERFOBSERVER))                 #Fire FUNC on new PERFENTRYs
PERFOBSERVER.observe(OPTS)                      #OPTS:
                                                #  - entryTypes STR_ARR (valid PERFENTRY.entryType to listen to)
                                                #  - type STR: same but single STR
                                                #  - buffered BOOL:
                                                #     - if false (def): fire listener callbacks sync
                                                #     - if true:
                                                #        - use setImmediate()
                                                #        - requires OPTS.type
                                                #Must be called for PERFOBSERVER to work
PERFOBSERVER.takeRecords()->PERFENTRY_ARR       #Get and empty PERFLIST, right away
PERFOBSERVER.disconnect()                       #Should be called as soon as no longer needed, e.g. in FUNC()

PerformanceEntry                                #
PERFENTRY.name                                  #Type-specific name STR. Do not have do be unique.
PERFENTRY.entryType                             #Type-specific type name.
PerformanceObserver.supportedEntryTypes         #ARR of all 'TYPE'
PERFENTRY.startTime                             #DOMLOCALTIME when PERFENTRY was created
PERFENTRY.duration                              #DOMDURATION (0 if none)
PERFENTRY.toJSON()->OBJ                         #

PerformanceResourceTiming                       #Child of PerformanceEntry, for network requests.
PERF_RESOURCE_TIMING.entryType                  #'resource'
PERF_RESOURCE_TIMING.name                       #'URL'

TIMES ==>                                       #Following are DOMLOCALTIME, in order
PERF_RESOURCE_TIMING.workerStart                #If through service WORKER, when it started (0 if none)
PERF_RESOURCE_TIMING.redirectStart|End          #HTTP redirections (0 if none)
PERF_RESOURCE_TIMING.fetchStart                 #Is going to do HTTP main request
PERF_RESOURCE_TIMING.domainLookupStart|End      #DNS request (same as fetchStart if cached, local request or kept TCP socket (e.g. keep-alive))
PERF_RESOURCE_TIMING.connectStart|End           #TCP handshake (same as fetchStart if kept TCP socket)
PERF_RESOURCE_TIMING.secureConnectionStart      #TLS handshake (0 if none). End is connectEnd
PERF_RESOURCE_TIMING.requestStart               #HTTP main request
PERF_RESOURCE_TIMING.responseStart|End          #HTTP main response

PERF_RESOURCE_TIMING.initiatorType              #Similar to fetch's REQ.destination, but with different values
PERF_RESOURCE_TIMING.nextHopProtocol            #Scheme used, as defined by ALPN
PERF_RESOURCE_TIMING.transferSize               #NUM (in bytes) of headers + body
PERF_RESOURCE_TIMING.decoded|encodedBodySize    #NUM (in bytes) of body, after|before decompression

PERFORMANCE.setResourceTimingBufferSize(NUM)    #Sets maximum amount of PERF_RESOURCE_TIMINGs to keep track of
PERFORMANCE.addEventListener
 ('resourcetimingbufferfull', FUNC(EVENT))      #When limit is hit

PERF_RESOURCE_TIMING.serverTiming               #SERVER_TIMING_ARR
PerformanceServerTiming                         #Server-Timing [S] headers
SERVER_TIMING.name                              #'NAME'
SERVER_TIMING.duration                          #NUM
SERVER_TIMING.description                       #STR
SERVER_TIMING.toJSON()                          #STR

PerformanceNavigationTiming                     #Child of PerformanceResourceTiming, for navigation
PERF_NAVIGATION_TIMING.entryType                #'navigation'

TIMES ==>                                       #Following are DOMLOCALTIME, in order
PERF_NAVIGATION_TIMING.unloadEventStart|End     #Previous page unload event (0 if different origins)
PERF_NAVIGATION_TIMING.domInteractive           #DOCUMENT.readyState 'interactive'
PERF_NAVIGATION_TIMING.
 domContentLoadedEventStart|End                 #DOCUMENT DOMContentLoaded event
PERF_NAVIGATION_TIMING.domComplete              #DOCUMENT.readyState 'complete'
PERF_NAVIGATION_TIMING.[un]loadEventStart|End   #DOCUMENT [un]load event

PERF_NAVIGATION_TIMING.type                     #How page started.
                                                #Can be:
                                                #  - "navigate": normal navigation
                                                #  - "reload": page reloaded
                                                #  - "back_forward": using history
                                                #  - "prerender"
PERF_NAVIGATION_TIMING.redirectCount            #Number of redirections 3** that happened

PERFORMANCE.mark('NAME'[, OPTS])->PERF_MARK     #
new PerformanceMark('NAME'[, OPTS])             #Child of PerformanceEntry, for custom discrete point in time
PERF_MARK.entryType                             #'mark'
PERF_MARK.name                                  #'NAME'
                                                #Recommends using the following names when used to mark the following cases:
                                                #  - 'mark_above_the_fold': viewport fully visible to end-user
                                                #  - 'mark_fully_visible': full page fully visible to end-user
                                                #  - 'mark_time_to_user_action': end-user can interact
                                                #  - 'mark_fully_loaded': page fully loaded, including application modules initialized (not only page subresouces)
PERF_MARK|OPTS.detail                           #VAL (def: null)
PERF_MARK|OPTS.startTime                        #DOMLOCALTIME (def: now)

PERFORMANCE.measure('NAME'[, OPTS])             #OPTS:
 ->PERF_MEASURE                                 #  - start (def: timeOrigin): DOMLOCALTIME or PERF_TIMING 'NAME' (use its startTime)
                                                #  - end (def: now): same type as OPTS.start
                                                #  - duration DOMDURATION (def: end - start): computes start|end based on end|start
PERFORMANCE.measure('NAME', STR[, STR2])        #Same as using OPTS.start|end STR[2]
PerformanceMeasure                              #Child of PerformanceMArk, for custom duration between two marks. Shown in devtools
PERF_MEASURE.entryType                          #'measure'
PERF_MEASURE.name                               #'NAME'
PERF_MEASURE.startTime                          #DOMLOCALTIME of OPTS.start
PERF_MEASURE.duration                           #DOMDURATION
PERF_MEASURE|OPTS.detail                        #VAL (def: null)



          
   EVENTS  
          



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PERFORMANCE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DEFAULT HANDLERS ==>                            #Event with browser default handler (e.g. scroll, touch*, click on link, context menu)
                                                #defer default handler, so user handler should not be too long

THROTTLING ==>                                  #Event handlers fired very rapidly (e.g. scroll, hovering) should be throttled

TEMPORARY ==>                                   #Conditional event handlers:
                                                #  - e.g. touchmove|end only triggered between touchstart and touchend
                                                #  - should be added|removed dynamically

TASKS ==>                                       #Event handlers are fired in a new macrotask

                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EventTarget                                     #OBJ that can receive EVENTs
EVENTTARGET.add|removeEventListener             #Idempotent if same FUNC + OPTS
 ('TYPE', FUNC(EVENT)[->>][, BOOL|OPTS])        #BOOL: same as { capture BOOL }
                                                #Instead of FUNC, can be { handleEvent: FUNC }
OPTS.once                                       #BOOL (def: false)
OPTS.signal                                     #ABORT_SIGNAL
OPTS.capture                                    #BOOL (def: false). If false|true: bubbling|capturing phase only
OPTS.passive                                    #BOOL. Make EVENT not cancelable (but do not change EVENT.cancelable value itself)
                                                #Only used as a performance hint:
                                                #  - i.e. user agent does not need to wait for event handlers to do default action
                                                #  - e.g. on touch|wheel events to give smoother scrolling, etc.
                                                #Def: false, except for touchstart|touchmove on Chrome
<any onEVENT="CODE">                            #Same but:
EVENTTARGET.onEVENT = FUNC(EVENT)               #  - can only register one handler
                                                #  - dispatchEvent() does not work
                                                #  - kept by cloneNode()
EVENTTARGET.dispatchEvent(EVENT)->BOOL          #Returns true if defaultPrevented

new Event('TYPE'[, OPTS])                       #Creates EVENT, but does not emit until dispatchEvent()
                                                #Usually inherited by an EVENTTYPE (e.g. MouseEvent or CustomEvent)
                                                #OPTS:
                                                #  - bubbles|cancelable|composed
                                                #  - most child allow overriding EVENT.*, unless readonly
EVENT.type                                      #'TYPE' (e.g. 'click|mouseover|...')
EVENT.eventPhase                                #Event handlers are fired in that order:
                                                #  - Event.CAPTURING_PHASE: capturing handlers, from outermost to target
                                                #  - Event.AT_TARGET: target
                                                #  - Event.BUBBLING_PHASE: bubbling handlers (def), from target to outermost, providing EVENT.bubbles true
                                                #Can also be Event.NONE
EVENT.bubbles                                   #True for:
                                                #  - UI events:
                                                #     - except select, resize, scroll
                                                #     - focus|blur does not bubble, but focusin|out fixes it
                                                #     - mouse|pointerover|out does bubble (should not), but mouse|pointerleave|enter fixes it
                                                #  - UI-related events:
                                                #     - fullscreen*, selectstart, SVG* (except SVG[Un]Load), visibilitychange
                                                #     - transitionend
                                                #  - location-related events:
                                                #     - DOMContentLoaded, hashchange, popstate
                                                #  - resourcetimingbufferfull
EVENT.currentTarget                             #The current EVENTTARGET (=== this in event handler)
EVENT.target                                    #The original EVENTTARGET

EVENT.cancelable                                #True for:
                                                #  - bubbling UI events, except:
                                                #     - end|abort-related: abort, dragend|leave, pointer|touchcancel, pointerlockchange|error
                                                #     - input, change
                                                #     - animation*
                                                #  - selectstart, transitionend, resourcetimingbufferfull
                                                #  - reset, invalid
                                                #True (but actually preventDefault() is a noop):
                                                #  - beforeunload
EVENT.preventDefault()                          #Cancel browser default handler (but not user handlers), providing cancelable true.
                                                #Can cancel:
                                                #  - typing, zooming, selecting, form submit|reset, validation alerts, drag&drop, keyboard shortcuts, following links
                                                #  - (must prevent input events directly, e.g. keydown|click|mousedown|wheel|touchstart): focus, control interactions, scroll
                                                #  - not: media controls, high-level navigation (unload|pagehide, history), hardware (orientation|motion, location), HTTP requests
                                                #Consider alternative solutions when end-user expects default browser action:
                                                #  - e.g. <control disabled> (focus, control interaction), CSS overflow (scroll)
EVENT.defaultPrevented                          #preventDefault() has been called

EVENT.stopImmediatePropagation()                #Do not call any further user handlers
EVENT.stopPropagation()                         #Same, except for currentTarget's ones

EVENT.composedPath()->EVENTTARGET_ARR           #All EVENTTARGET called during propagation
EVENT.composed                                  #BOOL. true if propagation will cross current SHADOW_ROOT

EVENT.timeStamp                                 #DATE_NUM (in ms)

EVENT.isTrusted                                 #BOOL. Whether generated programatically (new Event()) or UI

CustomEvent                                    $#User-defined event
CUSTOMEVENT.detail                             $#VAL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            UIEVENT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


UIEvent                                         #Child of EVENT
UIEVENT.view                                    #WINDOW

FOCUSABLE                                       #Is A|AREA|BUTTON|INPUT|TEXTAREA|CONTENTEDITABLE|SELECT|WINDOW
FOCUSABLE.onfocus|blur = FUNC(FOCUSEVENT)       #Gains|loses focus. Can sometimes fire twice.
                                                #Not cancelable (use mousedown|touchstart.preventDefault() instead)
FOCUSABLE.onfocusin|out = FUNC(FOCUSEVENT)      #Like focus|blur, but bubbles.
FOCUSABLE.focus|blur()                          #Emit those events
DOCUMENT.activeElement                          #Currently focused ELEM. If none, BODY.
                                                #Readonly.
DOCUMENT.hasFocus()->BOOL                       #

FocusEvent                                      #UIEVENT child, for focus*|blur
FOCUSEVENT.relatedTarget                        #For focus|focusin, previous ELEM
                                                #For blur|focusout, next ELEM

INPUT|TEXTAREA.oninput = FUNC(EVENT)            #Control value just changed.
                                                #Not cancelable
INPUT|TEXTAREA|SELECT.onchange = FUNC(EVENT)    #SELECT: control value changes.
                                                #INPUT|TEXTAREA: blur + value changed since focus
                                                #Not cancelable


DOCUMENT|FOCUSABLE.onkeydown = FUNC(KEYBOARDEVT)#When key is down (repeats).
                                                #Possible default browser action (cancelable):
                                                #  - DOCUMENT|FOCUSABLE: scrolling (arrows)
                                                #  - DOCUMENT: navigation (refresh, history), shortcuts (bookmarks), etc.
                                                #  - FOCUSABLE: typing characters, tabbing
                                                #  - most controls keyboard interaction
DOCUMENT|FOCUSABLE.onkeyup = FUNC(KEYBOARDEVENT)#When key is not down anymore (only once).

KeyboardEvent                                   #UIEVENT child
                                                #Modifier keys launch event themselves.
                                                #There is no attribute for getting the key value that is crossbrowser.
KEYBOARDEVENT.ctrl|shift|alt|metaKey            #True if pressed while keyboard event
KEYBOARDEVENT.location                          #Can be KeyboardEvent.DOM_KEY_LOCATION_*:
                                                #  - STANDARD (def)
                                                #  - LEFT|RIGHT: where key present several times on keyboard, i.e. possible for key 'Shift|Control|Alt|Meta'
                                                #  - NUMPAD: key is on numpad, i.e. possible for key 'Arrow*', 'Home|End', 'PageDown|Up', '0-9', 'Enter', '+ - * /'
KEYBOARDEVENT.key                              $#Typed key, from a visual perspective:
                                               $#  - takes combination into account (e.g. case), but each combination key still fire an event
                                               $#  - takes keyboard layout into account
                                               $#  - does not take location into account
                                               $#  - useful when need value of typed key, e.g. shortcuts
                                               $#Can be:
                                               $#  - printable Unicode 'CHAR' (including case, whitespaces)
                                               $#  - 'F1-12'
                                               $#  - 'Enter', 'Tab', 'Backspace', 'Delete', 'Insert', 'Escape', 'Pause', 'Clear'
                                               $#  - 'ArrowDown|Up|Left|Right', 'Home|End', 'PageDown|Up'
                                               $#  - 'Shift', 'Meta', 'Control', 'Alt[Graph]', 'Hyper', 'Super'
                                               $#  - 'Accel' ('Meta' in OSX, 'Control' otherwise)
                                               $#  - 'CapsLock', 'Fn[Lock]', 'NumLock', 'ScrollLock', 'Symbol[Lock]'
                                               $#  - 'Power[Off]|Hibernate|Standby|WakeUp', 'PrintScreen', 'BrightnessUp|Down', 'Eject', 'LogOff'
                                               $#  - 'MediaFastForward|Pause|Play[Pause]|Record|Rewind|Stop|TrackNext|TrackPrevious'
                                               $#  - 'AudioVolumeDown|Up|Mute'
                                               $#  - 'Dead': combining key, e.g. circumflex accent on French keyboard
                                               $#  - 'AppSwitch', 'GoBack|Home': on mobile keyboards
                                               $#   - 'Copy', 'Cut', 'Paste', 'Redo', 'Undo'
                                               $#  - 'Unidentified'
                                               $#  - Others: see spec
                                               $#'inexorabletash polyfill' (only keyboard.js) (0.1.33)
KEYBOARDEVENT.code                             $#Typed key, from a mechanic perspective:
                                               $#  - does not take combination into account
                                               $#  - regardless of layout (i.e. on US layout)
                                               $#  - takes location into account
                                               $#  - useful when need physical location of key, e.g. for games
                                               $#E.g. 'keyA' or 'ShiftRight'. See spec for values
                                               $#'inexorabletash polyfill' (only keyboard.js) (0.1.33)


DOCUMENT|FOCUSABLE.oncompositionstart|end       #When IME autocompletion start|ends
 = FUNC(COMPOSITIONEVENT)                       #Possible browser default action (cancelable): opening up IME
DOCUMENT|FOCUSABLE.oncompositionupdate
 = FUNC(COMPOSITIONEVENT)                       #When IME autocompletion is updated (e.g. by typing keys, including at start, but not at end)

CompositionEvent                                #UIEVENT child
                                                #Similar to key events, but for IME (Input Method Editor):
                                                #  - autocompletion choice started|ended
                                                #  - e.g. used:
                                                #     - when typing diacretics characters
                                                #     - for asian characters entry
                                                #     - by speech recognition software
                                                #     - word suggestion on mobile
COMPOSITIONEVENT.data                           #STR: characters entered


ELEM|DOCUMENT|WINDOW.onscroll = FUNC(EVENT)     #When scrolling happens.
                                                #Not cancelable (but can preventDefault() keydown|wheel instead)
WINDOW|ELEM.onresize = FUNC(EVENT)              #When user resizes window or element
                                                #Not cancelable


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      MOUSE/TOUCH EVENTS       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SUMMARY ==>                                     #In order:
                                                #                     +--------------+--------------+--------------+
                                                #                     | mouse        | tap          | hold         |
                                                #   +-----------------+--------------+--------------+--------------+
                                                #   | touchstart      |              | y            | y            |
                                                #   | touchmove       |              | y            |              |
                                                #   |                 |              | might scroll |              |
                                                #   |                 |              | or zoom      |              |
                                                #   | touchend        |              | y            |              |
                                                #   | touchcancel     |              |              | y            |
                                                #   +-----------------+--------------+--------------+--------------+
                                                #   | mouseover|enter | y            | session      | session      |
                                                #   | mouseout|leave  | y            | session      | session      |
                                                #   | mousemove       | y            | once         | once         |
                                                #   | mousedown       | y            | y            | y            |
                                                #   | mouseup         | y            | y            |              |
                                                #   | click           | y            | y            |              |
                                                #   | dblclick        | y            | zoom         |              |
                                                #   | contextmenu     | y            |              | y            |
                                                #   | wheel           | y            |              |              |
                                                #   +-----------------+--------------+--------------+--------------+


ALL                                             #Is ELEM|DOCUMENT|WINDOW
ALL.onclick = FUNC(MOUSEEVENT)                  #Left click down then up on same element. Fired after mouseup.
                                                #Possible default browser action (cancelable):
                                                #  - following <a|area> link
                                                #  - some controls mouse interaction (e.g. checkbox, file upload, buttons, datepicker, etc.)
HTMLELEM.click()                                #
ALL.oncontextmenu = FUNC(MOUSEEVENT)            #Same for right click.
                                                #Possible default browser action (cancelable): opening context menu
ALL.ondblclick = FUNC(MOUSEEVENT)               #Same for double left click.
ALL.onmousedown|up = FUNC(MOUSEEVENT)           #Any mouse button down|up (only once).
                                                #Possible default browser action for mousedown (cancelable):
                                                #  - focus
                                                #  - some controls mouse interaction (e.g. number, range, select, etc.)
ALL.onmousemove = FUNC(MOUSEEVENT)              #While moves (repeats).
                                                #Possible default browser action (cancelable):
                                                #  - some controls mouse interaction (e.g. range, etc.)

ALL.onmouseover|out = FUNC(MOUSEEVENT)          #When enter|leaves (only once)
                                                #Bubbles, which means that anytime the mouse enters/leaves a child element,
                                                #it is fired again: prefer mouseenter|leave.
ALL.onmouseenter|leave = FUNC(MOUSEEVENT)       #Same but doesn't bubble

MouseEvent                                      #UIEVENT child
MOUSEEVENT.screenX|Y                            #According to screen
MOUSEEVENT.clientX|Y                            #According to page (visual viewport)
MOUSEEVENT.pageX|Y                              #According to page (layout viewport)
MOUSEEVENT.offsetX|Y                            #Offset to ELEM border-box top-left corner
MOUSEEVENT.ctrl|shift|alt|metaKey               #True if pressed while mouse event
MOUSEEVENT.button                               #Event's button: 0|1|2 for left|middle|right button
MOUSEEVENT.buttons                             $#All event's buttons as or'd flag: 0|1|2|4|8|16 for none|left|right|middle|4th(back)|5th(forward) button
                                               $#'mikolalysenko mouse-event' (1.0.5)
MOUSEEVENT.detail                               #Number of clicks.
                                                #Only for [dbl]click, mousedown|up


WINDOW|DOCUMENT|ELEM.onwheel = FUNC(WHEELEVENT) #Possible default browser action (cancelable): scrolling
WHEELEVENT                                      #Child of MOUSEEVENT
WHEELEVENT.deltaX|Y|Z                           #Amount scrolled as DOUBLE
WHEELEVENT.deltaMode                            #Whether deltaX|Y|Z is in WheelEvent.DOM_DELTA_PIXEL|LINE|PAGE


TOUCH EVENTS ==>                                #Only:
                                                #  - touch screens (which might have a mouse as well)
                                                #  - implemented by Chrome|Opera on desktop
                                                #Emulation concepts:
                                                #  - tap -> like left click
                                                #  - hold -> like select + right click
                                                #  - mouse hovering sessions:
                                                #     - tapping somewhere -> like keeping mouse hovered until next tap
                                                #        - fire mouseover|enter once the first time,
                                                #          then mouseout|leave once when exits
                                                #        - mousemove fired only once, at each tap
                                                #     - touchmove: more of a gesture|swipe session than hovering
                                                #Touch user interaction:
                                                #  - double tap: zoom
                                                #  - touchmove: might scroll|zoom
                                                #Mouse events are fired in addition after touch events:
                                                #  - unless preventDefault() fired during both touchstart and touchend
                                                #  - unless zooming|scrolling
                                                #  - previously (not anymore) with 300ms delay:
                                                #     - allow waiting for double tap
                                                #     - can be disabled with <meta name="viewport"> (see HTML doc)
                                                #Warning:
                                                #  - finger less precise than mouse
                                                #  - should keep touch event handlers limited in number and space, cause it can flicker scrolling

DOCUMENT|ELEM.ontouchstart = FUNC(TOUCHEVENT)   #Like mousedown but for touch, except:
                                                #  - possible default browser action: scrolling, zooming
                                                #     - cancelable:
                                                #        - except on Chrome
                                                #        - prefer using touch-action
DOCUMENT|ELEM.ontouchend = FUNC(TOUCHEVENT)     #Like mouseup but for touch
DOCUMENT|ELEM.ontouchcancel = FUNC(TOUCHEVENT)  #Fired when touch stops but not because of touchend:
                                                #  - holding usually triggers contextmenu
                                                #  - going beyong screen borders
                                                #  - too many fingers on screen
DOCUMENT|ELEM.ontouchmove = FUNC(TOUCHEVENT)    #Like mousemove but for touch, except:
                                                #  - more of a gesture|swipe session than hovering, i.e. only cares about DOM when move starts:
                                                #     - target remains the same during the whole move
                                                #     - move stops when touchend|touchcancel, not when not hovering anymore
                                                #  - preventDefault() prevents scrolling|zooming (except on Chrome):
                                                #     - only on the first touchmove event
                                                #     - prefer using touch-action

TOUCHEVENT.alt|ctrl|meta|shiftKey               #Like MOUSEEVENT
TOUCHEVENT.changedTouches                       #TOUCHLIST: that actually triggered the TOUCHEVENT
TOUCHEVENT.targetTouches                        #TOUCHLIST: any with TOUCH.target === TOUCHEVENT.target
TOUCHEVENT.touches                              #TOUCHLIST: any related or not to current TOUCHEVENT

TOUCHLIST                                       #TOUCH_ARR-like
                                                #On touchend|touchcancel, that touch is not available anymore
TOUCH.identifier                                #ID_NUM
TOUCH.target                                    #
TOUCH.screen|client|pageX|Y                     #Like MOUSEEVENT


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          LOAD EVENTS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOCUMENT.onDOMContentLoaded = FUNC(EVENT)       #When page parsed
WINDOW.onload = FUNC(UIEVENT)                   #When resources done loading
DOCUMENT.readyState                             #Can be:
                                                #  - "loading": first
                                                #  - "interactive": after DOMContentLoaded
                                                #  - "complete": after load
DOCUMENT.onreadystatechange = FUNC(EVENT)       #When DOCUMENT.readyState changes
WINDOW.onbeforeunload = FUNC(BEFOREUNLOADEVENT) #Just before unload event.
                                                #If BEFOREUNLOADEVENT.returnValue STR + return STR (for crossbrowser):
                                                #  - does WINDOW.confirm(STR) first
                                                #  - not supported by Mobile Safari nor Chrome
                                                #  - only if page has been interacted with.
                                                #Unreliable: see unload event
WINDOW.onunload = FUNC(UIEVENT)                 #On closing page.
                                                #DOM is still available but invisible to the user.
                                                #Unreliable:
                                                #  - on mobile devices, not fired if switching application then closing the application
                                                #  - prefer checking for visibilitychange

WINDOW|DOCUMENT.onpageshow|hide =               #
FUNC(PAGETRANSITIONEVENT)                       #Like [un]load (including reliablity problems), except also fired when loaded from history cache.
PAGETRANSITIONEVENT.persisted                   #True when loaded from history cache.

RESOURCE                                        #Any external|embedded resource:
                                                #  - <script>, <style>, <link> (including prefetching)
                                                #  - <img>, <input type="image">, <video>, <audio>, <iframe>, <svg>, <object>
                                                #Also <body>
RESOURCE.onload = FUNC(UIEVENT)                 #When done loading
RESOURCE.onerror = FUNC(UIEVENT)                #
WINDOW|RESOURCE.onabort = FUNC(UIEVENT)         #When starts loading but stops.


DOCUMENT.visibilityState                        #Can be:
                                                #  - 'hidden': not current tab, e.g. tab is closed, tab is switched, window is minimized, OS screen is locked
                                                #  - 'prerender': e.g. using <link rel="prerender">
                                                #  - 'visible'
DOCUMENT.onvisibilitychange = FUNC(EVENT)       #When DOCUMENT.visibilityState changes



            
   DOCUMENT  
            



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TOP-LEVEL           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Window                                          #
Document                                        #NODE child, parent of HTML.
HTMLDocument                                    #DOCUMENT child
DocumentType                                    #See HTML doc

WINDOW.window                                   #Same as WINDOW
WINDOW.document                                 #DOCUMENT
DOCUMENT.defaultView                            #WINDOW|null

DOCUMENT.doctype                                #
DOCUMENT.documentElement                        #
HTMLDOCUMENT.body                               #
HTMLDOCUMENT.head                               #See HTML doc

HTMLDOCUMENT.title                              #
HTMLDOCUMENT.scripts                            #
HTMLDOCUMENT.images                             #
HTMLDOCUMENT.links                              #
HTMLDOCUMENT.forms                              #See HTML doc

WINDOW.status                                   #Status bar text. Not always available.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             QUERY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Node                                            #Parent of ELEM, DOCUMENT, CHARDATA, DOCUMENTTYPE, DOCUMENTFRAG
                                                #Note: any whitespace between two ELEM is a CHARDATA
Element                                         #NODE being an HTML|SVG tag
HTMLElement                                     #
HTMLUnknownElement                              #Cf doc HTML
NodeList                                        #Similar to HTMLCOLL but for NODE

DOCUMNT|HTMLELEM.getElementsByClassName('CLASS')#HTMLCOLL
DOCUMENT.getElementsByName('NAME')              #HTMLCOLL
DOCUMENT|ELEM.getElementsByTagName('tag|*')     #HTMLCOLL
DOCUMENT.getElementById('ID')                   #ELEM|null
WINDOW.ID                                       #Same but from WINDOW

DOCUMENT|ELEM|DOCUMENTFRAG.                     #Closest matching child, or itself
querySelector[All]('CSS_SELECTORS')             #ELEM|null or NODELIST
                                                #Cannot use pseudo-element
                                                #As opposed to jQuery, the query:
                                                #  - is retrieved differently:
                                                #     - is not actually performed from DOCUMENT|ELEM|DOCUMENTFRAG
                                                #     - it is done from the top document, then only returns ones that are ancestors to DOCUMENT|ELEM|DOCUMENTFRAG
                                                #     - this can carry different results because:
                                                #        - it allows higher parts of the query to target parent nodes
                                                #        - providing lower parts of the query target children nodes
                                                #  - cannot start with a combinator
ELEM.closest('CSS_SELECTORS')->ELEM2|null      $#Closest matching parent, or itself

NODE.childNodes                                 #NODELIST. Readonly.
HTMLELEM.children                               #HTMLCOLL. Readonly
ELEM.childElementCount                          #children.length
NODE.hasChildNodes()->BOOL                      #
NODE.first|lastChild                            #NODE|null. Readonly.
ELEM.first|lastElementChild                     #ELEM|null. Readonly.
NODE.previous|nextSibling                       #NODE|null. Readonly.
ELEM.previous|nextElementSibling                #ELEM|null. Readonly.
NODE.parentNode                                 #NODE. Readonly. null for DOCUMENT or root NODE not attached in DOM
HTMLELEM.parentElement                          #ELEM. Readonly. null for HTML
NODE.ownerDocument                              #DOCUMENT. Readonly. null for DOCUMENT


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           ITERATION           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOCUMENT.createNodeIterator
(NODE[, ENUM[, OBJ]])->NODEITERATOR             #Arguments are root, whatToShow (def: null), {filter}
NodeIterator                                    #
NODEITERATOR.root                               #NODE. Iterate over its children
NODEITERATOR.whatToShow                         #or'd ENUM: NodeFilter.SHOW_ALL|ELEM|ATTRIBUTE|TEXT|COMMENT|
                                                #DOCUMENT|DOCUMENT_TYPE|DOCUMENT_FRAGMENT
NODEITERATOR.filter                             #FUNC(NODE)->NodeFilter.FILTER_ACCEPT|REJECT
NODEITERATOR.next|previousNode()->NODE|null     #


DOCUMENT.createTreeWalker
(NODE[, ENUM[, OBJ]])->TREEWALKER               #
TreeWalker                                      #Like NodeIterator but can iterate recursively over children
TREEWALKER.root                                 #
TREEWALKER.whatToShow                           #
TREEWALKER.filter                               #Can also return NodeFilter.FILTER_SKIP, which rejects parent but not children
TREEWALKER.next|previousNode()                  #Like NODEITERATOR

TREEWALKER.currentNode                          #NODE
TREEWALKER.parentNode()->NODE|null              #
TREEWALKER.first|lastChild()->NODE|null         #
TREEWALKER.previous|nextSibling()->NODE|null    #Also moves cursor



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TEST              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ELEM.matches('CSS_SELECTORS')->BOOL            $#

NODE.isEqualNode(NODE2)->BOOL                   #NODE.outerHTML === NODE2.outerHTML
NODE.contains(NODE2)->BOOL                      #Is child or same
NODE.compareDocumentPosition(NODE2)->NUM        #Returns or'd bitmask of relation of NODE2 to NODE:
                                                #  - DOCUMENT_POSITION_CONTAINS|CONTAINED_BY
                                                #  - DOCUMENT_POSITION_PRECEDING|FOLLOWING: of start tag, i.e. if contains, precedes
                                                #  - DOCUMENT_DISCONNECTED: not same DOCUMENT
                                                #  - DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
                                                #None (i.e. 0) means NODE === NODE2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           CREATION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOCUMENT.implementation                         #DOMIMPL

DOMIMPL.createHTMLDocument(['TITLE'])->HTML     #
DOCUMENT.createElement('TAG')->ELEM             #
DOCUMENT.createTextNode(STR)->TEXT              #
DOCUMENT.createComment(STR)->COMMENT            #
DOCUMENT.createAttribute('ATTR')->ATTR          #

new DOMParser()                                 #
DOMPARSER.parseFromString('HTML', 'text/html')
->HTMLDOCUMENT                                  #
DOMPARSER.parseFromString('SVG','image/svg+xml')
->XMLDOCUMENT                                   #

RANGE.createContextualFragment('HTML')
->DOCUMENTFRAG                                  #'HTML' is content. DOCUMENTFRAG.ownerDocument is taken from RANGE.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         MANIPULATION          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SAME DOCUMENT ==>                               #Required for all methods except importNode|adoptNode()

DOCTYPE|ELEM|CHARDATA.before|after(NODE|STR...)$#Add NODE|STR... as previous|next sibling
DOCUMENT[FRAG]|ELEM.append|prepend(NODE|STR...)$#Add NODE|STR... as first|last children
NODE.insertBefore(NODE2[, NODE3])->NODE2        #Add NODE2 as NODE child, before sibling NODE3 (def: put as last child).
NODE.appendChild(NODE2)->NODE2                  #Same as NODE.insertBefore(NODE2, null)

DOCTYPE|ELEM|CHARDATA.replaceWith(NODE|STR...) $#Replace itself
NODE.replaceChild(NODE2, NODE3)->NODE3          #Replace child NODE3 by NODE2
DOCTYPE|ELEM|CHARDATA.remove()                 $#Remove itself
NODE.removeChild(NODE3)->NODE3                  #Remove child

NODE.cloneNode([BOOL])->NODE2                   #NODE2 is not attached to DOM.
                                                #Does not keep:
                                                #  - children, unless BOOL true
                                                #  - event listeners (except <any onevent>)
DOCUMENT.importNode(NODE[, BOOL])->NODE2        #Same but NODE does not have to be in current DOCUMENT
DOCUMENT.adoptNode(NODE)->NODE2                 #Same as DOCUMENT.importNode(NODE, true) but then remove NODE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           OBSERVING           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new MutationObserver                            #FUNC is listener aggregator:
(FUNC(RECORD_ARR, OBSERVER))                    #  - each RECORD represents a listener added by OBSERVER.observe()
                                                #RECORD:
                                                #  - NODE2 insertion|removal:
                                                #     - type 'childList'
                                                #     - target NODE: NODE2's parent
                                                #     - added|removedNodes NODELIST|null
                                                #     - previous|nextSibling NODE|null
                                                #  - CHARDATA modification:
                                                #     - type 'characterData'
                                                #     - target CHARDATA
                                                #     - oldValue STR
                                                #  - ELEM's attributes insertion|removal|modification:
                                                #     - type 'attributes'
                                                #     - target ELEM
                                                #     - attributeName[space] STR
                                                #     - oldValue STR
OBSERVER.observe(NODE, OBJ)                     #OBJ:
                                                #  - childList|characterData|attributes BOOL (def: false): at least one must be true
                                                #  - attribute|characterDataOldValue BOOL (def: false): populate RECORD.oldValue
                                                #  - attributesFilter 'ATTR'_ARR: only observe those attributes
                                                #  - subtree BOOL (def: false): include descendants
OBSERVER.takeRecords()->RECORD_ARR              #OBSERVERS's FUNC is always fired after DOM event handlers
                                                #So must call this to get access to pending RECORD_ARR inside a DOM event handler
                                                #This empties RECORD_ARR
OBSERVER.disconnect()                           #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONTENT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOCUMENT.compatMode                             #
DOCUMENT.characterSet                           #See HTML doc


NODE.nodeType                                   #Among DOCUMENT.DOCUMENT[_TYPE|FRAGMENT]|ELEM|TEXT|COMMENT_NODE
                                                #Readonly.
NODE.nodeName                                   #For ELEM: ELEM.tagName
                                                #For DOCUMENTTYPE: DOCUMENTTYPE.name
                                                #Others: '#comment|text|document[-fragment]'
                                                #Readonly.
ELEM.tagName                                    #'TAG|tag'


HTMLELEM.inner|outerHTML                        #'HTML', with[out] ELEM itself
                                                #Can lead to XSS attacks, so prefer textContent if only TEXT.
HTMLELEM.insertAdjacentHTML
('before|afterbegin|end', 'HTML')               #Inserts 'HTML' inside ELEM next to its start|end tag.

NODE.textContent                                #Children TEXT concatenated as STR.
                                                #DOCUMENT: null
NODE.nodeValue                                  #For CHARDATA: NODE.textContent
                                                #Others: null
NODE.normalize()                                #Erase empty TEXT, and join adjacent TEXT.

DOCUMENT.open()                                 #Remove all 'HTML'
DOCUMENT.write[ln]('HTML',...)                  #Append 'HTML' (with newline if "ln") to BODY
                                                #Fires HTMLDOCUMENT.open() first
DOCUMENT.close()                                #To be invoked after HTMLDOCUMENT.write*()


ELEM.ATTR                                       #
ELEM.attributes                                 #
ELEM.getAttribute[Node]('ATTR')->'VAL'|ATTR     #
ELEM.setAttribute[Node]('ATTR', 'VAL'|ATTR)     #
ELEM.hasAttribute('ATTR')->BOOL                 #
ELEM.hasAttributes()->BOOL                      #
ELEM.removeAttribute[Node]('ATTR'|ATTR)[->ATTR] #See HTML doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       ATTR/TEXT/COMMENT       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/



Attr                                            #HTML attribute
ATTR.name                                       #'ATTR'
ATTR.value                                      #'VAL'

CharacterData                                   #NODE child. TEXT|COMMENT parent
CHARDATA.data                                   #STR
CHARDATA.length                                 #NUM
CHARDATA.appendData(STR)                        #
CHARDATA.insertData(UINT, STR)                  #
CHARDATA.substringData(UINT, UINT2)->STR        #
CHARDATA.deleteData(UINT, UINT2)                #
CHARDATA.replaceData(UINT, UINT2, STR)          #

Text                                            #CHARDATA child. ELEM's text content
TEXT.wholeText                                  #TEXT and its sibling TEXT2 as a single STR
TEXT.splitText(UINT)                            #Split into two TEXT at position UINT

Comment                                         #CHARDATA child. HTML comment


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       RANGE / SELECTION       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Range                                           #NODE or parts of NODE following each other.
DOCUMENT.createRange()->RANGE                   #
DocumentFragment                                #NODE child. Several NODE or parts of NODE not attached to DOM
DOCUMENT.createDocumentFragment()->DOCUMENTFRAG #

RANGE.start|endContainer                        #NODE
RANGE.start|endOffset                           #Offset after|before start|endContainer:
                                                #  - if start|endContainer CHARDATA, in Unicode CHAR
                                                #  - otherwise in NODE
                                                #Readonly.
RANGE.setStart|End(NODE, UINT)                  #
RANGE.setStart|EndBefore|After(NODE)            #
RANGE.selectNode[Contents](NODE)                #Set start|endContainer|offset so it selects NODE (if 'Contents', its children)
RANGE.collapsed                                 #startContainer === endContainer
RANGE.collapse([BOOL])                          #Collapse to startContainer (BOOL true) or endContainer.

RANGE.commonAncestorContainer                   #Deepest NODE containing both startContainer and endContainer
RANGE.compareBoundaryPoints(ENUM,RANGE2)->-1|0|1#According to ENUM Range.END|START_TO_END|START

RANGE.insertNode(NODE)                          #At RANGE start
RANGE.surroundContents(NODE)                    #Wraps with NODE.
                                                #NODE must have no children.
                                                #RANGE boundaries cannot be inside a CHARDATA.
RANGE.cloneContents()->DOCUMENTFRAG             #Like NODE.cloneNode()
RANGE.deleteContents()                          #
RANGE.extractContents()->DOCUMENTFRAG           #Like cloneContents() + deleteContents()
RANGE.toString()                                #Gets textContent

RANGE.cloneRange()->RANGE2                      #


DOCUMENT|ELEM.onselectstart = FUNC(EVENT)       #When selection starts (i.e. new anchorNode, even collapsed) on that ELEM or (if DOCUMENT) any ELEM
                                                #Not for TEXTAREA|INPUT content selection
                                                #Cancelable
DOCUMENT.onselectionchange = FUNC(EVENT)        #When selection starts (i.e. new anchorNode) or changes (i.e. new focusNode) on any ELEM
                                                #Includes TEXTAREA|INPUT content selection
                                                #Not cancelable
TEXTAREA|INPUT.onselect = FUNC(UIEVENT)         #When selection ends (of text inside)
                                                #Not cancelable

TEXTAREA|INPUT.selectionEnd|Start               #start|end indexes UINT
TEXTAREA|INPUT.setSelectionRange(NUM,NUM2[,STR])#With start NUM, end NUM2, selectionDirection 'none' (def) or 'forward|backward'
TEXTAREA|INPUT.select()                         #Emit select event


WINDOW.getSelection()->SELECTION                #
Selection                                       #User selection, containing one or more RANGE.
SELECTION.anchor|focusNode                      #Like RANGE.start|endContainer
SELECTION.anchor|focusOffset                    #Like RANGE.start|endOffset
SELECTION.isCollapsed                           #Like RANGE.collapsed
SELECTION.collapseToStart|End()                 #Like RANGE.collapse()
SELECTION.collapse(NODE, UINT)                  #Like RANGE.setEnd() + RANGE.collapse()
SELECTION.selectAllChildren(NODE)               #Like RANGE.setNodeContents()
SELECTION.toString()                            #Like RANGE.toString()

SELECTION.rangeCount                            #length (0 if none). Always 1 in current browsers (no multiple selections).
SELECTION.getRangeAt(UINT)->RANGE               #
SELECTION.addRange(RANGE)                       #Only works if RANGE includes a SELECTION's RANGE2, which will merge (so does nothing)
SELECTION.removeRange(RANGE)                    #
SELECTION.removeAllRanges()                     #

SELECTION.deleteFromDocument()                  #Erase all TEXT's content (not parent node, but potentially children)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             CSSOM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SEE CSS DOC ==>                                 #For CSSOM and CSSOM view (including dimensions, positions, scrolling)



            
   BROWSING  
            



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              URL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new URL('URI'|URL[, URI2|'URI2'])->URL          #URI can be absolute or (if URI2 specified as base) relative
                                                #SEARCH must start with '?'
                                                #Is normalized, including:
                                                #  - case
                                                #  - . and ..
                                                #  - non-ASCII -> Punycode
                                                #Invalid structure:
                                                #  - constructor throws TypeError
                                                #  - setters fixes when there is a problem:
                                                #     - percent-encode forbidden chars
                                                #     - invalid href makes all other fields ''
                                                #     - protocol prepends missing ':'
                                                #     - port is clamped|converted to '0-47150'
                                                #     - search prepends missing '?'
                                                #     - hash prepends missing '#'
                                                #core-js polyfill
URL.href                                        #
URL.toString()->STR                             #Returns URL.href
URL.toJSON()->STR                               #Returns URL.href
URL.protocol                                    #
URL.username                                    #
URL.password                                    #
URL.hostname                                    #
URL.port                                        #
URL.host                                        #
URL.origin                                      #protocol+host, without username|password
URL.pathname                                    #
URL.search                                      #
URL.searchParams                                #SEARCHPARAMS
URL.hash                                        #

URL.canParse(...)->BOOL                        $#False if new URL(...) would throw

new URLSearchParams                             #?SEARCH string or application/x-www-form-urlencoded value
 (['SEARCH'|[KEY,VAL]_ITERABLE])                #'SEARCH' must not including leading '?'
                                                #SEARCHPARAMS|FORMDATA can be passed as [KEY,VAL]_ITERABLE
                                                #Is an [KEY, VAL]_ITERABLE
SEARCHPARAMS.toString()->'SEARCH'               #Without leading '?'
SEARCHPARAMS.get('VAR')->VAL
SEARCHPARAMS.set('VAR', VAL)
SEARCHPARAMS.has('VAR'[, VAL])->BOOL
SEARCHPARAMS.delete('VAR'[, VAL])
SEARCHPARAMS.keys|values|entries|forEach(...)
SEARCHPARAMS.size                               #Like MAP, but for individual search VARs
SEARCHPARAMS.getAll('VAR')->VAL_ARR             #
SEARCHPARAMS.append('VAR', VAL)                 #As opposed to set() (which erase all previous VARs with same name first),
SEARCHPARAMS.sort()                             #

URLPattern                                     $#See URLPattern doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           LOCATION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW.location                                 #LOCATION

[WORKER]LOCATION.href                           #
DOCUMENT.URL                                    #Same but readonly
[WORKER]LOCATION.toString()                     #Returns LOCATION.href

[WORKER]LOCATION.protocol                       #
[WORKER]LOCATION.hostname                       #Can only be set to a superdomain.
DOCUMENT.domain                                 #Same but readonly
[WORKER]LOCATION.port                           #
[WORKER]LOCATION.host                           #
[WORKER]LOCATION.origin                         #
[WORKER]LOCATION.pathname                       #
[WORKER]LOCATION.search                         #
[WORKER]LOCATION.hash                           #Same as URL.*

[WORKER]LOCATION.ancestorOrigins               $#'DOMAIN'_ARR of parent contexts (e.g. IFRAMEs)

LOCATION.assign(STR)                            #Navigate to URL STR.
LOCATION.replace(STR)                           #Same but don't save current page in history.
LOCATION.reload()                               #Reload current page.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            IMPORT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


import.meta.url                                 #Current file absolute 'URL' (including file://)

import.meta.resolve(STR)->'URI'                 #Returns file targetted by import(STR) as an absolute 'URI' (including file://)
                                                #Unlike new URL(STR, import.meta.url), takes into account IMPORT_MAPs
                                                #Throws
                                                #  - when using bare specifiers not found in an IMPORT_MAP
                                                #  - but not when using absolute|relative URIs

IMPORT_MAP                                      #Maps import statements identifiers
                                                #Only for top-level application, not libraries
                                                #JSON. File extension *.importmap or *.json
Content-Type: application/importmap+json [S]    #

<script type="importmap">                       #IMPORT_MAP
                                                #Throws if done after an import statement has already been done.
                                                #Blocks, i.e. prefer inlining instead of using <script src>
                                                #Only one per document

IMPORT_MAP.imports.IURL                         #'OURL'. Maps any import 'IURL' -> 'OURL'
                                                #'IURL|OURL' can be:
                                                #  - absolute URL
                                                #  - relative URL (i.e. path)
                                                #     - starting with [.]/ or ../
                                                #  - bare specifier otherwise
                                                #     - e.g. 'MODULE'
                                                #Relative URL base:
                                                #  - import 'IURL' statement: its file's location
                                                #  - IMPORT_MAP.imports.IURL: IMPORT_MAP's location
                                                #  - both are resolved first before matching
                                                #Can import 'IURL/...', providing both 'IURL' and 'OURL' end with /
                                                #Only for `import` statements, not for <script>, <link>, etc.

IMPORT_MAP.scopes.SURL.IURL                     #Same as IMPORT_MAP.imports.IURL except only applies
                                                #if the import statement is done inside SURL[/...]
                                                #SURL must end with /
                                                #If multiple SURLs match, longer one prevails


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            HISTORY            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW.history                                  #Browser HISTORY

HISTORY.length                                  #
HISTORY.go(NUM)                                 #Navigates
HISTORY.back|forward()                          #Same as go(1|-1)
HISTORY.pushState(STATE, 'TITLE'[, 'URL'])      #Adds an history entry, and goes to it.
                                                #Must be handled server-side too.
HISTORY.replaceState(...)                       #Removes current history entry, then do HISTORY.pushState(...)
HISTORY.state                                   #STATE

WINDOW.onpopstate = FUNC(POPSTATEVENT)          #Triggered by:
                                                #  - user using browser history (e.g. Back|Forward buttons or shortcuts)
                                                #  - HISTORY.go|back|forward()
                                                #Providing the later history entry was created by HISTORY.pushState|replaceState()
                                                #Not triggered by HISTORY.pushState|replaceState() itself.
PopStateEvent                                   #EVENT child
POPSTATEVENT.state                              #STATE|null

WINDOW.onhashchange = FUNC(HASHCHANGEEVENT)     #On LOCATION.hash change.
HashChangeEvent                                 #EVENT child
HASHCHANGEEVENT.old|newURL                      #



                  
   BROWSER|DEVICE  
                  



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           PLATFORM            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW.navigator                                #NAVIGATOR
[WORKER]NAVIGATOR.userAgent                     #Browser type|version. Not readonly.
                                                #Prefer feature detection to user agent.
[WORKER]NAVIGATOR.platform                      #OS and CPU, e.g. "Linux x86_64". Not readonly.

NAVIGATOR.languages                             #'LANG'_ARR, defined by browser|OS settings
NAVIGATOR.language                              #Preferred 'LANG'_ARR

NAVIGATOR.mimeTypes                             #MIMETYPEARR (HTMLCOLL-like of MIMETYPE)
                                                #Mime types recognized for <object>, e.g. Flash and PDF
MIMETYPE.type                                   #'MIME/TYPE'
MIMETYPE.suffixes                               #'EXT'
MIMETYPE.description                            #STR
MIMETYPE.enabledPlugin                          #PLUGIN

NAVIGATOR.plugins                               #PLUGINARR (HTMLCOLL-like of PLUGIN with extra methods)
                                                #Plugins allowing using mime types for <object>
PLUGINARR.refresh([BOOL])                       #If true, also refreshes the page
PLUGIN.name                                     #STR
PLUGIN.description                              #STR
PLUGIN.filename                                 #STR
PLUGIN[NUM]                                     #MIMETYPE
PLUGIN.length                                   #Of MIMETYPE

NAVIGATOR.javaEnabled()->BOOL                   #

WINDOW|NAVIGATOR.doNotTrack                     #HTTP header DNT, as STR|null (see HTTP doc)
                                                #Try both WINDOW or NAVIGATOR for cross-browser compatibility


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PERMISSIONS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[WORKER]NAVIGATOR.permissions                   #PERMISSIONS
PERMISSIONS.query(PERM_REQ)->>PERM_STATUS       #Get whether a permission is granted
PERM_REQ|PERM_STATUS.name                       #STR. Permission type among:
                                                #  - 'geolocation'
                                                #  - 'notifications'
                                                #  - 'midi'
                                                #  (only Chrome|Firefox)
                                                #  - 'persistent-storage'
                                                #  - 'push'
                                                #  (only Chrome|Webkit)
                                                #  - 'accelerometer'
                                                #  - 'background-fetch'
                                                #  - 'display-capture'
                                                #  - 'gyroscope'
                                                #  - 'magnetometer'
                                                #  - 'nfc'
                                                #  - 'screen-wake-lock'
                                                #  (only Chrome)
                                                #  - 'ambient-light-sensor'
                                                #  - 'background-sync'
                                                #  (only Webkit)
                                                #  - 'bluetooth'
                                                #  - 'camera'
                                                #  - 'microphone'
                                                #  - 'speaker-selection'

PERM_STATUS.state                               #One of:
                                                #  - 'granted': by default, or prompt accepted
                                                #  - 'prompt': not by default, and no prompt yet
                                                #  - 'denied': not by default, and prompt denied
PERM_STATUS.onchange = FUNC(EVENT)              #When PERM_STATUS.state changes


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          GEOLOCATION          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NAVIGATOR.geolocation                           #GEOLOCATION

GEOLOCATION.getCurrentPosition
(FUNC(POS), FUNC2(POS_ERR), POS_OPTS)           #Asks for user confirmation, then only use cached answer (positive or not)
GEOLOCATION.watchPosition(...)->UINT            #Like GEOLOCATION.getCurrentPosition(...) but fired each time POS changes
GEOLOCATION.clearWatch(UINT)                    #

POS.coords.latitude|longitude                   #DOUBLE
POS.coords.accuracy                             #NUM (meters)
POS.coords.altitude[Accuracy]                   #null in many devices
POS.coords.heading                              #DOUBLE indicating direction angle:
                                                #  - 0 (north), 90 (east), etc.
                                                #  - null if no device sensor
                                                #  - NaN if POS.coords.speed 0
POS.coords.speed                                #DOUBLE (m/s).
                                                #null if no device sensor.
POS.timestamp                                   #DATE_NUM

POS_ERR.code                                    #NUM:
                                                #  - 1: permission denied
                                                #  - 2: position unavailable
                                                #  - 3: timeout
POS_ERR.message                                 #STR

POS_OPTS.enableHighAccuracy                     #BOOL. If true, maybe higher accuracy, but more power consumption (def: false)
POS_OPTS.timeout                                #NUM (def: Infinity)
POS_OPTS.maximumAge                             #NUM for cache (in ms, 0 for none) (def: Infinity)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      ORIENTATION/MOTION       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SCREEN.orientation                             $#ORIENTATION
                                               $#'polyfill.io' (only include that feature to keep size low)
                                               $#(only a small part of the spec is available, documented here)
ORIENTATION.type                               $#'landscape|portrait-primary'
                                              $$#or 'landscape|portrait-secondary' (upside down)

DESKTOP SUPPORT ==>                             #Only Chrome/Firefox on desktop. Supported on mobile browsers.

WINDOW.ondeviceorientation =
FUNC(DEVICEORIENTATIONEVENT)                    #When device orientation changes
DEVICEORIENTATIONEVENT.beta|gamma|alpha         #x|y|z axis angle DOUBLE (0-360)
DEVICEORIENTATIONEVENT.absolute                 #BOOL: whether angle is Earth-related or arbritrary

WINDOW.ondevicemotion = FUNC(DEVICEMOTIONEVENT) #When device moves
DEVICEMOTIONEVENT.acceleration[IncludingGravity]#DEVICEACCELERATION
                                                #Usually should not use 'IncludingGravity'
DEVICEACCELERATION.x|y|z                        #x|y|z axis move in DOUBLE m/s
DEVICEMOTIONEVENT.rotationRate                  #DEVICEROTATIONRATE
DEVICEROTATIONRATE.beta|gamma|alpha             #x|y|z axis angle DOUBLE (0-360)
DEVICEMOTIONEVENT.interval                      #Timeframe of the sample in NUM ms



              
   NETWORKING  
              



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OFFLINE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[WORKER]NAVIGATOR.onLine                        #BOOL. Is the browser connected to network.
                                                #Updated each time a network request is made.
                                                #Some browsers return true even if only connected to local network.
WINDOW|WORKERGLOBAL.
onoffline|online = FUNC(EVENT)                  #When NAVIGATOR.onLine changed


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         HTTP HEADERS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOCUMENT.lastModified                           #Returns Last-Modified [S] as 'DATE'
                                                #If not set, current date.

DOCUMENT.cookie                                 #Get|set Set-Cookie [S]
                                                #Get all 'VAR=VAL;VAR=VAL...' but only set a single 'VAR=VAL[;SVAR=SVAL]...'
                                                #Should use en|decodeURIComponent(VAL)
                                                #Setting on Chrome when using file:/// does not work.
NAVIGATOR.cookieEnabled                         #BOOL. Readonly.

DOCUMENT.referrer                               #Returns Referer [S] (or '')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              XHR              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


XMLHttpRequest                                  #HTTP request|response
new XMLHttpRequest()                            #

XHR.open                                        #Specify the request:
(METHOD, URL[, BOOL[, USERNAME[, PASSWORD]]])   #  - BOOL: if true (def), async
XHR.setRequestHeader('VAR', 'VAL')              #Adds HTTP header
                                                #Cannot be set via XHR:
                                                #  - Underlying HTTP protocol: Host, Connection, Keep-Alive, Expect, Upgrade, Proxy-* [C]
                                                #  - Request integrity: Origin, Via, Date, Content-Length, Transfer-Encoding, TE, Trailer [C]
                                                #  - Browser capability: Accept-Charset, Accept-Encoding [C]
                                                #  - Security/privacy: Cookie, Referer, Access-Control-Request-Headers|Method, DNT [C]
                                                #Some headers are set by def, usually same as normal page load request, e.g. for Chrome:
                                                #  - Connection: keepalive [C]
                                                #  - Content-Length [C]
                                                #  - Host, Referer, User-Agent [C]
                                                #  - Cache-Control: no-cache [C]
                                                #  - Accept [C], Accept-Encoding [C], Accept-Language [C]
XHR.responseType                                #Modifies how XHR.response is interpreted:
                                                #  - 'text' or '' (def): STR
                                                #  - 'arraybuffer': ARRBUFFER
                                                #  - 'blob': BLOB
                                                #  - 'document': DOCUMENT
                                                #  - 'json': OBJ
XHR.overrideMimeType('MIME/TYPE')               #Overrides Content-Type [S]
XHR.withCredentials                             #If false (def), do not send Cookie [C] nor [Proxy-]Authentication [C]

XHR.send([BODY_VAL])                            #Sends the request.
                                                #BODY_VAL (only if HTTP method allows it):
                                                #  - STR:
                                                #     - body is STR as is
                                                #     - default Content-Type: "text/plain[;charset=CHARSET]" [C]
                                                #     - to use Content-Type: "application/x-www-form-urlencoded" [C]
                                                #       with 'VAR=VAL&...', must manually:
                                                #        - use encodeURIComponent()
                                                #        - set Content-Type
                                                #  - DOCUMENT:
                                                #     - body is DOCUMENT as STR
                                                #     - default Content-Type: "application/xml[;charset=CHARSET]" [C]
                                                #  - BLOB|ARRBUFFERVIEW:
                                                #     - body is binary as is
                                                #     - no default Content-Type [C]
                                                #  - FORMDATA:
                                                #     - body as "multipart/form-data" content (see HTML doc)
                                                #        - filename is "blob" for anonymous BLOB, real filename otherwise, and not set for STR
                                                #     - default Content-Type: "multipart/form-data;boundary=BOUNDARY" [C]
XHR.abort()                                     #Emit event

XHR.onreadystatechange = FUNC(EVENT)            #When XHR.readyState changes
XHR.readyState                                  #Can be:
                                                #  - XHR.UNSENT: uninitialized
                                                #  - XHR.OPENED: open()
                                                #  - XHR.HEADER_RECEIVED: send() and response header received
                                                #  - XHR.LOADING: downloading response body
                                                #  - XHR.DONE: downloaded response body

XHR.onloadstart = FUNC(PROGRESSEVENT)           #When starts reading
XHR.onprogress = FUNC(PROGRESSEVENT)            #When is reading
XHR.onload[end] = FUNC(PROGRESSEVENT)           #When finishes. load is success, loadend is success or failure.
XHR.onabort = FUNC(PROGRESSEVENT)               #
XHR.onerror = FUNC(PROGRESSEVENT)               #

XHR.upload.on*                                  #Like XHR.on*:
                                                #  - except readystatechange
                                                #  - only fired if BODY_VAL with proper HTTP method

XHR.timeout                                     #In ms (def: 0, i.e. unlim)
XHR.ontimeout = FUNC(PROGRESSEVENT)             #

PROGRESSEVENT.lengthComputable                  #true if PROGRESSEVENT.loaded|total available
PROGRESSEVENT.loaded|total                      #Number of bytes

XHR.status[Text]                                #HTTP response status code as NUM|STR
XHR.response                                    #Server response as STR|ARRBUFFER|BLOB|DOCUMENT|OBJ, depending on XHR.responseType
XHR.responseText                                #Server response as STR
XHR.getResponseHeader('VAR')->'VAL'             #
XHR.getAllResponseHeaders()->OBJ                #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             FETCH             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW|WORKERGLOBAL.fetch(...)->>RES            #Performs a HTTP request
                                                #Same arguments as new Request(...)
                                                #PROMISE is rejected only if RES.type === 'error' (see below)
                                                #  - i.e. resolved even if status is 4** or 5**
                                                #  - ERROR is a standard error, i.e. only ERROR.message|stack is interesting

new Request(REQP[, REQQ])                       #REQ. HTTP request
                                                #Data URI supported
                                                #Throws error if wrong input (e.g. 'URL', headers or body)
REQP                                            #'URL'|URL|REQ
REQ.clone()->REQ2                               #Throws exception if REQ.bodyUsed true
REQ.url                                         #'URL'
REQ[Q].method                                   #STR (normalized uppercase)
REQ.destination                                 #How the request was initiated:
                                                #  - 'script': <script>, WORKERGLOBAL.importScripts()
                                                #  - '[service|shared]worker'
                                                #  - 'paint|audioworklet'
                                                #  - 'style': <link rel="stylesheet">, @import
                                                #  - 'font': @font-face
                                                #  - 'image': <img src[set]>, <picture>, /favicon.ico, SVG <image>, background-image,
                                                #    list-style-image, cursor
                                                #  - 'video': <video>
                                                #  - 'audio': <audio>
                                                #  - 'track': <track>
                                                #  - 'document': <[i]frame> or user interaction (e.g. clicking on link or for submission)
                                                #  - 'object|embed': <object|embed>
                                                #  - 'manifest': <link rel="manifest"> (App Manifest)
                                                #  - 'report': CSP or Network Error Logging reports
                                                #  - 'xslt': <?xml-stylesheet>
                                                #  - '': others, e.g. XHR-like (XHR, fetch(), WEBSOCKET, sendBeacon(), EventSource),
                                                #    <any ping>, <a download>
REQ[Q].keepalive                                #BOOL (def: false)
                                                #If true, do not stop request if WINDOW|WORKER is closed
                                                #Might not be sent right away (low priority), but guaranteed to be when
                                                #DOCUMENT.visibilityState becomes 'hidden'
                                                #Max request body length is 64KB
REQ[Q].mode                                     #Whether to allow cross-origin:
                                                #  - 'cors' (def): allow cross-origin requests
                                                #  - 'no-cors':
                                                #     - allow only cross-origin requests that are simple (i.e. without preflight request)
                                                #     - RES.type will be 'opaque'
                                                #  - 'navigate':
                                                #     - allow only cross-origin requests resulting from user interaction (e.g. clicking on link)
                                                #     - cannot be set programmatically
                                                #     - RES.type will be 'basic'
                                                #  - 'same-origin': only allow same-origin request
REQ.isHistoryNavigation                        $#When due to history navigation, e.g. going backward
REQ.isReloadNavigation                         $#When due to reload
REQ[Q].redirect                                 #How client-side redirects (301|302|303|307|308) are handled:
                                                #  - 'follow' (def): follows redirect
                                                #  - 'manual': follows redirect, but redirect RES.type is 'opaqueredirect'
                                                #  - 'error': network error
REQ[Q].credentials                              #Similar to XHR.withCredentials (whether to send Cookie [C] and [Proxy-]Authentication [C]):
                                                #  - 'omit': never
                                                #  - 'same-origin' (def): only if same-origin
                                                #  - 'include': always
REQ[Q].cache                                    #Whether cache is used and whether If-* [C] is sent:
                                                #  +----------------+-------------------------+-------------------------+----------------------------+-------------------------------------+
                                                #  | NAME           | CACHE AVAILABLE & FRESH | CACHE AVAILABLE & STALE | NO CACHED ANSWER AVAILABLE | NOTES                               |
                                                #  +----------------+---------------------------------------------------+----------------------------+-------------------------------------+
                                                #  | only-if-cached | Use cache                                         | Network error              | mode must be 'same-origin'          |
                                                #  +----------------+---------------------------------------------------+----------------------------+-------------------------------------+
                                                #  | force-cache    | Use cache                                         | Request without If-* [C]   |                                     |
                                                #  +----------------+-------------------------+-------------------------+----------------------------+-------------------------------------+
                                                #  | default        | Use cache               | Request with If-* [C]   | Request without If-* [C]   |                                     |
                                                #  +----------------+-------------------------+-------------------------+----------------------------+-------------------------------------+
                                                #  | no-cache       | Request with If-* [C]                             | Request without If-* [C]   |                                     |
                                                #  +----------------+---------------------------------------------------+----------------------------+-------------------------------------+
                                                #  | reload         | Request without If-* [C]                                                       |                                     |
                                                #  +----------------+--------------------------------------------------------------------------------+-------------------------------------+
                                                #  | no-store       | Request without If-* [C]                                                       | Does not update cache with response |
                                                #  +----------------+--------------------------------------------------------------------------------+-------------------------------------+
                                                #Def: if If-* [C] specified, 'no-store', otherwise 'default'
REQ[Q].referrer                                 #What Referer [C]:
                                                #  - 'no-referrer': nothing
                                                #  - 'URL'
                                                #  - 'client' (def): current 'URL', or nothing depending on settings
REQ[Q].referrerPolicy                           #How Referer [C] is populated (see web security doc)
REQ[Q].integrity                                #'ALGO-HASH' (see <link|script integrity>)
REQ[Q].signal                                   #ABORT_SIGNAL
REQQ.window                                     #If null, dissociate from WINDOW

new Response([VAL[, RESS]])                     #RES. HTTP response
                                                #VAL: like REQQ.body
                                                #Throws error if wrong input (e.g. status or body)
RES.clone()->RES2                               #
Response.error()->RES                           #Creates RES with type 'error'
Response.redirect('URL'|URL[, STATUS_NUM])->RES #Creates RES with status STATUS_NUM (def: 302), url '', Location: URL [S]
Response.json(VAL[, RESS])->RES                 #Creates new Response(JSON.stringify(VAL), RESS), with Content-Type: application/json [S]

RES.url                                         #'URL' (last URL if redirected)
RES.redirected                                  #BOOL
RES[S].status                                   #NUM (def: 200)
RES[S].statusText                               #STR (def: 'OK')
RES.ok                                          #RES.status === 2**
RES.type                                        #Can be:
                                                #  - 'default': normal response
                                                #  - 'basic': Set-Cookie [S] was removed
                                                #  - 'cors':
                                                #      - CORS preflight request's response.
                                                #      - i.e. removed any header not allowed to be exposed by CORS (taking Access-Control-Expose-Headers [S] into account)
                                                #  - 'opaque': response where fields are hidden. url '', status: 0, statusText '', headers {}, body null
                                                #  - 'opaqueredirect': same but is a redirect, so url is defined
                                                #  - 'error':
                                                #      - hide fields like 'opaqueredirect'
                                                #      - happens when request-response could not work properly ("network error"):
                                                #         - aborted with an ABORT_CONTROLLER
                                                #         - TCP|TLS connection failure
                                                #         - blocked for security (same-origin, CSP, mixed content, nosniff, REQ.integrity)
                                                #         - wrong input, parsing error ('URL', headers, body, status)
                                                #         - unexpected scheme ('blob|data:' without GET, any scheme beyong usual ones (http[s]:, file:, ftp:, etc.))
                                                #         - redirection problems (REQ.redirect 'error' and a redirect happened, wrong Location [S], too many redirects)
                                                #      - but not when status is 4** or 5**

REQQ|RESS.headers                               #HEADERS, {'NAME': 'VALUE', ...} or ['NAME', 'VALUE']_ARR
REQ|RES.headers                                 #HEADERS
RES.trailer                                     #>HEADERS for trailer headers

new Headers([VAL])                              #HTTP header
                                                #VAL: same as REQQ.headers
                                                #Allowed headers:
                                                #  - new Headers() not related to REQ|RES yet: none
                                                #  - REQ: like XHR
                                                #  - RES:
                                                #     - if created with new Response(), only Set-Cookie [S]
                                                #     - Otherwise, read-only
                                                #NAMEs are converted to lowercase
HEADERS                                         #[KEY, VAL]_ITERABLE
HEADERS.get|has|set|delete(...)
HEADERS.keys|values|entries|forEach(...)        #Like MAP, but for individual headers
HEADERS.append('VAR', VAL)                      #As opposed to set() (which erase all previous headers with same name first),
HEADERS.getSetCookie()->'VAR=VAL'_ARR           #Returns Set-Cookie [S]

REQQ.body                                       #STR|BLOB|ARRBUFFER[VIEW]|FORMDATA|SEARCHPARAMS|RSTREAM
REQ|RES.body                                    #RSTREAM
REQ|RES.json|text|blob|arrayBuffer|formData()   #Retrieves body
 ->>VAL                                         #Throws exception if cannot parse, or called twice.
REQ|RES.bodyUsed                                #BOOL: whether json|text|blob|arrayBuffer|formData() has already been called

new FormData([FORM[, BUTTON|INPUT]])            #multipart/form-data value
                                                #If BUTTON|INPUT, must be of type "image"
                                                #Is a [KEY, VAL]_ITERABLE
FORMDATA.get|has|set|delete(...)
FORMDATA.keys|values|entries|forEach(...)       #Like MAP
FORMDATA.getAll('VAR')->VAL_ARR                 #
FORMDATA.append('VAR', STR)                     #
FORMDATA.append('VAR', BLOB[, 'FILENAME'])      #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       ABORT_CONTROLLER        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new AbortController()                           #
ABORT_CONTROLLER.signal                         #ABORT_SIGNAL
ABORT_CONTROLLER.abort([VAL])                   #Aborts a ABORT_SIGNAL
                                                #VAL is ABORT_SIGNAL.reason (def: DOMException)

new AbortSignal()                               #
ABORT_SIGNAL.aborted                            #BOOL
ABORT_SIGNAL.onabort = FUNC(EVENT)              #
AbortSignal.abort([VAL])->ABORT_SIGNAL          #Return already aborted ABORT_SIGNAL
AbortSignal.timeout(NUM)->ABORT_SIGNAL          #Returns ABORT_SIGNAL which aborts after NUMms
AbortSignal.any(ABORT_SIGNAL_ARR)->ABORT_SIGNAL #Returns ABORT_SIGNAL which aborts if any ABORT_SIGNAL_ARR does
ABORT_SIGNAL.reason                             #VAL, usually ERROR
ABORT_SIGNAL.throwIfAborted()                   #If ABORT_SIGNAL.aborted true, throw ABORT_SIGNAL.reason

ABORT-CONTROLLER ==>                           ##Node.js ponyfill/polyfill implementation (e.g. to use with node-fetch). Prefer with Node.js
                                               ##Uses Node.js EVENTLISTENER not DOM's EVENTTARGET
                                               ##Not needed with Node.js >=15.0.0
                                               ##Version 3.0.0

YET-ANOTHER-ABORTCONTROLLER-POLYFILL ==>       ##JavaScript polyfill implementation. Prefer if client-side or universal JavaScript
                                               ##Uses DOM's EVENTTARGET
                                               ##Version 0.0.3


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             CACHE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


caches                                          #CACHE_STORAGE

CacheStorage
CACHE_STORAGE                                   #CACHEs. 'CACHE' can e.g. be a URL domain.
CACHE_STORAGE.open('CACHE')->>CACHE             #
CACHE_STORAGE.delete('CACHE')->>BOOL            #
CACHE_STORAGE.has('CACHE')->BOOL                #
CACHE_STORAGE.keys()->>'CACHE'_ARR              #

Cache
CACHE                                           #HTTP cache. Caches one RES per REQP
CACHE.put(REQP, RES)->>                         #Add an entry
CACHE.add(REQP)->>
CACHE.addAll(REQP_ARR)->>                       #Like fetch(...) + CACHE.put()
CACHE.delete(REQP[, OPTS])->>BOOL               #Delete an entry
                                                #Returns true if one was found
CACHE.match(REQP[, OPTS])[->>RES]               #Get first matching entry
CACHE_STORAGE.match(REQP[, OPTS])[->RES]        #Same but for OPTS.cacheName 'CACHE' (def: any)
CACHE.matchAll(REQP[, OPTS])->>RES_ARR          #Get all matching entries
CACHE.keys([REQP[, OPTS]])->>REQ_ARR            #Get all entries keys

OPTS.ignoreSearch                               #BOOL (def: false). Ignore '?SEARCH' in REQP key
OPTS.ignoreMethod                               #BOOL (def: false). Ignore HTTP method in REQP key
OPTS.ignoreVary                                 #BOOL (def: false). Ignore Vary [C]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BEACON             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[WORKER]NAVIGATOR.sendBeacon('URL'[, VAL])     $#Like WINDOW.fetch('URL', {method: 'POST', body: VAL, credentials: 'include', cors: 'no-cors', keepalive: true}) except:
  ->BOOL                                       $#  - return BOOL:
                                               $#     - i.e. HTTP request successfully queued
                                               $#     - no access to RES
                                               $#        - hence server should provide limited response, e.g. 204 or END_STREAM
                                               $#  - use cors: 'cors' if body BLOB
                                               $#'navigator.sendBeacon' (0.0.9) (polyfills with a normal XHR if unsupported)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           WEBSOCKET           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WebSocket                                       #
new WebSocket('URL'|URL[, STR[_ARR]])           #Opens websocket (see Websocket doc)
                                                #STR[_ARR] are requested subprotocols.
                                                #Throws SECURITY_ERR if port blocked.
WEBSOCKET.send(STR|BLOB|ARRBUFFER[VIEW])        #Can throw:
                                                #  - INVALID_STATE_ERR: connection not opened
                                                #  - SYNTAX_ERR: invalid data sent
WEBSOCKET.onopen = FUNC(EVENT)                  #
WEBSOCKET.onmessage = FUNC(MESSAGEEVENT)        #
WEBSOCKET.binaryType                            #MESSAGEEVENT.data type: 'blob' (def) or 'arraybuffer'

WEBSOCKET[_STREAM].url                          #'URL'
WEBSOCKET[_CONN].protocol                       #Subprotocol STR returned by server.
WEBSOCKET[_CONN].extensions                     #Extensions STR, changed by server.
WEBSOCKET.bufferedAmount                        #Number of bytes sent buffered.

WEBSOCKET.readyState                            #Any of WebSocket.CONNECTING|OPEN|CLOSING|CLOSED

WEBSOCKET.close([UINT[, STR]])                  #UINT is error code (1000 (def) or 3000-4999)
                                                #STR error message (def: '')
                                                #Should make sure bufferedAmount is 0 before.
                                                #Can throw:
                                                #  - INVALID_ACCESS_ERR: invalid UINT
                                                #  - SYNTAX_ERR: invalid STR
WEBSOCKET.onclose = FUNC(CLOSEEVENT)            #
CLOSEEVENT.wasClean                             #True if cleanly closed.
CLOSEEVENT|CLOSE_OBJ.code                       #UINT
CLOSEEVENT|CLOSE_OBJ.reason                     #STR

WEBSOCKET.onerror = FUNC(ERROREVENT)            #

new WebSocketStream('URL'|URL[, OPTS])         $#Like WEBSOCKET, but communicating through RSTREAM|WSTREAM
                                               $#instead of MESSAGEEVENTs
OPTS.protocols                                 $#STR_ARR, like new WebSocket(..., STR_ARR)
OPTS.headers                                   $#Like REQQ.headers

WEBSOCKET_STREAM.connection                    $#>WEBSOCKET_CONN
WEBSOCKET_CONN.readable                        $#RSTREAM
WEBSOCKET_CONN.writable                        $#WSTREAM

OPTS.signal                                    $#ABORT_SIGNAL to close()
WEBSOCKET_STREAM.close(CLOSE_OBJ)              $#
WEBSOCKET_STREAM.closed                        $#>CLOSE_OBJ


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              SSE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new EventSource('URI'[, OPTS])                  #Connection to a SSE stream (see HTTP doc)
EVENTSOURCE.url                                 #'URI'
EVENTSOURCE|OPTS.withCredentials                #BOOL (def: false) (see XHR)

EVENTSOURCE.onopen = FUNC(EVENT)                #Including when reconnecting
EVENTSOURCE.onerror = FUNC(EVENT)               #Including when trying to reconnect, and failing to do so
EVENTSOURCE.close()                             #
EVENTSOURCE.onclose = FUNC(CLOSEEVENT)          #
EVENTSOURCE.readyState                          #EventSource.CONNECTING|OPEN|CLOSED

EVENTSOURCE.onEVENT = FUNC(MESSAGEEVENT)        #Fired on server-sent event
                                                #EVENT is the event type (def: 'message')
MESSAGEEVENT.data                               #STR
MESSAGEEVENT.lastEventId                        #Message 'ID'
MESSAGEEVENT.*                                  #Like others, except ports|source are null



           
   STORAGE  
           


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STREAMS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new ReadableStream([ROPTS[, RROPTS]])           #RSTREAM for input
                                                #In-memory FIFO where:
                                                #  - producer pushes data:
                                                #     - either:
                                                #        - on read request: pull()
                                                #        - on new data: enqueue()
                                                #     - can wait if full: QueuingStrategy
                                                #  - consumer pops data:
                                                #     - read(), ITERATOR
                                                #     - can be deferred
ROPTS.start                                     #FUNC(RSTREAM_CONTROLLER)[->>]
                                                #Called on new ReadableStream(), synchronously
                                                #Exceptions propagate from new ReadableStream()
                                                #PROMISE rejections call RSTREAM_CONTROLLER.error()

RSTREAM_CONTROLLER.close()                      #Ends RSTREAM but can still read from queue
                                                #Fails if already closed|canceled|errored
RSTREAM[_READER].cancel([VAL])->>               #Ends RSTREAM and discard read queue
                                                #VAL can be anything but should generally be undefined|ERROR
                                                #PROMISE is resolved|rejected based on ROPTS.cancel() PROMISE2
                                                #Fails if already closed|canceled|errored
RSTREAM_CONTROLLER.error([VAL])                 #Ends RSTREAM and discard read queue
                                                #VAL can be anything (including undefined) but should generally be ERROR
ROPTS.cancel                                    #FUNC([VAL])->>
                                                #Called on RSTREAM[_READER].cancel()
RSTREAM_READER.closed                           #PROMISE resolved on:
                                                #  - close() and queue empty
                                                #  - cancel()
                                                #Rejected on:
                                                #  - error()
                                                #  - RSTREAM_READER end (releaseLock()) before close()

ROPTS.type                                      #undefined|'bytes'
RSTREAM_CONTROLLER                              #Either:
                                                #  - RDSTREAM_CONTROLLER (ROPTS.type undefined): chunks are any type
                                                #  - RBSTREAM_CONTROLLER (ROPTS.type 'bytes'): chunks are TDBUFFERs
                                                #    (without Node: DATAVIEW|TYPEDARR)
RDSTREAM_CONTROLLER.enqueue(VAL)                #Pushes a value to read queue
                                                #Succeeds even if read queue full
RBSTREAM_CONTROLLER.enqueue(TDBUFFER)           #Same but:
                                                #  - enqueues TDBUFFER
                                                #  - re-use TDBUFFER memory allocation
                                                #  - calls TDBUFFER.buffer.transfer(), i.e.:
                                                #     - underlying ARRBUFFER data is kept, but not ARRBUFFER itself
                                                #     - must ensure other TDBUFFERs are not using same underlying ARRBUFFER

ROPTS.pull                                      #FUNC(RSTREAM_CONTROLLER)->> called on:
                                                #  - init
                                                #     - goal: enqueue initial data
                                                #  - read():
                                                #     - goal: enqueue data at the pace it is being read
                                                #     - called when read() is called, not when it returns
                                                #     - read() does not wait for pull() PROMISE
                                                #  - enqueue():
                                                #     - goal: repeat until queue is full
                                                #     - should use desiredSize to avoid repeats
                                                #Not called when queue is full
                                                #Awaits previous pull() PROMISE first
                                                #Debounced
                                                #  - e.g. if read() happens right after init, pull() called only once

RBSTREAM_CONTROLLER.byobRequest                $#RBSTREAM_REQUEST
                                               $#null unless all of:
                                               $#  - read() has started, i.e.:
                                               $#     - in ROPTS.pull()
                                               $#  - read() has not resolved yet, i.e.:
                                               $#     - before enqueue|respond*()
                                               $#     - RBSTREAM_REQUEST.view is not reset yet
                                               $#  - queue is empty
                                               $#Goal: when using pull(RBSTREAM_CONTROLLER), re-use read()'s TDBUFFER instead of re-allocating one
RBSTREAM_REQUEST.view                          $#TDBUFFER currently passed to either:
                                               $#  - RBSTREAM_READER.read(TDBUFFER)
                                               $#  - RDSTREAM_READER.read(), providing ROPTS.autoAllocateChunkSize NUM defined
                                               $#     - this allocates a new TDBUFFER of NUM bytes on each read()
RBSTREAM_REQUEST.respond(NUM)                  $#Does RBSTREAM_CONTROLLER.enqueue() with first NUM bytes of RBSTREAM_REQUEST.view
RBSTREAM_REQUEST.respondWithNewView(TDBUFFER2) $#Does RBSTREAM_CONTROLLER.enqueue(TDBUFFER2)
                                               $#TDBUFFER2.byteLength must === RBSTREAM_REQUEST.view.byteLength
                                               $#Only works with RBSTREAM_READER

new ReadableStreamDefaultReader(RSTREAM)        #RDSTREAM_READER
                                                #Does not fail if RSTREAM closed|canceled|errored
                                                #Read data value by value
new ReadableStreamByobReader(RSTREAM)          $#Same for RBSTREAM_READER
                                               $#Requires ROPTS.type 'bytes'
                                               $#Read data byte-wise
RSTREAM_READER                                  #RDSTREAM_READER|RBSTREAM_READER
RSTREAM.getReader([OPTS])->RSTREAM_READER       #Same as (depending on OPTS.mode):
                                                #  - undefined (def): new ReadableStreamDefaultReader(RSTREAM)
                                                #  - 'byob': new ReadableStreamByobReader(RSTREAM)
RSTREAM.locked                                  #BOOL (read-only):
                                                #  - true on new ReadableStream*Reader(RSTREAM)
                                                #  - false on RSTREAM_READER.releaseLock()
                                                #If true, forbids:
                                                #  - another new ReadableStream*Reader(RSTREAM)
                                                #  - RSTREAM[_READER].cancel() (but not close())
                                                #If false, forbids read()
RSTREAM_READER.releaseLock()                    #Throws if a read() PROMISE is pending
                                                #Does not fail if RSTREAM closed|canceled|errored
RDSTREAM_READER.read()->>OBJ                    #Pops a value from read queue, right away
                                                #If another read() ongoing, wait for it first
                                                #If RSTREAM:
                                                #  - open|closed (queue not empty): { value VAL, done: false }
                                                #     - if ROPTS.type 'bytes', value is ARRBUFFER
                                                #  - open (queue empty): PROMISE waits for a value to get pushed
                                                #  - closed (queue empty) or canceled: { value: undefined, done: true }
                                                #  - errored: rejection
RBSTREAM_READER.read(TDBUFFER)->>OBJ           $#Same but:
                                               $#  - read TDBUFFER.byteLength bytes
                                               $#  - re-use TDBUFFER memory allocation
                                               $#  - calls TDBUFFER.buffer.transfer(), i.e.:
                                               $#     - TDBUFFER data is discarded, it is only used for transferring data
                                               $#     - must ensure other TDBUFFERs are not using same underlying ARRBUFFER
                                               $#     - only done once PROMISE has resolved, i.e. when there is data to read

RSTREAM_ASYNC_ITERATOR                          #RSTREAM is an ASYNC_ITERATOR
RSTREAM.values([OPTS])->ASYNC_ITERATOR          #Steps:
                                                #  - ITERATOR.next() returns RSTREAM_READER.read(), i.e.:
                                                #     - hangs if queue empty
                                                #     - resolves if RSTREAM closed (queue empty) or canceled
                                                #     - rejects if RSTREAM errored
                                                #  - ITERATOR.return([VAL]) calls:
                                                #     - cancel([VAL]) if OPTS.preventCancel false (def)
                                                #     - close() otherwise
                                                #        - i.e. queue data is not discarded
                                                #        - but ITERATOR is now finished, i.e. next() now returns { value: undefined, done: true }
                                                #  - no ITERATOR.throw()
                                                #Uses an underlying RSTREAM_READER
                                                #  - on start: RSTREAM.getReader({ mode: undefined })
                                                #  - on RSTREAM closed|canceled|errored: RSTREAM_READER.releaseLock()

new WritableStream([WOPTS[, WWOPTS]])           #WSTREAM for output
                                                #In-memory FIFO where:
                                                #  - consumer pushes data:
                                                #     - WSTREAM_WRITER.write()
                                                #     - can wait if full: QueuingStrategy
                                                #  - producer pops data:
                                                #     - WOPTS.write()
                                                #     - cannot be deferred
WOPTS.start                                     #FUNC(WSTREAM_CONTROLLER)[->>]
                                                #Called on new WritableStream(), synchronously
                                                #Exceptions propagate from new WritableStream()
                                                #PROMISE rejections call WSTREAM_CONTROLLER.error()

WSTREAM[_WRITER].close()->>                     #Ends WSTREAM, not allowing writing to queue
                                                #Ongoing writes are still processed
                                                #PROMISE is resolved|rejected based on WOPTS.close() PROMISE2
                                                #Fails if already closed|aborted|errored
WSTREAM[_WRITER].abort([VAL])->>                #Ends WSTREAM, not allowing writing to queue
                                                #Ongoing writes are rejected with VAL
                                                #VAL can be anything but should generally be undefined|ERROR
                                                #PROMISE is resolved|rejected based on WOPTS.abort() PROMISE2
                                                #Fails if already closed|aborted|errored
WSTREAM_CONTROLLER.error([VAL])                 #Ends WSTREAM, not allowing writing to queue
                                                #Ongoing writes are rejected with VAL
                                                #VAL can be anything (including undefined) but should generally be ERROR
WOPTS.close                                     #FUNC()->> called on WSTREAM[_WRITER].close()
WOPTS.abort                                     #FUNC([VAL])->> called on WSTREAM[_WRITER].abort()
WSTREAM_CONTROLLER.signal                       #ABORT_SIGNAL. onabort():
                                                #  - called on abort()
                                                #  - EVENT passed as argument, but must use abortReason to access abort VAL
                                                #  - exceptions are uncaught exceptions
WSTREAM_CONTROLLER.abortReason                  #VAL passed to WSTREAM[_WRITER].abort()
WSTREAM_WRITER.closed                           #PROMISE resolved on:
                                                #  - close()
                                                #  - abort()
                                                #Rejected on:
                                                #  - error()
                                                #  - WSTREAM_WRITER end (releaseLock())

new WritableStreamDefaultWriter(WSTREAM)        #WDSTREAM_WRITER
WSTREAM_WRITER                                  #Always WDSTREAM_WRITER
                                                #Does not fail if WSTREAM closed|aborted|errored
                                                #Write data value by value
WSTREAM.getWriter()->WSTREAM_WRITER             #Same as new WritableStreamDefaultWriter(WSTREAM)
WSTREAM.locked                                  #BOOL (read-only):
                                                #  - true on new WritableStream*Writer(WSTREAM)
                                                #  - false on WSTREAM_WRITER.releaseLock()
                                                #If true, forbids:
                                                #  - another new WritableStream*Writer(WSTREAM)
                                                #  - WSTREAM[_WRITER].close|abort()
                                                #If false, forbids write()
WSTREAM_WRITER.releaseLock()                    #Does not fail if:
                                                #  - a write() PROMISE is pending (and the write is not aborted)
                                                #  - WSTREAM closed|aborted|errored
WDSTREAM_WRITER.write([VAL])->>                 #Pushes a new writes to the queue
                                                #Resolves|rejects based on WOPTS.write() PROMISE
                                                #If another write() ongoing, wait for it first
WSTREAM_WRITER.ready                            #PROMISE:
                                                #  - resolved when no more ongoing write()
                                                #  - rejected when any ongoing write() PROMISE is rejected

WOPTS.type                                      #Always undefined
WSTREAM_CONTROLLER                              #Always WDSTREAM_CONTROLLER
WOPTS.write                                     #FUNC(VAL, WSTREAM_CONTROLLER)->>
                                                #Called when a write is available from the queue, popping it

new TransformStream                             #TSTREAM for input+output
 ([TOPTS[, WWOPTS[, RROPTS]]])                  #In-memory FIFO where:
                                                #  - consumer pushes data
                                                #     - WSTREAM_WRITER.write()
                                                #     - can wait if full: writable QueuingStrategy
                                                #  - producer transforms data:
                                                #     - WSTREAM -> transform() -> RSTREAM
                                                #     - automatically wait if full: readable QueuingStrategy
                                                #  - consumer pops data
                                                #     - read(), ITERATOR
                                                #     - can be deferred
TOPTS.start(TSTREAM_CONTROLLER)[->>]            #Called on new TransformStream(), synchronously
                                                #Exceptions propagate from new Transform()
                                                #PROMISE rejections call readable|writable error()

STREAMS ENDS ==>                                #Calling:
                                                #  - writable close() -> readable close()
                                                #  - writable abort|error() -> readable error()
                                                #  - readable close|cancel|error() -> writable error()
TSTREAM_CONTROLLER.terminate()                  #Call readable close() and writable error()
TSTREAM_CONTROLLER.error([VAL])                 #Call readable|writable error()

TSTREAM.writable                                #WSTREAM, created on init. Cannot pass WOPTS.
TOPTS.writableType                              #Always undefined
TOPTS.transform                                 #FUNC(VAL, TSTREAM_CONTROLLER)->>
                                                #Allows transforming chunks written to writable
                                                #Similar to WOPTS.write():
                                                #  - called on a new writable write()
                                                #  - write() awaits transform() PROMISE, including:
                                                #     - rejection
                                                #     - waiting on readable queue not to be full
                                                #Awaits previous transform() PROMISE first
                                                #Writable queue:
                                                #  - can increase if too many writes but either:
                                                #     - transform() PROMISE too slow
                                                #     - readable queue full (e.g. not enough read())
                                                #  - desiredSize can be manually checked before write()
                                                #Readable:
                                                #  - queue added by calling TSTREAM_CONTROLLER.enqueue() 0-n times
                                                #  - read() does not await transform() PROMISE
                                                #Waits for the readable queue not to be full:
                                                #  - queue is added|subtracted by readable enqueue|read()
                                                #  - def RROPTS.highWaterMark 0, i.e. transform() always waits for a read(), one at a time
                                                #Def: identity function
TOPTS.flush                                     #FUNC(TSTREAM_CONTROLLER)->>
                                                #Meant to perform logic at the end of transform
                                                #  - including enqueue() final chunk to readable
                                                #Called on writable close() and all write|transform() have ended
                                                #But called before readable close()
                                                #writable write|close() follows PROMISE resolution|rejection
                                                #PROMISE rejections call readable|writable error()

TSTREAM.readable                                #RSTREAM, created on init. Cannot pass ROPTS.
TOPTS.readableType                              #Always undefined
TSTREAM_CONTROLLER                              #Always TDSTREAM_CONTROLLER
TDSTREAM_CONTROLLER.enqueue([VAL])              #Call readable enqueue([VAL])

RSTREAM.pipeTo(WSTREAM[, OPTS])->>              #Pipe RSTREAM to WSTREAM:
                                                #  - wait for new chunk with RSTREAM_READER.read()
                                                #     - including creating underlying RSTREAM_READER
                                                #     - same behavior as RSTREAM_ASYNC_ITERATOR
                                                #  - pass each chunk to WSTREAM_WRITER.write()
                                                #     - including creating underlyng WSTREAM_WRITER
                                                #Meant for final piping
                                                #Terminations:
                                                #  - RSTREAM close():
                                                #     - PROMISE resolved
                                                #     - if OPTS.preventClose:
                                                #        - false (def): WSTREAM close()
                                                #        - true: WSTREAM still open but unlocked
                                                #  - RSTREAM error([VAL]):
                                                #     - PROMISE rejected with VAL
                                                #     - if OPTS.preventAbort:
                                                #        - false (def): WSTREAM abort([VAL])
                                                #        - true: WSTREAM still open but unlocked
                                                #  - WSTREAM error([VAL]):
                                                #     - PROMISE rejected with VAL
                                                #     - if OPTS.preventCancel:
                                                #        - false (def): RSTREAM cancel([VAL])
                                                #        - true: RSTREAM still open but unlocked
                                                #  - WSTREAM close(), RSTREAM|WSTREAM cancel|abort():
                                                #     - method fails
                                                #     - RSTREAM|WSTREAM still open and locked
                                                #OPTS:
                                                #  - signal ABORT_SIGNAL: on abort:
                                                #     - RSTREAM cancel(ABORT_ERROR), WSTREAM abort(ABORT_ERROR)
                                                #     - PROMISE rejected with ABORT_ERROR
RSTREAM.pipeThrough(OBJ[, OPTS])->RSTREAM2      #Like RSTREAM.pipeTo(OBJ.writable) but returns OBJ.readable instead
                                                #OBJ can be a TSTREAM
                                                #Meant for intermediary piping
RSTREAM.tee()->[RSTREAM2, RSTREAM3]             #Creates RSTREAM2|3 and pipe RSTREAM to them:
                                                #  - wait for new chunk with RSTREAM_READER.read()
                                                #     - including creating underlying RSTREAM_READER
                                                #     - same behavior as RSTREAM_ASYNC_ITERATOR
                                                #  - pass each chunk to each RSTREAM_CONTROLLER.enqueue()
                                                #     - same chunk reference passed to both RSTREAM2|3 for both RDSTREAM|RBSTREAM
                                                #Terminations:
                                                #  - RSTREAM close() -> RSTREAM2|3 noop
                                                #  - RSTREAM2|3 close() -> not possible since no access to their CONTROLLER
                                                #  - RSTREAM cancel() -> not allowed since RSTREAM is locked
                                                #  - RSTREAM2 cancel() -> RSTREAM noop
                                                #  - RSTREAM2 + RSTREAM3 cancel(VAL) -> RSTREAM cancel(VAL_ARR)
                                                #  - RSTREAM error() <-> RSTREAM2|3 error()

DEFAULT QUEUING STRATEGY ==>                    #According to RROPTS|WWOPTS.type:
                                                #  - undefined:
                                                #     - def size(): CountQueuingStrategy.size()
                                                #     - def highWaterMark: 1
                                                #        - exception: RROPTS in TSTREAM: 0
                                                #  - 'bytes':
                                                #     - size(): ByteLengthQueuingStrategy.size()
                                                #        - cannot change it (including through *QueuingStrategy)
                                                #     - def highWaterMark: 0
new ByteLengthQueuingStrategy(OPTS)             #Can be used instead of RROPTS|WWOPTS
new CountQueuingStrategy(OPTS)                  #OPTS: highWaterMark NUM
QUEUING_STRATEGY|RROPTS|WWOPTS.highWaterMark    #NUM. Queue max size.
RSTREAM_CONTROLLER|WSTREAM_WRITER|              #NUM (read-only)
 TSTREAM_CONTROLLER.desiredSize                 #How much left until queue is full
                                                #Can be <= 0, i.e. queue is full
QUEUING_STRATEGY.size(VAL)->NUM                 #Unit used by highWaterMark|desiredSize:
                                                #  - ByteLengthQueuingStrategy: TDBUFFER.byteLength
                                                #     - i.e. number of bytes
                                                #     - only works if TDBUFFERs are enqueued
                                                #  - CountQueuingStrategy: always 1
                                                #     - i.e. number of chunks
RROPTS|WWOPTS.size                              #FUNC(VAL)->NUM
                                                #Custom unit for highWaterMark|desiredSize

ReadableStream.from(ASYNC_ITERABLE)->RSTREAM    #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             FILES             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Blob                                            #Similar to ARRBUFFER but kept as temp file, not in memory.
                                                #Can see debug info at about:blobs (Chrome)
                                                #Ponyfill: see fetch-blob
new Blob(ARRBUFFER_ARR|DATAVIEW_ARR|            #ARR will be concatenated.
TYPED_ARR_ARR|BLOB_ARR|STR_ARR[, OPTS])         #OPTS:
                                                #  - type 'MIME'
                                                #  - endings 'transparent' (no change, def) or 'native' (convert newlines to OS-specific)
                                                #Max size: around 500MB
BLOB.size                                       #NUM
BLOB.type                                       #'MIME'
BLOB.slice(ULONG[, ULONG2[, 'MIME']])->BLOB2    #From byte ULONG to byte ULONG2 (def: end)
BLOB.text()->>STR                              $#
BLOB.arrayBuffer()->>ARRBUFFER                 $#
BLOB.stream()->RSTREAM                         $#

FileList                                        #FILE_ARR (array-like)
File                                            #BLOB child, with a name and timestamp
                                                #Obtained usually through INPUT|DATATRANSFER.files
new File(VAL, STR[, OPTS])                      #VAL is like new Blob()
                                                #STR is FILE.name
                                                #OPTS:
                                                #  - type 'MIME' (def: ''): like Blob
                                                #  - endings STR: like Blob
                                                #  - lastModified (def: Date.now()): like FILE.lastModified
FILE.name                                       #'FILE[.EXT]'
FILE.lastModified                               #NUM (ms since Epoch)

new FileReader()                                #
FILEREADER.readAsText(BLOB[, 'ENCODING'])       #Starts reading. FILEREADER.result will be STR
                                                #Def 'ENCODING': 'UTF-8'
FILEREADER.readAsArrayBuffer(BLOB)              #Same but result will be ARRBUFFER
FILEREADER.readAsDataURL(BLOB)                  #Same but result will be data URI
FILEREADER.result                               #VAL, or null (error or not read yet)
FILEREADER.readyState                           #Can be :
                                                #  - FileReader.EMPTY: before read
                                                #  - FileReader.LOADING : read in progress
                                                #  - FileReader.NONE : read complete|error|abort
FILEREADER.abort()                              #
FILEREADER.error                                #DOMERROR with name "NotFoundError|SecurityError|NotReadableError"

FILEREADER.onloadstart = FUNC(PROGRESSEVENT)    #
FILEREADER.onprogress = FUNC(PROGRESSEVENT)     #
FILEREADER.onload[end] = FUNC(PROGRESSEVENT)    #
FILEREADER.onabort = FUNC(PROGRESSEVENT)        #
FILEREADER.onerror = FUNC(PROGRESSEVENT)        #Cf XHR

FileReaderSync                                  #Same as as FileReader but:
                                                #  - sync: returns VAL instead of firing events, so only read*()
                                                #  - only available inside WORKER

URL.createObjectURL(BLOB)->'URL'                #Save BLOB with an object URL:
                                                #  - 'blob:DOMAIN/UUID'
                                                #  - BLOB data is stored in memory, until DOCUMENT ends (including page refresh)
                                                #  - unlike data URI, data is not in URL itself
                                                #  - can be accessed by other tabs
                                                #Can be used by other WINDOW.
URL.revokeObjectURL('URL')                      #Remove the data, i.e. object URL will not resolve


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          WEB STORAGE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW.localStorage                             #Persistent OBJ per domain.
                                                #Private browsing:
                                                #  - (Safari) has a max quota of 0 bytes, so setItem() will throw error
                                                #  - (other browsers) creates new STORAGE temp.
                                                #Cleaned when cleaning cookies.
WINDOW.sessionStorage                           #Same but cleaned when WINDOW is closed.

STORAGE.length                                  #
STORAGE.key(UINT)->'VAR'                        #
STORAGE.getItem('VAR')->'VAL'                   #
STORAGE.setItem('VAR', 'VAL')                   #Throws if above quota
STORAGE.removeItem('VAR')                       #
STORAGE.clear()                                 #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           INDEXEDDB           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


COMPARISON TO LOCAL STORAGE ==>                 #Like localStorage:
                                                #  - client-side key-value store
                                                #  - affected by private browsing and removing using user settings (data+schema)
                                                #Unlike localStorage:
                                                #  - more value types
                                                #  - async
                                                #     - browser can time out connections and requests
                                                #     - faster
                                                #  - more ACID
                                                #  - different persistence (see below)
ACID ==>                                        #Atomicity:
                                                #  - 1 operation === 1 transaction: auto-commit, auto-rollback
                                                #  - use locks (no MVCC):
                                                #     - database-wide lock for schema operations
                                                #     - table-wide lock for write operations
                                                #     - no lock for read operations
                                                #Consistency/durability:
                                                #  - notifies when buffered (but not flushed to disk). OS can safely crash afterwards
                                                #  - transaction can abort without triggering an event (e.g. when user closes browser)
about:indexeddb-internals                       #For debugging (Chrome only)


WINDOW|WORKERGLOBAL.indexedDB                   #IFACTORY

IDBDatabase                                     #Connection to a database
IFACTORY.open('DB'[, VERSION_NUM])->IOREQ(IDB)  #Creates it if not existing
                                                #Def VERSION_NUM: if existing, current one. Otherwise 1.
IFACTORY.deleteDatabase('DB')->IOREQ()          #
IDB.name                                        #'DB'
IDB.close()                                     #Let pending ITRANSACTION finish first, but do not start new ones
IDB.onabort = FUNC(EVENT)                       #Fired if any ITRANSACTION.onabort
IDB.onerror = FUNC(EVENT)                       #Fired if any ITRANSACTION.onerror

IDB.version                                     #VERSION_NUM (ULONGLONG), changed everytime schema changes.
                                                #Non-yet-existing IDB has version 0
                                                #When IFACTORY.open() use VERSION_NUM:
                                                #  - < IDB.version: IREQ will be 'VersionError'
                                                #  - > IDB.version:
                                                #     - requests IDB-wide lock:
                                                #        - new connections are queued
                                                #        - existing connections (e.g. other tabs) get IDB.onversionchange event, to allow them to close
                                                #     - if any could not close, IOREQ.onblocked is fired
                                                #     - otherwise, IOREQ.onupgradeneeded is fired, with IOREQ.mode 'versionchange' (i.e. can change schema)
                                                #When IFACTORY.deleteDatabase():
                                                #  - new VERSION_NUM is null, upgradeneeded is not fired
                                                #  - but otherwise is like upgradeneeded mechanism
IDB.onversionchange = FUNC(VCHANGEEVENT)       $#Not supported by IE. 'IndexedDBShim' (pretty big, consider twice)
IOREQ.onupgradeneeded = FUNC(VCHANGEEVENT)      #IOREQ.result null, but IOREQ.transaction available
IOREQ.onblocked = FUNC(VCHANGEEVENT)            #
VCHANGEEVENT.old|newVersion                     #VERSION_NUM


IVAL                                            #Any VAL supported by structured clone algorithm (see JavaScript doc)
                                                #If trying to IVAL with unsupported type, will use IREQ with 'DataCloneError'

KEY                                             #Can be:
                                                #  - STR|DATE|NUM
                                               $#  - STR|DATE|NUM_ARR, depending on multiEntry:
                                               $#     - false: whole array is key, including its order
                                               $#     - true: same for reads. For writes, flattened as several keys.
                                               $#    Not supported by IE. 'IndexedDBShim' (pretty big, consider twice)
                                                #Constraints:
                                                #  - unique:
                                                #     - enforces uniquess on KEY
                                                #     - if not unique, queries will retrieve first one only.
                                                #  - primary key always has unique true, multiEntry false
                                                #Primary vs secondary:
                                                #  - ISTORE only have one key, the primary one
                                                #  - IINDEX's primary key is ISTORE's secondary key
                                                #Default value possible if:
                                                #  - keyPath KEYPATH:
                                                #     - IVAL[KEYPATH], if exists (i.e. IVAL must be OBJ)
                                                #     - IVAL[KEYPATH] is still stored as part of IVAL
                                                #  - autoIncrement true: NUM++ (starts at 1). Can mix with non-NUM keys
KEYPATH                                         #'VARR' (targetting STR|DATE|NUM) or 'VARR'_ARR (targetting STR|DATE|NUM)
IFACTORY.cmp(KEY, KEY2)->-1|0|1                 #Using default IndexedDB key sorting
                                                #By default, values are stored in ISTORE by key in asc order

IDBKeyRange                                     #Sets of continuous KEY
IRANGE.lower|upper                              #KEY|undefined
IRANGE.lower|upperOpen                          #BOOL: whether lower|upper is excluded
IKeyRange.bound(KEY,KEY2[,BOOL][,BOOL2])->IRANGE#IRANGE with lower|upper KEY[2], lower|upperOpen BOOL[2] (def: false)
IKeyRange.lower|upperBound(KEY[, BOOL])->IRANGE #IRANGE with lower KEY, upper undefined, lowerOpen false, upperOpen true (or inverse)
IKeyRange.only(KEY)->IRANGE                     #IRANGE with lower|upper KEY, lower|upperOpen false


IDBObjectStore                                  #Store (table-like)
IDB.createObjectStore('STORE'[, OBJ])->ISTORE   #OBJ: keyPath, autoIncrement
IDB.deleteObjectStore('STORE')                  #
IDB.objectStoreNames                            #'STORE'_ARR (ARR-like, with also contains('STORE'))
ISTORE.name                                     #'STORE'
ISTORE.keyPath                                  #KEYPATH|null (see above) (read-only)
                                                #If specified wrong, will use IREQ with 'SyntaxError'
ISTORE.autoIncrement                            #BOOL (def: false) (see above) (read-only)
                                               $#Not supported by IE (but OBJ.autoIncrement is). 'IndexedDBShim' (pretty big, consider twice)
ISTORE.add(IVAL[, KEY])->IREQ(KEY)              #Create. If already exist, IREQ with 'ConstraintError'
ISTORE.put(IVAL[, KEY])->IREQ(KEY)              #Upsert
ISTORE.get(KEY|IRANGE)->IREQ(IVAL)              #Cannot tell if key exists or if value is just undefined (use ICUR instead for this).
ISTORE.count([KEY|IRANGE])->IREQ(NUM)           #
ISTORE.delete(KEY|IRANGE)->IREQ()               #
ISTORE.clear()->IREQ()                          #

IDBCursor                                       #Iterator
ISTORE|IINDEX.open[Key]Cursor                   #If 'Key', ICUR.value is not available.
 ([KEY|IRANGE[, DIRECTION]])->IREQ(ICUR)       $#ISTORE.openKeyCursor(): not supported by IE. 'IndexedDBShim' (pretty big, consider twice)
ICUR.source                                     #ISTORE|IINDEX
ICUR.direction                                  #'next' (def), 'prev' or (skips duplicates) 'next|prevunique'
ICUR.primaryKey|key                             #If source is IINDEX, primary key and secondary key
                                                #If source is ISTORE, primary key for both (since there are no secondary key)
ICUR.value                                      #Current IVAL
Boolean(ICUR)                                   #False if iteration ended
ICUR.advance(ULONG)                             #Moves cursor ULONG times.
                                                #Make original IREQ fire success event again (moves cursor only after that event)
ICUR.continue()                                 #Like ICUR.advance(1)
ICUR.continue(KEY)                              #Moves cursor until KEY reached. Fires exception if KEY already passed.
                                                #Make original IREQ fire success like ICUR.advance()
ICUR.update(IVAL)->IREQ(KEY)                    #Updates at current position
ICUR.delete()->IREQ()                           #Deletes at current position

IDBIndex                                        #Retrieves values from an ISTORE using a different KEYPATH2:
                                                #  - primary key: ISTORE.keyPath KEYPATH, pointing to ISTORE
                                                #  - secondary key: IINDEX.keyPath KEYPATH2, pointing to ISTORE as well
ISTORE.indexNames                               #'INDEX'_ARR (ARR-like, with also contains('INDEX'))
ISTORE.createIndex('INDX',KEYPATH[,OBJ])->IINDEX#OBJ: unique BOOL, multiEntry BOOL
ISTORE.index('INDEX')->IINDEX                   #
ISTORE.deleteIndex('INDEX')                     #
IINDEX.name                                     #'INDEX'
IINDEX.objectStore                              #ISTORE
IINDEX.keyPath                                  #KEYPATH2
IINDEX.unique                                   #BOOL (def: false) (see above)
IINDEX.multiEntry                               #BOOL (def: false) (see above)
                                               $#Not supported by IE (but OBJ.multiEntry is). 'IndexedDBShim' (pretty big, consider twice)
IINDEX.getKey(KEY|IRANGE)->IREQ(KEY)            #Primary key
IINDEX.get(KEY|IRANGE)->IREQ(IVAL)              #
IINDEX.count([KEY|IRANGE])->IREQ(NUM)           #


IDBTransaction                                  #Database transaction
                                                #Can timeout, in which case IREQ will be 'TimeoutError'
                                                #Once closed, any IREQ will be 'TransactionInactiveError'
IDB.transaction('STORE'[_ARR][,MODE])->ITRNSACTN#
ITRANSACTION.db                                 #IDB
ITRANSACTION.objectStore('STORE')->ISTORE       #
ISTORE.transaction                              #ITRANSACTION
ITRANSACTION.mode                               #MODE:
                                                #  - 'readonly' (def):
                                                #     - cannot modify anything, otherwise IREQ will be 'ReadOnlyError'
                                                #     - no lock
                                                #  - 'readwrite':
                                                #     - cannot modify schema (*.create|deleteObjectStore|Index())
                                                #     - ISTORE-wide lock
                                                #  - 'versionchange':
                                                #     - can do anything
                                                #     - IDB-wide lock
                                                #     - only available inside upgradeneeded event handler
ITRANSACTION.oncomplete = FUNC(EVENT)           #Fired on success, i.e. when transaction result is buffered (not flushed to disk)
ITRANSACTION.onerror = FUNC(EVENT)              #Fired if any IREQ.onerror
ITRANSACTION.error                              #ERROR|null
ITRANSACTION.abort()                            #Rollbacks changes
                                                #Future IREQ with fail with 'AbortError'
ITRANSACTION.onabort = FUNC(EVENT)              #On ITRANSACTION.abort()

IDBRequest                                      #Async operation (PROMISE-like)
IREQ.source                                     #Object having returned it, i.e. ISTORE|IINDEX|IICURSOR|null
IREQ.transaction                                #ITRANSACTION|null
IREQ.readyState                                 #Can be 'pending', or 'done' (success|error)
IREQ.onsuccess = FUNC(EVENT)                    #
IREQ.result                                     #If success. VAL
IREQ.onerror = FUNC(EVENT)                      #Default browser action (cancelable): calls IREQ.transaction.abort()
IREQ.error                                      #If error. ERROR:
                                                #  - 'NoError': if success
                                                #  - 'NotFoundError': did not find name
                                                #  - 'ConstraintError': e.g. name already exist, unique constraints
                                                #  - 'DataError': wrong argument type
                                                #  - 'InvalidAccessError': wrong argument value
                                                #  - 'InvalidStateError': function cannot be called yet|anymore
                                                #  - 'QuotaExceededError': no more spaces
                                                #  - 'UnknownError': e.g. IO error
                                                #  - '*Error': see above
IDBOpenDBRequest                                #Child of IRequest with upgradeneeded and blocked events (see above)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        STORAGE SUMMARY        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DIFFERENT STORAGE ==>                           #All storage : can be erased through private data erasing GUI for normal
                                                #websites/hosted apps, but not for extensions/packaged apps.

                            +------------------+----------------------------------------------------------+--------------------+--------------------------------+
                            | Avail.           | Limit                                                    | Model              | Other                          |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+
  | cookies                 | All              | 4KB/cookie, 50/domain                                    | Flat. As STR.      | Communicated to server         |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+
  | localStorage            | All              | 2-10MB/domain                                            | Flat. As STR.      | Not async.                     |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+
  | XHR                     | All              | None                                                     | None               | Slower. Persisted on server.   |
  |                         |                  |                                                          |                    | Requires network.              |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+
  | chrome.storage          | Chrome apps/exts | Unlim (permissions)                                      | Flat. As OBJ.      | Can be used by content scripts |
  |                         |                  |                                                          |                    | Can Cloud sync.                |
  |                         |                  |                                                          |                    | Storage event.                 |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+
  | indexedDB               | All              | 33-50% of disk space for all domains (browser-dependant) | Database           |                                |
  |                         |                  | 33-50% * 20% (i.e. 6.6-10%) for each domain              |                    |                                |
  |                         |                  | LRU removal if no space                                  |                    |                                |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+
  | chrome.downloads        | Chrome exts      | Unlim (only download)                                    | Real filesystem    | Filechooser popup or not       |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+
  | chrome.[sync]filesystem | Chrome apps      | Unlim (permissions)                                      | Real filesystem    | Use fileSystem API.            |
  |                         |                  |                                                          |                    | Can sync with Google Drive.    |
  +-------------------------+------------------+----------------------------------------------------------+--------------------+--------------------------------+

DEBUGGING ==>                                   #about:quota-internals (Chrome)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           ENCODING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ENCODING                                       $#Can be:
                                               $#  - 'utf-8', 'utf-16be', 'utf-16le'
                                               $#  - 'iso-8859-2|3|4|5|6|7|8|8-I|10|13|14|15|16'
                                               $#  - 'ibm866'
                                               $#  - 'koi8-r|u', 'gbk', 'gb18030', 'big5', 'euc-jp|kr', 'iso-2022-jp', 'shift_jis'
                                               $#  - 'macintosh', 'x-mac-cyrillic'
                                               $#  - 'windows-874|1250|1251|1252|1253|1254|1255|1256|1257|1258'
                                               $#  - 'replacement'
                                               $#  - 'x-*'
                                               $#There are also many possible aliases (see online doc).
                                               $#Polyfill: 'text-encoding' (0.6.4)

new TextDecoder(['ENCODING'[, OPTS]])          $#From ENCODING to UTF8
                                               $#OPTS: fatal BOOL, ignoreBOM BOOL
TEXTDECODER.encoding                           $#'ENCODING' (def: 'utf-8')
TEXTDECODER.fatal                              $#BOOL (def: false). Throws if decoding error
TEXTDECODER.ignoreBOM                          $#BOOL (def: false). Includes BOM instead of using it.
TEXTDECODER.decode                             $#OPTS:
 ([ARRBUFFER|DATAVIEW|TYPED_ARR[, OPTS]])->STR $#  - stream BOOL (def: false):
                                               $#     - buffers incomplete byte sequences at end of input, and reuse them in next call
                                               $#     - last call should pass `undefined` as first argument to return any buffered value

new TextEncoder()                              $#Get UTF8 bytes (instead of chars)
TEXTENCODER.encoding                           $#Always 'utf-8'
TEXTENCODER.encode([STR])->UINT8_ARR           $#
TEXTENCODER.encodeInto(STR, UINT8_ARR)->OBJ    $#Same but directly mutates UINT8_ARR, for performance.
                                               $#UINT8_ARR.length should be >= STR.length * 3 since:
                                               $#  - UTF-8 characters can be up to 4 bytes long
                                               $#  - astral characters are represented as 2 characters with UTF-16 (STR.length)
                                               $#OBJ:
                                               $#  - read NUM: number of bytes read from STR. Same as STR.length unless UINT8_ARR is too small
                                               $#  - written NUM: number of bytes written in UINT8_ARR

new TextDecoderStream(['ENCODING'[, OPTS]])    $#Like TextDecoder|TextEncoder but as a TSTREAM
new TextEncoderStream()                        $#No decode|encode[Into]() method (should use TSTREAM.readable|writable instead)

WINDOW|WORKERGLOBAL.btoa|atob(STR)              #Convert to|from Base64
                                                #Unicode (non-ASCII) chars in STR must be escaped first with encode|decodeURIComponent()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          COMPRESSION          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new CompressionStream(STR)
new DecompressionStream(STR)             18.0.0$#TSTREAM for [de]compressing. STR is 'deflate|gzip'



                     
   MESSAGING/WORKERS  
                     



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           MESSAGING           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SUMMARY ==>                                     #Comparison:
                                                #  - onstorage: any tab, same domain. Transfer STR. Broadcasts.
                                                #  - postMessage(): same tab, any domain. Transfer much more types. Broadcasts.
                                                #    Works with WORKER
                                                #  - MessageChannel: like postMessage() but does not broadcast, and buffers.

WINDOW.onstorage = FUNC(STORAGEEVENT)           #Triggered when another WINDOW2 modified localStorage|sessionStorage:
                                                #  - WINDOW2: an IFRAME|popup|parent on same tab or another tab.
                                                #    Has to be same domain.
                                                #  - Only triggered if value changed.
STORAGEEVENT.key                                #'VAR'
STORAGEEVENT.new|oldValue                       #'VAL'
STORAGEEVENT.storageArea                        #STORAGE
STORAGEEVENT.url                                #WINDOW2.URL

WINDOW2.postMessage                             #WINDOW2 protocol+host must match second argument:
(VAL, 'PROTOCOL://HOST|*'[, VAL2_ARR])          #  - WINDOW2: an IFRAME|WORKERS|popup|parent on same tab.
                                                #    Does not have to be same domain.
                                                #Uses structuredClone(VAL, { transfer: VAL2_ARR })
WINDOW2.onmessage = FUNC(MESSAGEEVENT)          #
MESSAGEEVENT.data                               #VAL
MESSAGEEVENT.origin                             #PROTOCOL://HOST|*
                                                #Should be checked to prevent XSS and CSRF
MESSAGEEVENT.source                             #WINDOW having called postMessage()
MESSAGEEVENT.ports                              #MESSAGEPORT_ARR

structuredClone(VAL[, OPTS])->VAL               #Use structured clone algorithm (see JavaScript doc)
                                                #OPTS:
                                                #  - transfer VAL2_ARR:
                                                #     - transfer memory without copying
                                                #     - original VAL becomes non-accessible
                                                #     - can be:
                                                #        - ARRBUFFER[VIEW]
                                                #        - MESSAGEPORT: will be available in MESSAGEEVENT.ports

WORKER|DWORKERGLOBAL.postMessage(VAL[,VAL2_ARR])#
WORKER|DWORKERGLOBAL.onmessage = FUNC(MESGEVENT)#Like WINDOW.postMessage() but between WORKER and its parent
WORKER|DWORKERGLOBL|MESSAGEPORT.onmessageerror
 = FUNC(ERROR)                                  #When postMessage() was called with a non-serializable value

new MessageChannel()                            #Like WINDOW.postMessage() but:
                                                #  - using dedicated channel instead of broadcasting to any listener on a given domain.
                                                #  - messages are buffered until listener setup
MESSAGECHANNEL.port1|2                          #MESSAGEPORT
MESSAGEPORT.postMessage(VAL[, VAL2_ARR])        #Sent to the other MESSAGEPORT message event handler
                                                #See WINDOW.postMessage()
MESSAGEPORT.onmessage = FUNC(MESSAGEEVENT)      #
MESSAGEPORT.onmessageerror = FUNC(ERROR)        #
MESSAGEPORT.start|close()                       #Starts|stops message event handler
                                                #Cannot be restarted after closed.
                                                #MESSAGEPORT.start() is automatically called when assigning MESSAGEPORT.onmessage
                                                #(but not when calling MESSAGEPORT.addEventListener('message'))

new BroadcastChannel('CHANNEL_NAME')            #One-to-many message passing from child|parent to child|parent
BROADCAST_CHANNEL.name                          #'CHANNEL_NAME'
BROADCAST_CHANNEL.postMessage(VAL)
BROADCAST_CHANNEL.on('message[error]', FUNC)
BROADCAST_CHANNEL.close()                       #Like MESSAGEPORT.*


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            WORKERS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ABSTRACTWORKER                                  #Base class for WORKER
Worker                                          #Child of ABSTRACTWORKER. Thread
WorkerGlobalScope                               #WORKERGLOBAL: global scope in a script launched as a WORKER or SHAREDWORKER
                                                #Can use Web APIs, limited BOM (see below) but not DOM
DedicatedWorkerGlobalScope                      #DWORKERGLOBAL, child of WORKERGLOBAL, for WORKER


new Worker('SCRIPT_URL'[, OPTS])                #Same origin policy
                                                #Script starts to load right away (in a separate thread), and starts execution after loading.
                                                #OPTS:
                                                #  - type 'classic' (def, script) or 'module' (ESM)
                                                #  - name STR: DWORKERGLOBAL.name, mostly used for debugging
                                                #  - credentials:
                                                #     - like REQ.credentials
                                                #     - always 'omit' with type 'classic'
                                                #     - def: 'same-origin' otherwise
                                                #  - with OBJ: like `import ... with { ... }`
WORKERGLOBAL.importScripts('SCRIPT_URL'...)     #Load other scripts

WORKER.terminate()                              #Worker will not finish current microtask
DWORKERGLOBAL.close()                           #Worker will finish current microtask

WORKERGLOBAL|WINDOW.self                        #Global object (i.e. WORKERGLOBAL|WINDOW) similar to Node.js 'global'
WORKERGLOBAL.navigator                          #WORKERNAVIGATOR
WORKERGLOBAL.location                           #WORKERLOCATION


[WORKER]NAVIGATOR.hardwareConcurrency          $#NUM of cores, i.e. number of workers that should be run at once.
                                               $#'core-estimator' (version from 2016-05-31):
                                               $#  - must run [WORKER]NAVIGATOR.getHardwareConcurrency(FUNC(NUM)) first



                 
   UI COMPONENTS  
                 



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             POPUP             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WINDOW.open('URL', 'NAME'[,'FEAT=VAL,...'])     #Opens new tab, providing user removed popup blocker.
->WINDOW2                                       #'URL':
                                                #  - if '', blank page
                                                #  - while page is loading, WINDOW2 will be blank page.
                                                #NAME:
                                                #  - is WINDOW2.name
                                                #  - if existing, replace content of that one
                                                #FEAT:
                                                #  - dialog|modal yes|no (def: no): popup instead of new tab
WINDOW2.opener                                  #WINDOW|null: if WINDOW.open()
WINDOW2.close()                                 #Close WINDOW2 opened with WINDOW.open()
WINDOW2.closed                                  #BOOL

WINDOW2.moveBy|To(NUM, NUM2)                    #Move WINDOW2 opened with WINDOW.open() (relative|absolute to screen)
WINDOW2.resizeBy|To(NUM, NUM2)                  #Same for size


WINDOW.alert([STR])                             #Opens popup with OK button. Def STR: ''
WINDOW.confirm([STR])->BOOL                     #Same with OK and Cancel buttons. Return true if OK.
WINDOW.prompt([STR[, 'PLACEHOLDER']])->STR2|null#Same but asks for user input.

WINDOW.print()                                  #Opens print dialog



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           DRAG&DROP           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MOBILE SUPPORT ==>                              #Drag&drop is not available on mobile

<any>
  draggable="true|false|"                       #Changes possibility to drag (user interaction + events):
                                                #  - "true" (def on links, images, selection)
                                                #  - "false"
                                                #  - "" (def otherwise): inherit

DragEvent                                       #MOUSEEVENT child
                                                #During a drag, keyboard and other mouse events are neutralized.
                                                #Drag and drop sources can also come from other applications.
DRAGEVENT.dataTransfer                          #DATATRANSFER

ELEM|DOCUMENT.ondragstart = FUNC(DRAGEVENT)     #When source starts being dragged
                                                #Should do DATATRANSFER.setData()
                                                #Can set DATATRANSFER.effectAllowed
ELEM|DOCUMENT.ondragend = FUNC(DRAGEVENT)       #When source stops being dragged (success or not)
                                                #Can check if operation was successful with DATATRANSFER.dropEffect
ELEM|DOCUMENT.ondrag = FUNC(DRAGEVENT)          #When source moves

ELEM|DOCUMENT.ondragenter|leave = FUNC(DRAGEVNT)#When target starts|ends being hovered
                                                #Should call DRAGEVENT.stopPropagation() + preventDefault()
ELEM|DOCUMENT.ondragover = FUNC(DRAGEVENT)      #When target is being hovered and source moves
                                                #Should call DRAGEVENT.stopPropagation() + preventDefault()
ELEM|DOCUMENT.ondrop = FUNC(DRAGEVENT)          #When target is being dropped on
                                                #Should do DATATRANSFER.getData()
                                                #Possible browser default action is to open file, so probably want to:
                                                #  - DRAGEVENT.stopPropagation() + preventDefault()

DATATRANSFER.setData('MIME', 'VAL')             #To do during dragstart.
                                                #Can set several types:
                                                #  - the most specific should be preferred on getData()
                                                #  - should include 'text/plain' as a fallback
                                                #Usual 'MIME':
                                                #  - "text/plain":
                                                #     - default for links and selection
                                                #  - "text/uri-list":
                                                #     - default for images
                                                #     - URLs, newline-separated.
                                                #     - can have comments starting with #
                                                #     - will also define "URL" MIME with only the first URL
                                                #  - "text/html"
                                                #  - "Files": FILELIST
DATATRANSFER.getData('MIME')->'VAL'             #
DATATRANSFER.clearData(['MIME'])                #
DATATRANSFER.types                              #'MIME'_ARR
DATATRANSFER.files                              #Same as DATATRANSFER.getData('Files')

DATATRANSFER.effectAllowed                      #To do during dragstart.
                                                #Restrict possible dropEffect:
                                                #  - 'copy|move|link|none'
                                                #  - 'copyLink|copyMove|linkMove|all': combination
                                                #  - 'uninitialized': like 'all'
                                                #If unallowed, drop will not be performed.
DATATRANSFER.dropEffect                         #Can be read on dragend (not drop)
                                                #Can be set on dragover|dragenter, but also default are chosen according to modifier:
                                                #  - 'copy' (def with shift)
                                                #  - 'move' (def with no modifier key)
                                                #  - 'link' (def with shift+ctrl)
                                                #  - 'none'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              RTF              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOCUMENT.designMode                             #If 'on' (def: 'off'), disable events and allow execCommand()
DOCUMENT.execCommand                            #Fire RTF (MIDAS) COMMAND on current selection
('COMMAND'[, false, 'ARG'])->BOOL               #Returns false if failed.
                                                #Available COMMAND ARG:
                                                #  - back|forecolor "#ffffff"
                                                #  - hilitecolor "#ffffff": only if styleWithCSS
                                                #  - bold|italic|strikethrough|underline
                                                #  - copy|cut|paste
                                                #  - createlink "URL" | unlink
                                                #  - de|increasefontsize
                                                #  - delete
                                                #  - fontname "FONT"
                                                #  - fontsize "NUM"
                                                #  - heading "H*"
                                                #  - out|indent
                                                #  - inserthorizontalrule : replace by <hr>
                                                #  - inserthtml STR : replace by HTMLDOCUMENT code STR
                                                #  - insertimage STR
                                                #  - insert[un]ordererdlist
                                                #  - insertparagraph
                                                #  - justifycenter|full|left|right
                                                #  - undo|redo
                                                #  - removeformat
                                                #  - selectall
                                                #  - sub|superscript
                                                #  - styleWithCSS : change format with CSS, not HTMLDOCUMENT
                                                #  - contentReadOnly : all document becomes readonly
                                                #Browsers implement differently: use tags (e.g. <b>) or CSS (e.g. <... style="...">)
DOCUMENT.queryCommandSupported('COMMAND')->BOOL #Browser can do it
DOCUMENT.queryCommandEnabled('COMMAND')->BOOL   #Browser allows to do it
DOCUMENT.queryCommandIndeterm('COMMAND')->BOOL  #Current selection: if style partially applied to children
DOCUMENT.queryCommandState('COMMAND')->BOOL     #Current selection: If style applied or not
DOCUMENT.queryCommandValue('COMMAND')->'ARG'    #Current selection


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         NOT SUPPORTED         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


POLYFILLS ==>                                   #
UPDATING ==>                                    #
STAGES ==>                                      #
UNSUPPORTED BROWSERS ==>                        #
PARTIAL SUPPORT ==>                             #See HTML doc

FULLY SUPPORTED ==>                             #
                                                #DOM Requirements (G)
                                                #Element Traversal Specification (R)
                                                #Geolocation API (R)
                                                #High resolution Time (R)
                                                #HTML5 Web Messaging (R)
                                                #JavaScript, a.k.a. Web ECMAScript (WHATWG) (difference between JavaScript in browsers and ES6 spec, for the moment none)
                                                #Navigation Timing (R)
                                                #Page Visibility (Second Edition) (R)
                                                #Page Visibility Level 2 (R)
                                                #Progress Events (R)
                                                #WebIDL Level 1 (R)
                                                #Web IDL (Second Edition) (E)
                                                #WebSocket API (R)
                                                #Web Storage (Second Edition) (R)
                                                #XMLHttpRequest Level 1 (W)

FULLY|PARTIALLY UNSUPPORTED ==>                 #Follows, by category.


DOM ==>                                     IE11#Custom Elements (W) (register a <tag> with lifecycle events)
                                                #  - including <any>: is, CUSTOMELEMENTSREGISTRY, WINDOW: customElements
                                                #DOM Level 3 (R):
                                            IE11#  - COMMENT: new
                                           $IE11#  - CUSTOMEVENT
                                            IE11#  - DOCUMENT: documentURI
                                           $IE11#  - EVENT: new
                                            IE11#  - NODE: baseURI
                                                #DOM Level 4 (R):
                                            IE11#  - CHARDATA: previous|nextElementSibling
                                           $IE11#  - DOCTYPE|ELEM|CHARDATA: remove()
                                            IE11#  - DOCUMENT: new, origin, contentType
                                            IE11#  - DOCUMENTFRAG: new, getElementById()
                                            IE11#  - DOCUMENT[FRAGMENT]: children
                                           $IE11#  - DOMTOKENLIST: toggle() second arg, add|remove() multiple args
                                            IE11#  - DOMTOKENLIST: iterable
                                            IE11#  - ELEM (instead of HTMLELEM): classList, className, id, getElementsByClassName(), children
                                           $IE11#  - NODE (instead of HTMLELEM): contains()
                                            IE11#  - NODE (instead of HTMLELEM): parentElement
                                            IE11#  - NODEITERATOR: [pointerBefore]referenceNode
                                            IE11#  - NODELIST: iterable
                                            IE11#  - RANGE: new, comparePoint(), intersectsNode(), isPointInRange()
                                            IE11#  - TEXT: new
                                                #DOM (WHATWG):
                                           $IE11#  - DOCTYPE|ELEM|CHARDATA: before|after(STR|NODE...), replaceWith(STR|NODE...)
                                            IE11#  - DOCUMENT: createElement() second argument OBJ
                                           $IE11#  - DOCUMENT[FRAGMENT]|ELEM: append|prepend(NODE|STR...)
                                            IE11#  - DOMTOKENLIST: replace(STR, STR), supports(STR)->BOOL, value
                                           $IE11#  - ELEM: closest()
                                            IE11#  - ELEM: getAttributeNames()
                                           $IE11#  - EVENTTARGET: add|removeEventListener(..., OBJ) (instead of BOOL)
                                            IE11#  - NODE: isConnected
                                                #DOM Parsing and Serialization (W):
                                            IE11#  - ELEM (instead of HTMLELEM): innerHTML, outerHTML, insertAdjacentHTML()
                                            IE11#FindText API (W) (search for text inside DOM)
                                            IE11#Shadow DOM (W) (DOM inside another DOM)
                                                #  - including NODE: getRootNode(), <slot>, <any>: slot

WORKERS ==>                                 IE11#Service Workers (W) (workers shared-loaded across a domain/directory or reacting to events in the browser's background. Can intercept HTTP requests.)
                                                #  - including about:inspect#service-workers, about:serviceworkers-internals (Chrome only), about:serviceworkers (Firefox)
                                                #Web Workers (W):
                                            IE11#  - Shared Workers (worker that can be shared/accessed across tabs|iframes)
                                                #     - including about:inspect#workers (Chrome only)

NETWORK REQUESTS ==>                       $IE11#Beacon (R) (XHR guarenteed to be sent even if tab closes)
                                           $IE11#Fetch (WHATWG 2017-12-20)
                                            IE11#Network Error Logging (G) (NEL [C] header that tells browser [where|how] to report HTTP network problems)
                                            IE11#Reporting API (W) (generalization of CSP reporting fields, for other APIs)
                                           $IE11#URL (API part) (WHATWG)
                                            IE11#Webmention (R) (get HTTP requests when another website links to current site)
                                            IE11#XMLHttpRequest (WHATWG) (XHR.responseURL (request URL after redirects), more methods on FORMDATA)

REALTIME ==>                                IE11#Notifications API (WHATWG) (notifications outside browser)
                                            IE11#Web Notifications (R)
                                                #  - developers.google.com/web/fundamentals/primers/push-notifications
                                                #  - developers.google.com/web/fundamentals/engage-and-retain/push-notifications
                                                #  - developers.google.com/web/fundamentals/getting-started/push-notifications/
                                            IE11#Push API (W) (server unidirectional push, using a capability URL and targetting a service worker)
                                                #  - RFC 8030
                                           $IE11#Server-Sent Events (R)

FILES ==>                                       #File API (W):
                                             F52#  - BLOB: close()
                                            IE11#  - BLOB: isClosed
                                            IE11#  - FILE: new
                                            IE11#  - URL: createFor()
                                           $IE11#Indexed Database API (R) (few different behavior)
                                            IE11#Indexed Database API 2.0 (R)
                                            IE11#Storage (WHATWG) (persistent storage and size quota for localStorage and indexedDB)
                                            IE11#Streams API (WHATWG) (like Node.js streams)
                                           $IE11#Encoding API (WHATWG) (R) (like iconv)

MOBILE ==>                                  IE11#Client Hints (W) (RTF draft-ietf-httpbis-client-hints) (client HTTP headers indicating screen size/ratio, network speed, etc.)
                                          SM10.2#Web App Manifest (W) (progressive web apps)

SENSORS ==>                               SM10.2#Ambient Light Sensor (R) (luminosity sensor)
                                          SM10.2#Accelerometer Sensor (R)
                                          SM10.2#Battery Status API (R) (battery level)
                                                #DeviceOrientation Event (R):
                                          SM10.2#  - WINDOW: oncompassneedscalibration = FUNC(EVENT), ondeviceorientationabsolute = FUNC(EVENT)
                                          SM10.2#Generic Sensor API (R) (generic API for sensors)
                                          SM10.2#Gyroscope Sensor (R)
                                          SM10.2#Magnetometer Sensor (R) (used for orientation)
                                          SM10.2#Orientation Sensor (R)
                                          SM10.2#Proximity Sensor (W) (on close the device is from user)
                                           $IE11#Screen Orientation API (W) (reading|setting portrait|landscape mode)
                                          SM10.2#Vibration API (R) (vibrate device)
                                          SM10.2#Wake Lock API (R) (prevent mobile screen lock)
                                          SM10.2#Wake Lock: Use cases (G)

INPUT ==>                                   IE11#Gamepad (W) (gamepads|controllers input)
                                            IE11#Input Events (W) (beforeinput event, input event selection ranges)
                                           S10.0#Pointer Events (R) (higher-level events for mouse|touch|pen.
                                                #                    Also: pen|stylus events (surface area, pressure, title), screen touch detection, preventing scrolling|zooming)
                                           S10.0#Pointer Events Level 2 (R)
                                            IE11#Pointer Lock (R) (FPS-like mouse capture, i.e. no icon, can go beyond document boundaries, gets movements deltas not absolute position)
                                            IE11#Pointer Lock 2.0 (W) (Adds shadow DOM support to Pointer Lock
                                                #Touch Events (R):
                                            IE11#  - DOCUMENT: createTouch[List]()
                                            IE11#Touch Events API level 2 (E) (touch pressure|rotation|radius)
                                                #UI Events Specification (W):
                                          SM10.2#  - KEYBOARDEVENT|MOUSEEVENT: getModifierState(), constructor OBJ: modifierAltGraph|CapsLock|etc.
                                           S10.0#  - KEYBOARDEVENT: repeat
                                            IE11#  - KEYBOARDEVENT: isComposing
                                          $S10.0#  - MOUSEEVENT: buttons
                                         $SM10.2#UI Events KeyboardEvent code Values (R), KEYBOARDEVENT: code
                                         $SM10.2#UI Events KeyboardEvent key Values (R), KEYBOARDEVENT: key

BROWSER UI ==>                              IE11#Clipboard API and events (W)
                                            IE11#Custom Scroll Restoration (E) (how scrolling is restablished with history back|forward)
                                                #  - including HISTORY: scrollRestoration
                                         $SM10.2#Fullscreen API (WHATWG)
                                                #Selection API (W):
                                            IE11#  - SELECTION: type, empty(), setPosition(), extend(), setBaseAndExtent(), containsNode()
                                            IE11#  - INPUT|TEXTAREA: onselectionchange = FUNC(EVENT)

DEBUGGING ==>                                   #Console (WHATWG):
                                           $IE11#  - CONSOLE: table(), timeStamp(), info|log|warn|error() (%o, %c, %O), trace() first arg, timeLog()
                                             C57#  - CONSOLE: assert() (format strings)

PERFORMANCE ==>                             IE11#Cooperative Scheduling of Background Tasks (R) (low priority threads)
                                          $S10.0#Efficient Script Yielding (E) (setImmediate())
                                            IE11#High Resolution Time Level 2 (R) (WORKERGLOBALSCOPE.performance)
                                            IE11#High Resolution Time Level 3 (W) (takes system skew into account)
                                            IE11#Long Tasks API 1 (W) (long tasks stats)
                                             F52#Navigation Timing API level 2 (W)
                                            IE11#Network Information API (E) (network type and speed)
                                            IE11#Paint Timing 1 (W) (paint timing stats)
                                          $S10.0#Performance Timeline (R) (higher-level API on other timing APIs)
                                          $S10.0#Performance Timeline Level 2 (R) (add PerformanceObserver)
                                           S10.0#Resource Timing Level 1 (R) (network timing stats when loading resources)
                                           S10.0#Resource Timing Level 2 (W) (adds: works in workers, ALPN, network request size info)
                                          $S10.0#User Timing (R) (custom timing stats)
                                           S10.0#User Timing Level 2 (W) (adds support in workers)

SECURITY ==>                                IE11#Credential management API (W) (easier and standardized login flows)
                                            IE11#Secure Contexts (W) (check if file|https://. Used by other APIs)
                                            IE11#Web Authentication: A Web API for accessing scoped credentials (W)
                                            IE11#Web Cryptography API (R) (crypto: symmetric, asymmetric, hashes, PRNG)

PRIVACY ==>                                     #DNT (R):
                                            IE11#  - NAVIGATOR: doNotTrack (instead of WINDOW.doNotTrack)
                                             C57#  - NAVIGATOR: store|remove|confirmSiteSpecific|WebSideTrackingException()
                                            IE11#Frame Timing (G) (frame refresh rate timing stats)
                                           $IE11#Referrer policy (W) (control over Referred [C])

EXTERNAL DEVICES ==>                        IE11#Network Service Discovery (W) (DNS-SD using NAVIGATOR.getNetworkServices())
                                            IE11#Presentation API (R) (connecting to external display, e.g. TV or Chromecast)
                                            IE11#Remote Playback API (W) (manipulating external display, e.g. TV or Chromecast)
