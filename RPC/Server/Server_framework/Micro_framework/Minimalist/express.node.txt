
           
   EXPRESS  
           



VERSION ==>                       #Node module (4.19.2)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MAIN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPRESS()->APP                    #APP is HTTP[S]SERVER 'request' event handler
APP.listen(...)                   #Same as HTTP.createServer(APP).listen(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONFIG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.get('CONFVAR')->VAL           #
APP.set('CONFVAR', VAL)->APP      #
APP.enabled|disabled('CONFVAR')
 ->BOOL
APP.enable|disable('CONFVAR')
 ->APP                            #Same but using true|false

CONF.x-powered-by                 #Adds X-Powered-By: Express [S] (def: true)

CONF.env                          #Defines whether it is run in 'development', 'test' or 'production'
                                  #Some MIDWR behaves accordingly
                                  #Def: ENVVAR NODE_ENV, or 'development'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          MIDDLEWARE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONNECT()->APP                    #Returns APP like EXPRESS but only with APP.use|listen() and limited functionalities
                                  #(e.g. no globbing, PARAM, CONF, etc.)
                                  #Version 3.4.1

ORDER ==>                         #Should do in order:
                                  #  - APP.set()
                                  #  - MIDWRs (logging first)
                                  #  - APP.METHOD()
                                  #  - ERROR_MIDWRs
                                  #  - APP.listen()

APP.use                           #MIDWR are middleware functions, i.e. meant to modify incoming|outcoming REQ|RES
 (MIDWR(REQ, RES, NEXT([ERROR]))  #NEXT() proceeds to the next registered MIDWR
 [_ARR],...)->APP                 #One MIDWR should not call NEXT(), i.e. be endpoint:
                                  #  - usually delivers the content to the client
                                  #  - can be different from request to request
                                  #     - e.g. static MIDWR calls NEXT() if find file, serve file otherwise
                                  #If every MIDWR calls NEXT()
                                  #  - send 404 with body "Cannot METHOD PATH"
                                  #  - to redefine it, use a last MIDWR with no 'PATH' (but not an ERROR_MIDWR)

APP.use(MIDWR(ERROR, ...),...)    #ERROR_MIDWR, called if previous MIDWR calls NEXT(ERROR) or throws ERROR
 ->APP                            #Def: send 500 status code with response ERROR

APP.use('ROUTE_PATH'[_ARR], ...)  #Only applies to requests to 'ROUTE_PATH[/...]' (def: '/'):
 ->APP                            #Excluding query string or hash
                                  #Can use globbing: ? + ( ) *
ROUTER_OPTS.caseSensitive
CONF."case sensitive routing"     #BOOL (def: false). Case-sensitiveness of 'ROUTE_PATH'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           MOUNTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.use(['ROUTE_PATH', ]APP2)     #Use APP2 for requests to 'ROUTE_PATH[/...]'
 ->APP                            #Goal: sub-apps
                                  #Common pattern is to export APP, and only use APP.listen() if (!module.parent)

APP2.on('mount', FUNC(APP))       #
APP2.mounthpath                   #Parent 'ROUTE_PATH' (def: '/')
APP2.path()->'PATH'               #Ancestor 'ROUTE_PATH' (def: '')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ROUTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.METHOD('ROUTE_PATH', ...)     #Like APP.use('ROUTE_PATH', ...) except only when using HTTP METHOD
 ->APP                            #  - can be 'all'
                                  #  - 'get' also catches 'head'
                                  #     - unless APP.head() defined
                                  #  - 'options' sends back 200 with Allow: METHOD,... [C] for each defined METHOD
                                  #     - unless APP.options() defined
                                  #Cannot define ERROR_MIDWR nor sub-app
                                  #'ROUTE_PATH':
                                  #  - must be exact match
                                  #  - can be REGEXP (partial match)
ROUTER_OPTS.strict
CONF."strict routing"             #BOOL (def: false). Make APP.METHOD('ROUTE_PATH', ...) match 'ROUTE_PATH[/]'
NEXT('route')                     #Inside APP.METHOD(), skip other APP.METHOD() or MIDWRs with same METHOD + 'ROUTE_PATH'

APP.route('ROUTE_PATH')->ROUTE    #Same as APP.METHOD('ROUTE_PATH', ...)
ROUTE.METHOD(...)->ROUTE          #Meant for re-usability

EXPRESS.Router([ROUTER_OPTS])
 ->ROUTER                         #ROUTER is a MIDWR meant for routing
ROUTER.use|METHOD|route|param(...)#Like APP.*(...)
NEXT('router')                    #In a ROUTER, skip the rest of that ROUTER


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PARAMETERS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


:PARAM                            #Can be used in 'ROUTE_PATH'
                                  #Matched against request URL
                                  #Name must be [:alnum:]_
:PARAM?                           #Optional

REQ.params.PARAM                  #VAL
REQ.params[NUM]                   #VAL when ROUTE_PATH is REGEXP

APP.param('PARAM'[_ARR],
 MIDWR(..., PARAM_VAL, 'PARAM'))
 ->APP                            #MIDWR that is called for ROUTE_PATHs that use :PARAM

ROUTER_OPTS.mergeParams           #BOOL (def: false). Inherits parent ROUTER PARAMs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              REQ              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ                               #Like Node.js but additional members
REQ.app                           #APP

REQ.originalUrl                   #Absolute URL
REQ.baseUrl                       #'ROUTE_PATH' from all APP.use('ROUTE_PATH',...) (MIDWR, routing or sub-app)
REQ.url                           #URL relative to REQ.baseUrl
REQ.path                          #REQ.url without '?SEARCH' nor '#HASH'
REQ.route.methods.METHOD          #BOOL
REQ.protocol                      #'http[s]'
REQ.secure                        #BOOL. Whether 'https'
REQ.hostname                      #STR
REQ.subdomains                    #STR_ARR. REQ.hostname.split('.').reverse()
                                  #Also, ARR.slice(CONF.'subdomain offset') (def: 2)

REQ.ip                            #'ADDR'. Client IP
REQ.ips                           #'ADDR'_ARR. Client + reverse proxies (closest to server last)

CONF."trust proxy fn"             #FUNC('ADDR', NUM)->BOOL or 'ADDR2'[_ARR] passed to PROXY-ADDR (see its doc)
                                  #Use X-Forwarded-Host|For|Proto [C] for REQ.protocol|hostname|ip
                                  #I.e. ignore reverse proxies
                                  #Required to use REQ.ips
                                  #Def: nothing is trusted, i.e. only uses last proxy
CONF."trust proxy"                #Same but can also be:
                                  #  - true: same as FUNC()->true
                                  #  - NUM: same as FUNC(VAL, NUM2)->NUM2 < NUM

REQ.query                         #GET variables as OBJ
CONF."query parser"               #Whether to use QS ('complex', def) or node:querystring  ('simple')

REQ.get('HEADER_VAR')->'VAL'      #Case insensitive

REQ.range(NUM[, OPTS])->VAL       #Parses Range [C] using RANGE-PARSER (see its doc)
REQ.xhr                           #BOOL. X-Requested-With [C] === 'XMLHttpRequest' (case-insensitive)
REQ.accepts
 [Charsets|Languages|Encodings]   #Parses Accept[-Charset|Language|Encoding] [C] using ACCEPTS (see its doc)
 ([STR2[_ARR],...])->STR[_ARR]    #If undefined: should respond with error code 406 "Not Acceptable"
REQ.is('MIME'[_ARR]...)->BOOL     #Check against Content-Type [C]
                                  #MIME can contain TYPE/*, EXT, etc.
                                  #Uses TYPE-IS (see its doc)
REQ.[signedC|c]ookies
REQ.secret                       ##See COOKIE-PARSER

REQ.fresh|stale                   #Returns true|false if:
                                  #  - method is GET|HEAD
                                  #  - RES.statusCode is 2** or 304
                                  #  - If-Modified-Since [C] matches Last-Modified [S] or If-None-Match [C] matches ETag [S], using FRESH(...)
                                  #    (see its doc)
                                  #Used by REQ.send(). REQ.sendFile() does not use it directly but uses same logic.
                                  #Note:
                                  #  - ETag [S] is set by REQ.send[File]()
                                  #  - Last-Modified [S] is set by REQ.sendFile()

REQ.body                          #Only defined with BODY-PARSER
EXPRESS.
 json|urlencoded|text|raw(...)    #Reference to BODY-PARSER.json|urlencoded|text|raw(...) (see its doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              RES              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RES                               #Same as Node.js but augmented with extra properties
RES.app                           #APP


RES.status(NUM)->RES              #Sets RES.statusCode
RES.set('VAR','VAL'[ARR])->RES    #Like RES.setHeader() but:
RES.set(OBJ)->RES                 #  - can use OBJ
                                  #  - returns RES
                                  #  - adds "; charset=UTF-8" if missing and Content-Type: text/... [C]
RES.get('VAR')->'VAL'[_ARR]       #Like RES.getHeader()
RES.append('VAR', VAL[_ARR])
 ->RES                            #Like RES.set(), but appends to current value if existing
RES.headersSent                   #BOOL: true after headers have been sent


RES.location(URL)->RES            #Sets Location: URL [S]
                                  #Calls encodeURI()
                                  #If URL is 'back', use Referrer [C] (def: '/') as URL
RES.type('MIME')->RES             #Sets Content-Type: MIME [S]
                                  #MIME can be '[.]EXT' or 'FILENAME.EXT', in which case it deduces actual MIME
RES.attachment(['FILE'])->RES     #Sets Content-Disposition: attachment[; filename="FILE"] [S] (using CONTENT-DISPOSITION, see its doc)
                                  #Sets Content-Type [S] if 'FILE'
RES.links(OBJ)->RES               #Appends|sets Link [S], where OBJ is { REL: 'URI' }
RES.cookie                        #Sets Set-Cookie: COOKIE [S], using COOKIE('VAR', 'VAL', OPTS) (see its doc)
('VAR', 'VAL'[, OPTS])->RES       #Also:
                                  #  - 'VAL' can be OBJ -> 'j:JSON'
                                  #  - OPTS: #     - path def '/'
                                  #     - maxAge: ms instead of seconds
                                  #     - expires def (using OPTS.maxAge)
                                  #     - signed BOOL: if true (def: false):
                                  #        - 'VAL' -> 's:VAL.HASH', using REQ.secret 'SECRET'
                                  #           - uses COOKIE-SIGNATURE (see its doc)
                                  #           - usually a middleware (like COOKIE-PARSER) sets REQ.secret and verifies 's:VAL.HASH'
RES.clearCookie('VAR'[, OBJ2])
 ->RES                            #Same as RES.cookie, with OPTS.expires 1970-01-01


RES.format({ MIME|default() })    #Fire MIME(REQ, RES, NEXT) according to REQ.accepts('MIME'_ARR)
 ->RES                            #Sets Content-Type [S], Vary: Accept [S] (using VARY, see its doc)
                                  #If no match:
                                  #  - default()
                                  #  - if no default, NEXT(ERROR) with ERROR: status[Code] 406, types 'MIME'_ARR


RES.sendFile('PATH'[, OPTS]       #Uses SEND(REQ, ...) (see its doc)
[, FUNC([ERROR])])                #On top of SEND():
                                  #  - can add OPTS.headers HEADER_OBJ
                                  #  - 'PATH' does not need to be encodeURIComponent'd
                                  #  - fires FUNC(ERROR) (or, if undefined, NEXT(ERROR)) instead of sending 4**, 5**
                                  #  - fires FUNC(ERROR) (or, if undefined, NEXT()) instead of 301
RES.download('PATH'[, 'FILE'],
[OPTS, ]FUNC)                     #Same as RES.attachment(['FILE']); RES.sendFile('PATH', OPTS, FUNC);
EXPRESS.static(...)               #Link to SERVE-STATIC(...) (see its doc), which uses same logic as sendFile() for a whole directory of files

RES.send([VAL])->RES              #Similar to sendFile() but:
                                  #  - sends content directly, not file content
                                  #     - VAL can be any JSON value except null:
                                  #        - uses JSON.stringify(VAL[, APPNAME "json replacer"][, APPNAME "json spaces"])
                                  #        - replace <>& by \uXXXX to avoid HTML sniffing if APPNAME "json escape" true (def: false)
                                  #  - does not:
                                  #     - set Last-Modified [S]
                                  #     - allow range requests
                                  #     - set Cache-Control [S]
                                  #     - set Content-Security-Policy [S]
                                  #     - allow conditional modification, i.e. If-Match [C] or If-Unmodified-Since [C]
                                  #  - different ETag [S]: uses ETAG(..., {weak: BOOL}) (see its doc)
                                  #     - BOOL according to CONF.etag 'weak' (def) or 'strong'
                                  #     - i.e. '[W/]"SIZE-SHA1HASH"'
                                  #     - can customize with CONF."etag fn"(STR, 'ENCODING')->'ETAG'
                                  #  - if 204, no body
                                  #  - never fires NEXT([ERROR])
RES.json(...)->RES                #Same as RES.send(OBJ)
RES.jsonp(...)->RES               #Same as RES.send(OBJ) but for JSONP, i.e. returns FUNC(BODY)
                                  #  - 'FUNC' is REQ.query[CALLBACK]
                                  #     - CALLBACK is "jsonp callback name" (def: 'callback')
RES.sendStatus(STATU_NUM)->RES    #Like RES.status(STATUS_NUM).send(HTTP.STATUS_CODES[NUM])
RES.redirect([NUM, ]'URL')        #Same RES.location('URL'); RES.sendStatus(NUM);

TFUNC('PATH'[, OBJ]               #Template function:
 [, FUNC(ERROR, STR)])            #  - processes 'PATH', using OBJ locals, then return STR
                                  #  - can use CONSOLIDATE (see its doc)
APP.engine('EXT', TFUNC)          #Make APP.render('FILE[.EXT]') use TFUNC (def '.EXT' is CONF."view engine" (def: none))
APP.render(...)                   #Fires TFUNC(...):
                                  #  - 'PATH' should be relative to CONF.views 'DIR'[_ARR] (def: ./views)
                                  #     - but is resolved when passed to TFUNC()
                                  #  - OBJ: filled with APP.locals OBJ
                                  #Use 'PATH'-based cache if OBJ.cache true (def: CONF."view cache" (def: true if NODE_ENV === "production"))
                                  #Can customize low-level templating logic with CONF.view (see source code)
RES.render(...)                   #Same as APP.render(...) except:
                                  #  - can use RES.locals
                                  #  - def FUNC is RES.send(STR)
