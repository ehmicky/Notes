
           
   EXPRESS  
           



VERSION ==>                       #Node module (4.19.2)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MAIN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPRESS()->APP                    #APP is HTTP[S]SERVER 'request' event handler
APP.listen(...)                   #Same as HTTP.createServer(APP).listen(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONFIG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.get('CONFVAR')->VAL           #
APP.set('CONFVAR', VAL)->APP      #
APP.enabled|disabled('CONFVAR')
 ->BOOL
APP.enable|disable('CONFVAR')
 ->APP                            #Same but using true|false

CONF.x-powered-by                 #Adds X-Powered-By: Express [S] (def: true)

CONF.env                          #Defines whether it is run in 'development', 'test' or 'production'
                                  #Some MIDWR behaves accordingly
                                  #Def: ENVVAR NODE_ENV, or 'development'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          MIDDLEWARE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONNECT()->APP                    #Returns APP like EXPRESS but only with APP.use|listen() and limited functionalities
                                  #(e.g. no globbing, PARAM, CONF, etc.)
                                  #Version 3.4.1

ORDER ==>                         #Should do in order:
                                  #  - APP.set()
                                  #  - MIDWRs (logging first)
                                  #  - APP.METHOD()
                                  #  - ERROR_MIDWRs
                                  #  - APP.listen()

APP.use                           #MIDWR are middleware functions, i.e. meant to modify incoming|outcoming REQ|RES
 (MIDWR(REQ, RES, NEXT([ERROR]))  #NEXT() proceeds to the next registered MIDWR
 [_ARR],...)->APP                 #One MIDWR should not call NEXT(), i.e. be endpoint:
                                  #  - usually delivers the content to the client
                                  #  - can be different from request to request
                                  #     - e.g. static MIDWR calls NEXT() if find file, serve file otherwise
                                  #If every MIDWR calls NEXT()
                                  #  - send 404 with body "Cannot METHOD PATH"
                                  #  - to redefine it, use a last MIDWR with no 'PATH' (but not an ERROR_MIDWR)

APP.use(MIDWR(ERROR, ...),...)    #ERROR_MIDWR, called if previous MIDWR calls NEXT(ERROR) or throws ERROR
 ->APP                            #Def: send 500 status code with response ERROR

APP.use('ROUTE_PATH'[_ARR], ...)  #Only applies to requests to 'ROUTE_PATH[/...]' (def: '/'):
 ->APP                            #Excluding query string or hash
                                  #Can use globbing: ? + ( ) *
ROUTER_OPTS.caseSensitive
CONF."case sensitive routing"     #BOOL (def: false). Case-sensitiveness of 'ROUTE_PATH'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           MOUNTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.use(['ROUTE_PATH', ]APP2)     #Use APP2 for requests to 'ROUTE_PATH[/...]'
 ->APP                            #Goal: sub-apps
                                  #Common pattern is to export APP, and only use APP.listen() if (!module.parent)

APP2.on('mount', FUNC(APP))       #
APP2.mounthpath                   #Parent 'ROUTE_PATH' (def: '/')
APP2.path()->'PATH'               #Ancestor 'ROUTE_PATH' (def: '')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ROUTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.METHOD('ROUTE_PATH', ...)     #Like APP.use('ROUTE_PATH', ...) except only when using HTTP METHOD
 ->APP                            #  - can be 'all'
                                  #  - 'get' also catches 'head'
                                  #     - unless APP.head() defined
                                  #  - 'options' sends back 200 with Allow: METHOD,... [C] for each defined METHOD
                                  #     - unless APP.options() defined
                                  #Cannot define ERROR_MIDWR nor sub-app
                                  #'ROUTE_PATH':
                                  #  - must be exact match
                                  #  - can be REGEXP (partial match)
ROUTER_OPTS.strict
CONF."strict routing"             #BOOL (def: false). Make APP.METHOD('ROUTE_PATH', ...) match 'ROUTE_PATH[/]'
NEXT('route')                     #Inside APP.METHOD(), skip other APP.METHOD() or MIDWRs with same METHOD + 'ROUTE_PATH'

APP.route('ROUTE_PATH')->ROUTE    #Same as APP.METHOD('ROUTE_PATH', ...)
ROUTE.METHOD(...)->ROUTE          #Meant for re-usability

EXPRESS.Router([ROUTER_OPTS])
 ->ROUTER                         #ROUTER is a MIDWR meant for routing
ROUTER.use|METHOD|route|param(...)#Like APP.*(...)
NEXT('router')                    #In a ROUTER, skip the rest of that ROUTER


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PARAMETERS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


:PARAM                            #Can be used in 'ROUTE_PATH'
                                  #Matched against request URL
                                  #Name must be [:alnum:]_
:PARAM?                           #Optional

REQ.params.PARAM                  #VAL
REQ.params[NUM]                   #VAL when ROUTE_PATH is REGEXP

APP.param('PARAM'[_ARR],
 MIDWR(..., PARAM_VAL, 'PARAM'))
 ->APP                            #MIDWR that is called for ROUTE_PATHs that use :PARAM

ROUTER_OPTS.mergeParams           #BOOL (def: false). Inherits parent ROUTER PARAMs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           REQ MAIN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ                               #Like Node.js but additional members
REQ.app                           #APP

REQ.query                         #GET variables as OBJ
CONF."query parser"               #Whether to use QS ('complex', def) or node:querystring  ('simple')

EXPRESS
 .json|urlencoded|text|raw(...)   #Reference to BODY-PARSER.json|urlencoded|text|raw(...) (see its doc)
REQ.body                          #Only defined with BODY-PARSER


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REQ URL            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ.originalUrl                   #Absolute URL
REQ.baseUrl                       #'ROUTE_PATH' from all APP.use('ROUTE_PATH',...) (MIDWR, routing or sub-app)
REQ.url                           #URL relative to REQ.baseUrl
REQ.path                          #REQ.url without '?SEARCH' nor '#HASH'

REQ.route.methods.METHOD          #BOOL
REQ.protocol                      #'http[s]'
REQ.secure                        #BOOL. Whether 'https'
REQ.hostname                      #STR
REQ.subdomains                    #STR_ARR. REQ.hostname.split('.').reverse()
                                  #Also, ARR.slice(CONF.'subdomain offset') (def: 2)

REQ.ip                            #'ADDR'. Client IP
REQ.ips                           #'ADDR'_ARR. Client + reverse proxies (closest to server last)

CONF."trust proxy fn"             #FUNC('ADDR', NUM)->BOOL or 'ADDR2'[_ARR] passed to PROXY-ADDR (see its doc)
                                  #Use X-Forwarded-Host|For|Proto [C] for REQ.protocol|hostname|ip
                                  #I.e. ignore reverse proxies
                                  #Required to use REQ.ips
                                  #Def: nothing is trusted, i.e. only uses last proxy
CONF."trust proxy"                #Same but can also be:
                                  #  - true: same as FUNC()->true
                                  #  - NUM: same as FUNC(VAL, NUM2)->NUM2 < NUM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          REQ HEADERS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ.get('HEADER_VAR')->'VAL'      #Case insensitive

REQ.is(STR_ARR or STR,...)->BOOL  #Check against Content-Type [C] using TYPE-IS (see its doc)
REQ.accepts
 [Charsets|Languages|Encodings]()
 ->STR[_ARR]
REQ.accepts
 [Charsets|Languages|Encodings]
 (STR2_ARR or STR2,...)
 [->STR]                          #Parses Accept[-Charset|Language|Encoding] [C] using ACCEPTS (see its doc)

REQ.range(NUM[, OPTS])->VAL       #Parses Range [C] using RANGE-PARSER (see its doc)

REQ.fresh                         #BOOL. True if:
                                  #  - matching If-None-Match [C], If-Modified-Since [C], ETag [S], Last-Modified [S], Cache-Control [C]
                                  #     - using FRESH (see its doc)
                                  #  - GET|HEAD
                                  #  - RES.statusCode 2** or 304
                                  #REQ.send[File]():
                                  #  - use it
                                  #  - set ETag [S]
                                  #  - set Last-Modified [S] (only REQ.sendFile())
REQ.stale                         #!REQ.fresh

REQ.xhr                           #BOOL. X-Requested-With [C] === 'XMLHttpRequest' (case-insensitive)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              RES              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RES                               #Same as Node.js but augmented with extra properties
RES.app                           #APP

RES.status(NUM)->RES              #Sets RES.statusCode

RES.get('HEADER_VAR')->'VAL'[_ARR]#Like RES.getHeader()
RES.set|append                    #Like RES.setHeader()
 ('HEADER_VAR', 'VAL'[_ARR])->RES #If append(), appends to current value if existing
RES.set(HEADERS_OBJ)->RES         #Adds '; charset=UTF-8' to Content-Type: text/... [C], if missing
RES.headersSent                   #BOOL. true after headers have been sent

RES.location(URL)->RES            #Sets Location: URL [S]
                                  #Uses encodeURI(URL)
                                  #If URL is 'back', use Referrer [C] (def: '/') as URL
RES.type('MIME'|'[[PATH].]EXT')
 ->RES                            #Sets Content-Type: MIME [S] (using MIME-TYPES, see its doc)
RES.attachment(['FILE'])->RES     #Sets Content-Disposition: attachment[; filename="FILE"] [S] (using CONTENT-DISPOSITION, see its doc)
                                  #Sets Content-Type [S] if 'FILE'
RES.links({ REL: 'URI',... })->RES#Appends|sets Link [S]

RES.cookie('VAR', 'VAL'[, OPTS])
 ->RES                            #Sets Set-Cookie: COOKIE [S]
RES.cookie('VAR', OBJ[, OPTS])
 ->RES                            #Same but using 'j:JSON' as VAL
OPTS.*                            #Like COOKIE serialize() (see its doc)
OPTS.path                         #STR. Def: '/'
OPTS.expires                      #DATE. Def: uses OPTS.maxAge
OPTS.maxAge                       #NUM (in ms)
RES.clearCookie('VAR'[, OBJ2])
 ->RES                            #Same as RES.cookie, with OPTS.expires 1970-01-01

OPTS.signed                       #BOOL (def: false). 'VAL' -> 's:VAL.HASH', using REQ.secret 'SECRET'
                                  #Uses COOKIE-SIGNATURE (see its doc)
REQ.[signed]cookies
REQ.secret                       ##Sets by COOKIE-PARSER (see its doc)

RES.format({                      #Calls MIME() according to REQ.accepts('MIME'_ARR)
 MIME|default(REQ, RES, NEXT),    #If no match, calls default()
 ...                              #If no default(), NEXT(ERROR) with ERROR: status[Code] 406, types 'MIME'_ARR
})->RES                           #Sets Content-Type [S]
                                  #Sets Vary: Accept [S] (using VARY, see its doc)

RES.sendFile                      #Calls SEND(REQ, 'PATH', OPTS) (see its doc)
 ('PATH'[, OPTS][, FUNC([ERROR])])#'PATH' automatically encodeURIComponent'd
                                  #FUNC([ERROR]) (def: NEXT([ERROR])) called instead of sending 301|4**|5**
OPTS.*                            #See SEND doc
OPTS.headers                      #HEADERS_OBJ

RES.download('PATH'[, 'FILE']
 [, OPTS], FUNC)                  #RES.attachment(['FILE']) + RES.sendFile('PATH', OPTS, FUNC)

EXPRESS.static(...)               #Calls SERVE-STATIC(...) (see its doc)

RES.send([STR|JSON_VAL])->RES     #Similar to RES.sendFile() but with following differences
                                  #Sends content directly, not file content
                                  #JSON_VAL uses JSON.stringify(), and cannot be null
                                  #Does not:
                                  #  - allow If-Match [C] or If-Unmodified-Since [C], nor set Last-Modified [S] or Cache-Control [S]
                                  #  - set Content-Security-Policy [S]
                                  #  - allow range requests
                                  #Different ETag [S]: uses ETAG(..., {weak: BOOL}) (see its doc)
                                  #  - BOOL according to CONF.etag 'weak' (def) or 'strong'
                                  #  - i.e. '[W/]"SIZE-SHA1HASH"'
                                  #  - can customize with CONF."etag fn"(STR, 'ENCODING')->'ETAG'
                                  #If 204, no body
                                  #Never fires NEXT([ERROR])
CONF."json replacer"
CONF."json spaces"                #Used as 2nd|3rd argument of JSON.strigify() with RES.send(JSON_VAL)
CONF."json escape"                #BOOL (def: false). Replaces <>& by \uXXXX to avoid HTML sniffing
RES.json(...)->RES                #Same as RES.send(OBJ)
RES.jsonp(...)->RES               #Same as RES.send(OBJ) but for JSONP, i.e. returns FUNC(BODY)
                                  #  - 'FUNC' is REQ.query[CALLBACK]
                                  #     - CALLBACK is "jsonp callback name" (def: 'callback')
RES.sendStatus(STATU_NUM)->RES    #Like RES.status(STATUS_NUM).send(HTTP.STATUS_CODES[NUM])
RES.redirect([NUM, ]'URL')        #Same RES.location('URL'); RES.sendStatus(NUM);

TFUNC('PATH'[, OBJ]               #Template function:
 [, FUNC(ERROR, STR)])            #  - processes 'PATH', using OBJ locals, then return STR
                                  #  - can use CONSOLIDATE (see its doc)
APP.engine('EXT', TFUNC)          #Make APP.render('FILE[.EXT]') use TFUNC (def '.EXT' is CONF."view engine" (def: none))
APP.render(...)                   #Fires TFUNC(...):
                                  #  - 'PATH' should be relative to CONF.views 'DIR'[_ARR] (def: ./views)
                                  #     - but is resolved when passed to TFUNC()
                                  #  - OBJ: filled with APP.locals OBJ
                                  #Use 'PATH'-based cache if OBJ.cache true (def: CONF."view cache" (def: true if NODE_ENV === "production"))
                                  #Can customize low-level templating logic with CONF.view (see source code)
RES.render(...)                   #Same as APP.render(...) except:
                                  #  - can use RES.locals
                                  #  - def FUNC is RES.send(STR)
