
           
   EXPRESS  
           



VERSION ==>                       #5.0.0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MAIN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXPRESS()->APP                    #APP is HTTP[S]SERVER 'request' event handler
APP.listen(...)                   #Same as HTTP.createServer(APP).listen(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONFIG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.settings                      #CONF
APP.get('CONFVAR')->VAL           #
APP.set('CONFVAR', VAL)->APP      #
APP.enabled|disabled('CONFVAR')
 ->BOOL
APP.enable|disable('CONFVAR')
 ->APP                            #Same but using true|false

CONF.env                          #Defines whether it is run in 'development', 'test' or 'production'
                                  #Some MIDWR behaves accordingly
                                  #Def: ENVVAR NODE_ENV, or 'development'

CONF.x-powered-by                 #BOOL (def: true). Sets X-Powered-By: Express [S]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          MIDDLEWARE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONNECT()->APP                    #Returns APP like EXPRESS but only with APP.use|listen() and limited functionalities
                                  #(e.g. no globbing, PARAM, CONF, etc.)
                                  #Version 3.4.1

ORDER ==>                         #Should do in order:
                                  #  - APP.set()
                                  #  - MIDWRs (logging first)
                                  #  - APP.METHOD()
                                  #  - ERROR_MIDWRs
                                  #  - APP.listen()

APP.use                           #MIDWR are middleware functions, i.e. meant to modify incoming|outcoming REQ|RES
 (MIDWR(REQ, RES, NEXT([ERROR]))  #NEXT() proceeds to the next registered MIDWR
 [_ARR],...)->APP                 #One MIDWR should not call NEXT(), i.e. be endpoint:
                                  #  - usually delivers the content to the client
                                  #  - can be different from request to request
                                  #     - e.g. static MIDWR calls NEXT() if find file, serve file otherwise
                                  #If every MIDWR calls NEXT()
                                  #  - send 404 with body "Cannot METHOD PATH"
                                  #  - to redefine it, use a last MIDWR with no 'PATH' (but not an ERROR_MIDWR)

APP.use(MIDWR(ERROR, ...),...)    #ERROR_MIDWR, called if previous MIDWR calls NEXT(ERROR) or throws|rejects ERROR
 ->APP                            #Def: send 500 status code with response ERROR

APP.use(ROUTE_PATHS, ...)->APP    #Only applies to requests to 'ROUTE_PATH[/...]' (def: '/', i.e. any)
ROUTER[_OPTS].caseSensitive
CONF."case sensitive routing"     #BOOL (def: false). Case-sensitiveness of 'ROUTE_PATH'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           MOUNTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.use([ROUTE_PATHS, ]APP2)      #Use APP2 for requests to 'ROUTE_PATH[/...]'
 ->APP                            #Goal: sub-apps
                                  #Common pattern is to export APP, and only use APP.listen() if (!module.parent)

APP2.on('mount', FUNC(APP))       #
APP2.mountpath                    #Parent 'ROUTE_PATH' (def: '/')
APP2.path()->'PATH'               #Ancestor 'ROUTE_PATH' (def: '')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ROUTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


APP.METHOD(ROUTE_PATHS, ...)->APP #Like APP.use(ROUTE_PATHS, ...) except only when using HTTP METHOD
                                  #  - can be 'all'
                                  #  - 'get' also catches 'head'
                                  #     - unless APP.head() defined
                                  #  - 'options' responds with 200 and Allow: METHOD,... [C] for each defined METHOD
                                  #     - unless APP.options() defined
                                  #Cannot define ERROR_MIDWR nor sub-app
                                  #ROUTE_PATHS is exact match if 'ROUTE_PATH', partial if REGEXP

ROUTE_PATHS                       #Matches REQ.url (i.e. no origin)
                                  #Either a:
                                  #  - 'ROUTE_PATH': uses path-to-regexp (see its doc)
                                  #  - REGEXP
                                  #Can be an ARR of 'ROUTE_PATH'|REGEXP

ROUTER[_OPTS].strict
CONF."strict routing"             #BOOL (def: false). Allow trailing / in ROUTE_PATHS
NEXT('route')                     #Skips the rest of the ROUTE

APP.route(ROUTE_PATHS)->ROUTE     #Same as APP.METHOD(ROUTE_PATHS, ...)
ROUTE.METHOD(...)->ROUTE          #Meant for re-usability

REQ.route                         #ROUTE
ROUTE.methods.HTTP_METHOD         #BOOL
ROUTE.path                        #'ROUTE_PATH'

APP.router
EXPRESS.Router([ROUTER_OPTS])
 ->ROUTER                         #MIDWR meant to re-use multiple ROUTEs or MIDWRs
ROUTER.use|METHOD|route|param(...)#Like APP.*(...)
NEXT('router')                    #Skip the rest of the ROUTER

new Router([ROUTER_OPTS])         #ROUTER. Package 'router' (version 2.0.0)
                                  #Used by Express for APP|ROUTER.use|METHOD|route|param(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              REQ              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ                               #Like Node.js but additional members
REQ.app                           #APP

REQ.query                         #Query variables as OBJ
CONF."query parser fn"            #FUNC('QUERY')->QUERY_OBJ
CONF."query parser"               #Same but is either:
                                  #  - false: leave 'QUERY' as is
                                  #  - 'simple'|true (def): node:querystring parse()
                                  #  - 'extended': QS.parse() (see its doc)
                                  #     - uses default OPTS, except OPTS.allowPrototypes true

EXPRESS
 .json|urlencoded|text|raw(...)   #Reference to BODY-PARSER.json|urlencoded|text|raw(...) (see its doc)
REQ.body                          #Only defined with BODY-PARSER

REQ.get('HEADER_VAR')->'VAL'      #Case insensitive

REQ.range(NUM[, OPTS])->VAL       #Parses Range [C] using RANGE-PARSER (see its doc)

REQ.xhr                           #BOOL. X-Requested-With [C] === 'XMLHttpRequest' (case-insensitive)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              URL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ.originalUrl                   #Absolute URL
REQ.baseUrl                       #'ROUTE_PATH' from all parent ROUTE_PATHS (MIDWR, routing or sub-app)
REQ.url                           #URL relative to REQ.baseUrl
REQ.path                          #REQ.url without '?SEARCH' nor '#HASH'

REQ.protocol                      #'http[s]'
REQ.secure                        #BOOL. Whether 'https'
REQ.host                          #'HOSTNAME:PORT'
REQ.hostname                      #'HOSTNAME'
REQ.subdomains                    #STR_ARR. REQ.hostname.split('.').reverse()
                                  #Also, ARR.slice(CONF.'subdomain offset') (def: 2)

REQ.ip                            #'ADDR'. Client IP
REQ.ips                           #'ADDR'_ARR. Client + reverse proxies (closest to server last)

CONF."trust proxy fn"             #FUNC('ADDR', NUM)->BOOL passed to PROXY-ADDR (see its doc)
                                  #Use X-Forwarded-Host|For|Proto [C] for REQ.protocol|host[name]|ip
                                  #I.e. ignore reverse proxies
                                  #Required to use REQ.ips
                                  #Def: nothing is trusted, i.e. only uses last proxy
CONF."trust proxy"                #Same but can also be:
                                  #  - true: same as FUNC()->true
                                  #  - NUM: same as FUNC(VAL, NUM2)->NUM2 < NUM
                                  #  - 'ADDR2'[_ARR] or 'ADDR2,...'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PARAMETERS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


:PARAM                            #Can be used in 'ROUTE_PATH'
                                  #Matched against request URL
                                  #Name must be [:alnum:]_
:PARAM?                           #Optional

REQ.params.PARAM                  #VAL when ROUTE_PATHS is 'ROUTE_PATH' (see path-to-regexp doc) or REGEXP (?<NAME>...)
                                  #Calls decodeURIComponent() on values
REQ.params[NUM]                   #Same but when ROUTE_PATHS is REGEXP (...)

APP.param('PARAM'[_ARR],
 MIDWR(..., PARAM_VAL, 'PARAM'))
 ->APP                            #MIDWR that is called for ROUTE_PATHs that use :PARAM

ROUTER[_OPTS].mergeParams         #BOOL (def: false). Inherits parent ROUTER PARAMs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              RES              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RES                               #Same as Node.js but augmented with extra properties
RES.app                           #APP

RES.status(NUM)->RES              #Sets RES.statusCode

RES.get('HEADER_VAR')->'VAL'[_ARR]#Like RES.getHeader()
RES.set|append                    #Like RES.setHeader()
 ('HEADER_VAR', 'VAL'[_ARR])->RES #If append(), appends to current value if existing
RES.set(HEADERS_OBJ)->RES         #Adds '; charset=UTF-8' to Content-Type: text/... [C], if missing
RES.headersSent                   #BOOL. true after headers have been sent


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SEND              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RES.sendFile                      #Calls SEND(REQ, 'PATH', OPTS) (see its doc)
 ('PATH'[, OPTS][, FUNC([ERROR])])#'PATH' automatically encodeURIComponent'd
                                  #FUNC([ERROR]) (def: NEXT([ERROR])) called instead of sending 301|4**|5**
OPTS.*                            #See SEND doc
OPTS.headers                      #HEADERS_OBJ

RES.attachment(['FILE'])->RES     #Sets Content-Disposition: attachment[; filename="FILE"] [S] (using CONTENT-DISPOSITION, see its doc)
                                  #Sets Content-Type [S] if 'FILE'
RES.download('PATH'[, 'FILE']
 [, OPTS], FUNC)                  #RES.attachment(['FILE']) + RES.sendFile('PATH', OPTS, FUNC)

RES.send([STR|JSON_VAL])->RES     #Similar to RES.sendFile() but with following differences
                                  #Sends content directly, not file content
                                  #JSON_VAL uses JSON.stringify(), and cannot be null
                                  #Does not:
                                  #  - allow If-Match [C] or If-Unmodified-Since [C], nor set Last-Modified [S] or Cache-Control [S]
                                  #  - set Content-Security-Policy [S]
                                  #  - allow range requests
                                  #If 204, no body
                                  #Does not call NEXT([ERROR])

CONF."etag fn"                    #FUNC(BUFFER, 'ENCODING')->'ETAG', sed for ETag [S]
                                  #Def: uses ETAG (see its doc)
CONF.etag                         #'weak' (def) or 'strong'. Whether to prepend 'W/' to Etag [S]

CONF."json replacer"
CONF."json spaces"                #Used as 2nd|3rd argument of JSON.strigify() with RES.send(JSON_VAL)
CONF."json escape"                #BOOL (def: false). Replaces <>& by \uXXXX to avoid HTML sniffing

RES.json(...)->RES                #Same as RES.send(OBJ)
RES.jsonp(...)->RES               #Same as RES.send(OBJ) but for JSONP: sends FUNC_NAME(BODY)
CONF."jsonp callback name"        #'CALLBACK' (def: 'callback')
                                  #FUNC_NAME in RES.jsonp() is REQ.query.CALLBACK

RES.sendStatus(STATUS_NUM)->RES   #RES.status(STATUS_NUM) + RES.send(HTTP.STATUS_CODES[NUM])

EXPRESS.static(...)               #Reference to SERVE-STATIC(...) (see its doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           REDIRECTS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RES.location('URL')->RES          #Sets Location: URL [S]
                                  #Uses encodeURI('URL')
RES.redirect([NUM, ]'URL')        #RES.location('URL') + RES.sendStatus(NUM)

RES.links({ REL: 'URI',... })->RES#Appends|sets Link [S]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            COOKIES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RES.cookie('VAR', 'VAL'[, OPTS])
 ->RES                            #Sets Set-Cookie: COOKIE [S]
RES.cookie('VAR', OBJ[, OPTS])
 ->RES                            #Same but using 'j:JSON' as VAL
OPTS.*                            #Like COOKIE serialize() (see its doc)
OPTS.path                         #STR. Def: '/'
OPTS.expires                      #DATE. Def: uses OPTS.maxAge
OPTS.maxAge                       #NUM (in ms)
RES.clearCookie('VAR'[, OPTS])
 ->RES                            #Same as RES.cookie('VAR', '', {...OPTS, expires: 1970-01-01})

OPTS.signed                       #BOOL (def: false). 'VAL' -> 's:VAL.HASH', using REQ.secret 'SECRET'
                                  #Uses COOKIE-SIGNATURE (see its doc)
REQ.[signed]cookies
REQ.secret                       ##Sets by COOKIE-PARSER (see its doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CACHING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ.fresh                         #BOOL. True if:
                                  #  - matching If-None-Match [C], If-Modified-Since [C], ETag [S], Last-Modified [S], Cache-Control [C]
                                  #     - using FRESH (see its doc)
                                  #  - GET|HEAD
                                  #  - RES.statusCode 2** or 304
                                  #REQ.send[File]():
                                  #  - use it
                                  #  - set ETag [S]
                                  #  - set Last-Modified [S] (only REQ.sendFile())
REQ.stale                         #!REQ.fresh


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      CONTENT NEGOTIATION      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REQ.is(STR[_ARR],...)->BOOL       #Check against Content-Type [C] using TYPE-IS (see its doc)
RES.type('MIME'|'[[PATH].]EXT')
 ->RES                            #Sets Content-Type: MIME [S] (using MIME-TYPES, see its doc)

REQ.accepts
 [Charsets|Languages|Encodings]()
 ->STR[_ARR]
REQ.accepts
 [Charsets|Languages|Encodings]
 (STR2[_ARR],...)[->STR]          #Parses Accept[-Charset|Language|Encoding] [C] using ACCEPTS (see its doc)

RES.format({                      #Calls MIME() according to REQ.accepts('MIME'_ARR)
 MIME|default(REQ, RES, NEXT),    #If no match, calls default()
 ...                              #If no default(), NEXT(ERROR) with ERROR: status[Code] 406, types 'MIME'_ARR
})->RES                           #Sets Content-Type [S]
                                  #Sets Vary: Accept [S] (using VARY, see its doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           TEMPLATES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TFUNC('PATH'[, OPTS],             #Template function
 FUNC(ERROR, STR))                #Can use CONSOLIDATE (see its doc)

OPTS.*                            #Template variables
APP|RES.locals                    #Default values for OPTS.*
APP|RES.locals.settings           #CONF

OPTS.cache                        #BOOL. Memoizes TFUNC per 'PATH'
CONF."view cache"                 #BOOL (def: true if CONF.env 'production'). Default value of OPTS.cache

APP.engine('EXT', TFUNC)          #Sets TFUNC used by APP.render('FILE.EXT')
CONF."view engine"                #Def 'EXT' used by APP.render() when none

CONF.views                        #'DIR'[_ARR] (def: ./views) used as base to resolve 'PATH' in APP.render() before passing it to TFUNC

CONF.view                         #Customize templating logic of APP.render (not documented yet)

APP.render(...)                   #Fires TFUNC(...)
RES.render(...)                   #Same as APP.render(...) except:
                                  #  - calls RES.send(STR), unless TFUNC has a FUNC callback
                                  #  - can use RES.locals


FINALHANDLER(REQ, RES[, OPTS])    #If no ERROR: 404 with 'Cannot HTTP_METHOD /PATH'
 ->NEXT([ERROR])                  #If ERROR:
                                  #  - STATUS_NUM is ERROR.status[Code], RES.statusCode, or 500
                                  #  - headers use ERROR.headers HEADERS_OBJ (providing ERROR.status[Code] exists)
                                  #  - body is ERROR.stack
                                  #Noop if headers already sent
OPTS.env                          #Def: ENVVAR NODE_ENV, or 'development'
                                  #If 'production', use 'STATUS' message instead of ERROR.stack (see STATUSES doc)
OPTS.onerror                      #FUNC(ERROR, REQ, RES) (def: none) called on NEXT(ERROR)
