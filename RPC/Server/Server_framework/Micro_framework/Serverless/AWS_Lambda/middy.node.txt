
                                  ┏━━━━━━━━━━━┓
                                  ┃   MIDDY   ┃
                                  ┗━━━━━━━━━━━┛

VERSION ==>                       #5.5.0

GOAL ==>                          #Server middleware for AWS Lambda

                                  ┌──────────┐
                                  │   CORE   │
                                  └──────────┘

@middy/core                       #Package name

MIDDY([HANDLER][, OPTS])
 ->MHANDLER                       #Wraps Lambda HANDLER(REQ, NCONTEXT)->>RES (def: noop)
MHANDLER.handler(HANDLER)
 ->MHANDLER                       #[Re-]set HANDLER

                                  ┌────────────────┐
                                  │   MIDDLEWARE   │
                                  └────────────────┘

MHANDLER.use(MIDDY_MDWR[_ARR])    #MIDDY_MDWR: before STEP, after STEP, onError STEP
 ->MHANDLER                       #Calls MHANDLER.before|after|onError()

MHANDLER.before(STEP)->MHANDLER   #Called before HANDLER

MHANDLER.after(STEP)->MHANDLER    #Called after HANDLER (unless it threw)

MHANDLER.onError(STEP)->MHANDLER  #Called if any of the following throws:
                                  #  - HANDLER
                                  #     - including OPTS.before|afterHandler()
                                  #  - 'before|after' STEPs
                                  #     - including their OPTS.before|afterMiddleware()
                                  #  - OPTS.timeoutEarlyResponse()
                                  #Also, not of the above is run anymore
                                  #Exception is still propagated
                                  #Not called if OPTS.beforePrefetch|requestStart|requestEnd() throws
                                  #If an 'onError' STEP throws:
                                  #  - further 'onError' STEPs are not run
                                  #  - its exception is thrown instead
                                  #     - original exception available as ERROR.originalError
                                  #OPTS.requestEnd() is always run, regardless of exceptions
                                  #  - providing OPTS.requestStart() has ended and did not throw

                                  ┌──────────┐
                                  │   STEP   │
                                  └──────────┘

FUNC(INFO)[->[>]RES]              #STEP
                                  #Ordered: first registered is first run
                                  #If RES is returned:
                                  #  - no more STEP is run
                                  #  - if 'before' STEP: HANDLER not run
                                  #  - if 'onError' STEP: exception not thrown|propagated
                                  #  - RES is returned from MHANDLER

INFO.event                        #REQ
INFO.context                      #NCONTEXT
INFO.response                     #RES returned by HANDLER
                                  #Only set in:
                                  #  - 'after' STEP
                                  #  - OPTS.requestEnd(), if HANDLER did not throw
INFO.error                        #Exception VAL
                                  #Only set in:
                                  #  - 'onError' STEP
                                  #  - OPTS.requestEnd(), if HANDLER threw

                                  ┌────────────┐
                                  │   EVENTS   │
                                  └────────────┘

OPTS.beforePrefetch()             #On MIDDY() call

OPTS.requestStart()               #On MHANDLER() start
OPTS.beforeHandler()              #On HANDLER() start
OPTS.afterHandler()               #On HANDLER() end (excluding throwing)
OPTS.requestEnd(INFO)[->>]        #On MHANDLER() end (including throwing)

OPTS.beforeMiddleware(STR)        #Before each STEP. STR is its FUNC.name
OPTS.afterMiddleware(STR)         #After each STEP. STR is its FUNC.name

                                  ┌───────────┐
                                  │   STATE   │
                                  └───────────┘

OPTS|INFO.internal                #MIDDY_CONTEXT (def: {})
                                  #OBJ to pass information between STEPs, MDWRs and HANDLER
                                  #Keys should be camelCase'd, with only :alnum:

@middy/util                       #
getInternal(VAL, INFO)->>OBJ      #Returns, according to VAL:
                                  #  - true -> MIDDY_CONTEXT
                                  #  - 'VARR'[_ARR] -> { VARR: MIDDY_CONTEXT.VARR, ... }
                                  #  - { KEY: 'VARR' } -> { KEY: MIDDY_CONTEXT.VARR, ... }
                                  #VARR:
                                  #  - can include .VAR or .NUM
                                  #  - resolves to undefined if any parent key missing
                                  #OBJ keys are normalized:
                                  #  - start with NUM -> _NUM
                                  #  - non-:alnum: character -> _
                                  #Top-level MIDDY_CONTEXT.* PROMISEs are resolved
                                  #  - exceptions are propagated, aggregated as ERROR.cause.data EXCEPTION_ARR
                                  #  - howevere, to avoid unhandled rejections, should make sure they cannot be rejected

                                  ┌─────────────┐
                                  │   TIMEOUT   │
                                  └─────────────┘

OPTS.timeoutEarlyInMillis         #NUM (in ms, def: 5)
                                  #Time out the HANDLER NUMms before the INVOCATION itself times out (NCONTEXT.getRemainingTimeInMillis())
                                  #'after|onError' STEPs and OPTS.* events are still run
                                  #  - NUM should be high enough for this logic to run

OPTS.timeoutEarlyResponse         #FUNC()->RES used instead of HANDLER when it times out
                                  #Def: throw an ERROR with name 'TimeoutError' and cause.package '@middy/core'

{signal: ABORT_SIGNAL}            #Passed as third argument to HANDLER
                                  #Aborted on HANDLER timeout
                                  #When HANDLER times out, it is short-circuited with Promise.race(), but it still runs
                                  #I.e. must use that ABORT_SIGNAL to interrupt any ongoing logic on timeout

                                  ┌───────────────┐
                                  │   STREAMING   │
                                  └───────────────┘

OPTS.streamifyResponse            #BOOL (def: false). When using FUNC_URL.InvokeMode 'RESPONSE_STREAM' (see Lambda doc)
                                  #Use awslambda.streamifyResponse() and awslambda.HttpResponseStream.from() under-the-hood

FUNC(REQ, NCONTEXT)
 ->>RES_OBJ[.body]                #Must be used as HANDLER instead

RES_OBJ.body                      #ISTREAM|STR (def: '')

RES_OBJ.statusCode                #NUM. Required if returning REQ_OBJ.body, else def 200
RES_OBJ.headers                   #OBJ
RES_OBJ.cookies                   #'VAR=VAL[;...]'_ARR

                                  ┌───────────────┐
                                  │   NORMALIZE   │
                                  └───────────────┘

@middy/util                       #
normalizeHttpResponse(INFO)->RES  #Normalizes INFO.response to FUNC_URL_RES or API Gateway MAIN_RES:
                                  #  - undefined -> {}
                                  #  - STR -> {statusCode: 200, body: STR}
                                  #  - def statusCode: 500
                                  #  - def headers: {}
                                  #Directly mutates INFO.response, then returns it

                                  ┌───────────┐
                                  │   ERROR   │
                                  └───────────┘

@middy/util                       #
createError(STATUS_NUM
 [, 'MESSAGE'][, ERROR_OPTS])
 ->ERROR
new HttpError(STATUS_NUM
 [, 'MESSAGE'][, ERROR_OPTS])     #

ERROR.name                        #STATUS-NUM-specific, e.g. 'NoContentError' for 204
ERROR.message                     #Def: STATUS_NUM-specific, e.g. 'No Content' for 204

ERROR.status[Code]                #STATUS_NUM

ERROR[_OPTS].expose               #BOOL (def: true unless STATUS_NUM 5**)
                                  #Hint whether stack trace should be shown

ERROR_OPTS.*                      #Passed to Error, e.g. cause, etc.

                                  ┌──────────────────┐
                                  │   COMMAND MAIN   │
                                  └──────────────────┘

OPTS.fetchData.FETCH_KEY          #PARAMS. Calls a specific COMMAND for a given AWS SERVICE
                                  #Common pattern for multiple builtin MDWRs, created as FUNC(OPTS)->MDWR
                                  #The specific COMMAND and FETCH_RES is documented in each SERVICE

NCONTEXT.FETCH_KEY                #FETCH_RES. COMMAND's RESP, mapped

MIDDY_CONTEXT.FETCH_KEY           #FETCH_RES_PROMISE. Same but as PROMISE

OPTS.setToContext                 #BOOL. If false (def):
                                  #  - sets only MIDDY_CONTEXT.FETCH_KEY, not NCONTEXT.FETCH_KEY
                                  #  - i.e. the COMMAND is not awaited by the MDWR itself, which is faster
                                  #  - it will be awaited instead by the next MDWR or HANDLER that retrieves FETCH_RES using getInternal()

                                  ┌───────────────────┐
                                  │   COMMAND ERROR   │
                                  └───────────────────┘

COMMAND ERRORS ==>                #If COMMAND has a STS signature error, it is retried once
                                  #Else, any exception is propagated

UNHANDLED REJECTED PROMISE ==>    #Can happen if the COMMAND throws, since it is not awaited right away
                                  #This happens if the failure happens before FETCH_RES is retrieved
                                  #Can be solved by either:
                                  #  - using OPTS.setToContext true
                                  #  - using synchronous or no MDWRs in-between
                                  #  - not refreshing cache, i.e. not using OPTS.cacheExpiry
                                  #     - then, it can still happen, but only once at FUNC_INSTANCE's first REQ

                                  ┌───────────────────┐
                                  │   COMMAND CACHE   │
                                  └───────────────────┘

CACHE ==>                         #FETCH_RES is cached
                                  #Cache is invalidated if COMMAND fails

OPTS.cacheKey                     #'CACHE_KEY'. Unless set, all MDWRs of same kind share the cache
                                  #I.e. only useful if using 2+ MDWRs with same kind but different OPTS.fetchData

OPTS.cacheExpiry                  #How long to cache, either:
OPTS.cacheKeyExpiry.CACHE_KEY     #  - -1 (def): forever
                                  #  - 0: never
                                  #  - NUM (max 1d): duration in ms
                                  #  - DATE_NUM: Unix timestamp in ms
                                  #If NUM (not DATE_NUM): refreshes every NUMms, calling COMMAND again

                                  ┌────────────────────┐
                                  │   COMMAND CLIENT   │
                                  └────────────────────┘

OPTS.awsClientOptions             #COPTS passed to the CLIENT

OPTS.awsClientAssumeRole          #'VAR'. Uses MIDDY_CONTEXT.VAR CREDS_OBJ as COPTS.credentials
                                  #If set, must be called after @middy/sts

OPTS.awsClientCapture             #FUNC(CLIENT)->CLIENT mapping it
                                  #Requires OPTS.disablePrefetch true

OPTS.disablePrefetch              #BOOL. Whether to create CLIENT during MDWR init (false, def) or 'before' STEP (true)
                                  #Always true if OPTS.awsClientAssumeRole set
                                  #Regardless, CLIENT is always created only once per FUNC_INSTANCE

                                  ┌────────┐
                                  │   S3   │
                                  └────────┘

OPTS.fetchData.FETCH_KEY          #PARAMS. See middy doc for more info, including the other OPTS.*
                                  #Performs GetObject(PARAMS)
                                  #FETCH_RES is OBJECT contents:
                                  #  - STR
                                  #  - JSON_VAL: if Content-Type: application/[...+]json[;...] [S]
                                  #CACHE_KEY is 's3'

                                  ┌─────────────┐
                                  │   MEMOIZE   │
                                  └─────────────┘

@middy/util                       #
processCache
 (OPTS, CFUNC(VAL2)->VAL, VAL2)   #Memoize CFUNC and call it
 ->CACHE_RES                      #VAL2 is any value, bound to CFUNC

CACHE_RES.value                   #VAL returned by CFUNC

OPTS.cacheKey                     #'CACHE_KEY'. Each CFUNC must have a different one

OPTS.cacheExpiry                  #How long to cache, either:
OPTS.cacheKeyExpiry.CACHE_KEY     #  - NUM (max 1d): duration in ms
                                  #  - DATE_NUM: Unix timestamp in ms
                                  #  - 0 (def ???): does not get|set cache
                                  #  - -1: does not set cache, but get it even if expired
                                  #     - i.e. used to cache but never expire
                                  #If NUM (not DATE_NUM):
                                  #  - refreshes every NUMms, calling CFUNC again
                                  #  - stops refreshing if modifyCache|clearCache() called
CACHE_RES.expiry                  #DATE_NUM

getCache('CACHE_KEY')->CACHE_RES  #Get cache, without calling CFUNC
                                  #If not cached, returns empty OBJ
modifyCache('CACHE_KEY', OBJ)     #Set cached VAL as {...OBJ, ...CFUNC(VAL2, OBJ)}
                                  #Only if already cached
                                  #CFUNC is only called in next processCache()
clearCache(['CACHE_KEY'[_ARR]])   #Delete cache

                                  ┌────────────┐
                                  │   CLIENT   │
                                  └────────────┘

createClient(OPTS, INFO)->>CLIENT #Create a new AWS CLIENT
OPTS.AwsClient                    #SERVICEClient
OPTS.awsClientOptions             #COPTS
OPTS.awsClientAssumeRole          #'VAR'. Uses MIDDY_CONTEXT.VAR CREDS_OBJ as COPTS.credentials
                                  #If set, must be called after @middy/sts
                                  #  - however, can be cached, i.e. only done on first REQ
OPTS.awsClientCapture             #FUNC(CLIENT)->CLIENT mapping it
                                  #Requires OPTS.disablePrefetch true

createPrefetchClient(OPTS)->CLIENT#Same but without OPTS.awsClientAssumeRole
                                  #I.e. must set OPTS.awsClientOptions.credentials
                                  #Since it does not rely on @middy/sts, can be called once at top-level

canPrefetch([OPTS])->BOOL         #Hints whether should use:
                                  #  - true (if no OPTS.awsClientAssumeRole): createPrefetchClient()
                                  #  - false (else): createClient()
OPTS.disablePrefetch              #BOOL (def: false). Make canPrefetch() always return false, i.e. always use createClient()

catchInvalidSignatureException    #If ERROR is due to invalid STS signature (including expiration), returns CLIENT.send(COMMAND)
 (ERROR, CLIENT, COMMAND)->>RESP  #Else, throw ERROR
                                  #Meant to retry a COMMAND on transient STS error:
                                  #  try {
                                  #    return await CLIENT.send(COMMAND)
                                  #  } catch (error) {
                                  #    return await catchInvalidSignatureException(error, CLIENT, COMMAND)
                                  #  }

                                  ┌─────────────────────────┐
                                  │   CONTENT NEGOTIATION   │
                                  └─────────────────────────┘

@middy/http-content-negotiation   #
HTTP-CONTENT-NEGOTIATION
 ([OPTS])->MIDDY_MDWR             #

OPTS.parseCharsets                #BOOL (def: true). Whether to set NCONTEXT.preferredCharset[s]
OPTS.availableCharsets            #'CHARSET'_ARR (def: any). Only allow those ones
NCONTEXT.preferredCharsets        #'CHARSET'_ARR to use in response, based on Accept-Charset [C]
                                  #Sorted from highest to lowest priority
                                  #Does not set RES
                                  #  - instead, other MIDDY_MDWRs (e.g. @middy/http-content-encoding) must use NCONTEXT.preferredCharset[s]
NCONTEXT.preferredCharset         #Same as:
                                  #  - NCONTEXT.preferredCharsets[0]
                                  #  - if undefined: OPTS.availableCharsets[0]
                                  #     - only if OPTS.defaultToFirstCharset true (def: false)
OPTS.failOnMismatch               #BOOL (def: true). Throw 406 if NCONTEXT.preferredCharset undefined

OPTS.parseEncodings
 |availableEncodings
 |defaultToFirstEncoding          #Same with Accept-Encoding [C] and NCONTEXT.preferredEncoding[s]

OPTS.parseLanguages
 |availableLanguages
 |defaultToFirstLanguage          #Same with Accept-Language [C] and NCONTEXT.preferredLanguage[s]

OPTS.parseMediaTypes
 |availableMediaTypes
 |defaultToFirstMediaType         #Same with Accept [C] and NCONTEXT.preferredMediaType[s]

                                  ┌─────────────────┐
                                  │   COMPRESSION   │
                                  └─────────────────┘

@middy/http-content-encoding      #
HTTP-CONTENT-ENCODING             #Compress response body, based on Accept-Encoding [C]
 ([OPTS])->MIDDY_MDWR             #Sets RES:
                                  #  - body STR
                                  #  - headers['Content-Encoding'] 'ALGO'
                                  #  - isBase64Encoded true
                                  #Do not compress if either:
                                  #  - no Accept-Encoding [C]
                                  #  - compressed size is bigger
                                  #Works with Middy streamifyResponse
                                  #Must register @middy/http-content-negotiation before (see its doc)
                                  #  - since it relies on NCONTEXT.preferredEncoding[s]

ALGO                              #'deflate', 'gzip' or 'br'
OPTS.overridePreferredEncoding    #'ALGO'_ARR. If set, use first ALGO that is also present in NCONTEXT.preferredEncodings
                                  #If not set, use NCONTEXT.preferredEncoding

OPTS.deflate|gzip|br              #OBJ passed to node:zlib create*Compress(OBJ)

                                  ┌──────────┐
                                  │   CORS   │
                                  └──────────┘

@middy/http-cors                  #
HTTP-CORS([OPTS])->MIDDY_MDWR     #
