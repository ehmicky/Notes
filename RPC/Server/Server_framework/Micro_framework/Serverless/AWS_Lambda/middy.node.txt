
                                  ┏━━━━━━━━━━━┓
                                  ┃   MIDDY   ┃
                                  ┗━━━━━━━━━━━┛

VERSION ==>                       #6.0.0-alpha.0

GOAL ==>                          #Server middleware for AWS Lambda

                                  ┌──────────┐
                                  │   CORE   │
                                  └──────────┘

@middy/core                       #Package name
@types/aws-lambda                 #Required with TypeScript

MIDDY([MIDDY_OPTS])->MHANDLER     #Wraps Lambda HANDLER(REQ, NCONTEXT)->>RES (def: noop)
MHANDLER.handler(HANDLER)         #[Re-]set HANDLER
 ->MHANDLER                       #By convention, and for better TypeScript types, should be called last
                                  #  - i.e. after MHANDLER.use|before|after|onError()

                                  ┌────────────────┐
                                  │   MIDDLEWARE   │
                                  └────────────────┘

MHANDLER.use(MIDDY_MDWR[_ARR])    #MIDDY_MDWR: before STEP, after STEP, onError STEP
 ->MHANDLER                       #Calls MHANDLER.before|after|onError()
                                  #MIDDY_MDWR is often created through some FUNC(OPTs)->MIDDY_MDWR[_ARR]
                                  #Public libraries should prefer exporting MIDDY_MDWRs
                                  #  - STEPs ("inline middleware") are more meant as a shortcut for private code
                                  #Unless documented otherwise, my documentation for public MDWRs assumes:
                                  #  - main logic is run in 'before' STEP
                                  #  - cleanup is run in 'after|onError' STEP

MHANDLER.before(STEP)->MHANDLER   #Called before HANDLER

MHANDLER.after(STEP)->MHANDLER    #Called after HANDLER (unless it threw)

MHANDLER.onError(STEP)->MHANDLER  #Called if any of the following throws:
                                  #  - HANDLER
                                  #     - including MIDDY_OPTS.before|afterHandler()
                                  #  - 'before|after' STEPs
                                  #     - including their MIDDY_OPTS.before|afterMiddleware()
                                  #  - MIDDY_OPTS.timeoutEarlyResponse()
                                  #Also, not of the above is run anymore
                                  #Exception is still propagated
                                  #Not called if MIDDY_OPTS.beforePrefetch|requestStart|requestEnd() throws
                                  #If an 'onError' STEP throws:
                                  #  - further 'onError' STEPs are not run
                                  #  - its exception is thrown instead
                                  #     - original exception available as ERROR.originalError
                                  #MIDDY_OPTS.requestEnd() is always run, regardless of exceptions
                                  #  - providing MIDDY_OPTS.requestStart() has ended and did not throw

                                  ┌──────────┐
                                  │   STEP   │
                                  └──────────┘

FUNC(MIDDY_REQ)[->[>]RES]         #STEP
                                  #Ordered: first registered is first run ('before' STEP) or last run ('after|onError' STEP)

EARLY RESPONSE ==>                #If RES is returned:
                                  #  - no more STEP is run
                                  #  - if 'before' STEP: HANDLER not run
                                  #  - if 'onError' STEP: exception not thrown|propagated
                                  #  - RES is returned from MHANDLER
                                  #To do an early response with RES undefined:
                                  #  - set MIDDY_SET.earlyResponse = undefined instead
                                  #  - same behavior, except if 'onError STEP': exception thrown|propagated instead
                                  #Skipping 'after|onError' STEPs prevents proper cleanup. I.e. either:
                                  #  - avoid early response
                                  #  - manually call any relevant cleanup logic from other MDWRs before doing the early response
@aws-lambda-powertools/commons
cleanupMiddlewares()              #To call when doing an early response, to cleanup any @aws-lambda-powertools/*
                                  #Documented in their respective doc

MIDDY_REQ.event                   #REQ
MIDDY_REQ.context                 #NCONTEXT
MIDDY_REQ.response                #RES returned by HANDLER
                                  #Only set in:
                                  #  - 'after' STEP
                                  #  - MIDDY_OPTS.requestEnd(), if HANDLER did not throw
MIDDY_REQ.earlyResponse           #If no early response, not defined
                                  #If early response, same as MIDDY_REQ.response
                                  #  - which can be undefined
MIDDY_REQ.error                   #Exception VAL
                                  #Only set in:
                                  #  - 'onError' STEP
                                  #  - MIDDY_OPTS.requestEnd(), if HANDLER threw

                                  ┌───────────┐
                                  │   HOOKS   │
                                  └───────────┘

MIDDY_OPTS.beforePrefetch()       #On MIDDY() call

MIDDY_OPTS.requestStart()         #On MHANDLER() start
MIDDY_OPTS.beforeHandler()        #On HANDLER() start
MIDDY_OPTS.afterHandler()         #On HANDLER() end (excluding throwing)
MIDDY_OPTS
 .requestEnd(MIDDY_REQ)[->>]      #On MHANDLER() end (including throwing)

MIDDY_OPTS.beforeMiddleware(STR)  #Before each STEP. STR is its FUNC.name
MIDDY_OPTS.afterMiddleware(STR)   #After each STEP. STR is its FUNC.name

PLUGIN                            #FUNC([PLUGIN_OPTS])->MIDDY_OPTS (usually hooks)
                                  #However, currently:
                                  #  - not fully documented
                                  #  - can only use one PLUGIN at once
                                  #Some builtin PLUGINs exist
                                  #  - to measure:
                                  #     - duration
                                  #     - memory
                                  #     - PROMISEs started but not stopped
                                  #  - before|after the MHANDLER, HANDLER or each STEP
                                  #  - but not published to npm right now
                                  #  - i.e. can only use through copy-paste from source code

                                  ┌───────────┐
                                  │   STATE   │
                                  └───────────┘

MIDDY_OPTS|MIDDY_REQ.internal     #MIDDY_CONTEXT (def: {})
                                  #OBJ to pass information between STEPs, MDWRs and HANDLER
                                  #Keys should be camelCase'd, with only :alnum:

@middy/util                       #
getInternal(VAL, MIDDY_REQ)->>OBJ #Returns, according to VAL:
                                  #  - true -> MIDDY_CONTEXT
                                  #  - 'VARR'[_ARR] -> { VARR: MIDDY_CONTEXT.VARR, ... }
                                  #  - { KEY: 'VARR' } -> { KEY: MIDDY_CONTEXT.VARR, ... }
                                  #VARR:
                                  #  - can include .VAR or .NUM
                                  #  - resolves to undefined if any parent key missing
                                  #OBJ keys are normalized:
                                  #  - start with NUM -> _NUM
                                  #  - non-:alnum: character -> _
                                  #Top-level MIDDY_CONTEXT.* PROMISEs are resolved
                                  #  - exceptions are propagated, aggregated as ERROR.cause.data EXCEPTION_ARR
                                  #  - however, to avoid unhandled rejections, should make sure they either:
                                  #     - cannot be rejected
                                  #     - cannot resolve before getInternal() is called

                                  ┌─────────────┐
                                  │   TIMEOUT   │
                                  └─────────────┘

MIDDY_OPTS.timeoutEarlyInMillis   #NUM (in ms, def: 5)
                                  #Time out the HANDLER NUMms before the INVOCATION itself times out (NCONTEXT.getRemainingTimeInMillis())
                                  #'after|onError' STEPs and MIDDY_OPTS.* hooks are still run
                                  #  - NUM should be high enough for this logic to run

MIDDY_OPTS.timeoutEarlyResponse   #FUNC()->RES used instead of HANDLER when it times out
                                  #Def: throw an ERROR with name 'TimeoutError' and cause.package '@middy/core'

{signal: ABORT_SIGNAL}            #Passed as third argument to HANDLER
                                  #Aborted on HANDLER timeout
                                  #When HANDLER times out, it is short-circuited with Promise.race(), but it still runs
                                  #I.e. must use that ABORT_SIGNAL to interrupt any ongoing logic on timeout

                                  ┌───────────────┐
                                  │   STREAMING   │
                                  └───────────────┘

MIDDY_OPTS.streamifyResponse      #BOOL (def: false). When using FUNC_URL.InvokeMode 'RESPONSE_STREAM' (see Lambda doc)
                                  #Use awslambda.streamifyResponse() and awslambda.HttpResponseStream.from() under-the-hood

FUNC(REQ, NCONTEXT)
 ->>RES_OBJ[.body]                #Must be used as HANDLER instead

RES_OBJ.body                      #ISTREAM|STR (def: '')

RES_OBJ.statusCode                #NUM. Required if returning REQ_OBJ.body, else def 200
RES_OBJ.headers                   #OBJ
RES_OBJ.cookies                   #'VAR=VAL[;...]'_ARR

                                  ┌───────────┐
                                  │   ERROR   │
                                  └───────────┘

@middy/util                       #
createError(STATUS_NUM
 [, 'MESSAGE'][, ERROR_OPTS])
 ->ERROR
new HttpError(STATUS_NUM
 [, 'MESSAGE'][, ERROR_OPTS])     #MIDDY_HTTP_ERROR

ERROR.name                        #STATUS-NUM-specific, e.g. 'NoContentError' for 204
ERROR.message                     #Def: STATUS_NUM-specific, e.g. 'No Content' for 204
                                  #Meant to use as error response body

ERROR.status[Code]                #STATUS_NUM
                                  #Meant to use as error response status

ERROR.headers                     #HEADERS_OBJ. Must be manually set
                                  #Meant to use as error response headers

ERROR[_OPTS].expose               #BOOL (def: false if STATUS_NUM 5**)
                                  #Hint whether should be sent in error response

ERROR_OPTS.*                      #Passed to Error, e.g. cause, etc.

                                  ┌───────────────────────┐
                                  │   NORMALIZE REQUEST   │
                                  └───────────────────────┘

@middy/http-event-normalizer      #
EVENT-NORMALIZER()->MIDDY_MDWR    #Normalizes REQ:
                                  #  - default empty OBJ for REQ.pathParameters|[multiValue]QueryStringParameters
                                  #  - camelCase for REQ.query_string_parameters|is_base64_encoded (like VPC)

@middy/event-normalizer           #
EVENT-NORMALIZER([OPTS])          #Normalize REQ
 ->MIDDY_MDWR                     #Mostly decoding: JSON, base64, URL encoding, etc.
                                  #SERVICE-specific, documented in each SERVICE

@middy/http-header-normalizer     #
HEADER-NORMALIZER([OPTS])
 ->MIDDY_MDWR                     #Normalize REQ.headers|multiValueHeaders
REQ.rawHeaders
 |rawMultiValueHeaders            #REQ.headers|multiValueHeaders before normalization
OPTS.defaultHeaders               #Default HEADERS_OBJ (def: {})
OPTS.normalizeHeaderKey           #FUNC('HEADER')->'HEADER' (def: make lowercase)
                                  #Normalize 'HEADER' name
OPTS.canonical                    #BOOL (def: false). Use Sentence-Case instead
                                  #If OPTS.normalizeHeaderKey is customized:
                                  #  - that behavior does not happen
                                  #  - but OPTS.canonical is passed as second argument

                                  ┌────────────────────────┐
                                  │   NORMALIZE RESPONSE   │
                                  └────────────────────────┘

@middy/util                       #
normalizeHttpResponse(MIDDY_REQ)  #Normalizes MIDDY_REQ.response RES:
 ->RES                            #  - undefined -> {}
                                  #  - STR -> {statusCode: 200, body: STR}
                                  #  - def RES.statusCode: 500
                                  #  - def RES.headers: {}
                                  #Directly mutates MIDDY_REQ.response, then returns it

                                  ┌─────────────────────────────┐
                                  │   REQUEST PATH PARAMETERS   │
                                  └─────────────────────────────┘

@middy/http-urlencode-path-parser #
PATH-PARSER()->MIDDY_MDWR         #decodeURIComponent() on REQ.pathParameters.*

                                  ┌─────────────────────┐
                                  │   REQUEST COOKIES   │
                                  └─────────────────────┘

middy-aws-cookie-parser           #Version 0.0.1
COOKIE-PARSER()->MIDDY_MDWR       #Sets REQ.cookies COOKIE_OBJ, using cookie parse() (see its doc0)
                                  #Uses either REQ.cookies ARR or REQ.headers.Cookie STR, e.g. set in API Gateway v1|v2

                                  ┌───────────────────────┐
                                  │   REQUEST BODY JSON   │
                                  └───────────────────────┘

@middy/http-json-body-parser      #
JSON-BODY-PARSER([OPTS])          #JSON parses REQ.body
 ->MIDDY_MDWR                     #If REQ.isBase64Encoded true, also base64 decode
                                  #On parsing error: MIDDY_HTTP_ERROR 415 with ERROR.cause.data INNER_ERROR

OPTS.reviver                      #FUNC (def: none) passed to JSON.parse(VAL, FUNC)

OPTS.disableContentTypeError      #BOOL. If false (def), fails if Content-Type [C] is not 'application/[...+]json[;...]'
                                  #Throw MIDDY_HTTP_ERROR 415 with ERROR.cause.data 'MIME'

@middy/ws-json-body-parser        #Same except:
                                  #  - no OPTS.disableContentTypeError nor Content-Type [C] checking
                                  #  - on parsing error: 422 instead

                                  ┌─────────────────────────────┐
                                  │   REQUEST BODY URLENCODED   │
                                  └─────────────────────────────┘

@middy/http-urlencode-body-parser #
URL-BODY-PARSER([OPTS])           #parse(REQ.body) using node:querystring parse() (see its doc)
 ->MIDDY_MDWR                     #If REQ.isBase64Encoded true, also base64 decode
                                  #On parsing error: MIDDY_HTTP_ERROR 415

OPTS.disableContentTypeError      #BOOL. If false (def), fails if Content-Type [C] is not 'application/x-www-form-urlencoded[;...]'
                                  #Throw MIDDY_HTTP_ERROR 415 with ERROR.cause.data 'MIME'

                                  ┌────────────────────────────┐
                                  │   REQUEST BODY MULTIPART   │
                                  └────────────────────────────┘

@middy/http-multipart-body-parser #
MULTIPART-BODY-PARSER([OPTS])     #Parse multipart/data for REQ.body using BUSBOY
 ->MIDDY_MDWR                     #If REQ.isBase64Encoded true, also base64 decode
                                  #On parsing error: MIDDY_HTTP_ERROR 415 with ERROR.cause.data INNER_ERROR

REQ.body.NAME                     #Either FILE[_ARR] or 'FIELD_CONTENTS'[_ARR]
FILE.filename                     #'FILE'
FILE.mimetype                     #'MIME' from FILE's Content-Type
FILE.content                      #BUFFER
FILE.encoding                     #'ENCODING' of BUFFER, from FILE's Content-Transfer-Encoding
FILE.truncated                    #BOOL

OPTS.disableContentTypeError      #BOOL. If false (def), fails if Content-Type [C] is not 'multipart/form-data[;...]'
                                  #Throw MIDDY_HTTP_ERROR 415 with ERROR.cause.data 'MIME'

OPTS.encoding                     #'ENCODING' (def: 'utf8') of input

OPTS.busboy                       #BUSBOY_OPTS (def: {})
                                  #Cannot set BUSBOY_OPTS.headers, which always uses Content-Type [C]

                                  ┌─────────────────────────────┐
                                  │   RESPONSE BODY SERIALIZE   │
                                  └─────────────────────────────┘

@middy/http-response-serializer   #
RESPONSE-SERIALIZER([OPTS])       #Serializes RES
 ->MIDDY_MDWR                     #Uses normalizeHttpResponse()
                                  #Done in 'after|onError' STEPs

OPTS.serializers                  #SERIALIZER_ARR, from highest to lower priority

SERIALIZER.regex                  #REGEXP applied on MIME
                                  #MIME is from Content-Type [C], which must have been previously parsed by @middy/http-content-negotiation
                                  #Matched MIME is set as Content-Type [S]
OPTS.defaultContentType           #'MIME' (def: none) used if none matches

SERIALIZER.serializer             #FUNC(RES)->RES[.body]

                                  ┌────────────────────────┐
                                  │   RESPONSE WEBSOCKET   │
                                  └────────────────────────┘

@middy/ws-response                #
WS-RESPONSE([OPTS])->MIDDY_MDWR   #Calls WebSocket API Gateway PostToConnection()
                                  #Calls it once, then sends empty 200
                                  #Done in 'after' STEP

RES[.Data]                        #WS_MESSAGE
RES.ConnectionId                  #'CONNECTION_MID'
                                  #Def: REQ.requestContext.connectionId (if none, noop)

OPTS.awsClient*|disablePrefetch   #See below
OPTS.awsClientOptions.endpoint    #Def: 'https://DNAME/STAGE' using REQ.requestContext.domainName|stage

                                  ┌──────────────────┐
                                  │   COMMAND MAIN   │
                                  └──────────────────┘

OPTS.fetchData.FETCH_KEY          #PARAMS. Call a specific COMMAND for a given AWS SERVICE
                                  #Common pattern for multiple builtin SERVICE-specific MDWRs, created as FUNC(OPTS)->MIDDY_MDWR
                                  #The specific COMMAND and FETCH_RES are documented in each SERVICE

NCONTEXT.FETCH_KEY                #FETCH_RES. COMMAND's RESP, mapped

MIDDY_CONTEXT.FETCH_KEY           #FETCH_RES_PROMISE. Same but as PROMISE

OPTS.setToContext                 #BOOL. Whether to set NCONTEXT.FETCH_KEY:
                                  #  - true:
                                  #     - COMMAND is awaited by MDWR itself, i.e. serial|foreground
                                  #     - COMMANDs within same MDWR are still run in parallel
                                  #  - false (def)
                                  #     - must use MIDDY_CONTEXT.FETCH_KEY
                                  #     - COMMAND is not awaited by MDWR, i.e. parallel|background
                                  #     - it will be awaited instead by the next MDWR or HANDLER that retrieves FETCH_RES using getInternal()
                                  #     - more efficient, but requires more care to avoid unhandled rejected promise

TYPE_FUNC(PARAMS)->PARAMS         #Identity FUNC, which must wrap OPTS.fetchData.FETCH_KEY
                                  #Its name is SERVICE-specific (some don't have any) and usually start with 'SERVICE'
                                  #It does nothing runtime, but sets the right TypeScript types for NCONTEXT|MIDDY_CONTEXT.FETCH_KEY

                                  ┌───────────────────┐
                                  │   COMMAND ERROR   │
                                  └───────────────────┘

COMMAND ERRORS ==>                #If COMMAND has an STS signature error, it is retried once
                                  #Else, any exception is propagated

UNHANDLED REJECTED PROMISE ==>    #Can happen if the COMMAND throws, since it is not awaited right away
                                  #This happens if the failure happens before FETCH_RES is retrieved
                                  #Can be solved by either:
                                  #  - using OPTS.setToContext true
                                  #  - using synchronous or no MDWRs in-between
                                  #  - not refreshing cache, i.e. not using OPTS.cacheExpiry
                                  #     - then, it can still happen, but only once at FUNC_INSTANCE's first REQ

                                  ┌───────────────────┐
                                  │   COMMAND CACHE   │
                                  └───────────────────┘

CACHE ==>                         #FETCH_RES is cached
                                  #Cache is invalidated if COMMAND fails

OPTS.cacheKey                     #'CACHE_KEY'. Def: 'SERVICE'
                                  #I.e. unless set, all MDWRs of same SERVICE share the cache
                                  #I.e. should be set if using 2+ MDWRs with same SERVICE but different OPTS.fetchData

OPTS.cacheExpiry                  #How long to cache, either:
OPTS.cacheKeyExpiry.CACHE_KEY     #  - -1 (def): forever
                                  #  - 0: never
                                  #  - NUM (max 1d): duration in ms
                                  #  - DATE_NUM: Unix timestamp in ms
                                  #If NUM (not DATE_NUM): refreshes every NUMms, calling COMMAND again

                                  ┌────────────────────┐
                                  │   COMMAND CLIENT   │
                                  └────────────────────┘

OPTS.awsClientOptions             #COPTS passed to the CLIENT

OPTS.awsClientAssumeRole          #'FETCH_KEY' (from @middy/sts). Sets COPTS.credentials
                                  #If set, MDWR must be placed after @middy/sts

OPTS.awsClientCapture             #FUNC(CLIENT)->CLIENT mapping it
                                  #Requires OPTS.disablePrefetch true

OPTS.disablePrefetch              #BOOL. Whether to create CLIENT during MDWR init (false, def) or 'before' STEP (true)
                                  #Always true if OPTS.awsClientAssumeRole set
                                  #Regardless, CLIENT is always created only once per FUNC_INSTANCE

                                  ┌─────────────┐
                                  │   MEMOIZE   │
                                  └─────────────┘

@middy/util                       #
processCache                      #Memoize CFUNC and call it
 (OPTS, CFUNC(VAL2)->VAL, VAL2)   #VAL2 is any value, bound to CFUNC
 ->CACHE_RES                      #Meant for memoization that refreshes at regular intervals
                                  #Used under-the-hood by OPTS.fetchData (see example usage in @middy/s3 code)

CACHE_RES.value                   #VAL returned by CFUNC
CACHE_RES.expiry                  #DATE_NUM

OPTS.cacheKey                     #'CACHE_KEY' (no default)
OPTS.cacheExpiry
OPTS.cacheKeyExpiry.CACHE_KEY     #Same as above, except def 0

getCache('CACHE_KEY')->CACHE_RES  #Get cache, without calling CFUNC
                                  #If not cached, returns empty OBJ
modifyCache('CACHE_KEY', OBJ)     #Set cached VAL as {...OBJ, ...CFUNC(VAL2, OBJ)}
                                  #Only if already cached
                                  #CFUNC is only called in next processCache()
                                  #Stops caching refreshing
                                  #Meant to invalid cache
clearCache(['CACHE_KEY'[_ARR]])   #Delete cache
                                  #Stops caching refreshing

                                  ┌────────────┐
                                  │   CLIENT   │
                                  └────────────┘

CLIENT ==>                        #The following is mostly meant to create public MDWRs, i.e. otherwise not useful
                                  #Used under-the-hood by OPTS.fetchData (see example usage in @middy/s3 code)

@middy/util                       #
createClient(OPTS, MIDDY_REQ)
 ->>CLIENT                        #Same as new SERVICEClient(COPTS)
OPTS.AwsClient                    #SERVICEClient
OPTS.awsClientOptions
OPTS.awsClientCapture             #Same as above
OPTS.awsClientAssumeRole          #Same as above. If set, must be called after @middy/sts
                                  #However, can be cached, e.g. only done on first REQ

createPrefetchClient(OPTS)->CLIENT#Same as createClient() but without OPTS.awsClientAssumeRole
                                  #I.e. must set OPTS.awsClientOptions.credentials
                                  #Since it does not rely on @middy/sts, can be called once at top-level

canPrefetch([OPTS])->BOOL         #Whether OPTS.awsClientAssumeRole is undefined
                                  #Meant to use a condition on whether to use createClient() or createPrefetchClient()
OPTS.disablePrefetch              #BOOL (def: false). Make canPrefetch() always return false, i.e. always use createClient()

catchInvalidSignatureException    #If ERROR is due to invalid STS signature (including expiration), returns CLIENT.send(COMMAND)
 (ERROR, CLIENT, COMMAND)->>RESP  #Else, throw ERROR
                                  #Meant to retry a COMMAND on transient STS error:
                                  #  try {
                                  #    return await CLIENT.send(COMMAND)
                                  #  } catch (error) {
                                  #    return await catchInvalidSignatureException(error, CLIENT, COMMAND)
                                  #  }

                                  ┌─────────────────────────┐
                                  │   CONTENT NEGOTIATION   │
                                  └─────────────────────────┘

@middy/http-content-negotiation   #
HTTP-CONTENT-NEGOTIATION
 ([OPTS])->MIDDY_MDWR             #

OPTS.parseCharsets                #BOOL (def: true). Whether to set NCONTEXT.preferredCharset[s]
OPTS.availableCharsets            #'CHARSET'_ARR (def: any). Only allow those ones
NCONTEXT.preferredCharsets        #'CHARSET'_ARR to use in response, based on Accept-Charset [C]
                                  #Sorted from highest to lowest priority
                                  #Does not set RES
                                  #  - instead, other MIDDY_MDWRs (e.g. @middy/http-content-encoding) must use NCONTEXT.preferredCharset[s]
NCONTEXT.preferredCharset         #Same as:
                                  #  - NCONTEXT.preferredCharsets[0]
                                  #  - if undefined: OPTS.availableCharsets[0]
                                  #     - only if OPTS.defaultToFirstCharset true (def: false)
OPTS.failOnMismatch               #BOOL (def: true). Throw 406 if NCONTEXT.preferredCharset undefined

OPTS.parseEncodings
 |availableEncodings
 |defaultToFirstEncoding          #Same with Accept-Encoding [C] and NCONTEXT.preferredEncoding[s]

OPTS.parseLanguages
 |availableLanguages
 |defaultToFirstLanguage          #Same with Accept-Language [C] and NCONTEXT.preferredLanguage[s]

OPTS.parseMediaTypes
 |availableMediaTypes
 |defaultToFirstMediaType         #Same with Accept [C] and NCONTEXT.preferredMediaType[s]

                                  ┌────────────┐
                                  │   WARMUP   │
                                  └────────────┘

@middy/warmup                     #
WARMUP([OPTS])->MIDDY_MDWR        #Make a dummy ('warmup') early response for specific requests
                                  #Meant for requests made at regular intervals to avoid cold start

OPTS.isWarmingUp                  #FUNC(REQ)->BOOL
                                  #Def: if REQ.source 'serverless-plugin-warmup', which is a Serverless plugin for that purpose

                                  ┌────────────────┐
                                  │   VALIDATION   │
                                  └────────────────┘

@middy/validator                  #
VALIDATOR([OPTS])->MIDDY_MDWR     #Validates REQ|RES

OPTS.eventSchema                  #FUNC(REQ)->[>]BOOL (def: none)
                                  #If returns false, throws MIDDY_ERROR 400
                                  #Done in 'before' STEP
OPTS.contextSchema                #FUNC(NCONTEXT)->[>]BOOL (def: none)
                                  #If returns false, throws MIDDY_ERROR 500
                                  #Done in 'before' STEP
OPTS.responseSchema               #FUNC(RES)->[>]BOOL (def: none)
                                  #If returns false, throws MIDDY_ERROR 500
                                  #Done in 'after' STEP

ERROR.cause.data                  #FUNC.errors from OPTS.*Schema FUNC
                                  #I.e. if FUNC() returns false, should set FUNC.errors OBJ_ARR
OPTS.languages.LANG               #FUNC(OBJ_ARR) called on ERROR.cause.data
                                  #Meant to mutate OBJ_ARR based on language
                                  #Def: none
OPTS.defaultLanguage              #'LANG' used by OPTS.languages.*
                                  #Def: NCONTEXT.preferredLanguage (from @middy/http-content-negotiation), or 'en'

                                  ┌─────────────┐
                                  │   TO SORT   │
                                  └─────────────┘

LOGGING ==>                       #See @aws-lambda-powertools/logger
IDEMPOTENCY ==>                   #See @aws-lambda-powertools/idempotency
CLOUDWATCH EMBEDDED METRICS ==>   #See @aws-lambda-powertools/metrics and aws-embedded-metrics
RESPONSE BODY FILTERING ==>       #See @middy/http-partial-response doc, in json-mask doc
REQUEST LOGGING ==>               #See @middy/http-input-output-logger doc
ERROR HANDLING|LOGGING ==>        #See @middy/error-handler doc
ROUTER ==>                        #See @middy/http-router doc
STS ASSUMEROLE ==>                #See @middy/sts doc, in STS doc
S3 GETOBJECT ==>                  #See @middy/s3 doc, in S3 doc
CORS ==>                          #See @middy/cors doc
SECURITY HEADERS ==>              #See @middy/http-security-headers doc
