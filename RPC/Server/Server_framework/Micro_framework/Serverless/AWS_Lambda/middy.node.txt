
                                  ┏━━━━━━━━━━━┓
                                  ┃   MIDDY   ┃
                                  ┗━━━━━━━━━━━┛

VERSION ==>                       #5.5.0

GOAL ==>                          #Server middleware for AWS Lambda

                                  ┌──────────┐
                                  │   CORE   │
                                  └──────────┘

@middy/core                       #Package name
@types/aws-lambda                 #Required with TypeScript

MIDDY([OPTS])->MHANDLER           #Wraps Lambda HANDLER(REQ, NCONTEXT)->>RES (def: noop)
MHANDLER.handler(HANDLER)         #[Re-]set HANDLER
 ->MHANDLER                       #By convention, and for better TypeScript types, should be called last
                                  #  - i.e. after MHANDLER.use|before|after|onError()

                                  ┌────────────────┐
                                  │   MIDDLEWARE   │
                                  └────────────────┘

MHANDLER.use(MIDDY_MDWR[_ARR])    #MIDDY_MDWR: before STEP, after STEP, onError STEP
 ->MHANDLER                       #Calls MHANDLER.before|after|onError()
                                  #MIDDY_MDWR is often created through some FUNC(OPTs)->MIDDY_MDWR[_ARR]
                                  #Public libraries should prefer exporting MIDDY_MDWRs
                                  #  - STEPs ("inline middleware") are more meant as a shortcut for private code
                                  #Unless documented otherwise, my documentation for public MDWRs assumes:
                                  #  - main logic is run in 'before' STEP
                                  #  - cleanup is run in 'after|onError' STEP

MHANDLER.before(STEP)->MHANDLER   #Called before HANDLER

MHANDLER.after(STEP)->MHANDLER    #Called after HANDLER (unless it threw)

MHANDLER.onError(STEP)->MHANDLER  #Called if any of the following throws:
                                  #  - HANDLER
                                  #     - including OPTS.before|afterHandler()
                                  #  - 'before|after' STEPs
                                  #     - including their OPTS.before|afterMiddleware()
                                  #  - OPTS.timeoutEarlyResponse()
                                  #Also, not of the above is run anymore
                                  #Exception is still propagated
                                  #Not called if OPTS.beforePrefetch|requestStart|requestEnd() throws
                                  #If an 'onError' STEP throws:
                                  #  - further 'onError' STEPs are not run
                                  #  - its exception is thrown instead
                                  #     - original exception available as ERROR.originalError
                                  #OPTS.requestEnd() is always run, regardless of exceptions
                                  #  - providing OPTS.requestStart() has ended and did not throw

                                  ┌──────────┐
                                  │   STEP   │
                                  └──────────┘

FUNC(MIDDY_REQ)[->[>]RES]         #STEP
                                  #Ordered: first registered is first run ('before' STEP) or last run ('after|onError' STEP)

EARLY RETURN ==>                  #If RES is returned:
                                  #  - no more STEP is run
                                  #  - if 'before' STEP: HANDLER not run
                                  #  - if 'onError' STEP: exception not thrown|propagated
                                  #  - RES is returned from MHANDLER
                                  #Skipping 'after' STEPs prevents proper cleanup. I.e. either:
                                  #  - avoid early return
                                  #  - manually call any relevant cleanup logic from other MDWRs before doing the early return
@aws-lambda-powertools/commons
cleanupMiddlewares()              #To call when doing an early return, to cleanup any @aws-lambda-powertools/*
                                  #Documented in their respective doc

MIDDY_REQ.event                   #REQ
MIDDY_REQ.context                 #NCONTEXT
MIDDY_REQ.response                #RES returned by HANDLER
                                  #Only set in:
                                  #  - 'after' STEP
                                  #  - OPTS.requestEnd(), if HANDLER did not throw
MIDDY_REQ.error                   #Exception VAL
                                  #Only set in:
                                  #  - 'onError' STEP
                                  #  - OPTS.requestEnd(), if HANDLER threw

                                  ┌───────────┐
                                  │   HOOKS   │
                                  └───────────┘

OPTS.beforePrefetch()             #On MIDDY() call

OPTS.requestStart()               #On MHANDLER() start
OPTS.beforeHandler()              #On HANDLER() start
OPTS.afterHandler()               #On HANDLER() end (excluding throwing)
OPTS.requestEnd(MIDDY_REQ)[->>]   #On MHANDLER() end (including throwing)

OPTS.beforeMiddleware(STR)        #Before each STEP. STR is its FUNC.name
OPTS.afterMiddleware(STR)         #After each STEP. STR is its FUNC.name

                                  ┌───────────┐
                                  │   STATE   │
                                  └───────────┘

OPTS|MIDDY_REQ.internal           #MIDDY_CONTEXT (def: {})
                                  #OBJ to pass information between STEPs, MDWRs and HANDLER
                                  #Keys should be camelCase'd, with only :alnum:

@middy/util                       #
getInternal(VAL, MIDDY_REQ)->>OBJ #Returns, according to VAL:
                                  #  - true -> MIDDY_CONTEXT
                                  #  - 'VARR'[_ARR] -> { VARR: MIDDY_CONTEXT.VARR, ... }
                                  #  - { KEY: 'VARR' } -> { KEY: MIDDY_CONTEXT.VARR, ... }
                                  #VARR:
                                  #  - can include .VAR or .NUM
                                  #  - resolves to undefined if any parent key missing
                                  #OBJ keys are normalized:
                                  #  - start with NUM -> _NUM
                                  #  - non-:alnum: character -> _
                                  #Top-level MIDDY_CONTEXT.* PROMISEs are resolved
                                  #  - exceptions are propagated, aggregated as ERROR.cause.data EXCEPTION_ARR
                                  #  - however, to avoid unhandled rejections, should make sure they either:
                                  #     - cannot be rejected
                                  #     - cannot resolve before getInternal() is called

                                  ┌─────────────┐
                                  │   TIMEOUT   │
                                  └─────────────┘

OPTS.timeoutEarlyInMillis         #NUM (in ms, def: 5)
                                  #Time out the HANDLER NUMms before the INVOCATION itself times out (NCONTEXT.getRemainingTimeInMillis())
                                  #'after|onError' STEPs and OPTS.* hooks are still run
                                  #  - NUM should be high enough for this logic to run

OPTS.timeoutEarlyResponse         #FUNC()->RES used instead of HANDLER when it times out
                                  #Def: throw an ERROR with name 'TimeoutError' and cause.package '@middy/core'

{signal: ABORT_SIGNAL}            #Passed as third argument to HANDLER
                                  #Aborted on HANDLER timeout
                                  #When HANDLER times out, it is short-circuited with Promise.race(), but it still runs
                                  #I.e. must use that ABORT_SIGNAL to interrupt any ongoing logic on timeout

                                  ┌───────────────┐
                                  │   STREAMING   │
                                  └───────────────┘

OPTS.streamifyResponse            #BOOL (def: false). When using FUNC_URL.InvokeMode 'RESPONSE_STREAM' (see Lambda doc)
                                  #Use awslambda.streamifyResponse() and awslambda.HttpResponseStream.from() under-the-hood

FUNC(REQ, NCONTEXT)
 ->>RES_OBJ[.body]                #Must be used as HANDLER instead

RES_OBJ.body                      #ISTREAM|STR (def: '')

RES_OBJ.statusCode                #NUM. Required if returning REQ_OBJ.body, else def 200
RES_OBJ.headers                   #OBJ
RES_OBJ.cookies                   #'VAR=VAL[;...]'_ARR

                                  ┌───────────┐
                                  │   ERROR   │
                                  └───────────┘

@middy/util                       #
createError(STATUS_NUM
 [, 'MESSAGE'][, ERROR_OPTS])
 ->ERROR
new HttpError(STATUS_NUM
 [, 'MESSAGE'][, ERROR_OPTS])     #MIDDY_HTTP_ERROR

ERROR.name                        #STATUS-NUM-specific, e.g. 'NoContentError' for 204
ERROR.message                     #Def: STATUS_NUM-specific, e.g. 'No Content' for 204
                                  #Meant to use as error response body

ERROR.status[Code]                #STATUS_NUM
                                  #Meant to use as error response status

ERROR.headers                     #HEADERS_OBJ. Must be manually set
                                  #Meant to use as error response headers

ERROR[_OPTS].expose               #BOOL (def: false if STATUS_NUM 5**)
                                  #Hint whether should be sent in error response

ERROR_OPTS.*                      #Passed to Error, e.g. cause, etc.

                                  ┌───────────────────┐
                                  │   ERROR HANDLER   │
                                  └───────────────────┘

@middy/error-handler              #
ERROR-HANDLER([OPTS])->MIDDY_MDWR #Main 'onError' STEP logic
                                  #Sets RES
                                  #Uses normalizeHttpResponse()
                                  #No early return, i.e. other 'onError' STEPs still run
                                  #Should be the last 'onError' STEP

EXCEPTION_VAL                     #MIDDY_REQ.error
                                  #Can be anything, but should try to use MIDDY_HTTP_ERROR
EXCEPTION_VAL.statusCode          #STATUS_NUM (def: 500). Used as RES.statusCode
EXCEPTION_VAL.headers             #HEADERS_OBJ (def: none). Merged to RES.headers (higher priority)
EXCEPTION_VAL.message             #'MESSAGE' (def: none). Used as RES.body
                                  #Also sets Content-Type [S] with either:
                                  #  - 'text/plain'
                                  #  - 'application/json' (guessed by trying to parse)
EXCEPTION_VAL.expose              #BOOL (def: false if EXCEPTION_VAL.statusCode 5**)
                                  #Always false if no EXCEPTION_VAL.statusCode
                                  #If false:
                                  #  - MIDDY_REQ.error transformed to an {statusCode, message} OBJ
                                  #  - RES.statusCode 500
                                  #  - RES.body OPTS.fallbackMessage (def: undefined)

OPTS.logger                       #FUNC(EXCEPTION_VAL) (def: console.error) or false, to call

                                  ┌───────────────────┐
                                  │   ERROR LOGGING   │
                                  └───────────────────┘

@middy/error-logger               #
ERROR-LOGGER([OPTS])->MIDDY_MDWR  #
OPTS.logger                       #FUNC(MIDDY_REQ) (def: console.error) or false
                                  #Called in 'onError' STEP
                                  #No early return, i.e. other 'onError' STEPs still run
                                  #Should be the first 'onError' STEP

                                  ┌───────────────────────┐
                                  │   NORMALIZE REQUEST   │
                                  └───────────────────────┘

@middy/http-event-normalizer      #
EVENT-NORMALIZER()->MIDDY_MDWR    #Normalizes REQ:
                                  #  - default empty OBJ for REQ.pathParameters|[multiValue]QueryStringParameters
                                  #  - camelCase for REQ.query_string_parameters|is_base64_encoded (like VPC)

@middy/event-normalizer           #
EVENT-NORMALIZER([OPTS])          #Normalize REQ
 ->MIDDY_MDWR                     #Mostly decoding: JSON, base64, URL encoding, etc.
                                  #SERVICE-specific, documented in each SERVICE

@middy/http-header-normalizer     #
HEADER-NORMALIZER([OPTS])
 ->MIDDY_MDWR                     #Normalize REQ.headers|multiValueHeaders
REQ.rawHeaders
 |rawMultiValueHeaders            #REQ.headers|multiValueHeaders before normalization
OPTS.defaultHeaders               #Default HEADERS_OBJ (def: {})
OPTS.normalizeHeaderKey           #FUNC('HEADER')->'HEADER' (def: make lowercase)
                                  #Normalize 'HEADER' name
OPTS.canonical                    #BOOL (def: false). Use Sentence-Case instead
                                  #If OPTS.normalizeHeaderKey is customized:
                                  #  - that behavior does not happen
                                  #  - but OPTS.canonical is passed as second argument

                                  ┌────────────────────────┐
                                  │   NORMALIZE RESPONSE   │
                                  └────────────────────────┘

@middy/util                       #
normalizeHttpResponse(MIDDY_REQ)  #Normalizes MIDDY_REQ.response RES:
 ->RES                            #  - undefined -> {}
                                  #  - STR -> {statusCode: 200, body: STR}
                                  #  - def RES.statusCode: 500
                                  #  - def RES.headers: {}
                                  #Directly mutates MIDDY_REQ.response, then returns it

                                  ┌─────────────────────────────┐
                                  │   REQUEST PATH PARAMETERS   │
                                  └─────────────────────────────┘

@middy/http-urlencode-path-parser #
PATH-PARSER()->MIDDY_MDWR         #decodeURIComponent() on REQ.pathParameters.*

                                  ┌───────────────────────┐
                                  │   REQUEST BODY JSON   │
                                  └───────────────────────┘

@middy/http-json-body-parser      #
JSON-BODY-PARSER([OPTS])          #JSON parses REQ.body
 ->MIDDY_MDWR                     #If REQ.isBase64Encoded true, also base64 decode
                                  #On parsing error: MIDDY_HTTP_ERROR 415 with ERROR.cause.data INNER_ERROR

OPTS.reviver                      #FUNC (def: none) passed to JSON.parse(VAL, FUNC)

OPTS.disableContentTypeError      #BOOL. If false (def), fails if Content-Type [C] is not 'application/[...+]json[;...]'
                                  #Throw MIDDY_HTTP_ERROR 415 with ERROR.cause.data 'MIME'

                                  ┌─────────────────────────────┐
                                  │   REQUEST BODY URLENCODED   │
                                  └─────────────────────────────┘

@middy/http-urlencode-body-parser #
URL-BODY-PARSER([OPTS])           #parse(REQ.body) using QS (see its doc)
 ->MIDDY_MDWR                     #If REQ.isBase64Encoded true, also base64 decode
                                  #On parsing error: MIDDY_HTTP_ERROR 415

OPTS.disableContentTypeError      #BOOL. If false (def), fails if Content-Type [C] is not 'application/x-www-form-urlencoded[;...]'
                                  #Throw MIDDY_HTTP_ERROR 415 with ERROR.cause.data 'MIME'

                                  ┌────────────────────────────┐
                                  │   REQUEST BODY MULTIPART   │
                                  └────────────────────────────┘

@middy/http-multipart-body-parser #
MULTIPART-BODY-PARSER([OPTS])     #Parse multipart/data for REQ.body using BUSBOY
 ->MIDDY_MDWR                     #If REQ.isBase64Encoded true, also base64 decode
                                  #On parsing error: MIDDY_HTTP_ERROR 415 with ERROR.cause.data INNER_ERROR

REQ.body.NAME                     #Either FILE[_ARR] or 'FIELD_CONTENTS'[_ARR]
FILE.filename                     #'FILE'
FILE.mimetype                     #'MIME' from FILE's Content-Type
FILE.content                      #BUFFER
FILE.encoding                     #'ENCODING' of BUFFER, from FILE's Content-Transfer-Encoding
FILE.truncated                    #BOOL

OPTS.disableContentTypeError      #BOOL. If false (def), fails if Content-Type [C] is not 'multipart/form-data[;...]'
                                  #Throw MIDDY_HTTP_ERROR 415 with ERROR.cause.data 'MIME'

OPTS.encoding                     #'ENCODING' (def: 'utf8') of input

OPTS.busboy                       #BUSBOY_OPTS (def: {})
                                  #Cannot set BUSBOY_OPTS.headers, which always uses Content-Type [C]

                                  ┌─────────────────────────────┐
                                  │   RESPONSE BODY SERIALIZE   │
                                  └─────────────────────────────┘

@middy/http-response-serializer   #
RESPONSE-SERIALIZER([OPTS])       #Serializes RES
 ->MIDDY_MDWR                     #Uses normalizeHttpResponse()
                                  #Done in 'after|onError' STEPs

OPTS.serializers                  #SERIALIZER_ARR, from highest to lower priority

SERIALIZER.regex                  #REGEXP applied on MIME
                                  #MIME is from Content-Type [C], which must have been previously parsed by @middy/http-content-negotiation
                                  #Matched MIME is set as Content-Type [S]
OPTS.defaultContentType           #'MIME' (def: none) used if none matches

SERIALIZER.serializer             #FUNC(RES)->RES[.body]

                                  ┌──────────────────┐
                                  │   COMMAND MAIN   │
                                  └──────────────────┘

OPTS.fetchData.FETCH_KEY          #PARAMS. Call a specific COMMAND for a given AWS SERVICE
                                  #Common pattern for multiple builtin SERVICE-specific MDWRs, created as FUNC(OPTS)->MIDDY_MDWR
                                  #The specific COMMAND and FETCH_RES are documented in each SERVICE

NCONTEXT.FETCH_KEY                #FETCH_RES. COMMAND's RESP, mapped

MIDDY_CONTEXT.FETCH_KEY           #FETCH_RES_PROMISE. Same but as PROMISE

OPTS.setToContext                 #BOOL. Whether to set NCONTEXT.FETCH_KEY:
                                  #  - true:
                                  #     - COMMAND is awaited by MDWR itself, i.e. serial|foreground
                                  #     - COMMANDs within same MDWR are still run in parallel
                                  #  - false (def)
                                  #     - must use MIDDY_CONTEXT.FETCH_KEY
                                  #     - COMMAND is not awaited by MDWR, i.e. parallel|background
                                  #     - it will be awaited instead by the next MDWR or HANDLER that retrieves FETCH_RES using getInternal()
                                  #     - more efficient, but requires more care to avoid unhandled rejected promise

TYPE_FUNC(PARAMS)->PARAMS         #Identity FUNC, which must wrap OPTS.fetchData.FETCH_KEY
                                  #Its name is SERVICE-specific (some don't have any) and usually start with 'SERVICE'
                                  #It does nothing runtime, but sets the right TypeScript types for NCONTEXT|MIDDY_CONTEXT.FETCH_KEY

                                  ┌───────────────────┐
                                  │   COMMAND ERROR   │
                                  └───────────────────┘

COMMAND ERRORS ==>                #If COMMAND has an STS signature error, it is retried once
                                  #Else, any exception is propagated

UNHANDLED REJECTED PROMISE ==>    #Can happen if the COMMAND throws, since it is not awaited right away
                                  #This happens if the failure happens before FETCH_RES is retrieved
                                  #Can be solved by either:
                                  #  - using OPTS.setToContext true
                                  #  - using synchronous or no MDWRs in-between
                                  #  - not refreshing cache, i.e. not using OPTS.cacheExpiry
                                  #     - then, it can still happen, but only once at FUNC_INSTANCE's first REQ

                                  ┌───────────────────┐
                                  │   COMMAND CACHE   │
                                  └───────────────────┘

CACHE ==>                         #FETCH_RES is cached
                                  #Cache is invalidated if COMMAND fails

OPTS.cacheKey                     #'CACHE_KEY'. Def: 'SERVICE'
                                  #I.e. unless set, all MDWRs of same SERVICE share the cache
                                  #I.e. should be set if using 2+ MDWRs with same SERVICE but different OPTS.fetchData

OPTS.cacheExpiry                  #How long to cache, either:
OPTS.cacheKeyExpiry.CACHE_KEY     #  - -1 (def): forever
                                  #  - 0: never
                                  #  - NUM (max 1d): duration in ms
                                  #  - DATE_NUM: Unix timestamp in ms
                                  #If NUM (not DATE_NUM): refreshes every NUMms, calling COMMAND again

                                  ┌────────────────────┐
                                  │   COMMAND CLIENT   │
                                  └────────────────────┘

OPTS.awsClientOptions             #COPTS passed to the CLIENT

OPTS.awsClientAssumeRole          #'FETCH_KEY' (from @middy/sts). Sets COPTS.credentials
                                  #If set, MDWR must be placed after @middy/sts

OPTS.awsClientCapture             #FUNC(CLIENT)->CLIENT mapping it
                                  #Requires OPTS.disablePrefetch true

OPTS.disablePrefetch              #BOOL. Whether to create CLIENT during MDWR init (false, def) or 'before' STEP (true)
                                  #Always true if OPTS.awsClientAssumeRole set
                                  #Regardless, CLIENT is always created only once per FUNC_INSTANCE

                                  ┌─────────┐
                                  │   STS   │
                                  └─────────┘

@middy/sts                        #
MIDDY-STS(OPTS)->MIDDY_MDWR       #
OPTS.fetchData.FETCH_KEY          #ASSUME_ROLE_REQ. Calls AssumeRole()
                                  #Def ASSUME_REQ_REQ.RoleSessionName: 'middy-sts-session-RANDOM'
                                  #FETCH_RES is CREDS_OBJ (only accessKeyId|secretAccessKey|sessionToken)
                                  #Def CACHE_KEY: 'sts'
                                  #Should have OPTS.setToContext true, since NCONTEXT.* might be accidentally logged
                                  #See middy doc for more info on OPTS.fetchData, including the other OPTS.*

                                  ┌────────┐
                                  │   S3   │
                                  └────────┘

@middy/s3                         #
MIDDY-S3(OPTS)->MIDDY_MDWR        #
OPTS.fetchData.FETCH_KEY          #READ_OBJECT (and other PARAMS). Calls GetObject()
                                  #FETCH_RES is OBJECT contents:
                                  #  - STR
                                  #  - JSON_VAL
                                  #     - if Content-Type: application/[...+]json[;...] [S]
                                  #     - on parsing error: 'JSON_VAL' instead
                                  #Def CACHE_KEY: 's3'
                                  #TYPE_FUNC: s3Req()
                                  #See middy doc for more info on OPTS.fetchData, including the other OPTS.*

                                  ┌──────────────────────┐
                                  │   S3 OBJECT LAMBDA   │
                                  └──────────────────────┘

@middy/s3-object-response         #
S3-OBJECT-RESPONSE(OPTS)          #Calls WriteGetObjectResponse() in 'after' STEP
 ->MIDDY_MDWR                     #HANDLER must return {Body: STR}
                                  #Automatically sets x-amz-request-token|route [C]
                                  #Cannot set any x-amz-fwd-* [C]
                                  #Does an early return with {statusCode: 200}
                                  #Not very useful, to avoid

NCONTEXT.s3ObjectFetch            #fetch(REQ_GET.inputS3Url) RES_PROMISE
                                  #Since it is a PROMISE, it must be awaited
                                  #  - i.e. same issues I documented (see Middy doc) for OPTS.setToContext
                                  #    and unhandled rejected promises

OPTS.awsClient*|disablePrefetch   #For CLIENT|COPTS (see Middy doc)

                                  ┌───────────────┐
                                  │   BATCH SQS   │
                                  └───────────────┘

@middy/sqs-partial-batch-failure  #Alternative to @aws-lambda-powertools/batch, but only for SQS
                                  #Fewer features, i.e. avoid
SQS-PARTIAL([OPTS])->MIDDY_MDWR   #Sets RES.batchItemFailures
                                  #Done in 'after' STEP
                                  #HANDLER must return Promise.allSettled(REQ.Records.map(...))
                                  #  - any exception is handled and returned as a failure
                                  #In 'onError' STEP, return all RECORDs as failed
OPTS.logger                       #FUNC(ERROR, RECORD) (def: console.error) called on each failed RECORD

                                  ┌─────────────┐
                                  │   MEMOIZE   │
                                  └─────────────┘

@middy/util                       #
processCache                      #Memoize CFUNC and call it
 (OPTS, CFUNC(VAL2)->VAL, VAL2)   #VAL2 is any value, bound to CFUNC
 ->CACHE_RES                      #Meant for memoization that refreshes at regular intervals
                                  #Used under-the-hood by OPTS.fetchData (see example usage in @middy/s3 code)

CACHE_RES.value                   #VAL returned by CFUNC
CACHE_RES.expiry                  #DATE_NUM

OPTS.cacheKey                     #'CACHE_KEY' (no default)
OPTS.cacheExpiry
OPTS.cacheKeyExpiry.CACHE_KEY     #Same as above, except def 0

getCache('CACHE_KEY')->CACHE_RES  #Get cache, without calling CFUNC
                                  #If not cached, returns empty OBJ
modifyCache('CACHE_KEY', OBJ)     #Set cached VAL as {...OBJ, ...CFUNC(VAL2, OBJ)}
                                  #Only if already cached
                                  #CFUNC is only called in next processCache()
                                  #Stops caching refreshing
                                  #Meant to invalid cache
clearCache(['CACHE_KEY'[_ARR]])   #Delete cache
                                  #Stops caching refreshing

                                  ┌────────────┐
                                  │   CLIENT   │
                                  └────────────┘

CLIENT ==>                        #The following is mostly meant to create public MDWRs, i.e. otherwise not useful
                                  #Used under-the-hood by OPTS.fetchData (see example usage in @middy/s3 code)

@middy/util                       #
createClient(OPTS, MIDDY_REQ)
 ->>CLIENT                        #Same as new SERVICEClient(COPTS)
OPTS.AwsClient                    #SERVICEClient
OPTS.awsClientOptions
OPTS.awsClientCapture             #Same as above
OPTS.awsClientAssumeRole          #Same as above. If set, must be called after @middy/sts
                                  #However, can be cached, e.g. only done on first REQ

createPrefetchClient(OPTS)->CLIENT#Same as createClient() but without OPTS.awsClientAssumeRole
                                  #I.e. must set OPTS.awsClientOptions.credentials
                                  #Since it does not rely on @middy/sts, can be called once at top-level

canPrefetch([OPTS])->BOOL         #Whether OPTS.awsClientAssumeRole is undefined
                                  #Meant to use a condition on whether to use createClient() or createPrefetchClient()
OPTS.disablePrefetch              #BOOL (def: false). Make canPrefetch() always return false, i.e. always use createClient()

catchInvalidSignatureException    #If ERROR is due to invalid STS signature (including expiration), returns CLIENT.send(COMMAND)
 (ERROR, CLIENT, COMMAND)->>RESP  #Else, throw ERROR
                                  #Meant to retry a COMMAND on transient STS error:
                                  #  try {
                                  #    return await CLIENT.send(COMMAND)
                                  #  } catch (error) {
                                  #    return await catchInvalidSignatureException(error, CLIENT, COMMAND)
                                  #  }

                                  ┌─────────────────────────┐
                                  │   CONTENT NEGOTIATION   │
                                  └─────────────────────────┘

@middy/http-content-negotiation   #
HTTP-CONTENT-NEGOTIATION
 ([OPTS])->MIDDY_MDWR             #

OPTS.parseCharsets                #BOOL (def: true). Whether to set NCONTEXT.preferredCharset[s]
OPTS.availableCharsets            #'CHARSET'_ARR (def: any). Only allow those ones
NCONTEXT.preferredCharsets        #'CHARSET'_ARR to use in response, based on Accept-Charset [C]
                                  #Sorted from highest to lowest priority
                                  #Does not set RES
                                  #  - instead, other MIDDY_MDWRs (e.g. @middy/http-content-encoding) must use NCONTEXT.preferredCharset[s]
NCONTEXT.preferredCharset         #Same as:
                                  #  - NCONTEXT.preferredCharsets[0]
                                  #  - if undefined: OPTS.availableCharsets[0]
                                  #     - only if OPTS.defaultToFirstCharset true (def: false)
OPTS.failOnMismatch               #BOOL (def: true). Throw 406 if NCONTEXT.preferredCharset undefined

OPTS.parseEncodings
 |availableEncodings
 |defaultToFirstEncoding          #Same with Accept-Encoding [C] and NCONTEXT.preferredEncoding[s]

OPTS.parseLanguages
 |availableLanguages
 |defaultToFirstLanguage          #Same with Accept-Language [C] and NCONTEXT.preferredLanguage[s]

OPTS.parseMediaTypes
 |availableMediaTypes
 |defaultToFirstMediaType         #Same with Accept [C] and NCONTEXT.preferredMediaType[s]

                                  ┌─────────────────┐
                                  │   COMPRESSION   │
                                  └─────────────────┘

@middy/http-content-encoding      #
HTTP-CONTENT-ENCODING             #Compress response body, based on Accept-Encoding [C]
 ([OPTS])->MIDDY_MDWR             #Sets RES:
                                  #  - body STR
                                  #  - headers['Content-Encoding'] 'ALGO'
                                  #  - isBase64Encoded true
                                  #Do not compress if either:
                                  #  - no Accept-Encoding [C]
                                  #  - compressed size is bigger
                                  #Works with Middy streamifyResponse
                                  #Must use @middy/http-content-negotiation before (see its doc)
                                  #  - since it relies on NCONTEXT.preferredEncoding[s]

ALGO                              #'deflate', 'gzip' or 'br'
OPTS.overridePreferredEncoding    #'ALGO'_ARR. If set, use first ALGO that is also present in NCONTEXT.preferredEncodings
                                  #If not set, use NCONTEXT.preferredEncoding

OPTS.deflate|gzip|br              #OBJ passed to node:zlib create*Compress(OBJ)

                                  ┌──────────┐
                                  │   CORS   │
                                  └──────────┘

@middy/http-cors                  #
HTTP-CORS([OPTS])->MIDDY_MDWR     #Sets CORS headers to RES.headers
                                  #Does not set headers if already set
                                  #Done in 'after|onError' STEP
                                  #Uses normalizeHttpResponse() (see Middy doc)

OPTS                              #BOOL (def: true). If false:
 .disableBeforePreflightResponse  #  - if HTTP method OPTIONS
                                  #  - preflight response, 204
                                  #  - use an early return (see Middy doc)

OPTS.origins                      #Allowed 'ORIGIN'_ARR (def: []), for Access-Control-Allow-Origin [S]
                                  #'ORIGIN' can:
                                  #  - be '*'
                                  #  - include '*'
                                  #     - it must not include any REGEXP character, except for * and .
                                  #If no match, do not set Access-Control-Allow-Origin [S]
OPTS.origin                       #'ORIGIN' (def: '*'). Same as OPTS.origins ['ORIGIN'] except:
                                  #  - if no match, set Access-Control-Allow-Origin [S]
                                  #  - ORIGIN can be '*' but not include it
                                  #Only used if OPTS.origins []
OPTS.getOrigin                    #FUNC('ORIGIN'[, OPTS])->'ORIGIN'
                                  #Customize how Access-Control-Allow-Origin [S] is set
                                  #Including how OPTS.origin[s] are handled

OPTS.methods                      #'METHOD,...' (def: none). Access-Control-Allow-Methods [S]
OPTS.headers                      #'HEADER,...' (def: none). Access-Control-Allow-Headers [S]
OPTS.credentials                  #'true' (def: none). Access-Control-Allow-Credentials [S]
                                  #Note: this also disallows using Access-Control-Allow-Origin: * [S]
OPTS.maxAge                       #NUM (def: none). Access-Control-Max-Age [S]
OPTS.exposeHeaders                #'HEADER,...' (def: none). Access-Control-Expose-Headers [S]

OPTS.requestMethods               #'METHOD,...' (def: none). Access-Control-Request-Methods [S]
                                  #Probably a mistake: the actual header name has no 's', and is for the request instead
OPTS.requestHeaders               #'HEADER,...' (def: none). Access-Control-Request-Headers [S]
                                  #Probably a mistake: the actual header is for the request instead

OPTS.cacheControl                 #STR (def: none). Cache-Control [S]
                                  #Only if HTTP method OPTIONS
OPTS.vary                         #'HEADER'. Vary: HEADER [S]
                                  #Def: 'Origin', unless Access-Control-Allow-Origin [S] is either '*' or unset

                                  ┌──────────────────────┐
                                  │   SECURITY HEADERS   │
                                  └──────────────────────┘

@middy/http-security-headers      #
SECURITY-HEADERS([OPTS])          #Sets security-related RES.headers
 ->MIDDY_MDWR                     #Uses normalizeHttpResponse() (see its doc)
                                  #Done in 'after|onError' STEP
                                  #Following OPTS.* are ignored unless Content-Type: text/html[;...] [S]:
                                  #  - contentSecurityPolicy, crossOrigin*, permissionPolicy, reportTo, frameOptions, xssProtection

OPTS.contentSecurityPolicy        #{CSP_TYPE: 'TVAL',...}. Content-Security-Policy: CSP_TYPE TVAL;... [S]
                                  #For CSP_TYPE sandbox and upgrade-insecure-requests, TVAL can be empty
                                  #Def:
                                  #  - default-src|base-uri|form-action|frame-ancestors|navigate-to|trusted-types: "'none'"
                                  #  - report-to: "csp"
                                  #  - require-trusted-types-for: "'script'"
                                  #  - sandbox: ""
                                  #  - upgrade-insecure-requests: ""

OPTS.contentTypeOptions.action    #STR (def: 'nosniff'}). X-Content-Type-Options: STR [S]

OPTS
 .crossOriginEmbedderPolicy.policy#STR (def: 'require-corp'). Cross-Origin-Embedder-Policy: STR [S]

OPTS
 .crossOriginOpenerPolicy.policy  #STR (def: 'same-origin'}). Cross-Origin-Opener-Policy: STR [S]

OPTS
 .crossOriginResourcePolicy.policy#STR (def; 'same-origin'}). Cross-Origin-Resource-Policy: STR [S]

OPTS.dnsPrefetchControl.allow     #BOOL (def: false). X-DNS-Prefetch-Control: on|off [S]

OPTS.downloadOptions.action       #STR (def: 'noopen'}). X-Download-Options: STR [S]

OPTS.frameOptions.action          #STR (def: 'deny'). X-Frame-Options: STR [S]

OPTS.originAgentCluster           #Either undefined or {} (def). Origin-Agent-Cluster: ?1 [S]

OPTS.permissionsPolicy            #{TYPE: '*'|STR,...}. Permissions-Policy: TYPE=*|(STR),... [S]
                                  #Def: every possible TYPE (except 'unload'), STR always empty

OPTS.permittedCrossDomainPolicies
 .policy                          #STR (def: 'none'). X-Permitted-Cross-Domain-Policies: STR [S]

OPTS.poweredBy.server             #STR. X-Powered-By: STR [S]
                                  #If '' (def), delete X-Powered-By [S] and Server [S]

OPTS.referrerPolicy.policy        #STR (def: 'no-referrer'}). Referrer-Policy: STR [S]

OPTS.reportTo                     #REPORT_TO. Report-To: GREPORT,... [S]
                                  #One GREPORT per URL (def: none)
                                  #One URL must be 'default'
                                  #GREPORT.group always 'default'
REPORT_TO.URL                     #'URL'. GREPORT.endpoints[0].url
REPORT_TO.maxAge                  #NUM (in secs, def 1y). GREPORT.maxAge
REPORT_TO.includeSubdomains       #BOOL (def: true). Report-To: ..., "include_subdomains": BOOL [S]

OPTS.strictTransportSecurity      #STS. Strict-Transport-Security: max-age=NUM[; includeSubDomains][; preload] [S]
STS.maxAge                        #NUM (in secs, def: 6 months)
STS.includeSubDomains             #BOOL (def: true)
STS.preload                       #BOOL (def: true)

OPTS.xssProtection                #XSS. X-XSS-Protection: 1; mode=block[; report=STR] [S]
XSS.reportTo                      #STR (def: 'xss')

                                  ┌────────────┐
                                  │   ROUTER   │
                                  └────────────┘

@middy/http-router                #
HTTP-ROUTER([OPTS[.routes]])      #Calls different HANDLERs based on HTTP method + path
 ->HANDLER                        #Works with:
                                  #  - FUNC_URL, API Gateway HTTP, ELB, VPC
                                  #  - anything with REQ.httpMethod|path

OPTS.routes                       #ROUTE_ARR (def: []), from highest to lowest priority
ROUTE.handler                     #FUNC(...) being called if method|path match
                                  #Same signature as normal HANDLER
ROUTE.method                      #HTTP 'METHOD' (required). Can be 'ANY'
ROUTE.path                        #'/PATH' (required)
/PATH/                            #Trailing slashes are ignored both in ROUTE.path and from REQ
[/...]/{PATHVAR}[/...]            #Set to REQ.pathParameters.PATHVAR STR (unless already set)
                                  #Matches anything up until end, except /
                                  #Must matching something, i.e. STR is never ''
[/...]/{proxy+}                   #Set to REQ.pathParameters.proxy STR (unless already set)
                                  #Matching anything up until end, including /
                                  #Can matching nothing, in which case STR is ''

OPTS.notFoundResponse             #FUNC({method, path})[->>RES] if no method|path matches
                                  #Def: throw MIDDY_HTTP_ERROR 404 with ERROR.cause.data: method, path

@middy/ws-router                  #
WS-ROUTER([OPTS[.routes]])        #Like @middy/http-router except:
 ->HANDLER                        #  - for API Gateway WebSocket
                                  #  - uses REQ.requestContext.routeKey
                                  #  - method|path -> routeKey 'ROUTE'
                                  #  - no {PATHVAR} nor {proxy}

                                  ┌─────────────┐
                                  │   TO SORT   │
                                  └─────────────┘

LOGGING ==>                       #See @aws-lambda-powertools/logger
IDEMPOTENCY ==>                   #See @aws-lambda-powertools/idempotency
CLOUDWATCH EMBEDDED METRICS ==>   #See @aws-lambda-powertools/metrics and aws-embedded-metrics
RESPONSE BODY FILTERING ==>       #See @middy/http-partial-response doc, in json-mask doc
