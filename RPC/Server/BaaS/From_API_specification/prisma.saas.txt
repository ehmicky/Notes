
          
   PRISMA  
          


To do:
  - MongoDB raw queries: https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#raw-queries-with-mongodb
  - transaction:
     - https://www.prisma.io/docs/concepts/components/prisma-client/transactions
     - see all references of $transaction in https://www.prisma.io/docs/reference/api-reference/prisma-client-reference
  - metrics: https://www.prisma.io/docs/concepts/components/prisma-client/metrics
  - tracing: https://www.prisma.io/docs/concepts/components/prisma-client/opentelemetry-tracing
  - Extensions: https://www.prisma.io/docs/concepts/components/prisma-client/client-extensions
     - remove $use(): deprecated
     - https://www.prisma.io/docs/concepts/components/prisma-client/custom-validation#input-validation-with-prisma-client-extensions
     - https://www.prisma.io/docs/concepts/components/prisma-client/computed-fields#using-a-prisma-client-extension
     - https://www.prisma.io/docs/concepts/components/prisma-client/custom-models#static-methods-with-prisma-client-extensions
  - Prisma Data Platform: https://www.prisma.io/docs/data-platform
  - pricing
  - Get started: https://www.prisma.io/docs/getting-started
  - All guides:
     - except:
        - Seeding your database
        - Schema prototyping with db push
     - including:
        - Deno deploy
  - fix all `???` in this doc
  - https://github.com/prisma
  - https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators


VERSION ==>                       #5.4.2 (2023-10-16)

OPEN-SOURCE ==>                   #Most of it except:
                                  #  - studio
                                  #  - Accelerate
                                  #  - Proxy
                                  #  - Pulse

NON-GOALS ==>                     #Not meant as full BaaS:
                                  #  - no database hosting
                                  #  - no API hosting
                                  #  - no API generation by default (although can be done with generators)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              CLI              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma                            #CLI

prisma version                    #Version of prisma CLI|client|studio and current OS

ENVVAR PRISMA_HIDE_UPDATE_MESSAGE #Do not print version upgrade warning
ENVVAR PRISMA_DISABLE_WARNINGS    #Do not print any warnings

ENVVAR CHECKPOINT_DISABLE=1       #Do not send anonymous CLI usage telemetry


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ENGINES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ENGINE ==>                        #Rust libraries used by the TypeScript components (CLI, CLIENT)
                                  #When bundling, must make sure those are included

PSL ==>                           #Engine used to parse|serialize|validate|format SCHEMA
                                  #Used by schema|format|query engines, i.e. as a Rust dependency

SCHEMA ENGINE ==>                 #Engine used by `schema db|migrate`
                                  #Downloaded as postinstall script during `npm install prisma`
                                  #Def: inside node_modules/@prisma/engines/...
                                  #Runs as a separate executable file, as a HTTP server

FORMAT ENGINE ==>                 #Engine used by `schema format`
                                  #Loaded by CLI as WASM dependency

QUERY ENGINE ==>                  #Engine performing database queries, used by both the CLI and the CLIENT
                                  #Pools database connections on local machine
                                  #Downloaded the same way as schema engine
                                  #Loaded either as a:
                                  #  - library (def):
                                  #     - embedded in library, as a Node.js addon
                                  #     - takes more space, which is an issue inside serverless functions
                                  #  - binary:
                                  #     - separate executable file, as a HTTP server
                                  #     - slower due to IPC

generator.engineType
ENVVAR PRISMA_CLIENT_ENGINE_TYPE  #ENUM library|binary. How query engine should be used by CLIENT
ENVVAR
 PRISMA_CLI_QUERY_ENGINE_TYPE     #Same but for query engine used by CLI

schema generate --no-engine       #When using neither Data Proxy nor Accelerate
ENVVAR PRISMA_GENERATE_NO_ENGINE  #With "prisma-client-js" only

ENVVAR PRISMA_SCHEMA_ENGINE_BINARY#'PATH' to schema engine binary
ENVVAR PRISMA_QUERY_ENGINE_LIBRARY#'PATH' to query engine binary (Node.js addon)
                                  #Only with engineType 'library'
ENVVAR PRISMA_QUERY_ENGINE_BINARY #'PATH' to query engine binary (executable file)
                                  #Only with engineType 'binary'

ENVVAR PRISMA_ENGINES_MIRROR      #URL where to download schema|query engine binaries
                                  #Def: https://binaries.prisma.sh
ENVVAR PRISMA_ENGINES_
 CHECKSUM_IGNORE_MISSING          #Unless set, verify checksum of schema|query engine binaries

generator.binaryTargets           #STR_ARR. OS|CPU targets of schema|query engines to download, i.e. where CLI and client will run
ENVVAR PRISMA_CLI_BINARY_TARGETS  #Can be:
                                  #  - "native" (def): current
                                  #  - "debian-openssl-X.Y.x": Debian|Ubuntu|Mint|ArchLinux
                                  #  - "rhel-openssl-X.Y.x": Fedora|CentOS
                                  #  - "linux-musl[-arm64][-openssl-3.0.x]": Alpine >=|< 3.17, x86|ARM64
                                  #  - "linux-arm64-openssl-X.Y.x": other Linux ARM64, glibc
                                  #  - "darwin[-arm64]"
                                  #  - "windows"

ENVVAR DEBUG=prisma:engine        #Engine-related debug logs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           PREVIEWS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma --preview                  #Required for CLI experimental features

generator.previewFeatures         #STR_ARR. Required for SCHEMA|CLIENT experimental PREVIEW features

ENVVAR
 PRISMA_HIDE_PREVIEW_FLAG_WARNINGS#Do not warn on PREVIEWs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        SCHEMA GENERAL         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SCHEMA ==>                        #Defines data model in a declarative way

FORMAT ==>                        #PSL ("Prisma Schema Language"). GraphQL-like

prisma validate                   #Validate SCHEMA
prisma format                     #Validate and prettify SCHEMA, saving on-file

prisma init                       #Scaffold ./prisma/schema.prima and ./.env

prisma generate|validate|format
 |studio
prisma db pull|push|execute       #PATH to SCHEMA
prisma migrate dev|reset|deploy   #Def:
 |resolve|status                  #  - package.json prisma.schema 'PATH'
--schema=PATH                     #  - [.../]./[prisma/]schema.prisma

VSCODE EXTENSION ==>              #SCHEMA's syntax highlighting, linting, autocomplete, formatting, jump-to-definition, hovering help
                                  #There is also for other IDEs

```prisma
...
```                               #Can be used on GitHub

//COMMENT                         #
///COMMENT                        #Same but present when parsing as AST, i.e. can be used by tooling

env("ENVVAR")                     #"VAL"
                                  #Only for datasource.url and generator.binaryTargets
.env                              #Dotenv is parsed, to set any of the ENVVARs
                                  #Must be in same DIR as SCHEMA


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       SCHEMA DATASOURCE       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


datasource DB {
  VAR = VAL                       #Database
  ...                             #Only one per schema
}                                 #DB is often "db"
POPTS.datasources.DB              #Same as OBJ
                                  #Cannot set provider

datasource.provider               #"DB_PROVIDER". Database type ("connector") among:
prisma init --datasource-provider #  - "postgresql" (>=9.6): has most support
                                  #  - "mysql"
                                  #  - "sqlserver"
                                  #  - "sqlite"
                                  #  - "cockroachdb"
                                  #  - "mongodb" (>=4.2): has fewer features
datasource.url                    #Connection "URL" to the main database, through connection pooler
POPTS.datasourceUrl               #E.g.:
prisma init --url                 #  - Postgres: 'LIBPQ'
                                  #  - SQLite: 'file:./PATH.db'
datasource.directUrl              #Connection "URL" to the main database, without connection pooler
                                  #Used with prisma db|migrate|studio
                                  #Def: same as datasource.url

@prisma/adapter-*                 #ADAPTER
                                  #Fixes database connection for specific providers: neon, PlanetScale, turso
                                  #Requires PREVIEW driverAdapters
POPTS.adapter                     #ADAPTER

LIBPQ.*                           #In connection 'URL', different from Postgres ones
LIBPQ.options|host|connect_timeout
 |application_name|sslcert
 |sslpassword|channel_binding     #Like Postgres
LIBPQ.schema                      #'SCHEMA'
LIBPQ.socket_timeout              #NUM (def: none). Query timeout
LIBPQ.connection_limit            #NUM (def: CPUs * 2 + 1). Keep pool of connections
LIBPQ.pool_timeout                #NUM (in sec, def: 10). If pool empty, how long to wait
                                  #Can be 0 for Infinity
LIBPQ.sslidentity                 #Like Postgres LIBPQ.ssl_key_file
LIBPQ.sslcert                     #Like Postgres LIBPQ.ssl_cert_file
LIBPQ.sslmode                     #Like Postgres, but no "allow" nor "verify-*"
LIBPQ.sslaccept                   #'accept_invalid_certs' (def) or 'strict'
                                  #Whether to allow missing values in certificates
LIBPQ.pgbouncer                   #BOOL (def: false). When using pgBouncer

datasource.extensions             #ARR of EXTENSION[(ARG: "VAL",...)]
                                  #Postgres EXTENSIONs. ARGs (all optional):
                                  #  - version "EVERSION"
                                  #  - schema "SCHEMA"
                                  #  - map "EXTENSION2": like @map but for "EXTENSION"
                                  #Requires PREVIEW postgresqlExtensions


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      SCHEMA TYPE COMPLEX      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


model MODEL {
  FIELD FTYPE [@ATTR]...          #Database TABLE
  ...                             #Can use MODEL as FTYPE
  [@@ATTR]                        #With any database
  ...                             #JavaScript client: OBJ|ARR
}                                 #In schema: ???

view VIEW { ... }                 #Database VIEW
                                  #Same syntax and behavior as MODEL
                                  #With any database
                                  #Requires PREVIEW views
./prisma/views/SCHEMA/VIEW.sql    #SQL query of VIEW
                                  #Created by `prisma db pull`

type OBJ_TYPE { ... }             #"Composite type"
                                  #Same syntax as `model MODEL`
                                  #No @unique, @id, @relation, @ignore, @updatedAt
                                  #Can use OBJ_TYPE as FTYPE
                                  #Only with MongoDB
                                  #JavaScript client: OBJ
                                  #In schema: ???

enum ENUM { ... }                 #Same syntax as `model MODEL`, except no FTYPE
                                  #Only @[@]map
                                  #Can use ENUM as FTYPE
                                  #Postgres|MySQL|CDB: enum type
                                  #MondoDB: done at ORM-level
                                  #Not with SQLite nor SQL server
                                  #JavaScript client: ???
                                  #In schema: FIELD

MODEL|VIEW|ENUM|OBJ_TYPE          #Name must be [[:alnum:]_] and not start with _ nor digit
                                  #Usually CamelCase, singular
                                  #Cannot be one of the JavaScript reserved keywords, nor "Prisma[Client]"

FIELD                             #Database COL name
                                  #Must be [[:alnum:]_] and not start with _ nor digit
                                  #Usually camelCase
                                  #Cannot be "AND|OR|NOT"
FIELD_VARR                        #FIELD name
                                  #Can be dot-delimited for OBJ_TYPE

FTYPE?                            #Optional FTYPE
                                  #Most databases: `not null`
                                  #MongoDB: done at ORM-level
                                  #Implies @default null

FTYPE[]                           #ARR ("list")
                                  #Not with SQLite, MySQL, SQL server
                                  #Cannot be FTYPE[]? nor FTYPE?[]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      SCHEMA TYPE SIMPLE       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


String                            #Postgres: text, MongoDB: String, SQLite: TEXT, also MySQL, SQL server, CDB
                                  #JavaScript client: STR
                                  #In schema: "..."
String @db.Text                   #Postgres: text, SQLite: TEXT, also MySQL, SQL server
String @db.Char(NUM)              #Postgres: char(NUM), also MySQL, SQL server, CDB
String @db.VarChar(NUM)           #Postgres: varchar(NUM), also MySQL, SQL server
String @db.Bit(NUM)               #Postgres: bit(NUM), also CDB
String @db.VarBit                 #Postgres: varbit, also CDB
String @db.Uuid                   #Postgres: uuid, also CDB
String @db.Xml                    #Postgres: xml, also SQL server
String @db.Inet                   #Postgres: inet, also CDB
String @db.Citext                 #Postgres: citext
String @db.Tiny|Medium|LongText   #Only MySQL
String @db.NText                  #Only SQL server
String @db.N[Var]Char(NUM)        #Only SQL server
String @db.UniqueIdentifier       #Only SQL server
String @db.CatalogSingleChar      #Only CDB
String @db.String                 #MongoDB: String, also CDB
String @db.ObjectId               #MongoDB: String, as objectId

Boolean                           #Postgres: boolean, MongoDB: Bool, SQLite: INTEGER, also MySQL, SQL server, CDB
                                  #JavaScript client: BOOL
                                  #In schema: true|false
Boolean @db.Boolean               #Postgres: boolean
Boolean @db.TinyInt(NUM)          #Only MySQL
Boolean @db.Bool                  #Only CDB
Boolean @db.Bit                   #MongoDB: bit, also MySQL

Int                               #Postgres: int4, MongoDB: Int, SQLite: INTEGER, also MySQL, SQL server, CDB
                                  #JavaScript client: NUM
                                  #In schema: INT
Int @db.SmallInt                  #Postgres: int2, also MySQL, SQL server
Int @db.Integer                   #Postgres: int4
Int @db.Oid                       #Postgres: oid
Int @db.Int                       #MongoDB: Int, also MySQL, SQL server
Int @db.TinyInt                   #Only MySQL, SQL server
Int @db.MediumInt                 #Only MySQL
Int @db
 .Unsigned[Tiny|Small|Medium]Int  #Only MySQL
Int @db.Year                      #Only MySQL
Int @db.Bit                       #Only SQL server
Int @db.Int2|4|8                  #Only CDB
Int @db.Long                      #MongoDB: Long

BigInt                            #Postgres: int8, MongoDB: Long, SQLite: INTEGER, also MySQL, SQL server, CDB
                                  #JavaScript client: BIGINT
                                  #In schema: INT
BigInt @db.BigInt                 #Postgres: int8, also MySQL, SQL server
BigInt @db.UnsignedBigInt         #Only MySQL
BigInt @db.Int8                   #Only CDB

Float                             #Postgres: float8, MongoDB: Double, SQLite: REAL, also MySQL, SQL server, CDB
                                  #JavaScript client: NUM
                                  #In schema: NUM
Float @db.Real                    #Postgres: float4, also SQL server
Float @db.DoublePrecision         #Postgres: float8
Float @db.Float                   #Only MySQL, SQL server
Float @db.Double                  #Only MySQL
Float @db.[Small]Money            #Only SQL server
Float @db.Float4|8                #Only CDB

Decimal                           #Postgres: numeric(65, 30), SQLite: DECIMAL, also MySQL, SQL server, CDB
                                  #Not with MongoDB
                                  #JavaScript client: DECIMAL
                                  #  - using decimal.js library, re-exported as Prisma.Decimal
                                  #In schema: NUM
Decimal @db.Decimal(NUM, NUM2)    #Postgres: numeric(NUM, NUM2), also MySQL, SQL server, CDB
Decimal @db.Money                 #Postgres: money

DateTime                          #Postgres: timestamp(3), MongoDB: Timestamp, SQLite: NUMERIC|STRING, also MySQL, SQL server, CDB
                                  #JavaScript client: DATE
                                  #In schema: "YYYY-MM-DDTHH:MM:SSTZ"
DateTime @db.Timestamp(NUM)       #Postgres: timestamp(NUM), also MySQL, CDB
DateTime @db.Timestamptz(NUM)     #Postgres: timestamptz(NUM), also CDB
DateTime @db.Date                 #Postgres: date, also SQL server, CDB
DateTime @db.Time(NUM)            #Postgres: time(NUM), also MySQL, CDB
DateTime @db.Timetz(NUM)          #Postgres: timetz(NUM), also CDB
DateTime @db.Date[Time](NUM)      #Only MySQL
DateTime @db.DateTime[2]          #Only SQL server
DateTime @db.SmallDateTime        #Only SQL server
DateTime @db.DateTimeOffset       #Only SQL server
DateTime @db.Time                 #Only SQL server

Json                              #Postgres: jsonb, MongoDB: BSON v2 relaxed, also MySQL, SQL server, CDB
                                  #Not with SQLite
                                  #JavaScript client: VAL
                                  #In schema: VAL
Json @db.Json                     #Postgres: json, also MySQL
Json @db.JsonB                    #Postgres: jsonb, also CDB
Json @db.NVarChar                 #Only with SQL server

Bytes                             #Postgres: bytea, MongoDB: BinData, SQLite: BLOB, also MySQL, SQL server, CDB
                                  #JavaScript client: Node.js BUFFER
                                  #In schema: "BASE64"
Bytes @db.ByteA                   #Postgres: bytea
Bytes @db.Binary                  #Only MySQL, SQL server
Bytes @db.VarBinary               #Only MySQL, SQL server
Bytes @db.Bit                     #Only MySQL
Bytes @db.[Tiny|Medium|Long]Blob  #Only MySQL
Bytes @db.Image                   #Only SQL server
Bytes @db.Bytes                   #Only CDB
Bytes @db.BinData                 #MongoDB: BinData
Bytes @db.ObjectId                #MongoDB: ObjectId

Unsupported("TYPE")               #Database type called exactly TYPE
                                  #Not with MongoDB
                                  #Implies @ignore
                                  #In schema: not possible


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       SCHEMA ATTRIBUTE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@ATTR[([ARG: ]VAL, ...)]          #Attribute. Options to FIELD
                                  #ARGs can always be named, and often also positional
@@ATTR[([ARG: ]VAL, ...)]         #Same for options to multiple FIELDs, or to MODEL|ENUM

@map(STR)                         #Database COL name
                                  #Def: "FIELD"
                                  #Meant when:
                                  #  - "FIELD" contains invalid characters
                                  #  - want a different name in API than in database
@@map(STR)                        #Same but for database MODEL name

@ignore                           #Omit FIELD in JavaScript client, except in raw queries
                                  #If no @default, cannot create|update|upsert MODEL
                                  #But works with prisma db|migrate
                                  #Done at the ORM-level, i.e. on any database
@@ignore                          #Same but for a MODEL

@@schema("SCHEMA")                #MODEL's database "SCHEMA" (def: default database "SCHEMA")
                                  #"SCHEMA" is database concept, not Prisma concept with the same name
                                  #Only with Posgres, SQL server, CDB
                                  #Requires PREVIEW "multiSchema"
datasource.schemas                #Database "SCHEMA"_ARR available to @@schema


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        SCHEMA DEFAULT         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@updatedAt                        #Set on each MODEL update (unless overridden) with current time
                                  #DateTime FTYPE
                                  #Done at ORM-level, i.e. for any database

@default(OPTS[.value])            #FIELD's default VAL
                                  #For any database
                                  #If none, FIELD is required
OPTS.map                          #STR. Only for SQL server
OPTS.value                        #Default VAL
                                  #Can also use any of the following

now()                             #DateTime FTYPE
                                  #With most databases: current_timestamp
                                  #MongoDB: done at ORM-level

uuid()                            #String FTYPE
                                  #Done at ORM-level, i.e. for any database
                                  #UUIDv4
cuid()                            #String FTYPE
                                  #Done at ORM-level, i.e. for any database
                                  #CUID1 (min 30 chars)

autoincrement()                   #Postgres: serial2|4|8, SQLite: AUTOINCREMENT, also with MySQL, SQL server, CDB
                                  #Int FTYPE
                                  #  - Postgres: Int @db.[Small|Big]Int
                                  #Not with MongoDB

dbgenerated('EXPR')               #Database-specific EXPR, e.g. FUNC(), OPs, etc.
                                  #Not with MongoDB

auto()                            #ObjectId
                                  #String @db.ObjectId FTYPE
                                  #Must use @map("_id")
                                  #Only with MongoDB

sequence(...)                     #SEQUENCE table
                                  #Only with CDB


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         SCHEMA INDEX          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@id[(OPTS)]                       #Primary key constraint on one FIELD
                                  #Only one per MODEL
                                  #Required for each MODEL
                                  #  - alternative: one @[@]unique, if required and not MongoDB
                                  #For any database
                                  #MongoDB:
                                  #  - required
                                  #  - must use @map("_id")
                                  #  - if ObjectId, must use:
                                  #     - String|Bytes @db.ObjectId
                                  #     - optional: @default(auto())
                                  #Cannot be on optional FIELD
OPTS.map|length|clustered         #Like @@index
OPTS.sort                         #Like @@index
                                  #Only with SQL server

@@id(OPTS)                        #Like @id, but on multiple FIELDs
                                  #Not with MongoDB
OPTS.sort|map|length|clustered    #Like @id
OPTS.fields|name                  #Like @@index

@unique[(OPTS)]                   #Unique constraint on one FIELD
                                  #For any database
                                  #nulls are distinct
OPTS.sort|map|length|clustered    #Like @@index

@@unique(OPTS[.fields])           #Like @unique, but on multiple FIELDs
                                  #With MongoDB: index must be created manually
OPTS.sort|map|length|clustered    #Like @unique
OPTS.fields|name                  #Like @@index

@@index(OPTS[.fields])            #Database index
OPTS.fields                       #ARR of FIELD_VARR[(OPTS)]
                                  #None must not be optional
OPTS.name                         #Dynamic 'FIELD' created with combination of all fields, i.e. can be queried
                                  #Def: 'FIELD_FIELD2_...'
OPTS.sort                         #ENUM. Asc (def) or Desc
OPTS.map                          #Database 'INDEX' name
                                  #Database INDEX can already exist
                                  #Def:
                                  #  - if database INDEX already exist: re-use its name
                                  #  - @[@]id: "TABLE_pkey"
                                  #  - @[@]unique: "TABLE_FIELD..._unique"
                                  #  - @[@]index: "TABLE_FIELD..._index"
                                  #  - @relation: "TABLE_FIELD..._fkey"
                                  #Not with MySQL, MongoDB
OPTS.type                         #ENUM. ACCESS_METHOD
                                  #Can be BTree (def), Gist, Gin, SpGist, Brin, Hash
                                  #Only with Postgres
OPTS.ops                          #ENUM. OPCLASS
                                  #Can be raw("OPCLASS") if value not available in ENUM
                                  #Only with Postgres
OPTS.length                       #NUM. Only with MySQL
OPTS.clustered                    #BOOL. Only with SQL server


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       SCHEMA RELATIONS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@relation(OPTS)                   #Foreign key source|destination constraint on FIELDs
                                  #MODEL FTYPE:
                                  #  - must be on populated FIELD, not present in database
                                  #  - alongside separate foreign key FIELD, present in database
                                  #Cannot use @unique (but can use @@unique) nor @default
                                  #For all databases
OPTS.fields                       #FIELD_VARR_ARR of source foreign keys
                                  #ARR has multiple items only if source MODEL uses @@id
OPTS.references                   #FIELD_VARR_ARR of destination primary keys
                                  #ARR has multiple items only if destination MODEL uses @@id
OPTS.name                         #"RELATION"
OPTS.map                          #Like @@index

OPTS.onUpdate|onDelete            #ENUM among:
                                  #  - NoAction
                                  #     - MongoDB: required if cycle between relations
                                  #  - Restrict (def with OPTS.onDelete if required)
                                  #     - not with SQL server
                                  #  - SetNull (def with OPTS.onDelete if optional)
                                  #  - SetDefault
                                  #     - not with MySQL, MongoDB
                                  #  - Cascade (def with OPTS.onUpdate)
                                  #Like SQL `references ... on update|delete ACTION`
                                  #  - see Postgres doc for meaning of each option
                                  #As an alternative, can also update|delete across multiple TABLEs at once by using a $transaction

datasource.relationMode           #ENUM. Whether @relation:
                                  #  - "foreignKeys":
                                  #     - creates a database foreign key
                                  #     - default with most databases
                                  #     - usually recommended
                                  #  - "prisma":
                                  #     - emulates foreign key at the ORM layer
                                  #     - only enforced during update|delete, not create
                                  #     - cannot use OPTS.onUpdate|onDelete:
                                  #        - NoAction: with Postgres or SQLite
                                  #        - SetDefault
                                  #     - required for "mongodb"

1-1 RELATIONSHIP ==>              #When source|destination FIELDs are both @[@]unique|@[@]id, not ARR

1-N RELATIONSHIP ==>              #When source|destination FIELDs are both not ARR, and only destination FIELD is @[@]unique|@[@]id

N-N RELATIONSHIP ==>              #When both source|destination FIELDs are ARRs

EXPLICIT N-N RELATIONSHIP ==>     #Define a n-n TABLE in SCHEMA, with 1-n relationship towards both TABLEs
                                  #Both TABLEs contain reverse FIELDs (see below)

IMPLICIT N-N RELATIONSHIP ==>     #Automatically handle a n-n TABLE at ORM-level
                                  #Only need to define source|destination FIELDs, without any @relation nor foreign key FIELD
                                  #Source|destination MODELs must both have @id (not @@id), which are used as targets
                                  #Underlying database TABLE:
                                  #  - name is _TABLE2ToTABLE3
                                  #     - can use @relation with OPTS.name to change it
                                  #        - cannot use other OPTS.*
                                  #  - both FIELDs are called A|B pointing to TABLE2|3, and use @@unique
                                  #  - non-unique index on FIELD B

MONGODB N-N RELATIONSHIP ==>      #Automatically handle a n-n TABLE at ORM-level
                                  #Each TABLE must have foreign key FIELD:
                                  #  - ARR
                                  #  - use @relation
                                  #  - target the other TABLE @id (not @@id)
                                  #  - no OPTS.onUpdate|onDelete

REVERSE RELATIONSHIP ==>          #Automatically populating a FIELD, without any @relation nor key FIELD
                                  #Only when there is a reverse relationship declared:
                                  #  - source FIELD -> destination FIELD declared
                                  #  - i.e. can imply reverse destination FIELD2 -> source MODEL
                                  #With:
                                  #  - 1-1 relationship: reverse FIELD must be optional `FTYPE?`
                                  #  - 1-n or n-n relationship: reverse FIELD must be `FTYPE[]`

DISAMBIGUATION ==>                #For implicit n-n and reverse relationships, destination|source FIELDs must use @relation with OPTS.name if:
                                  #  - destination|source MODEL is same
                                  #  - source MODEL has multiple foreign key FIELDs to destination MODEL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           GENERATE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


schema generate                   #Call all GENERATOR_PROVIDERs
--watch                           #Call on SCHEMA file change

prisma db push
prisma migrate dev|reset
--skip-generate                   #Unless set, calls `prisma generate` at the end

GENERATOR_PROVIDER                #Module generating code base on SCHEMA. Can be:
                                  #  - "prisma-client-js": CLIENT
                                  #  - "MODULE|PATH": third-party

generator GENERATOR {
  VAR = VAL
  ...
}                                 #GENERATORs used by `schema generate`, in SCHEMA

generator.provider
schema generate --generator       #"GENERATOR_PROVIDER"

generator.output                  #'OPATH'. Def: "./node_modules/.prisma/client"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          INTROSPECT           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma db pull                    #"Introspection". Make SCHEMA reflect production DATABASE
--print                           #Print new SCHEMA to stdout instead of modifying it

SCAFFOLD ==>                      #Can be used to scaffold initial SCHEMA

INCREMENTAL CHANGES ==>           #Can also be used as alternative to `prisma db push` and `prisma migrate`
                                  #I.e. modify production DATABASE -> SCHEMA, instead of opposite
                                  #Not with MongoDB
--force                           #Overwrite everything on incremental changes
                                  #Unless specified, do not overwrite:
                                  #  - comments
                                  #  - order of {...} blocks
                                  #     - but order of FIELDs within blocks is always same as database COLs order,
                                  #       with complex FTYPEs before simple ones
                                  #  - @[@]map
                                  #  - @updatedAt
                                  #  - @default(uuid|cuid())
                                  #  - @relation(name: "RELATION")
                                  #  - @[@]ignore

SUBSET ==>                        #To only introspect a subset of production DATABASE, can:
                                  #  - use datasource.schemas
                                  #  - use a datasource.url with a database USER with permissions only to read specific entities
                                  #Alternative is also to introspect some entities, but use @[@]ignore on them

MONGODB ==>                       #Schemaless, i.e. use sampled data instead
                                  #Cannot infer @[@]ATTR nor FTYPE? FTYPE[]
                                  #Can only infer @@index if INDEX has some data

NAMES ==>                         #Invalid characters in MODEL|FIELD|etc. are replaced with _
                                  #@[@]map is then also used

POSTGRES EXTENSIONS ==>           #Only infers specific ones: citext, pgcrypto, uuid-ossp, postgis


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PUSH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma db push                    #Inverse of `prisma db pull`
                                  #Make production DATABASE reflect SCHEMA, using direct database DDL
                                  #Meant for the initial scaffolding, or for local prototyping
                                  #Only add|modify entities, not remove
                                  #Does not create VIEWs
--force-reset                     #Empty database first
--accept-data-loss                #Unless set, fails if TABLE DDL change requires truncating its data


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MIGRATE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma migrate ...                #Make production DATABASE reflect SCHEMA, using automatically generated SQL files
                                  #Meant for incremental changes

MONGODB ==>                       #Does not support `prisma migrate`
                                  #  - except `prisma migrate diff`, without --from|to-migrations nor --script
                                  #Must use `prisma db push|execute` instead

datasource.shadowDatabaseUrl      #Connection "URL" to the "shadow database"
prisma migrate diff               #Temporary and used only by `prisma migrate dev` and `prisma migrate diff --from|to-migrations`
--shadow-database-url             #As opposed to the "dev database", which is the main local database

./prisma/migrations               #MDIR
MDIR/MIGRATION/migration.sql      #SQL file with DDL commands, indicating incremental changes of SCHEMA
                                  #"MIGRATION" is "YYYYMMDDHHSSMM_MNAME"
MDIR/migration_lock.toml          #File with metadata, e.g. DB_PROVIDER

_prisma_migrations                #TABLE recording all applied MIGRATIONs in dev|production database
                                  #Includes applied MIGRATIONs:
                                  #  - list: to detect additions|removals
                                  #  - checksums: to detect changes

LOCAL VS PRODUCTION ==>           #prisma migrate dev|reset|db seed|diff: local development
                                  #prisma migrate deploy|resolve|status: production|CI

prisma migrate dev                #Create migration file by comparing:
                                  #  - current SCHEMA
                                  #  - all previously applied migrations (_prisma_migrations)
                                  #     - by creating a temporary "shadow database" and applying all migrations to it
                                  #If dev database has drifted from previous migrations, first call `prisma migrate reset`
--name                            #"MNAME"
--create-only                     #When not set, also apply new migration file to dev database
                                  #When set, can manually modify it first

prisma migrate reset              #Re-create dev database, then apply all migrations to it
--force                           #No confirmation prompt

package.json prisma.seed          #"SEED_COMMAND". Shell command meant to populate dev database with data
                                  #Recommended location: ./prisma/seed.ts
prisma db seed [-- ARGS...]       #Calls "SEED_COMMAND ARGS..."
prisma migrate dev|reset
--skip-seed                       #Unless set, calls `prisma db seed` at the end of `prisma migrate reset`

prisma migrate deploy             #Applies new migrations to production database

prisma migrate resolve            #Fix a failed migration by changing its status in _prisma_migrations TABLE
--applied                         #"MIGRATION". Mark failed migration as successful, i.e. not retried
--rolled-back                     #"MIGRATION". Mark failed migration to retry

prisma migrate status             #Print information about migrations for the production database:
                                  #  - count
                                  #  - whether new migrations exist
                                  #Exit code 0 if no issues nor new migrations

prisma migrate diff               #Compare 2 databases|SCHEMAs, printing result on stdout
                                  #Must have same "DB_PROVIDER"
--script                          #Print migration SQL instead
--exit-code                       #Exit code 2 if there is a diff
                                  #With|without it: exit code 1 if error
--from|to-*                       #Must use one for each
--from|to-url                     #Database connection "URL", as is
--from|to-schema-datasource       #Database connection "URL", using "PATH" to SCHEMA, then using datasource.url
--from|to-schema-datamodel        #"PATH" to SCHEMA
--from|to-migrations              #"DIR" to MIGRATION files
--from|to-empty                   #Empty database

ENVVAR PRISMA_SCHEMA_             #Unless set, use database advisory lock to prevent running 2 concurrent `prisma migrate` against same production database
 DISABLE_ADVISORY_LOCK            #Always 10 seconds timeout

ENVVAR HTTP[S]_PROXY|NO_PROXY     #Can be used


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EXECUTE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma db execute                 #Run SQL against database
                                  #Output only meant for debugging or success reporting, not returning data
                                  #Not with MongoDB
--file                            #'PATH' to SQL file
--stdin                           #SQL as stdin instead
--url                             #Def: datasource.url


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STUDIO             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PRISMA STUDIO ==>                 #Web app to create|edit|delete and view|filter|sort database
                                  #Only the data modelled with SCHEMA

prisma studio                     #Start local server, then open studio web app
--port|-p                         #NUM (def: 5555)
--browser|-b
ENVVAR BROWSER                    #'COMMAND' (def: default browser)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT MAIN          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@prisma/client                    #Node.js client
@prisma/client/edge.js            #JavaScript client, for edge computing
@prisma/client/index-browser.js   #Browser client
OPATH[/...]                       #Should be used instead of @prisma/client[/...] when either:
                                  #  - Deno
                                  #  - custom generator.output

ENVVAR
 PRISMA_GENERATE_SKIP_AUTOINSTALL #Unless set, `prisma generate` installs @prisma/client, if 'prisma-client-js' GENERATOR_PROVIDER
ENVVAR
 PRISMA_SKIP_POSTINSTALL_GENERATE #UNless set, @prisma/client has a `postinstall` script that calls `prisma generate`

new PrismaClient([POPTS])         #CLIENT
                                  #Since each CLIENT has its pool of database connections, should instantiate only one per PROCESS

CLIENT.$connect()->>              #Start pool of database connections
                                  #Automatically called on first database query
CLIENT.$disconnect()->>           #Stop pool of database connections
                                  #Automatically called on 'beforeExit'
CLIENT.$on('beforeExit',FUNC()->>)#Called on process.on('beforeExit'), before $disconnect()
                                  #Only if generator.engineType 'binary'

CLIENT.$use                       #Adds middleware FUNC
 (FUNC(MPARAMS, MFUNC(MPARAMS)->>RES)->>RES)#Called before database queries
                                  #FUNC() must call MFUNC(MPARAMS) to end
MPARAMS.model                     #'MODEL'
MPARAMS.action                    #'METHOD' of CMODEL.METHOD(OPTS) being called
MPARAMS.args                      #OPTS_OBJ passed to CMODEL.METHOD(OPTS)
MPARAMS.dataPath                  #'VAR'_ARR when using CPROMISE.FIELD()
MPARAMS.runInTransaction          #BOOL. Whether uses $transaction

CLIENT.$extend(OBJ)->CLIENT       #
                                  #See https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#remarks-35 ???
                                  #Cannot use CLIENT.$use|$on(...) anymore

CLIENT.MODEL                      #CMODEL
                                  #MODEL is lowercase'd
                                  #Fully typed according to SCHEMA, except nested|populated models
CMODEL.METHOD(...)->CPROMISE      #CPROMISE behaves like a PROMISE except lazy: only start on then()|catch()|await
CPROMISE.FIELD()->CPROMISE        #Returns COBJ.FIELD instead of COBJ
                                  #FIELD is fetched in a separate database query, not a join
                                  #Parent must not be:
                                  #  - CMODEL.*Many()
                                  #  - another CPROMISE.FIELD() on an ARR FIELD

COBJ                              #MODEL as an OBJ
BATCH.count                       #NUM of COBJs created|updated|deleted


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT ERROR          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Prisma.Prisma*Error               #ERROR class instances, to use with `instanceof`
ERROR.message                     #STR
ERROR.meta                        #OBJ. Additional context, e.g. FIELDs
                                  #Only with PrismaClientKnownRequestError
ERROR.clientVersion               #'X.Y.Z'

ERROR.code                        #'PNXXX'
                                  #XXX are digits
                                  #N is category among:
                                  #  - 1: common
                                  #  - 2: query engine
                                  #  - 3: schema engine
                                  #  - 4: prisma db pull
                                  #  - 5: data proxy
                                  #  - 6: Accelerate
                                  #Only with PrismaClientKnownRequestError
                                  #Also printed by CLI
ERROR.errorCode                   #Same but only with PrismaClientInitializationError

PrismaClientInitializationError   #Error during CLIENT.$connect()
                                  #E.g. database connection issues, missing query engine binary, etc.
PrismaClientValidationError       #Invalid arguments passed to CLIENT method
PrismaClientKnownRequestError     #Database error, e.g. unique constraint
PrismaClientUnknownRequestError   #Uncaught exception or unknown database response
PrismaClientRustPanicError        #Rust process crash. Should restart current process


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT LOG           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


POPTS.log                         #'LEVEL'_ARR|PLOG_OPT_ARR
PLOG_OPT.level                    #'LEVEL' among:
                                  #  - 'error'
                                  #  - 'warn' (def)
                                  #  - 'info'
                                  #  - 'query': debug, including all SQL queries
ENVVAR DEBUG=prisma:client        #CLIENT-related debug logs

PLOG_OPT.emit                     #STR among:
                                  #  - 'stdout' (def): print to stdout
                                  #  - 'event': emit 'LEVEL' EVENT
CLIENT.$on('error|warn|info',
 FUNC(LOG_EVENT))                 #
CLIENT.$on('query',
 FUNC(QUERY_EVENT))               #
LOG|QUERY_EVENT.timestamp         #DATE
LOG|QUERY_EVENT.target            #STR
LOG_EVENT.message                 #STR. Log message
QUERY_EVENT.query                 #STR. SQL query
QUERY_EVENT.params                #STR. SQL query parameters
QUERY_EVENT.duration              #NUM (in ms) from client sending to receiving

POPTS.errorFormat                 #Error message format, among:
                                  #  - 'pretty' (def): colors + hints on how to fix
                                  #  - 'colorless': hints on how to fix
                                  #  - 'minimal': neither
ENVVAR NO_COLOR                   #Like POPTS.errorFormat 'colorless'
ENVVAR NODE_ENV=production        #Like POPTS.errorFormat 'minimal'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT READ          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.findMany([OPTS])->>COBJ_ARR#Get all matching COBJs, like SQL `select`
OPTS.where|select|include|orderBy
 |cursor|take|skip                #See below
OPTS.distinct                     #'FIELD'_ARR. Ignore COBJs with duplicate values for those FIELDs
                                  #Done at the ORM-level, not using a SQL `distinct on (...)`

CMODEL.findFirst[OrThrow]         #Get one matching COBJ, like SQL `select ... limit 1`
 ([OPTS])->>COBJ|null             #If none:
                                  #  - if `OrThrow`: throw NotFoundError
                                  #  - otherwise: returns null
OPTS.where|select|include|orderBy
 |cursor|skip|distinct            #See below
OPTS.take                         #Like below, except only 1 (def) or -1

CMODEL.findUnique[OrThrow]        #Like findFirst[OrThrow]() except OPTS.where is UFILTERS and required.
 (OPTS)->>COBJ|null               #Also, optimized because multiple calls are batched into a single SQL query
OPTS.where|select|include         #See below


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT CREATE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.create(OPTS)->>COBJ        #Create one COBJ, like SQL `insert`
OPTS.select|include               #See below
OPTS.data                         #CREATES. Required
CREATES.*                         #Like COBJ.*

CMODEL.createMany(OPTS)->>BATCH   #Create multiple COBJs, like SQL `insert`
                                  #Not with SQLite
OPTS.data                         #COBJ_ARR. Required
OPTS.skipDuplicates               #BOOL (def: false). Ignore COBJs with FIELDs that fail @[@]unique|@[@]id constraint,
                                  #i.e. another COBJ2 already exists with it.
                                  #Like SQL `insert ... on conflict do nothing`
                                  #Not with SQL server, MongoDB


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT UPDATE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.update(OPTS)->>COBJ        #Update one COBJ, like SQL `update`
                                  #Throw NotFoundError if not found
OPTS.where                        #See below. Required
OPTS.select|include               #See below
OPTS.data                         #UPDATES. Required

CMODEL.updateMany(OPTS)->>BATCH   #Update multiple COBJs, like SQL `update`
OPTS.where                        #See below
OPTS.data                         #UPDATES. Required

CMODEL.upsert(OPTS)->>COBJ        #Like either create() or update()
                                  #Uses SQL `insert ... on conflict do update set ... where`
                                  #  - this avoids conflict when 2 concurrent upserts happens at once
                                  #  - not if nested write|read
                                  #  - only if single COBJ upserted
                                  #  - only if single OPTS.where FIELD, and it is present in OPTS.create with the same value
                                  #  - only with Postgres, SQLite, CDB
OPTS.where                        #See below. Required
OPTS.select|include               #See below
OPTS.create                       #Required. Like create()'s OPTS.data when COBJ does not exist
OPTS.update                       #Required. Like update()'s OPTS.data when COBJ exists

UPDATES                           #Like SQL `update ... set ... where ...`
UPDATES.FIELD[.UPDATE]            #VAL
                                  #Def UPDATE: 'set'
                                  #Can only specify one UPDATE per FIELD

UPDATE set                        #VAL. VAR = VAL
UPDATE unset                      #VAL. VAR = undefined
                                  #Only with MongoDB

NUM_UPDATE increment|decrement    #NUM2. NUM += -= NUM2
NUM_UPDATE multiply|divide        #NUM2. NUM *= /= NUM2

OBJ_UPDATE update                 #OBJ2. Shallow merge
                                  #Fail if OBJ undefined
OBJ_UPDATE upsert.set|update      #OBJ2. Set with `set` if OBJ undefined, shallow merge with `update` otherwise

ARR_UPDATE push                   #VAL[_ARR]. ARR.push(VAL[,...])
                                  #Only with Postgres, MongoDB


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT DELETE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.delete(OPTS)->>COBJ        #Delete one COBJ, like SQL `delete`
                                  #Throw NotFoundError if not found
OPTS.where                        #See below. Required
OPTS.select|include               #See below

CMODEL.deleteMany([OPTS])->>BATCH #Delete many COBJs, like SQL `delete`
OPTS.where                        #See below


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     CLIENT NESTED WRITES      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CREATES|UPDATES.MODEL_FIELD       #Nested writes on child MODELs
                                  #Also sets foreign key FIELDs
                                  #Rolled back if any fails
                                  #Only with create|update|upsert(), not createMany|updateMany()

CREATES|UPDATES.MODEL_FIELD       #COBJ[_ARR]
 .create                          #Nested `create`: add child MODELs. Does not merge

CREATES|UPDATES.MODEL_FIELD       #COBJ_ARR
 .createMany.data                 #Like nested `create` COBJ_ARR, but faster
                                  #Cannot nest further
                                  #Only with 1-n relationships

UPDATES.MODEL_FIELD.set           #COBJ[_ARR]
                                  #Set child MODELs

UPDATES.MODEL_FIELD.update[Many]  #OBJ[_ARR]: data UPDATES2[, where COBJ]
                                  #Can also be just UPDATES2
                                  #Nested `update[Many]`: update existing child MODELs
                                  #Fails if no matches

UPDATES.MODEL_FIELD.upsert        #OBJ[_ARR]: create COBJ, update UPDATES2[, where COBJ]
                                  #Nested `upsert`

UPDATES.MODEL_FIELD.delete[Many]  #COBJ[_ARR]
                                  #Nested `delete`: remove child MODELs
                                  #COBJ can be `true` or empty OBJ to match any
                                  #Noop if no match

CREATES|UPDATES.MODEL_FIELD       #COBJ[_ARR]
 .connect                         #Create relationship, i.e. set parent|child MODEL's foreign key FIELD to connect them
                                  #Only for child MODELs matching COBJ
                                  #Fails if no match

CREATES|UPDATES.MODEL_FIELD       #OBJ: where COBJ, create COBJ
 .connectOrCreate                 #Like `connect`, but if `where` does not match, does a nested `create` instead

CREATES|UPDATES.MODEL_FIELD       #COBJ[_ARR]
 .disconnect                      #Like `connect`, but unsets instead
                                  #COBJ can be `true` or empty OBJ to match any
                                  #Noop if no match


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       CLIENT AGGREGATE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.select|include._count        #OPTS2 (only select|where). Special MODEL_FIELD that returns child MODELs ARR.length
                                  #I.e. OPTS.select._count.select.MODEL_FIELD BOOL -> { _count: { FIELD: NUM } }
                                  #Must be top-level OPTS

CMODEL.count([OPTS])->>NUM        #Count OBJs, like SQL `select count(*)`
OPTS
 .where|orderBy|cursor|take|skip  #See below
OPTS.select                       #When used, returns COBJ, with NUM values
                                  #Can use FIELD `_all`

CMODEL.aggregate(OPTS)->>OBJ      #Aggregate OBJs, like SQL AFUNCs
                                  #Returns OBJ:
                                  #  - _*.FIELD NUM: for each OPTS._*.FIELD
OPTS
 .where|orderBy|cursor|take|skip  #See below
OPTS._*                           #Can use FIELD `_all`
                                  #If not _all, only non-undefined|null values
                                  #  - if only undefined values and not _count, returns `null`
OPTS._count[.FIELD]               #BOOL. Like SQL `select count(*)`
                                  #Def FIELD: _all
OPTS._avg|_sum.FIELD              #BOOL. Like SQL `select avg|sum()`
OPTS._min|_max.FIELD              #BOOL. Like SQL `select min|max()`

CMODEL.groupBy(OPTS)->>ARR        #Group and aggregate OBJs, like SQL AFUNCs + `group by`
                                  #Returns OBJ_ARR:
                                  #  - FIELD VAL: for each OPTS.by
                                  #  - _*.FIELD NUM: for each OPTS._*.FIELD
OPTS
 .where|orderBy|cursor|take|skip  #See below
OPTS._count|_avg|_sum|_min|_max   #See above
OPTS.by                           #'FIELD'[_ARR]. Like SQL `group by`
OPTS.having.FIELD._*              #FILTERS. Like SQL `having`
                                  #_* is _count|etc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       CLIENT SELECTION        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.select.NON_MODEL_FIELD       #BOOL. Returns NON_MODEL_FIELD
                                  #Def: false if OPTS.select defined, true otherwise

OPTS.include.MODEL_FIELD          #BOOL (def: false). Returns and populates child MODEL (ARR or not)

OPTS.select|include.MODEL_FIELD   #OPTS2 (only select|include|where|orderBy)
                                  #Apply OPTS2 on child MODEL (ARR or not)
                                  #Implies OPTS.include.MODEL_FIELD true
                                  #Can mix OPTS.include|select at different levels, but not same one


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT SORT          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.orderBy                      #ORDER[_ARR], like SQL `order by`
ORDER.FIELD                       #FORDER
                                  #With groupBy(): FIELD must be among the ones grouped (OPTS.by)

FORDER._count                     #FORDER2. Sort by _count
FORDER._*                         #FORDER2. Sort by _avg, etc.
                                  #Only with groupBy()

FORDER.FIELD                      #FORDER2. Sort by OBJ_TYPE|MODEL nested property

FORDER[.sort]                     #'asc|desc'. Sort by VAL
FORDER.count                      #'asc|desc'. Sort by ARR.length
FORDER.nulls                      #'first' (def) or 'last'
                                  #Not with MongoDB
                                  #FIELD must not be required nor a MODEL FTYPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        CLIENT PAGINATE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.take                         #NUM (can be negative). Only return first|last COBJs, like SQL `limit`
OPTS.skip                         #NUM of COBJs to skip, like SQL `offset`

OPTS.cursor                       #UFILTERS. Pagination: start at the matching COBJ
                                  #Should use OPTS.skip 1 to avoid repeating the matching COBJ


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     CLIENT FILTER GENERAL     :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.where                        #FILTERS

FILTERS                           #Filter COBJs, like SQL `where`
UFILTERS                          #FILTERS, but at least one FIELD must have @[@]unique|@[@]id
FILTERS.FIELD[.FILTER]            #VAL
                                  #Def FILTER: 'equals'
                                  #Each FILTER is and'd
                                  #With OBJ|ARR value: full, ordered match unless indicated otherwise

FILTERS.NOT                       #FILTERS2
FILTERS.AND|OR                    #FILTERS2_ARR
                                  #Cannot nest, but can define AND|OR|NOT together

Prisma.validator                  #Workaround to add correct TypeScript types to FILTERS, without widening them
 (...)(FILTERS)->FILTERS          #Should prefer instead `const FILTERS = { ... } satisfies TYPE`
                                  #Also for OPTS.orderBy

undefined                         #As input: always ignored
                                  #In this documentation, can also mean DbNull
Prisma.DbNull                     #Database NULL. With MongoDB, it is actually undefined
                                  #In FILTERS|COBJ|UPDATES
Prisma.JsonNull                   #null in JSON value
null                              #In FILTERS|COBJ|UPDATES
                                  #With MongoDB, same as DbNull
Prisma.AnyNull                    #DbNull|JsonNull
                                  #Only in FILTERS

CMODEL.fields.FIELD               #Can be used as a FILTER's VAL, to allow comparing FIELDs within same COBJ
                                  #Must be same CMODEL
                                  #FIELD cannot use @[@]unique|@[@]id
                                  #Cannot be within UFILTERS
                                  #If used in OPTS.having.FIELD, OPTS.by must include 'FIELD'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      CLIENT FILTER LIST       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FILTER equals|not                 #VAL. === !==
                                  #If on child MODEL and VAL null (or empty OBJ): means === !== undefined
FILTER in                         #ARR. ARR.includes(VAL)
FILTER notIn                      #ARR. !ARR.includes(VAL)
                                  #Does not return null values (same for `NOT + in`)
FILTER isSet                      #BOOL. !== undefined
                                  #Only with MongoDB

STR|NUM|DATE_FILTER lt[e]|gt[e]   #STR|NUM|DATE2. < <= > >=

STR_FILTER contains               #STR2. STR.includes(STR2)
                                  #With Postgres|MySQL, uses `[i]like`, i.e. must \-escape % _
STR_FILTER starts|endsWith        #STR2
                                  #Escaping: like STR_FILTER contains
FILTER mode                       #'insensitive'. Make other FILTERs case-insensitive
                                  #JSON_FILTER: always case-sensitive
                                  #STR_FILTER search (text search): always case-insensitive
                                  #Implemented by:
                                  #  - Postgres: use a non-deterministic COLLATION
                                  #     - citext: always case-insensitive
                                  #     - not with COLLATION C|POSIX
                                  #  - MongoDB: use a /REGEXP/i
                                  #  - others: case-insensitive by default
                                  #     - can be changed using a different COLLATION

ARR_FILTER                        #Only with Postgres, CDB, MongoDB
ARR_FILTER has                    #VAL. ARR.includes(VAL) && ARR.length !== 0
ARR_FILTER hasEvery               #ARR2. ARR2.every(VAL => ARR.includes(VAL)) && ARR2.length !== 0
ARR_FILTER hasSome                #ARR2. ARR2.some(VAL => ARR.includes(VAL)) && ARR2.length !== 0
ARR_FILTER isEmpty                #BOOL. ARR.length === 0

OBJ_[ARR_]FILTER                  #Not with findUnique|count|aggregate|groupBy()
OBJ_FILTER                        #Can be used for MODELs too
OBJ_FILTER is[Not]                #FILTERS. Whether OBJ partially matches it

OBJ_ARR_FILTER some               #FILTERS. OBJ_ARR.some(FILTERS) && OBJ_ARR.length !== 0
                                  #If FILTERS empty: OBJ_ARR.length !== 0
OBJ_ARR_FILTER none               #FILTERS. !OBJ_ARR.some(FILTERS)
                                  #If FILTERS empty: OBJ_ARR.length === 0
OBJ_ARR_FILTER every              #FILTERS. OBJ_ARR.every(FILTERS)

JSON_FILTER                       #Only with Postgres, MySQL
JSON_FILTER path                  #'VAR|NUM'_ARR. Make other JSON_FILTERs apply on JSON#>'VAR'_ARR
                                  #MySQL: JSONPath (e.g. '$.VARR') instead
JSON_FILTER string_contains       #STR. Like STR_FILTER contains
JSON_FILTER starts|ends_with      #STR. Like STR_FILTER startsWith|endsWith
JSON_FILTER array_contains        #ARR. Like ARR_FILTER hasEvery
JSON_FILTER array_starts|ends_with#VAL. ARR.at(0|-1) === VAL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      CLIENT TEXT SEARCH       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEXT SEARCH ==>                   #Only with Postgres, MySQL
                                  #Requires PREVIEW fullTextSearch

@@fulltext(OPTS.fields)           #Text search index
                                  #Only with MySQL, MongoDB
                                  #Requires PREVIEW fullTextIndex

STR_FILTER search                 #STR2. Text search filtering
                                  #Database-specific syntax, e.g. 'TSQUERY' with Postgres

OPTS.orderBy._relevance           #SEARCH_ORDER. Text search sorting
SEARCH_ORDER.fields               #'FIELD'_ARR
SEARCH_ORDER.search               #Like STR_FILTER search
SEARCH_ORDER.sort                 #'asc|desc'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT QUERY          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT.$queryRaw('SQL')->>COBJ_ARR#Perform SQL query that returns a ROW_SET
                                  #Not with MongoDB
CLIENT.$executeRaw('SQL')->>NUM   #Same but for SQL query that does not return a ROW_SET
                                  #Returns NUM of created|updated|deleted ROWs

CLIENT.$*Raw`SQL`                 #Run as SQL prepared statements, with each ${...} passed as value, i.e. sanitized
                                  #See database doc for restrictions related to SQL prepared statements
                                  #Only allow a single SQL statement, to prevent injections
${...}                            #Must be its own SQL token, e.g. not inside a 'STR', "VAR", etc.
                                  #Must be a SQL VAL, not a "VAR"

Prisma.sql`SQL`                   #sql-template-tag, used under the hood (see its doc)
                                  #CLIENT.$*Raw(`SQL`) is same as CLIENT.$*Raw(Prisma.sql`SQL`)
Prisma.raw('SQL')
Prisma.empty
Prisma.join(ARR[, ...])           #Same as sql-template-tag (see its doc)

CLIENT.$*RawUnsafe('SQL'[,VAL...])#Same as $*Raw`SQL`, except ${...} are passed as VAL... arguments instead
                                  #If VAL..., 'SQL' must use database-specific syntax for prepared statement variables:
                                  #  - Postgres: `$NUM`
                                  #  - MySQL: `?`
