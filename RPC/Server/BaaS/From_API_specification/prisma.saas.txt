
          
   PRISMA  
          


To do:
  - extensions:
     - https://github.com/prisma/extension-read-replicas
     - https://www.prisma.io/docs/concepts/components/prisma-client/client-extensions/extension-examples
     - https://www.prisma.io/ecosystem (extensions)
     - https://www.npmjs.com/search?q=prisma%20extension
  - https://www.prisma.io/ecosystem (others)
  - look for prisma on GitHub
  - generator:
     - docs:
        - https://github.com/pantharshit00/prisma-docs-generator
     - diagram:
        - https://github.com/keonik/prisma-erd-generator
        - https://github.com/samchon/prisma-markdown
     - JSON schema:
        - https://github.com/valentinpalkovic/prisma-json-schema-generator
     - JSON types:
        - https://github.com/arthurfiorette/prisma-json-types-generator
     - REST:
        - https://github.com/omar-dulaimi/prisma-json-server-generator
     - faker:
        - https://github.com/luisrudge/prisma-generator-fake-data
     - testing:
        - https://github.com/Quramy/jest-prisma
  - add summary


VERSION ==>                       #5.4.2 (2023-10-16)

OPEN-SOURCE ==>                   #Most of it except Data Platform (Accelerate, Proxy, Pulse), studio

NON-GOALS ==>                     #Not meant as full BaaS:
                                  #  - no database hosting
                                  #  - no API hosting
                                  #  - no API generation by default (although can be done with generators)

DENO ==>                          #Since it does not use node_modules, must use custom generator.output
                                  #Deno deploy also requires PREVIEW 'deno'

RDS PROXY ==>                     #Prisma uses prepared statements, which pins client to connections, i.e. no benefit from poolign


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              CLI              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma                            #CLI

prisma version                    #Version of prisma CLI|client|studio and current OS

ENVVAR PRISMA_HIDE_UPDATE_MESSAGE #Do not print version upgrade warning
ENVVAR PRISMA_DISABLE_WARNINGS    #Do not print any warnings

ENVVAR CHECKPOINT_DISABLE=1       #Do not send anonymous CLI usage telemetry


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           PREVIEWS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma --preview                  #Required for CLI experimental features

generator.previewFeatures         #STR_ARR. Required for SCHEMA|CLIENT experimental PREVIEW features

ENVVAR
 PRISMA_HIDE_PREVIEW_FLAG_WARNINGS#Do not warn on PREVIEWs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ENGINES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ENGINE ==>                        #Rust libraries used by the TypeScript components (CLI, CLIENT)
                                  #When bundling, must make sure those are included

PSL ==>                           #Engine used to parse|serialize|validate|format SCHEMA
                                  #Used by schema|format|query engines, i.e. as a Rust dependency

SCHEMA ENGINE ==>                 #Engine used by `schema db|migrate`
                                  #Downloaded as postinstall script during `npm install prisma`
                                  #Def: inside node_modules/@prisma/engines/...
                                  #Runs as a separate executable file, as a HTTP server

FORMAT ENGINE ==>                 #Engine used by `schema format`
                                  #Loaded by CLI as WASM dependency

QUERY ENGINE ==>                  #Engine performing database queries, used by both the CLI and the CLIENT
                                  #Also create|delete|pool database connections
                                  #Downloaded the same way as schema engine
                                  #Loaded either as a:
                                  #  - library (def):
                                  #     - embedded in library, as a Node.js addon
                                  #     - takes more space, which is an issue inside serverless functions
                                  #  - binary:
                                  #     - separate executable file, as a HTTP server
                                  #     - slower due to IPC
                                  #  - none (--no-engine):
                                  #     - use Query engine bundled in Accelerate proxy, when using those
                                  #     - as above, slower due to IPC, but smaller space, i.e. only useful for serverless functions

generator.engineType
ENVVAR PRISMA_CLIENT_ENGINE_TYPE  #ENUM library|binary. How query engine should be used by CLIENT
ENVVAR
 PRISMA_CLI_QUERY_ENGINE_TYPE     #Same but for query engine used by CLI
prisma generate --no-engine
ENVVAR PRISMA_GENERATE_NO_ENGINE  #With "prisma-client-js" only

ENVVAR PRISMA_SCHEMA_ENGINE_BINARY#'PATH' to schema engine binary
ENVVAR PRISMA_QUERY_ENGINE_LIBRARY#'PATH' to query engine binary (Node.js addon)
                                  #Only with engineType 'library'
ENVVAR PRISMA_QUERY_ENGINE_BINARY #'PATH' to query engine binary (executable file)
                                  #Only with engineType 'binary'

ENVVAR PRISMA_ENGINES_MIRROR      #URL where to download schema|query engine binaries
                                  #Def: https://binaries.prisma.sh
ENVVAR PRISMA_ENGINES_
 CHECKSUM_IGNORE_MISSING          #Unless set, verify checksum of schema|query engine binaries

generator.binaryTargets           #STR_ARR. OS|CPU targets of schema|query engines to download, i.e. where CLI and client will run
ENVVAR PRISMA_CLI_BINARY_TARGETS  #Can be:
                                  #  - "native" (def): current
                                  #  - "debian-openssl-X.Y.x": Debian|Ubuntu|Mint|ArchLinux
                                  #  - "rhel-openssl-X.Y.x": Fedora|CentOS, Amazon Linux (Lambda x86)
                                  #  - "linux-musl[-arm64][-openssl-3.0.x]": Alpine >=|< 3.17, x86|ARM64
                                  #  - "linux-arm64-openssl-X.Y.x": other Linux ARM64 (glibc) Amazon Linux (Lambda ARM64)
                                  #  - "darwin[-arm64]"
                                  #  - "windows"

ENVVAR DEBUG=prisma:engine        #Engine-related debug logs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        SCHEMA GENERAL         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SCHEMA ==>                        #Defines data model in a declarative way
                                  #File must be available at runtime
                                  #  - i.e. should avoid skipping it during bundling

FORMAT ==>                        #PSL ("Prisma Schema Language"). GraphQL-like

prisma validate                   #Validate SCHEMA
prisma format                     #Validate and prettify SCHEMA, saving on-file

prisma init                       #Scaffold ./prisma/schema.prima and ./.env

prisma generate|validate|format
 |studio
prisma db pull|push|execute       #PATH to SCHEMA
prisma migrate dev|reset|deploy   #Def:
 |resolve|status                  #  - package.json prisma.schema 'PATH'
--schema=PATH                     #  - [.../]./[prisma/]schema.prisma

VSCODE EXTENSION ==>              #SCHEMA's syntax highlighting, linting, autocomplete, formatting, jump-to-definition, hovering help
                                  #There is also for other IDEs

SCHEMA VIEWER ==>                 #In Data platform
                                  #Requires linking to SCHEMA file, through GitHub integration
                                  #  - also needed for data browser and query console

```prisma
...
```                               #Can be used on GitHub

//COMMENT                         #
///COMMENT                        #Same but present when parsing as AST, i.e. can be used by tooling

env("ENVVAR")                     #"VAL"
                                  #Only for datasource.url and generator.binaryTargets

.env                              #Dotenv is parsed, to set any of the ENVVARs
                                  #Must be in same DIR as SCHEMA or in ./prisma
                                  #Can use $ENVVAR, ${ENVVAR}, ${ENVVAR:-DEFAULT}


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       SCHEMA DATASOURCE       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


datasource DB {
  VAR = VAL                       #Database
  ...                             #Only one per schema
}                                 #DB is often "db"
POPTS.datasources.DB              #Same as OBJ
                                  #Cannot set provider

datasource.provider               #"DB_PROVIDER". Database type ("connector") among:
prisma init --datasource-provider #  - "postgresql" (>=9.6): has most support
                                  #  - "mysql"
                                  #  - "sqlserver"
                                  #  - "sqlite"
                                  #  - "cockroachdb"
                                  #  - "mongodb" (>=4.2): has fewer features
datasource.url                    #Connection "URL" to the main database
POPTS.datasourceUrl               #E.g.:
prisma init --url                 #  - Postgres: 'LIBPQ'
                                  #  - SQLite: 'file:./PATH.db'

@prisma/adapter-*                 #ADAPTER
                                  #Fixes database connection for specific providers: neon, PlanetScale, turso
                                  #Requires PREVIEW driverAdapters
POPTS.adapter                     #ADAPTER

LIBPQ.*                           #In connection 'URL', different from Postgres ones
LIBPQ.options|host|connect_timeout
 |application_name|sslcert
 |sslpassword|channel_binding     #Like Postgres
LIBPQ.socket_timeout              #NUM (def: none). Query timeout
LIBPQ.sslidentity                 #Like Postgres LIBPQ.ssl_key_file
LIBPQ.sslcert                     #Like Postgres LIBPQ.ssl_cert_file
LIBPQ.sslmode                     #Like Postgres, but no "allow" nor "verify-*"
LIBPQ.sslaccept                   #'accept_invalid_certs' (def) or 'strict'
                                  #Whether to allow missing values in certificates
LIBPQ.pgbouncer                   #BOOL (def: false). When using pgBouncer

datasource.extensions             #ARR of EXTENSION[(ARG: "VAL",...)]
                                  #Postgres EXTENSIONs. ARGs (all optional):
                                  #  - version "EVERSION"
                                  #  - schema "SCHEMA"
                                  #  - map "EXTENSION2": like @map but for "EXTENSION"
                                  #Requires PREVIEW postgresqlExtensions


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      SCHEMA TYPE COMPLEX      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


model MODEL {
  FIELD FTYPE [@ATTR]...
  ...                             #Database TABLE
  [@@ATTR]                        #Can use MODEL as FTYPE
  ...                             #With any database
}                                 #JavaScript client: OBJ|ARR

view VIEW { ... }                 #Database VIEW
                                  #Same syntax and behavior as MODEL
                                  #With any database
                                  #Requires PREVIEW views
./prisma/views/SCHEMA/VIEW.sql    #SQL query of VIEW
                                  #Created by `prisma db pull`

type OBJ_TYPE { ... }             #"Composite type"
                                  #Same syntax as `model MODEL`
                                  #No @unique, @id, @relation, @ignore, @updatedAt
                                  #Can use OBJ_TYPE as FTYPE
                                  #Only with MongoDB
                                  #JavaScript client: OBJ

enum ENUM { ... }                 #Same syntax as `model MODEL`, except no FTYPE
                                  #Only @[@]map
                                  #Can use ENUM as FTYPE
                                  #Postgres|MySQL|CDB: enum type
                                  #MondoDB: done at ORM-level
                                  #Not with SQLite nor SQL server
                                  #TypeScript client: ENUM
                                  #In schema: FIELD

MODEL|VIEW|ENUM|OBJ_TYPE          #Name must be [[:alnum:]_] and not start with _ nor digit
                                  #Usually CamelCase, singular
                                  #Cannot be one of the JavaScript reserved keywords, nor "Prisma[Client]"

FIELD                             #Database COL name
                                  #Must be [[:alnum:]_] and not start with _ nor digit
                                  #Usually camelCase
                                  #Cannot be "AND|OR|NOT"
FIELD_VARR                        #FIELD name
                                  #Can be dot-delimited for OBJ_TYPE

FTYPE?                            #Optional FTYPE
                                  #Most databases: `not null`
                                  #MongoDB: done at ORM-level
                                  #Implies @default null

FTYPE[]                           #ARR ("list")
                                  #Not with SQLite, MySQL, SQL server
                                  #Cannot be FTYPE[]? nor FTYPE?[]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      SCHEMA TYPE SIMPLE       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


String                            #Postgres: text, MongoDB: String, SQLite: TEXT, also MySQL, SQL server, CDB
                                  #JavaScript client: STR
                                  #In schema: "..."
String @db.Text                   #Postgres: text, SQLite: TEXT, also MySQL, SQL server
String @db.Char(NUM)              #Postgres: char(NUM), also MySQL, SQL server, CDB
String @db.VarChar(NUM)           #Postgres: varchar(NUM), also MySQL, SQL server
String @db.Bit(NUM)               #Postgres: bit(NUM), also CDB
String @db.VarBit                 #Postgres: varbit, also CDB
String @db.Uuid                   #Postgres: uuid, also CDB
String @db.Xml                    #Postgres: xml, also SQL server
String @db.Inet                   #Postgres: inet, also CDB
String @db.Citext                 #Postgres: citext
String @db.Tiny|Medium|LongText   #Only MySQL
String @db.NText                  #Only SQL server
String @db.N[Var]Char(NUM)        #Only SQL server
String @db.UniqueIdentifier       #Only SQL server
String @db.CatalogSingleChar      #Only CDB
String @db.String                 #MongoDB: String, also CDB
String @db.ObjectId               #MongoDB: String, as objectId

Boolean                           #Postgres: boolean, MongoDB: Bool, SQLite: INTEGER, also MySQL, SQL server, CDB
                                  #JavaScript client: BOOL
                                  #In schema: true|false
Boolean @db.Boolean               #Postgres: boolean
Boolean @db.TinyInt(NUM)          #Only MySQL
Boolean @db.Bool                  #Only CDB
Boolean @db.Bit                   #MongoDB: bit, also MySQL

Int                               #Postgres: int4, MongoDB: Int, SQLite: INTEGER, also MySQL, SQL server, CDB
                                  #JavaScript client: NUM
                                  #In schema: INT
Int @db.SmallInt                  #Postgres: int2, also MySQL, SQL server
Int @db.Integer                   #Postgres: int4
Int @db.Oid                       #Postgres: oid
Int @db.Int                       #MongoDB: Int, also MySQL, SQL server
Int @db.TinyInt                   #Only MySQL, SQL server
Int @db.MediumInt                 #Only MySQL
Int @db
 .Unsigned[Tiny|Small|Medium]Int  #Only MySQL
Int @db.Year                      #Only MySQL
Int @db.Bit                       #Only SQL server
Int @db.Int2|4|8                  #Only CDB
Int @db.Long                      #MongoDB: Long

BigInt                            #Postgres: int8, MongoDB: Long, SQLite: INTEGER, also MySQL, SQL server, CDB
                                  #JavaScript client: BIGINT
                                  #In schema: INT
BigInt @db.BigInt                 #Postgres: int8, also MySQL, SQL server
BigInt @db.UnsignedBigInt         #Only MySQL
BigInt @db.Int8                   #Only CDB

Float                             #Postgres: float8, MongoDB: Double, SQLite: REAL, also MySQL, SQL server, CDB
                                  #JavaScript client: NUM
                                  #In schema: NUM
Float @db.Real                    #Postgres: float4, also SQL server
Float @db.DoublePrecision         #Postgres: float8
Float @db.Float                   #Only MySQL, SQL server
Float @db.Double                  #Only MySQL
Float @db.[Small]Money            #Only SQL server
Float @db.Float4|8                #Only CDB

Decimal                           #Postgres: numeric(65, 30), SQLite: DECIMAL, also MySQL, SQL server, CDB
                                  #Not with MongoDB
                                  #JavaScript client: DECIMAL
                                  #  - using decimal.js library, re-exported as Prisma.Decimal
                                  #In schema: NUM
Decimal @db.Decimal(NUM, NUM2)    #Postgres: numeric(NUM, NUM2), also MySQL, SQL server, CDB
Decimal @db.Money                 #Postgres: money

DateTime                          #Postgres: timestamp(3), MongoDB: Timestamp, SQLite: NUMERIC|STRING, also MySQL, SQL server, CDB
                                  #JavaScript client: DATE
                                  #In schema: "YYYY-MM-DDTHH:MM:SSTZ"
DateTime @db.Timestamp(NUM)       #Postgres: timestamp(NUM), also MySQL, CDB
DateTime @db.Timestamptz(NUM)     #Postgres: timestamptz(NUM), also CDB
DateTime @db.Date                 #Postgres: date, also SQL server, CDB
DateTime @db.Time(NUM)            #Postgres: time(NUM), also MySQL, CDB
DateTime @db.Timetz(NUM)          #Postgres: timetz(NUM), also CDB
DateTime @db.Date[Time](NUM)      #Only MySQL
DateTime @db.DateTime[2]          #Only SQL server
DateTime @db.SmallDateTime        #Only SQL server
DateTime @db.DateTimeOffset       #Only SQL server
DateTime @db.Time                 #Only SQL server

Json                              #Postgres: jsonb, MongoDB: BSON v2 relaxed, also MySQL, SQL server, CDB
                                  #Not with SQLite
                                  #JavaScript client: VAL
                                  #In schema: VAL
Json @db.Json                     #Postgres: json, also MySQL
Json @db.JsonB                    #Postgres: jsonb, also CDB
Json @db.NVarChar                 #Only with SQL server

Bytes                             #Postgres: bytea, MongoDB: BinData, SQLite: BLOB, also MySQL, SQL server, CDB
                                  #JavaScript client: Node.js BUFFER
                                  #In schema: "BASE64"
Bytes @db.ByteA                   #Postgres: bytea
Bytes @db.Binary                  #Only MySQL, SQL server
Bytes @db.VarBinary               #Only MySQL, SQL server
Bytes @db.Bit                     #Only MySQL
Bytes @db.[Tiny|Medium|Long]Blob  #Only MySQL
Bytes @db.Image                   #Only SQL server
Bytes @db.Bytes                   #Only CDB
Bytes @db.BinData                 #MongoDB: BinData
Bytes @db.ObjectId                #MongoDB: ObjectId

Unsupported("TYPE")               #Database type called exactly TYPE
                                  #Not with MongoDB
                                  #Implies @ignore
                                  #In schema: not possible


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       SCHEMA ATTRIBUTE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@ATTR[([ARG: ]VAL, ...)]          #Attribute. Options to FIELD
                                  #ARGs can always be named, and often also positional
@@ATTR[([ARG: ]VAL, ...)]         #Same for options to multiple FIELDs, or to MODEL|ENUM

@map(STR)                         #Database COL name
                                  #Def: "FIELD"
                                  #Meant when:
                                  #  - "FIELD" contains invalid characters
                                  #  - want a different name in API than in database
@@map(STR)                        #Same but for database MODEL name

@ignore                           #Omit FIELD in JavaScript client, except in raw queries
                                  #If no @default, cannot create|update|upsert MODEL
                                  #But works with prisma db|migrate
                                  #Done at the ORM-level, i.e. on any database
@@ignore                          #Same but for a MODEL

@@schema("SCHEMA")                #MODEL's database "SCHEMA" (def: default database "SCHEMA")
                                  #"SCHEMA" is database concept, not Prisma concept with the same name
                                  #Only with Posgres, SQL server, CDB
                                  #Requires PREVIEW "multiSchema"
datasource.schemas                #Database 'SCHEMA'_ARR available to @@schema
LIBPQ.schema                      #Default 'SCHEMA'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        SCHEMA DEFAULT         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@updatedAt                        #Set on each MODEL update (unless overridden) with current time
                                  #DateTime FTYPE
                                  #Done at ORM-level, i.e. for any database

@default(OPTS[.value])            #FIELD's default VAL
                                  #For any database
                                  #If none, FIELD is required
OPTS.map                          #STR. Only for SQL server
OPTS.value                        #Default VAL
                                  #Can also use any of the following

now()                             #DateTime FTYPE
                                  #With most databases: current_timestamp
                                  #MongoDB: done at ORM-level

uuid()                            #String FTYPE
                                  #Done at ORM-level, i.e. for any database
                                  #UUIDv4
cuid()                            #String FTYPE
                                  #Done at ORM-level, i.e. for any database
                                  #CUID1 (min 30 chars)

autoincrement()                   #Postgres: serial2|4|8, SQLite: AUTOINCREMENT, also with MySQL, SQL server, CDB
                                  #Int FTYPE
                                  #  - Postgres: Int @db.[Small|Big]Int
                                  #Not with MongoDB

dbgenerated('EXPR')               #Database-specific EXPR, e.g. FUNC(), OPs, etc.
                                  #Not with MongoDB

auto()                            #ObjectId
                                  #String @db.ObjectId FTYPE
                                  #Must use @map("_id")
                                  #Only with MongoDB

sequence(...)                     #SEQUENCE table
                                  #Only with CDB


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         SCHEMA INDEX          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@id[(OPTS)]                       #Primary key constraint on one FIELD
                                  #Only one per MODEL
                                  #Required for each MODEL
                                  #  - alternative: one @[@]unique, if required and not MongoDB
                                  #For any database
                                  #MongoDB:
                                  #  - required
                                  #  - must use @map("_id")
                                  #  - if ObjectId, must use:
                                  #     - String|Bytes @db.ObjectId
                                  #     - optional: @default(auto())
                                  #Cannot be on optional FIELD
OPTS.map|length|clustered         #Like @@index
OPTS.sort                         #Like @@index
                                  #Only with SQL server

@@id(OPTS)                        #Like @id, but on multiple FIELDs
                                  #Not with MongoDB
OPTS.sort|map|length|clustered    #Like @id
OPTS.fields|name                  #Like @@index

@unique[(OPTS)]                   #Unique constraint on one FIELD
                                  #For any database
                                  #nulls are distinct
OPTS.sort|map|length|clustered    #Like @@index

@@unique(OPTS[.fields])           #Like @unique, but on multiple FIELDs
                                  #With MongoDB: index must be created manually
OPTS.sort|map|length|clustered    #Like @unique
OPTS.fields|name                  #Like @@index

@@index(OPTS[.fields])            #Database index
OPTS.fields                       #ARR of FIELD_VARR[(OPTS)]
                                  #None must not be optional
OPTS.name                         #Dynamic 'FIELD' created with combination of all fields, i.e. can be queried
                                  #Def: 'FIELD_FIELD2_...'
OPTS.sort                         #ENUM. Asc (def) or Desc
OPTS.map                          #Database 'INDEX' name
                                  #Database INDEX can already exist
                                  #Def:
                                  #  - if database INDEX already exist: re-use its name
                                  #  - @[@]id: "TABLE_pkey"
                                  #  - @[@]unique: "TABLE_FIELD..._unique"
                                  #  - @[@]index: "TABLE_FIELD..._index"
                                  #  - @relation: "TABLE_FIELD..._fkey"
                                  #Not with MySQL, MongoDB
OPTS.type                         #ENUM. ACCESS_METHOD
                                  #Can be BTree (def), Gist, Gin, SpGist, Brin, Hash
                                  #Only with Postgres
OPTS.ops                          #ENUM. OPCLASS
                                  #Can be raw("OPCLASS") if value not available in ENUM
                                  #Only with Postgres
OPTS.length                       #NUM. Only with MySQL
OPTS.clustered                    #BOOL. Only with SQL server


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       SCHEMA RELATIONS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@relation(OPTS)                   #Foreign key source|destination constraint on FIELDs
                                  #MODEL FTYPE:
                                  #  - must be on populated FIELD, not present in database
                                  #  - alongside separate foreign key FIELD, present in database
                                  #Cannot use @unique (but can use @@unique) nor @default
                                  #For all databases
OPTS.fields                       #FIELD_VARR_ARR of source foreign keys
                                  #ARR has multiple items only if source MODEL uses @@id
OPTS.references                   #FIELD_VARR_ARR of destination primary keys
                                  #ARR has multiple items only if destination MODEL uses @@id
OPTS.name                         #"RELATION"
OPTS.map                          #Like @@index

OPTS.onUpdate|onDelete            #ENUM among:
                                  #  - NoAction
                                  #     - MongoDB: required if cycle between relations
                                  #  - Restrict (def with OPTS.onDelete if required)
                                  #     - not with SQL server
                                  #  - SetNull (def with OPTS.onDelete if optional)
                                  #  - SetDefault
                                  #     - not with MySQL, MongoDB
                                  #  - Cascade (def with OPTS.onUpdate)
                                  #Like SQL `references ... on update|delete ACTION`
                                  #  - see Postgres doc for meaning of each option
                                  #As an alternative, can also update|delete across multiple TABLEs at once by using a $transaction

datasource.relationMode           #ENUM. Whether @relation:
                                  #  - "foreignKeys":
                                  #     - creates a database foreign key
                                  #     - default with most databases
                                  #     - usually recommended
                                  #  - "prisma":
                                  #     - emulates foreign key at the ORM layer
                                  #     - only enforced during update|delete, not create
                                  #     - cannot use OPTS.onUpdate|onDelete:
                                  #        - NoAction: with Postgres or SQLite
                                  #        - SetDefault
                                  #     - required for "mongodb"

1-1 RELATIONSHIP ==>              #When source|destination FIELDs are both @[@]unique|@[@]id, not ARR

1-N RELATIONSHIP ==>              #When source|destination FIELDs are both not ARR, and only destination FIELD is @[@]unique|@[@]id

N-N RELATIONSHIP ==>              #When both source|destination FIELDs are ARRs

EXPLICIT N-N RELATIONSHIP ==>     #Define a n-n TABLE in SCHEMA, with 1-n relationship towards both TABLEs
                                  #Both TABLEs contain reverse FIELDs (see below)

IMPLICIT N-N RELATIONSHIP ==>     #Automatically handle a n-n TABLE at ORM-level
                                  #Only need to define source|destination FIELDs, without any @relation nor foreign key FIELD
                                  #Source|destination MODELs must both have @id (not @@id), which are used as targets
                                  #Underlying database TABLE:
                                  #  - name is _TABLE2ToTABLE3
                                  #     - can use @relation with OPTS.name to change it
                                  #        - cannot use other OPTS.*
                                  #  - both FIELDs are called A|B pointing to TABLE2|3, and use @@unique
                                  #  - non-unique index on FIELD B

MONGODB N-N RELATIONSHIP ==>      #Automatically handle a n-n TABLE at ORM-level
                                  #Each TABLE must have foreign key FIELD:
                                  #  - ARR
                                  #  - use @relation
                                  #  - target the other TABLE @id (not @@id)
                                  #  - no OPTS.onUpdate|onDelete

REVERSE RELATIONSHIP ==>          #Automatically populating a FIELD, without any @relation nor key FIELD
                                  #Only when there is a reverse relationship declared:
                                  #  - source FIELD -> destination FIELD declared
                                  #  - i.e. can imply reverse destination FIELD2 -> source MODEL
                                  #With:
                                  #  - 1-1 relationship: reverse FIELD must be optional `FTYPE?`
                                  #  - 1-n or n-n relationship: reverse FIELD must be `FTYPE[]`

DISAMBIGUATION ==>                #For implicit n-n and reverse relationships, destination|source FIELDs must use @relation with OPTS.name if:
                                  #  - destination|source MODEL is same
                                  #  - source MODEL has multiple foreign key FIELDs to destination MODEL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           GENERATE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma generate                   #Call all GENERATOR_PROVIDERs
--watch                           #Call on SCHEMA file change

prisma db push
prisma migrate dev|reset
--skip-generate                   #Unless set, calls `prisma generate` at the end

GENERATOR_PROVIDER                #Module generating code base on SCHEMA. Can be:
                                  #  - "prisma-client-js": CLIENT
                                  #  - "MODULE|PATH": third-party

generator GENERATOR {
  VAR = VAL
  ...
}                                 #GENERATORs used by `schema generate`, in SCHEMA

generator.provider
prisma generate --generator       #"GENERATOR_PROVIDER"

generator.output                  #'OPATH'. Def: "./node_modules/.prisma/client"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          INTROSPECT           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma db pull                    #"Introspection". Make SCHEMA reflect production DATABASE
--print                           #Print new SCHEMA to stdout instead of modifying it

SCAFFOLD ==>                      #Can be used to scaffold initial SCHEMA

INCREMENTAL CHANGES ==>           #Can also be used as alternative to `prisma db push` and `prisma migrate`
                                  #I.e. modify production DATABASE -> SCHEMA, instead of opposite
                                  #Not with MongoDB
--force                           #Overwrite everything on incremental changes
                                  #Unless specified, do not overwrite:
                                  #  - comments
                                  #  - order of {...} blocks
                                  #     - but order of FIELDs within blocks is always same as database COLs order,
                                  #       with complex FTYPEs before simple ones
                                  #  - @[@]map
                                  #  - @updatedAt
                                  #  - @default(uuid|cuid())
                                  #  - @relation(name: "RELATION")
                                  #  - @[@]ignore

SUBSET ==>                        #To only introspect a subset of production DATABASE, can:
                                  #  - use datasource.schemas
                                  #  - use a datasource.url with a database USER with permissions only to read specific entities
                                  #Alternative is also to introspect some entities, but use @[@]ignore on them

MONGODB ==>                       #Schemaless, i.e. use sampled data instead
                                  #Cannot infer @[@]ATTR nor FTYPE? FTYPE[]
                                  #Can only infer @@index if INDEX has some data

NAMES ==>                         #Invalid characters in MODEL|FIELD|etc. are replaced with _
                                  #@[@]map is then also used

POSTGRES EXTENSIONS ==>           #Only infers specific ones: citext, pgcrypto, uuid-ossp, postgis


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PUSH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma db push                    #Inverse of `prisma db pull`
                                  #Make production DATABASE reflect SCHEMA, using direct database DDL
                                  #Meant for the initial scaffolding, or for local prototyping
                                  #Only add|modify entities, not remove
                                  #Does not create VIEWs
--force-reset                     #Empty database first
--accept-data-loss                #Unless set, fails if TABLE DDL change requires truncating its data


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MIGRATE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma migrate ...                #Make production DATABASE reflect SCHEMA, using automatically generated SQL files
                                  #Meant for incremental changes

MONGODB ==>                       #Does not support `prisma migrate`
                                  #  - except `prisma migrate diff`, without --from|to-migrations nor --script
                                  #Must use `prisma db push|execute` instead

datasource.shadowDatabaseUrl      #Connection "URL" to the "shadow database"
prisma migrate diff               #Temporary and used only by `prisma migrate dev` and `prisma migrate diff --from|to-migrations`
--shadow-database-url             #As opposed to the "dev database", which is the main local database

./prisma/migrations               #MDIR
MDIR/MIGRATION/migration.sql      #SQL file with DDL commands, indicating incremental changes of SCHEMA
                                  #"MIGRATION" is "YYYYMMDDHHSSMM_MNAME"
MDIR/migration_lock.toml          #File with metadata, e.g. DB_PROVIDER

_prisma_migrations                #TABLE recording all applied MIGRATIONs in dev|production database
                                  #Includes applied MIGRATIONs:
                                  #  - list: to detect additions|removals
                                  #  - checksums: to detect changes
PRISMA_MIGRATIONS.id              #UUID
PRISMA_MIGRATIONS.started_at      #'DATE'
PRISMA_MIGRATIONS.finished_at     #'DATE'
PRISMA_MIGRATIONS.rolled_back_at  #'DATE'
PRISMA_MIGRATIONS.migration_name  #'MIGRATION'
PRISMA_MIGRATIONS.checksum        #'HASH'
PRISMA_MIGRATIONS
 .applied_steps_count             #NUM of statements
PRISMA_MIGRATIONS.logs            #STR

LOCAL VS PRODUCTION ==>           #prisma migrate dev|reset|db seed|diff: local development
                                  #prisma migrate deploy|resolve|status: production|CI

prisma migrate dev                #Create migration file by comparing:
                                  #  - current SCHEMA
                                  #  - all previously applied migrations (_prisma_migrations)
                                  #     - by creating a temporary "shadow database" and applying all migrations to it
                                  #If dev database has drifted from previous migrations, first call `prisma migrate reset`
--name                            #"MNAME"
--create-only                     #When not set, also apply new migration file to dev database
                                  #When set, can manually modify it first

prisma migrate reset              #Re-create dev database, then apply all migrations to it
--force                           #No confirmation prompt

package.json prisma.seed          #"SEED_COMMAND". Shell command meant to populate dev database with data
                                  #Recommended location: ./prisma/seed.ts
prisma db seed [-- ARGS...]       #Calls "SEED_COMMAND ARGS..."
prisma migrate dev|reset
--skip-seed                       #Unless set, calls `prisma db seed` at the end of `prisma migrate reset`

prisma migrate deploy             #Applies new migrations to production database

prisma migrate resolve            #Fix a failed migration by changing its status in _prisma_migrations TABLE
--applied                         #"MIGRATION". Mark failed migration as successful, i.e. not retried
--rolled-back                     #"MIGRATION". Mark failed migration to retry

prisma migrate status             #Print information about migrations for the production database:
                                  #  - count
                                  #  - whether new migrations exist
                                  #Exit code 0 if no issues nor new migrations

prisma migrate diff               #Compare 2 databases|SCHEMAs, printing result on stdout
                                  #Must have same "DB_PROVIDER"
--script                          #Print migration SQL instead
--exit-code                       #Exit code 2 if there is a diff
                                  #With|without it: exit code 1 if error
--from|to-*                       #Must use one for each
--from|to-url                     #Database connection "URL", as is
--from|to-schema-datasource       #Database connection "URL", using "PATH" to SCHEMA, then using datasource.url
--from|to-schema-datamodel        #"PATH" to SCHEMA
--from|to-migrations              #"DIR" to MIGRATION files
--from|to-empty                   #Empty database

INITIAL MIGRATION ==>             #To create initial MIGRATION of existing database ("baseline"):
                                  #  - prisma migrate diff --from-empty --to-schema-datamodel --script > ./prisma/migrations/0_init/migration.sql
                                  #  - prisma migrate resolve --applied 0_init

ENVVAR PRISMA_SCHEMA_             #Unless set, use database advisory lock to prevent running 2 concurrent `prisma migrate` against same production database
 DISABLE_ADVISORY_LOCK            #Always 10 seconds timeout

ENVVAR HTTP[S]_PROXY|NO_PROXY     #Can be used


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EXECUTE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


prisma db execute                 #Run SQL against database
                                  #Output only meant for debugging or success reporting, not returning data
                                  #Not with MongoDB
--file                            #'PATH' to SQL file
--stdin                           #SQL as stdin instead
--url                             #Def: datasource.url


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STUDIO             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PRISMA STUDIO ==>                 #Web app to create|edit|delete and view|filter|sort database
                                  #Only the data modelled with SCHEMA
DATA BROWSER ==>                  #Online version of Prisma studio, with Data platform

prisma studio                     #Start local server, then open studio web app
--port|-p                         #NUM (def: 5555)
--browser|-b
ENVVAR BROWSER                    #'COMMAND' (def: default browser)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT MAIN          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@prisma/client                    #Node.js client
@prisma/client/edge.js            #JavaScript client, for edge computing
@prisma/client/index-browser.js   #Browser client
OPATH[/...]                       #Should be used instead of @prisma/client[/...] when custom generator.output

OTHER LANGUAGES ==>               #Available but not documented yet: Rust, Go, Python, Dart, Scala

ENVVAR
 PRISMA_GENERATE_SKIP_AUTOINSTALL #Unless set, `prisma generate` installs @prisma/client, if 'prisma-client-js' GENERATOR_PROVIDER
ENVVAR
 PRISMA_SKIP_POSTINSTALL_GENERATE #UNless set, @prisma/client has a `postinstall` script that calls `prisma generate`

new PrismaClient([POPTS])         #CLIENT

CLIENT.$connect()->>              #Start database connection
                                  #Automatically called on first database query
CLIENT.$disconnect()->>           #Stop database connection
                                  #Automatically called on 'beforeExit'
CLIENT.$on('beforeExit',FUNC()->>)#Called on process.on('beforeExit'), before $disconnect()
                                  #Only if generator.engineType 'binary'

CLIENT.MODEL                      #CMODEL
                                  #MODEL is lowercase'd
                                  #Fully typed according to SCHEMA, except nested|populated models
CMODEL.$name                      #'MODEL'
CMODEL.$parent                    #CMODEL2, when inside CMODEL2.$transaction(FUNC(CMODEL))

CMODEL.METHOD(...)->CPROMISE      #CPROMISE behaves like a PROMISE except lazy: only start on then()|catch()|await
CPROMISE.FIELD()->CPROMISE        #Returns COBJ.FIELD instead of COBJ ("fluent API")
                                  #FIELD is fetched in a separate database query, not a join
                                  #Parent must not be:
                                  #  - CMODEL.*Many()
                                  #  - another CPROMISE.FIELD() on an ARR FIELD

COBJ                              #MODEL as an OBJ
BATCH.count                       #NUM of COBJs created|updated|deleted

QUERY CONSOLE ==>                 #Run CMODEL.METHOD(...), in Data platform
                                  #Max 4MB response


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT ERROR          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Prisma.Prisma*Error               #ERROR class instances, to use with `instanceof`
ERROR.message                     #STR
ERROR.meta                        #OBJ. Additional context, e.g. FIELDs
                                  #Only with PrismaClientKnownRequestError
ERROR.clientVersion               #'X.Y.Z'

ERROR.code                        #'PNXXX'
                                  #XXX are digits
                                  #N is category among:
                                  #  - 1: common
                                  #  - 2: query engine
                                  #  - 3: schema engine
                                  #  - 4: prisma db pull
                                  #  - 5: data proxy
                                  #  - 6: Accelerate
                                  #Only with PrismaClientKnownRequestError
                                  #Also printed by CLI
ERROR.errorCode                   #Same but only with PrismaClientInitializationError

PrismaClientInitializationError   #Error during CLIENT.$connect()
                                  #E.g. database connection issues, missing query engine binary, etc.
PrismaClientValidationError       #Invalid arguments passed to CLIENT method
PrismaClientKnownRequestError     #Database error, e.g. unique constraint
PrismaClientUnknownRequestError   #Uncaught exception or unknown database response
PrismaClientRustPanicError        #Rust process crash. Should restart current process


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT LOG           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


POPTS.log                         #'LEVEL'_ARR|PLOG_OPT_ARR
PLOG_OPT.level                    #'LEVEL' among:
                                  #  - 'error'
                                  #  - 'warn' (def)
                                  #  - 'info'
                                  #  - 'query': debug, including all SQL queries
ENVVAR DEBUG=prisma:client        #CLIENT-related debug logs

PLOG_OPT.emit                     #STR among:
                                  #  - 'stdout' (def): print to stdout
                                  #  - 'event': emit 'LEVEL' EVENT
CLIENT.$on('error|warn|info',
 FUNC(LOG_EVENT))                 #
CLIENT.$on('query',
 FUNC(QUERY_EVENT))               #
LOG|QUERY_EVENT.timestamp         #DATE
LOG|QUERY_EVENT.target            #STR
LOG_EVENT.message                 #STR. Log message
QUERY_EVENT.query                 #STR. SQL query
QUERY_EVENT.params                #STR. SQL query parameters
QUERY_EVENT.duration              #NUM (in ms) from client sending to receiving

POPTS.errorFormat                 #Error message format, among:
                                  #  - 'pretty' (def): colors + hints on how to fix
                                  #  - 'colorless': hints on how to fix
                                  #  - 'minimal': neither
ENVVAR NO_COLOR                   #Like POPTS.errorFormat 'colorless'
ENVVAR NODE_ENV=production        #Like POPTS.errorFormat 'minimal'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT READ          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.findMany([OPTS])->>COBJ_ARR#Get all matching COBJs, like SQL `select`
OPTS.where|select|include|orderBy
 |cursor|take|skip|cacheStrategy  #See below
OPTS.distinct                     #'FIELD'_ARR. Ignore COBJs with duplicate values for those FIELDs
                                  #Done at the ORM-level, not using a SQL `distinct on (...)`

CMODEL.findFirst[OrThrow]         #Get one matching COBJ, like SQL `select ... limit 1`
 ([OPTS])->>COBJ|null             #If none:
                                  #  - if `OrThrow`: throw NotFoundError
                                  #  - otherwise: returns null
OPTS.where|select|include|orderBy
 |cursor|skip|distinct
 |cacheStrategy                   #See below
OPTS.take                         #Like below, except only 1 (def) or -1

CMODEL.findUnique[OrThrow]        #Like findFirst[OrThrow]() except OPTS.where is UFILTERS and required.
 (OPTS)->>COBJ|null               #Also, optimized because multiple calls are batched into a single SQL query
                                  #  - when done in the same tick with same OPTS.*
                                  #  - e.g. during "n+1" problem
OPTS.where|select|include
 |cacheStrategy                   #See below


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT CREATE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.create(OPTS)->>COBJ        #Create one COBJ, like SQL `insert`
OPTS.select|include               #See below
OPTS.data                         #CREATES. Required
CREATES.*                         #Like COBJ.*

CMODEL.createMany(OPTS)->>BATCH   #Create multiple COBJs, like SQL `insert`
                                  #Not with SQLite
OPTS.data                         #COBJ_ARR. Required
OPTS.skipDuplicates               #BOOL (def: false). Ignore COBJs with FIELDs that fail @[@]unique|@[@]id constraint,
                                  #i.e. another COBJ2 already exists with it.
                                  #Like SQL `insert ... on conflict do nothing`
                                  #Not with SQL server, MongoDB

CMODEL.createMany|updateMany
 |deleteMany(...)                 #"Bulk operation", i.e. actually performs several database queries in a transaction


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT UPDATE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.update(OPTS)->>COBJ        #Update one COBJ, like SQL `update`
                                  #Throw NotFoundError if not found
OPTS.where                        #See below. Required
OPTS.select|include               #See below
OPTS.data                         #UPDATES. Required

CMODEL.updateMany(OPTS)->>BATCH   #Update multiple COBJs, like SQL `update`
OPTS.where                        #See below
OPTS.data                         #UPDATES. Required

CMODEL.upsert(OPTS)->>COBJ        #Like either create() or update()
                                  #Uses SQL `insert ... on conflict do update set ... where`
                                  #  - this avoids conflict when 2 concurrent upserts happens at once
                                  #  - not if nested write|read
                                  #  - only if single COBJ upserted
                                  #  - only if single OPTS.where FIELD, and it is present in OPTS.create with the same value
                                  #  - only with Postgres, SQLite, CDB
OPTS.where                        #See below. Required
OPTS.select|include               #See below
OPTS.create                       #Required. Like create()'s OPTS.data when COBJ does not exist
OPTS.update                       #Required. Like update()'s OPTS.data when COBJ exists

UPDATES                           #Like SQL `update ... set ... where ...`
UPDATES.FIELD[.UPDATE]            #VAL
                                  #Def UPDATE: 'set'
                                  #Can only specify one UPDATE per FIELD

UPDATE set                        #VAL. VAR = VAL
UPDATE unset                      #VAL. VAR = undefined
                                  #Only with MongoDB

NUM_UPDATE increment|decrement    #NUM2. NUM += -= NUM2
NUM_UPDATE multiply|divide        #NUM2. NUM *= /= NUM2

OBJ_UPDATE update                 #OBJ2. Shallow merge
                                  #Fail if OBJ undefined
OBJ_UPDATE upsert.set|update      #OBJ2. Set with `set` if OBJ undefined, shallow merge with `update` otherwise

ARR_UPDATE push                   #VAL[_ARR]. ARR.push(VAL[,...])
                                  #Only with Postgres, MongoDB


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CLIENT DELETE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CMODEL.delete(OPTS)->>COBJ        #Delete one COBJ, like SQL `delete`
                                  #Throw NotFoundError if not found
OPTS.where                        #See below. Required
OPTS.select|include               #See below

CMODEL.deleteMany([OPTS])->>BATCH #Delete many COBJs, like SQL `delete`
OPTS.where                        #See below


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     CLIENT NESTED WRITES      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CREATES|UPDATES.MODEL_FIELD       #Nested writes on child MODELs
                                  #Also sets foreign key FIELDs
                                  #Use a transaction, i.e. rolled back if any fails
                                  #Only with create|update|upsert(), not createMany|updateMany()

CREATES|UPDATES.MODEL_FIELD       #COBJ[_ARR]
 .create                          #Nested `create`: add child MODELs. Does not merge

CREATES|UPDATES.MODEL_FIELD       #COBJ_ARR
 .createMany.data                 #Like nested `create` COBJ_ARR, but faster
                                  #Cannot nest further
                                  #Only with 1-n relationships

UPDATES.MODEL_FIELD.set           #COBJ[_ARR]
                                  #Set child MODELs

UPDATES.MODEL_FIELD.update[Many]  #OBJ[_ARR]: data UPDATES2[, where COBJ]
                                  #Can also be just UPDATES2
                                  #Nested `update[Many]`: update existing child MODELs
                                  #Fails if no matches

UPDATES.MODEL_FIELD.upsert        #OBJ[_ARR]: create COBJ, update UPDATES2[, where COBJ]
                                  #Nested `upsert`

UPDATES.MODEL_FIELD.delete[Many]  #COBJ[_ARR]
                                  #Nested `delete`: remove child MODELs
                                  #COBJ can be `true` or empty OBJ to match any
                                  #Noop if no match

CREATES|UPDATES.MODEL_FIELD       #COBJ[_ARR]
 .connect                         #Create relationship, i.e. set parent|child MODEL's foreign key FIELD to connect them
                                  #Only for child MODELs matching COBJ
                                  #Fails if no match

CREATES|UPDATES.MODEL_FIELD       #OBJ: where COBJ, create COBJ
 .connectOrCreate                 #Like `connect`, but if `where` does not match, does a nested `create` instead

CREATES|UPDATES.MODEL_FIELD       #COBJ[_ARR]
 .disconnect                      #Like `connect`, but unsets instead
                                  #COBJ can be `true` or empty OBJ to match any
                                  #Noop if no match


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       CLIENT AGGREGATE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.select|include._count        #OPTS2 (only select|where). Special MODEL_FIELD that returns child MODELs ARR.length
                                  #I.e. OPTS.select._count.select.MODEL_FIELD BOOL -> { _count: { FIELD: NUM } }
                                  #Must be top-level OPTS

CMODEL.count([OPTS])->>NUM        #Count OBJs, like SQL `select count(*)`
OPTS.where|orderBy|cursor|take
 |skip|cacheStrategy              #See below
OPTS.select                       #When used, returns COBJ, with NUM values
                                  #Can use FIELD `_all`

CMODEL.aggregate(OPTS)->>OBJ      #Aggregate OBJs, like SQL AFUNCs
                                  #Returns OBJ:
                                  #  - _*.FIELD NUM: for each OPTS._*.FIELD
OPTS.where|orderBy|cursor|take
 |skip|cacheStrategy              #See below
OPTS._*                           #Can use FIELD `_all`
                                  #If not _all, only non-undefined|null values
                                  #  - if only undefined values and not _count, returns `null`
OPTS._count[.FIELD]               #BOOL. Like SQL `select count(*)`
                                  #Def FIELD: _all
OPTS._avg|_sum.FIELD              #BOOL. Like SQL `select avg|sum()`
OPTS._min|_max.FIELD              #BOOL. Like SQL `select min|max()`

CMODEL.groupBy(OPTS)->>ARR        #Group and aggregate OBJs, like SQL AFUNCs + `group by`
                                  #Returns OBJ_ARR:
                                  #  - FIELD VAL: for each OPTS.by
                                  #  - _*.FIELD NUM: for each OPTS._*.FIELD
OPTS.where|orderBy|cursor|take
 |skip|cacheStrategy              #See below
OPTS._count|_avg|_sum|_min|_max   #See above
OPTS.by                           #'FIELD'[_ARR]. Like SQL `group by`
OPTS.having.FIELD._*              #FILTERS. Like SQL `having`
                                  #_* is _count|etc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       CLIENT SELECTION        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.select.NON_MODEL_FIELD       #BOOL. Returns NON_MODEL_FIELD
                                  #Def: false if OPTS.select defined, true otherwise

OPTS.include.MODEL_FIELD          #BOOL (def: false). Returns and populates child MODEL (ARR or not)

OPTS.select|include.MODEL_FIELD   #OPTS2 (only select|include|where|orderBy)
                                  #Apply OPTS2 on child MODEL (ARR or not)
                                  #Implies OPTS.include.MODEL_FIELD true
                                  #Can mix OPTS.include|select at different levels, but not same one


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLIENT SORT          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.orderBy                      #ORDER[_ARR], like SQL `order by`
ORDER.FIELD                       #FORDER
                                  #With groupBy(): FIELD must be among the ones grouped (OPTS.by)

FORDER._count                     #FORDER2. Sort by _count
FORDER._*                         #FORDER2. Sort by _avg, etc.
                                  #Only with groupBy()

FORDER.FIELD                      #FORDER2. Sort by OBJ_TYPE|MODEL nested property

FORDER[.sort]                     #'asc|desc'. Sort by VAL
FORDER.count                      #'asc|desc'. Sort by ARR.length
FORDER.nulls                      #'first' (def) or 'last'
                                  #Not with MongoDB
                                  #FIELD must not be required nor a MODEL FTYPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        CLIENT PAGINATE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.take                         #NUM (can be negative). Only return first|last COBJs, like SQL `limit`
OPTS.skip                         #NUM of COBJs to skip, like SQL `offset`

OPTS.cursor                       #UFILTERS. Pagination: start at the matching COBJ
                                  #Should use OPTS.skip 1 to avoid repeating the matching COBJ


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     CLIENT FILTER GENERAL     :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.where                        #FILTERS

FILTERS                           #Filter COBJs, like SQL `where`
UFILTERS                          #FILTERS, but at least one FIELD must have @[@]unique|@[@]id
FILTERS.FIELD[.FILTER]            #VAL
                                  #Def FILTER: 'equals'
                                  #Each FILTER is and'd
                                  #With OBJ|ARR value: full, ordered match unless indicated otherwise

FILTERS.NOT                       #FILTERS2
FILTERS.AND|OR                    #FILTERS2_ARR
                                  #Cannot nest, but can define AND|OR|NOT together

Prisma.validator                  #Workaround to add correct TypeScript types to FILTERS, without widening them
 (...)(FILTERS)->FILTERS          #Should prefer instead `const FILTERS = { ... } satisfies TYPE`
                                  #Also for OPTS.orderBy

undefined                         #As input: always ignored
                                  #In this documentation, can also mean DbNull
Prisma.DbNull                     #Database NULL. With MongoDB, it is actually undefined
                                  #In FILTERS|COBJ|UPDATES
Prisma.JsonNull                   #null in JSON value
null                              #In FILTERS|COBJ|UPDATES
                                  #With MongoDB, same as DbNull
Prisma.AnyNull                    #DbNull|JsonNull
                                  #Only in FILTERS

CMODEL.fields.FIELD               #Can be used as a FILTER's VAL, to allow comparing FIELDs within same COBJ
                                  #Must be same CMODEL
                                  #FIELD cannot use @[@]unique|@[@]id
                                  #Cannot be within UFILTERS
                                  #If used in OPTS.having.FIELD, OPTS.by must include 'FIELD'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      CLIENT FILTER LIST       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FILTER equals|not                 #VAL. === !==
                                  #If on child MODEL and VAL null (or empty OBJ): means === !== undefined
FILTER in                         #ARR. ARR.includes(VAL)
FILTER notIn                      #ARR. !ARR.includes(VAL)
                                  #Does not return null values (same for `NOT + in`)
FILTER isSet                      #BOOL. !== undefined
                                  #Only with MongoDB

STR|NUM|DATE_FILTER lt[e]|gt[e]   #STR|NUM|DATE2. < <= > >=

STR_FILTER contains               #STR2. STR.includes(STR2)
                                  #With Postgres|MySQL, uses `[i]like`, i.e. must \-escape % _
STR_FILTER starts|endsWith        #STR2
                                  #Escaping: like STR_FILTER contains
FILTER mode                       #'insensitive'. Make other FILTERs case-insensitive
                                  #JSON_FILTER: always case-sensitive
                                  #STR_FILTER search (text search): always case-insensitive
                                  #Implemented by:
                                  #  - Postgres: use a non-deterministic COLLATION
                                  #     - citext: always case-insensitive
                                  #     - not with COLLATION C|POSIX
                                  #  - MongoDB: use a /REGEXP/i
                                  #  - others: case-insensitive by default
                                  #     - can be changed using a different COLLATION

ARR_FILTER                        #Only with Postgres, CDB, MongoDB
ARR_FILTER has                    #VAL. ARR.includes(VAL) && ARR.length !== 0
ARR_FILTER hasEvery               #ARR2. ARR2.every(VAL => ARR.includes(VAL)) && ARR2.length !== 0
ARR_FILTER hasSome                #ARR2. ARR2.some(VAL => ARR.includes(VAL)) && ARR2.length !== 0
ARR_FILTER isEmpty                #BOOL. ARR.length === 0

OBJ_[ARR_]FILTER                  #Not with findUnique|count|aggregate|groupBy()
OBJ_FILTER                        #Can be used for MODELs too
OBJ_FILTER is[Not]                #FILTERS. Whether OBJ partially matches it

OBJ_ARR_FILTER some               #FILTERS. OBJ_ARR.some(FILTERS) && OBJ_ARR.length !== 0
                                  #If FILTERS empty: OBJ_ARR.length !== 0
OBJ_ARR_FILTER none               #FILTERS. !OBJ_ARR.some(FILTERS)
                                  #If FILTERS empty: OBJ_ARR.length === 0
OBJ_ARR_FILTER every              #FILTERS. OBJ_ARR.every(FILTERS)

JSON_FILTER                       #Only with Postgres, MySQL
JSON_FILTER path                  #'VAR|NUM'_ARR. Make other JSON_FILTERs apply on JSON#>'VAR'_ARR
                                  #MySQL: JSONPath (e.g. '$.VARR') instead
JSON_FILTER string_contains       #STR. Like STR_FILTER contains
JSON_FILTER starts|ends_with      #STR. Like STR_FILTER startsWith|endsWith
JSON_FILTER array_contains        #ARR. Like ARR_FILTER hasEvery
JSON_FILTER array_starts|ends_with#VAL. ARR.at(0|-1) === VAL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      CLIENT TEXT SEARCH       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TEXT SEARCH ==>                   #Only with Postgres, MySQL
                                  #Requires PREVIEW fullTextSearch

@@fulltext(OPTS.fields)           #Text search index
                                  #Only with MySQL, MongoDB
                                  #Requires PREVIEW fullTextIndex

STR_FILTER search                 #STR2. Text search filtering
                                  #Database-specific syntax, e.g. 'TSQUERY' with Postgres

OPTS.orderBy._relevance           #SEARCH_ORDER. Text search sorting
SEARCH_ORDER.fields               #'FIELD'_ARR
SEARCH_ORDER.search               #Like STR_FILTER search
SEARCH_ORDER.sort                 #'asc|desc'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       CLIENT QUERY SQL        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT.$queryRaw('SQL')->>COBJ_ARR#Perform SQL query that returns a ROW_SET
CLIENT.$executeRaw('SQL')->>NUM   #Perform SQL query that does not return a ROW_SET
                                  #Returns NUM of created|updated|deleted ROWs

CLIENT.$*Raw`SQL`                 #Run as SQL prepared statements, with each ${...} passed as value, i.e. sanitized
                                  #See database doc for restrictions related to SQL prepared statements
                                  #Only allow a single SQL statement, to prevent injections
                                  #Not with MongoDB

Prisma.sql`SQL`                   #sql-template-tag, used under the hood (see its doc)
                                  #CLIENT.$*Raw(`SQL`) is same as CLIENT.$*Raw(Prisma.sql`SQL`)
Prisma.raw('SQL')
Prisma.empty
Prisma.join(ARR[, ...])           #Same as sql-template-tag (see its doc)

CLIENT.$*RawUnsafe('SQL'[,VAL...])#Same as $*Raw`SQL`, except ${...} are passed as VAL... arguments instead
                                  #If VAL..., 'SQL' must use database-specific syntax for prepared statement variables:
                                  #  - Postgres: `$NUM`
                                  #  - MySQL: `?`


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     CLIENT QUERY MONGODB      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT.$runCommandRaw(OBJ)->>VAL  #Perform MongoDB runCommand(OBJ)

CMODEL.findRaw(OBJ)->>VAL         #Perform MongoDB runCommand({ find: 'MODEL', filter: OBJ.filter, ...OBJ.options })

CMODEL.aggregateRaw(OBJ)->>VAL    #Perform MongoDB runCommand({ aggregate: 'MODEL', pipeline: OBJ.pipeline, ...OBJ.options })


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      CLIENT TRANSACTION       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT.$transaction               #Runs each CPROMISE serially inside a database transaction
 (CPROMISE_ARR[, OPTS])->>ARR     #For any database
                                  #Cannot use CLIENT.*OrThrow(...)
OPTS.isolationLevel               #ENUM Prisma.TransactionIsolationLevel:
                                  #  - ReadUncommitted
                                  #  - ReadCommitted
                                  #     - def with Postgres, SQL server
                                  #  - RepeatableRead
                                  #     - def with MySQL
                                  #  - Snapshot
                                  #     - only with SQL server
                                  #  - Serializable
                                  #     - only possible value with SQLite, CDB
                                  #Not with MongoDB

CLIENT.$transaction
 (FUNC(CLIENT)->>VAL[, OPTS])
 ->>VAL                           #Run FUNC() inside a database transaction
OPTS.isolationLevel               #Like above
OPTS.maxWait                      #NUM (in ms, def: 2s). Rollback if takes longer to acquire transaction lock
OPTS.timeout                      #NUM (in ms, def: 5s). Rollback if FUNC() lasts longer


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            METRICS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT.$metrics                   #CMETRICS. Execution metrics
                                  #Requires PREVIEW metrics
CMETRICS.json([OPTS])->>METRICS   #
CMETRICS.prometheus([OPTS])->>STR #Same but using Prometheus format

METRICS.TYPE                      #METRIC_ARR
                                  #TYPE can be:
                                  #  - gauges: NUM
                                  #  - counters: NUM always incrementing
                                  #  - histograms
METRIC.key                        #'METRIC' name
METRIC.value                      #NUM (gauges|counters) or HISTOGRAM
METRIC.description                #STR
OPTS.globalLabels
METRIC.labels                     #OBJ. Metadata

HISTOGRAM.buckets                 #[X_NUM, Y_NUM]_ARR
HISTOGRAM.sum                     #NUM
HISTOGRAM.count                   #NUM

GAUGE prisma_client_queries_active#NUM of ongoing CLIENT.COMMAND()

COUNTER
 prisma_client_queries_total      #NUM of CLIENT.COMMAND() executed
COUNTER
 prisma_datasource_queries_total  #NUM of database queries executed

HISTOGRAM prisma_datasource_
 queries_duration_histogram_ms    #NUM (in ms). Duration of database queries
HISTOGRAM prisma_client_
 queries_duration_histogram_ms    #NUM (in ms). Duration of CLIENT.COMMAND()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            TRACING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@prisma/instrumentation           #Generates OpenTelemetry traces, i.e. overlapping duration spans for each CMODEL.METHOD()
                                  #Requires PREVIEW tracing

new PrismaInstrumentation([OPTS]) #INSTRUMENTATION
                                  #Must be used with @opentelemetry/instrumentation:
                                  #  - child class of InstrumentationBase
                                  #  - must be passed to registerInstrumentations() OPTS.instrumentations
OPTS.enabled                      #BOOL (def: true)

SPANS ==>                         #Indentation signifies child span
prisma:client:operation           #CMODEL.METHOD() call
  prisma:client:connect           #Connect to database
  prisma:client:serialize         #Create database query string
  prisma:engine                   #Query ENGINE
    prisma:engine:connection      #Connect to database
    prisma:engine:db_query        #Perform database query
                                  #Can be specified multiple times
                                  #Include query string in tags
    prisma:engine:serialize       #Create CMODEL.METHOD() return value, using database response

prisma:client:transaction         #CLIENT.$transaction(FUNC)
  prisma:client:connect           #
  prisma:engine:itx_runner        #Query ENGINE
    prisma:engine:connection      #
    prisma:engine:db_query        #Database query to start the transaction
    prisma:engine
    :itx_query_builder            #CMODEL.METHOD() call in transaction
      prisma:engine:db_query      #
      prisma:engine:serialize     #
  prisma:client:operation         #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           EXTENSION           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT.$extends                   #Clone CLIENT, but with an additional EXTENSION
 (EXTENSION)->CLIENT2             #CLIENT2 is separate from CLIENT
                                  #Cannot use CLIENT2.$on(...) nor fluent API
CLIENT.$extends
 (FUNC(CLIENT)->CLIENT2)->CLIENT2 #Calls and returns FUNC(), which should call and return CLIENT.$extends()
Prisma.defineExtension(EXTENSION)
 ->FUNC(CLIENT)->CLIENT2          #Returns FUNC that calls CLIENT.$extends(EXTENSION)
Prisma.defineExtension
 (FUNC(CLIENT)->CLIENT2)->FUNC    #Returns FUNC as is

EXTENSION.name                    #STR. Shown in logs and error messages

EXTENSION.model.MODEL|$allModels  #OBJ. Mixin OBJ.* to CMODEL.*
                                  #`this` is CMODEL

EXTENSION.client                  #OBJ. Mixin OBJ.* to CLIENT.*
                                  #`this` is CLIENT

Prisma.getExtensionContext        #Returns `this` but correctly typed
 (this)->this                     #To use inside EXTENSION.model|client's methods

EXTENSION.query[.MODEL|$allModels]#Wrap CMODEL.METHOD(...)
 .METHOD|$allOperations(OPTS)     #If no MODEL|$allModels: also wraps CLIENT.$*Raw*()
 ->>VAL                           #Does not wrap nested reads|writes, only top-level
OPTS.model                        #'MODEL'. undefined for CLIENT.$*Raw()
OPTS.operation                    #'METHOD'
OPTS.args                         #OBJ passed to CMODEL.METHOD(OBJ)
OPTS.query                        #FUNC. Original CMODEL.METHOD. Its return value must be returned

EXTENSION.result                  #MPROP. Adds COBJ.PROP to MODEL's COBJ, as returned by any CMODEL.METHOD(...)
 .MODEL|$allModels.PROP           #PROP must not be a child MODEL
                                  #Not usable by CMODEL.count|aggregate|groupBy()
MPROP.compute(COBJ)->VAL          #Sets COBJ.PROP = VAL
                                  #Defined as a `get` FUNC, i.e. lazy
MPROP.needs.PROP                  #BOOL. If true, noop if COBJ.PROP undefined
                                  #Only PROPs defined here are available in compute()'s argument

PUBLIC EXTENSIONS ==>             #npm package name and EXTENSION.name should be prisma-extension-*
                                  #Should have npm keywords prisma, @prisma/client, extension
                                  #Should export Prisma.defineExtension() result, for better typing
                                  #Should use $allModels|$allOperations, not 'MODEL|METHOD'
@prisma/client/extension          #Must be used instead of @prisma/client in public EXTENSIONs


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         DATA PLATFORM         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DATA PLATFORM ==>                 #Paid features, behind account
                                  #There was a previous version called "legacy"
                                  #  - pricing was different:
                                  #     - per ms, not per queries
                                  #     - limit only, not proportional charge

PRICING ==>                       #Free, pro (49$/month), business (299$/month), enterprise (custom)

SUPPORT ==>                       #Standard (pro), premium (business), dedicated (enterprise)

WORKSPACE ==>                     #Sets of projects + billing
                                  #In legacy Data platform, called "Environment"

PROJECT ==>                       #Sets of Accelerate|Pulse configurations
                                  #Max 5 (free), 10 (pro), 15 (premium)

TEAM ==>                          #Can invite team members
                                  #With privileges (pro|premium):
                                  #  - viewer: query console, read-only data browser
                                  #  - collaborator: also write in data browser
                                  #  - developer: also read-only schema viewer
                                  #  - admin: also write in schema viewer, manage team members, workspaces|projects
                                  #  - owner: also delete projects


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       ACCELERATE PROXY        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ACCELERATE ==>                    #"Accelerate" is a proxy, which forwards to database
                                  #Not with SQLite, SQL server
                                  #Can view most frequent queries in last 30d in UI
                                  #Price:
                                  #  - 1$/5e4 queries (free), 12e4 (pro), 17e4 (business)
                                  #     - free: first 6e4
                                  #  - 1$/11GB egress (free|pro), 12.5GB (business)
                                  #     - free: first 1KB/query (free|pro), 2KB/query (business)

LIMITS ==>                        #Applies soft limits (can be changed through support email):
                                  #  - query timeout: 10s
                                  #  - transaction timeout: 15s
                                  #  - response size: 5MB

CACHING ==>                       #Caches responses of read-only CMODEL.METHOD(...)
                                  #Does not cache CMODEL.*Raw*(...)
                                  #Not sure what cache key is, but is probably CMODEL + METHOD + OPTS
                                  #Cache invalidation:
                                  #  - done through UI, max 5/hour (free), 10 (pro), 20 (business)
                                  #  - not done otherwise, e.g. not by write methods
                                  #Cached among 300 edge locations
                                  #  - independent from each other, no consistency
                                  #Read-through caching, i.e. better with read-heavy, low cache hit ratio

prisma://
 accelerate.prisma-data.net
 /?api_key=JWT                    #To use as datasource.url

datasource.directUrl              #Connection "URL" to the main database
                                  #Unlike datasource.url, it bypasses any proxy, such as Accelerate or pgBouncer
                                  #Used with prisma db|migrate|studio
                                  #Def: same as datasource.url
                                  #If Accelerate proxy used, should set it since prisma db|migrate does not work with Accelerate proxy

Cache-Control: max-age=NUM [C]    #In secs. How long to cache
Cache-Control: ...,               #In secs. Once over ttl, how long to deliver stale-while-revalidate
 stale-while-revalidate=NUM [C]   #This means sending cached response, then updating the cache in the background
Cache-Control: no-cache [C]       #Def: no caching

Accelerate-Cache-Status: STR [S]  #One of:
                                  #  - 'ttl': cached
                                  #  - 'swr': delivered as stale-while-revalidate
                                  #  - 'miss': stale
                                  #  - 'none': no caching set
Last-Modified: DATE [S]           #
Cf-Ray: REQ_ID-REGION [S]         #Cloudflare request ID and REGION
Accelerate-Signature: STR [S]     #
Accelerate-Query-Engine-Jwt:
 JWT [C|S]                        #Authentication. Set by initial response


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:     ACCELERATE EXTENSION      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@prisma/extension-accelerate      #Version 0.6.2
withAccelerate()->EXTENSION       #Adds OPTS.cacheStrategy and CPROMISE.withAccelerateInfo()

OPTS.cacheStrategy                #CACHING
CACHING.ttl                       #NUM. Sets Cache-Control: max-age=NUM [C]
CACHING.swr                       #NUM. Sets Cache-Control: stale-while-revalidate [C]

CPROMISE.withAccelerateInfo()
 ->CPROMISE                       #Instead of returning VAL, return OBJ: data VAL, info CINFO
CINFO.cacheStatus                 #STR. Accelerate-Cache-Status [S]
CINFO.lastModified                #DATE. Last-Modified [S]
CINFO.region                      #'REGION' from Cf-Ray [S]
CINFO.requestId                   #'REQ_ID' from Cf-Ray [S]
CINFO.signature                   #STR. Accelerate-Signature [S]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            POOLING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CLIENT.$[dis]connect()->>         #Use local pool of connections
                                  #Each CLIENT has its own pool

CONNECTION POOLING ==>            #Accelerate uses pool of connections, as a separate proxy used after the caching proxy
                                  #Unlike CLIENT, can be shared by multiple machines, e.g. in serverless functions
                                  #Can choose REGION
                                  #Previously called "Data proxy"

STATIC IP ==>                     #Can set IP to use, when database restrict incoming IPs

QUERY ENGINE ==>                  #Database query is performed on the proxy (which bundles the query engine)
                                  #I.e. client only sends CLIENT METHOD arguments
                                  #This allows using schema generate --no-engine, for smaller bundle size in serverless functions

LIBPQ.*                           #The following is both for CLIENT and Accelerate
LIBPQ.connection_limit            #Max NUM (def: CPUs * 2 + 1) of connections to pool
                                  #Close after 6m idle
LIBPQ.pool_timeout                #NUM (in sec, def: 10). If pool empty, how long to wait
                                  #Can be 0 for Infinity

GAUGE prisma_pool_connections_open#NUM of connections in pool open
GAUGE prisma_pool_connections_idle#NUM of connections in pool open and not running a database query
GAUGE prisma_pool_connections_busy#NUM of connections in pool open and running a database query
GAUGE prisma_client_queries_wait  #NUM of CLIENT.COMMAND() waiting for a connection in pool

COUNTER prisma_pool_
 connections_opened_total         #NUM of connections in pool opened
COUNTER prisma_pool_
 connections_closed_total         #NUM of connections in pool closed

HISTOGRAM prisma_client_
 queries_wait_histogram_ms        #NUM (in ms). How long CLIENT.COMMAND() are waiting for a connection in pool


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PULSE MAIN           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PULSE ==>                         #Realtime events on data changes (new|updated|deleted COBJ)
                                  #Uses Debezium under-the-hood
                                  #Only Postgres
                                  #Uses Postgres logical replication
                                  #  - PCONF.wal_level 'logical'
                                  #  - recommends PCONF.max_replication_slots 20
                                  #  - recommends HCONF.wal_keep_size 2048
                                  #Connection URL must be superuser
                                  #EVENTs are not queued, i.e. lost if no SUB listening
                                  #No guarantee of EVENTs ordering, or exact-once

ws://subscription.pulse.
 prisma-data.net                  #WebSocket server

Bearer: JWT [C]                   #Authentication. JWT retrieved from UI
prisma_client_version: X.Y.Z [C]  #
connectionType: STR [C]           #'initial|reconnect'. Whether it is a connection retry or not

subscription: SUB_JSON [C]        #
SUB.query.name                    #'MODEL'
                                  #Max 10 SUBs per MODEL
ACTION                            #One of:
                                  #  - 'create': added ROWs
                                  #  - 'update': updated ROWs
                                  #  - 'delete': deleted ROWs
                                  #ACTION create|update uses `before`, delete uses `after`
SUB.query.where.ACTION            #Only subscribe to COBJs matching FILTERS
 .before|after                    #Cannot use FILTER search|mode, nor CMODEL.fields.FIELD
                                  #Is FILTERS but serialized as top-level 'AND' NODE:
                                  #  - match_type 'AND|OR|NOT|contains|equals|...'
                                  #  (only with 'AND|OR|NOT')
                                  #  - children NODE_ARR
                                  #  (not with 'AND|OR|NOT')
                                  #  - property 'PROP'
                                  #  - value VAL
                                  #  - fieldReference BOOL: whether uses CMODEL.fields.FIELD
                                  #  - case_insensitive BOOL: whether uses FILTER mode

REQ                               #There are no WebSocket requests to send
RES                               #WebSocket response
                                  #Initial handshake: "Hello"
                                  #Then: JSON_COBJ
                                  #  - also has COBJ.__op 'c|u|d' (ACTION)
                                  #  - Postgres: if no `replica identity full`, only primary keys with ACTION 'delete'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        PULSE EXTENSION        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@prisma/extension-pulse           #Version 0.1.8
withPulse(OPTS)->EXTENSION        #Adds CMODEL.subscribe()
OPTS.apiKey                       #'JWT'. Bearer [C]
OPTS.subscriptionUrl              #'URL'. Def: ws://subscription.pulse.prisma-data.net

CMODEL.subscribe([OPTS])          #Start WebSocket connection
 ->>EVENT_ASYNC_ITERABLE|ERROR    #Does not try to reconnect on connection failure
OPTS.ACTION[.before|after]        #FILTERS
                                  #Def: all ACTIONs
                                  #Can be empty OBJ, to match all
                                  #  - before|after is then optional
EVENT_ASYNC_ITERABLE.stop()       #

EVENT                             #WebSocket RES
EVENT.action                      #'ACTION'
EVENT.before                      #Old COBJ. Only with 'delete'
EVENT.after                       #New COBJ. Only with 'create|update'
