
                                  ┏━━━━━━━━━━━━━━━━━━━━┓
                                  ┃   STEP_FUNCTIONS   ┃
                                  ┗━━━━━━━━━━━━━━━━━━━━┛

VERSION ==>                       #2024-11-28

TODO:
  - https://states-language.net/spec.html#appendix-b
  - JSONata
     - including all references in https://states-language.net/spec.html
  - https://docs.aws.amazon.com/step-functions/latest/apireference/Welcome.html
  - part in https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultwriter.html:
     - from "If you export the child workflow execution results,"
     - to "to record the remaining results"
  - new_services doc
  - CDK:
     - document which properties are supported by --hotswap
     - API Gateway:
        - StepFunctionsIntegration:
           - v1: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/lib/integrations/stepfunctions.ts
           - v2: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/lib/http/stepfunctions.ts
        - StepFunctionsRestApi: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/lib/stepfunctions-api.ts
        - https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/README.md#aws-stepfunctions-backed-apis
  - SAM:
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-statemachine.html
        - RESPROP Policies: document like AWS::Serverless::Function, i.e. just refer to SAM_POLICIES
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification-generated-resources-statemachine.html
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-step-functions-in-sam.html
     - `aws cloudformation package` and `sam package` can be used with:
        - AWS::StepFunctions::StateMachine RESPROP DefinitionS3Location
        - AWS::Serverless::StateMachine RESPROP DefinitionUri
     - document that hot reloading is supported by `sam sync`
        - including part which documents that contents caching is done using STATE_MACHINE definition
     - move documentation about `sam remote invoke`
     - move documentation about AWS::Serverless::Connector
     - move POLICY_TEMPLATE doc from SAM transform doc
     - mention that SAM_POLICIES apply to AWS::Serverless::StateMachine RESPROP Policies too
     - see example of how to document this with AWS::Serverless::Function documentation in CloudWatch Logs
     - test locally using sam-translate binary
  - Infrastructure Composer
     - https://docs.aws.amazon.com/infrastructure-composer/latest/dg/using-composer-services-sf.html
     - https://docs.aws.amazon.com/infrastructure-composer/latest/dg/using-composer-external-files-new.html
     - connection from API Gateway API to Step Functions STATE_MACHINE
  - https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html
     - already done:
        - Processing input and output:
           - Map state input and output fields in Step Functions
  - https://github.com/awslabs/statelint

                                  ┌─────────┐
                                  │   API   │
                                  └─────────┘

PAGINATION ==>                    #Uses REQ.maxResults (def 100, max 1000) + REQ|RES.nextToken
                                  #ValidateStateMachineDefinition(): REQ.maxResults (def|max 100), no REQ|RES.nextToken, RES.truncated BOOL
                                  #No pagination: ListTagsForResource()

                                  ┌─────────────┐
                                  │   MACHINE   │
                                  └─────────────┘

CreateStateMachine()              #Req: MACHINE + NEW_VERSION
                                  #  - no creationDate, label, status
                                  #  - no stateMachineArn
                                  #  - only one with tags
                                  #Res: VERSION
                                  #  - no updateDate, revisionId
UpdateStateMachine()              #Req: MACHINE + NEW_VERSION
                                  #  - no creationDate, label, status
                                  #  - no name, type
                                  #Res: VERSION
                                  #  - no stateMachineArn, creationDate
ListStateMachines()               #Req: empty
                                  #Res: stateMachines MACHINE_ARR
                                  #  - only stateMachineArn, name, creationDate, type
DescribeStateMachine()            #Req:
                                  #  - MACHINE: only stateMachineArn
                                  #  - MACHINE_GET
                                  #Res:
                                  #  - MACHINE
                                  #  - VERSION: no stateMachineVersionArn, no updateDate
DescribeStateMachineForExecution()#Req:
                                  #  - EXEC: only executionArn
                                  #  - MACHINE_GET
                                  #Res:
                                  #  - MACHINE: no creationDate, status, type
                                  #  - VERSION: no stateMachineVersionArn, description
                                  #  - MAP_RUN: only mapRunArn
DeleteStateMachine()              #Req: MACHINE
                                  #  - only stateMachineArn
                                  #Res: empty

MACHINE.stateMachineArn           #'MACHINE_ARN'
MACHINE.name                      #'MACHINE'
MACHINE.creationDate              #DATE_NUM

MACHINE.status                    #STR

MACHINE.type                      #STR

MACHINE.label                     #STR

MACHINE.roleArn                   #'ROLE_ARN'

MACHINE.variableReferences.MVAR   #STR_ARR

                                  ┌─────────────┐
                                  │   VERSION   │
                                  └─────────────┘

PublishStateMachineVersion()      #Req: VERSION
                                  #  - no stateMachineVersionArn, *Date
                                  #  - only one with description, revisionId
                                  #Res: VERSION
                                  #  - only stateMachineVersionArn, creationDate
ListStateMachineVersions()        #Req: MACHINE
                                  #  - only stateMachineArn
                                  #Res: stateMachineVersions VERSION_ARR
                                  #  - only stateMachineVersionArn, creationDate
CreateStateMachine()
UpdateStateMachine()
DescribeStateMachine()            #Return VERSION too (see above)
DeleteStateMachineVersion()       #Req: VERSION
                                  #  - only stateMachineVersionArn
                                  #Res: empty

VERSION.stateMachineVersionArn    #'VERSION_ARN'
VERSION.stateMachineArn           #'MACHINE_ARN'
VERSION.description
NEW_VERSION.versionDescription    #STR
VERSION.creationDate              #DATE_NUM
VERSION.updateDate                #DATE_NUM

NEW_VERSION.publish               #BOOL

VERSION.revisionId                #STR

                                  ┌───────────┐
                                  │   ALIAS   │
                                  └───────────┘

CreateStateMachineAlias()         #Req: ALIAS
                                  #  - no stateMachineAliasArn, *Date
                                  #Res: ALIAS
                                  #  - only stateMachineAliasArn, creationDate
UpdateStateMachineAlias()         #Req: ALIAS
                                  #  - no name, *Date
                                  #Res: ALIAS
                                  #  - only updateDate
ListStateMachineAliases()         #Req: STATE_MACHINE
                                  #  - only stateMachineArn
                                  #Res: stateMachineAliases ALIAS_ARR
                                  #  - only stateMachineAliasArn, creationDate
DescribeStateMachineAlias()       #Req: ALIAS
                                  #  - only stateMachineAliasArn
                                  #Res: ALIAS
DeleteStateMachineAlias()         #Req: ALIAS
                                  #  - only stateMachineAliasArn
                                  #Res: empty

ALIAS.stateMachineAliasArn        #'ALIAS_ARN'
ALIAS.name                        #'ALIAS'
ALIAS.description                 #STR
ALIAS.creationDate                #DATE_NUM
ALIAS.updateDate                  #DATE_NUM

ALIAS.routingConfiguration        #ALIAS_ROUTING_ARR
ALIAS_ROUTING
 .stateMachineVersionArn          #'VERSION_ARN'
ALIAS_ROUTING.weight              #NUM

                                  ┌────────────────┐
                                  │   DEFINITION   │
                                  └────────────────┘

MACHINE.definition                #STR
MACHINE_GET.includedData          #STR

                                  ┌────────────────┐
                                  │   VALIDATION   │
                                  └────────────────┘

ValidateStateMachineDefinition()  #Req:
                                  #  - MACHINE: only definition|type
                                  #  - DIAGNOSTIC: only severity
                                  #Res: VALIDATE_RES

VALIDATE_RES.result               #'OK' or 'FAIL'
VALIDATE_RES.diagnostics          #DIAGNOSTIC_ARR
DIAGNOSTIC.code                   #'ERROR_CODE'
DIAGNOSTIC.message                #'MESSAGE'
DIAGNOSTIC.severity               #'ERROR' (def) or 'WARNING'
DIAGNOSTIC.location               #STR

                                  ┌───────────────┐
                                  │   EXECUTION   │
                                  └───────────────┘

StartExecution()                  #Req: EXEC
                                  #  - only stateMachineArn, name, input, traceHeader
                                  #Res: EXEC
                                  #  - only executionArn, startDate
StartSyncExecution()              #Req:
                                  #  - EXEC: only stateMachineArn, name, input, traceHeader
                                  #  - EXEC_GET
                                  #Res: EXEC
                                  #  - no mapRunArn, redrive*, stateMachineVersionArn|stateMachineAliasArn
                                  #  - only one with billingDetails
ListExecutions()                  #Req: EXEC
                                  #  - only either stateMachineArn or mapRunArn
                                  #  - only status -> statusFilter
                                  #  - only one with redriveFilter
                                  #Res: executions EXEC_ARR
                                  #  - no cause, error, input*|output*, redriveStatus[Reason], traceHeader
                                  #  - only one with itemCount
DescribeExecution()               #Req:
                                  #  - EXEC: only executionArn
                                  #  - EXEC_GET
                                  #Res: EXEC
StopExecution()                   #Req: EXEC
                                  #  - only executionArn, cause, error
                                  #Res: EXEC
                                  #  - only stopDate

EXEC.executionArn                 #'EXEC_ARN'
EXEC.name                         #'EXEC'
EXEC.startDate                    #DATE_NUM
EXEC.stopDate                     #DATE_NUM

EXEC.stateMachineArn              #'MACHINE_ARN'
EXEC.stateMachineVersionArn       #'VERSION_ARN'
EXEC.stateMachineAliasArn         #'ALIAS_ARN'

EXEC.status                       #STR
EXEC.cause                        #STR
EXEC.error                        #STR

EXEC.input                        #STR
EXEC.inputDetails.included        #BOOL
EXEC.output                       #STR
EXEC.outputDetails.included       #BOOL

EXEC.traceHeader                  #STR

EXEC.billingDetails               #EXEC_BILLING
EXEC_BILLING
 .billedDurationInMilliseconds    #NUM
EXEC_BILLING.billedMemoryUsedInMB #NUM

EXEC_GET.includedData             #STR

AVAILABLE EVENT_TYPES ==>         #ExecutionStarted ExecutionSucceeded ExecutionAborted ExecutionTimedOut ExecutionFailed
EVENT_INFO.roleArn                #STR
                                  #With EVENT_TYPE ExecutionStarted
EVENT_INFO.stateMachineAliasArn   #STR
                                  #With EVENT_TYPE ExecutionStarted
EVENT_INFO.stateMachineVersionArn #STR
                                  #With EVENT_TYPE ExecutionStarted

                                  ┌─────────────┐
                                  │   REDRIVE   │
                                  └─────────────┘

RedriveExecution()                #Req: REDRIVE
                                  #Res: EXEC
                                  #  - only redriveDate

REDRIVE.executionArn              #'EXEC_ARN'
REDRIVE.clientToken               #STR

EXEC|MAP_RUN.redriveCount         #NUM
EXEC|MAP_RUN.redriveDate          #DATE_NUM
EXEC.redriveStatus                #STR
EXEC.redriveStatusReason          #STR
EXEC.redriveFilter                #STR

AVAILABLE EVENT_TYPES ==>         #ExecutionRedriven MapRunRedriven
EVENT_INFO.redriveCount           #NUM
                                  #With EVENT_TYPEs ExecutionRedriven and MapRunRedriven
                                  #Different descriptions in
                                  #https://docs.aws.amazon.com/step-functions/latest/apireference/API_ExecutionRedrivenEventDetails.html#StepFunctions-Type-ExecutionRedrivenEventDetails-redriveCount???
                                  #And
                                  #https://docs.aws.amazon.com/step-functions/latest/apireference/API_MapRunRedrivenEventDetails.html#StepFunctions-Type-MapRunRedrivenEventDetails-redriveCount???

                                  ┌────────────┐
                                  │   EVENTS   │
                                  └────────────┘

GetExecutionHistory()             #Req: EVENTS_REQ
                                  #Res: events EVENT_ARR

EVENTS_REQ.executionArn           #'EXEC_ARN'
EVENTS_REQ.includeExecutionData   #BOOL
EVENTS_REQ.reverseOrder           #BOOL

EVENT.id                          #EVENT_MID. Serial NUM, 1-indexed
EVENT.previousEventId             #EVENT_MID, if any
EVENT.timestamp                   #DATE_NUM

EVENT.type                        #'EVENT_TYPE' (PascalCase)
                                  #Available ones documented in this doc
EVENT.EVENT_TYPEEventDetails      #EVENT_TYPE-specific EVENT_INFO
                                  #EVENT_TYPE is camelCase
                                  #EVENT_TYPE *StateEntered|StateExited -> stateEntered|stateExited
                                  #undefined some EVENT_TYPEs

EVENT_INFO.input                  #'JSON'
                                  #Max 260KB
                                  #With EVENT_TYPEs:
                                  #  - *StateEntered
                                  #  - ActivityScheduled
                                  #  - ExecutionStarted
                                  #  - LambdaFunctionScheduled
EVENT_INFO.inputDetails.truncated #BOOL
                                  #With same EVENT_TYPEs as EVENT_INFO.input

EVENT_INFO.output                 #'JSON'
                                  #Max 260KB
                                  #With EVENT_TYPEs:
                                  #  - *StateExited
                                  #  - ActivitySucceeded
                                  #  - ExecutionSucceeded
                                  #  - LambdaFunctionSucceeded
                                  #  - TaskSubmitted, TaskSucceeded
EVENT_INFO.outputDetails.truncated#BOOL
                                  #With same EVENT_TYPEs as EVENT_INFO.output

EVENT_INFO.assignedVariables.STR  #STR
                                  #With EVENT_TYPE *StateExited
EVENT_INFO
 .assignedVariablesDetails        #BOOL
 .truncated                       #With EVENT_TYPE *StateExited

EVENT_INFO.error                  #STR
                                  #With EVENT_TYPEs:
                                  #  - *Failed (except MapIterationFailed, MapStateFailed, ParallelStateFailed)
                                  #  - *TimedOut
                                  #  - ExecutionAborted
EVENT_INFO.cause                  #STR
                                  #With same EVENT_TYPEs as EVENT_INFO.error

EVENT_INFO.timeoutInSeconds       #NUM
                                  #With EVENT_TYPEs *Scheduled

EVENT_INFO.heartbeatInSeconds     #NUM
                                  #With EVENT_TYPEs ActivityScheduled and TaskScheduled

EVENT_INFO.taskCredentials.roleArn#'ROLE_ARN'
                                  #With EVENT_TYPEs LambdaFunctionScheduled and TaskScheduled

                                  ┌──────────────┐
                                  │   ACTIVITY   │
                                  └──────────────┘

CreateActivity()                  #Req: ACTIVITY
                                  #  - no activityArn
                                  #  - only one with tags
                                  #Res: ACTIVITY
                                  #  - no name, encryptionConfiguration
ListActivities()                  #Req: empty
                                  #Res: activities ACTIVITY_ARR
                                  #  - no encryptionConfiguration
DescribeActivity()                #Req: ACTIVITY
                                  #  - only activityArn
                                  #Res: ACTIVITY
DeleteActivity()                  #Req: ACTIVITY
                                  #  - only activityArn
                                  #Res: empty

ACTIVITY.activityArn              #'ACTIVITY_ARN'
ACTIVITY.name                     #'ACTIVITY'
ACTIVITY.creationDate             #DATE_NUM

AVAILABLE EVENT_TYPES ==>         #ActivityScheduled ActivityScheduleFailed ActivityStarted ActivitySucceeded ActivityTimedOut ActivityFailed
EVENT_INFO.resource               #STR
                                  #With EVENT_TYPE ActivityScheduled
EVENT_INFO.workerName             #STR
                                  #With EVENT_TYPE ActivityStarted

                                  ┌──────────┐
                                  │   TASK   │
                                  └──────────┘

GetActivityTask()                 #Req: TASK_GET
                                  #Res: TASK
                                  #  - only one with input
SendTaskSuccess()                 #Req: TASK
                                  #  - only one with output
                                  #Res: empty
SendTaskFailure()                 #Req: TASK
                                  #  - only one with error, cause
                                  #Res: empty
SendTaskHeartbeat()               #Req: TASK
                                  #Res: empty

TASK.taskToken                    #'TASK_MID'
TASK_GET.activityArn              #
TASK_GET.workerName               #

TASK.input                        #STR
TASK.output                       #STR
TASK.error                        #STR
TASK.cause                        #STR

AVAILABLE EVENT_TYPES ==>         #TaskSubmitted TaskSubmitFailed TaskScheduled TaskStarted TaskStartFailed TaskSucceeded TaskTimedOut TaskFailed
EVENT_INFO.resource               #STR
                                  #With EVENT_TYPEs Task* (except TaskState*)
EVENT_INFO.resourceType           #STR
                                  #With same EVENT_TYPEs as EVENT_INFO.resource
EVENT_INFO.parameters             #STR
                                  #With EVENT_TYPE TaskScheduled
EVENT_INFO.region                 #STR
                                  #With EVENT_TYPE TaskScheduled

                                  ┌────────────────┐
                                  │   ENCRYPTION   │
                                  └────────────────┘

MACHINE|ACTIVITY
 .encryptionConfiguration         #ENCRYPT
ENCRYPT.type                      #'AWS_OWNED_KEY' or 'CUSTOMER_MANAGED_KMS_KEY'
ENCRYPT.kmsKeyId                  #KMS 'KEY_ID'
ENCRYPT
 .kmsDataKeyReusePeriodSeconds    #NUM

                                  ┌─────────────┐
                                  │   LOGGING   │
                                  └─────────────┘

MACHINE
 .tracingConfiguration.enabled    #BOOL

MACHINE.loggingConfiguration      #MACHINE_LOGGING
MACHINE_LOGGING.destinations[*]
 .cloudWatchLogsLogGroup
 .logGroupArn                     #'LOG_GROUP_ARN'
MACHINE_LOGGING.level             #STR
MACHINE_LOGGING
 .includeExecutionData            #BOOL

                                  ┌─────────────┐
                                  │   MAP RUN   │
                                  └─────────────┘

UpdateMapRun()                    #Req: MAP_RUN
                                  #  - no *Date, status, executionArn, redrive*, *Counts
                                  #Res: empty
ListMapRuns()                     #Req: MAP_RUN
                                  #  - only executionArn
                                  #Res: mapRuns MAP_RUN_ARR
                                  #  - only mapRunArn, executionArn, startDate, stopDate
                                  #  - only one with stateMachineArn
DescribeMapRun()                  #Req: MAP_RUN
                                  #  - only mapRunArn
                                  #Res: MAP_RUN
DescribeStateMachineForExecution()#Also returns mapRunArn (see above)

MAP_RUN.mapRunArn                 #'MAP_RUN_ARN'
MAP_RUN.startDate                 #DATE_NUM
MAP_RUN.stopDate                  #DATE_NUM

MAP_RUN.status                    #STR

MAP_RUN.stateMachineArn           #'MACHINE_ARN'
MAP_RUN.executionArn              #'EXEC_ARN'
EXEC.mapRunArn                    #'MAP_RUN_ARN'
EXEC.itemCount                    #NUM

MAP_RUN.maxConcurrency            #NUM
MAP_RUN.toleratedFailureCount     #NUM
MAP_RUN.toleratedFailurePercentage#NUM

MAP_RUN.executionCounts           #MAP_COUNT
MAP_RUN.itemCounts                #MAP_COUNT
MAP_COUNT.aborted                 #NUM
MAP_COUNT.failed                  #NUM
MAP_COUNT.failuresNotRedrivable   #NUM
MAP_COUNT.pending                 #NUM
MAP_COUNT.pendingRedrive          #NUM
MAP_COUNT.resultsWritten          #NUM
MAP_COUNT.running                 #NUM
MAP_COUNT.succeeded               #NUM
MAP_COUNT.timedOut                #NUM
MAP_COUNT.total                   #NUM

AVAILABLE EVENT_TYPES ==>         #MapRunStarted MapRunSucceeded MapRunAborted MapRunFailed
EVENT_INFO.mapRunArn              #'MAP_RUN_ARN'
                                  #With EVENT_TYPEs MapRunStarted and MapRunRedriven

                                  ┌───────────────┐
                                  │   MAP STATE   │
                                  └───────────────┘

AVAILABLE EVENT_TYPES ==>         #MapStateEntered MapStateExited MapStateStarted MapStateSucceeded MapStateAborted MapStateFailed
EVENT_INFO.length                 #NUM
                                  #With EVENT_TYPE MapStateStarted

                                  ┌───────────────────┐
                                  │   MAP ITERATION   │
                                  └───────────────────┘

AVAILABLE EVENT_TYPES ==>         #MapIterationStarted MapIterationSucceeded MapIterationAborted MapIterationFailed
EVENT_INFO.index                  #NUM
                                  #With EVENT_TYPEs MapIteration*
EVENT_INFO.name                   #'STATE'
                                  #Max 80 chars, [:alnum:]-_
                                  #With EVENT_TYPEs MapIteration*, *StateEntered, *StateExited

                                  ┌───────────┐
                                  │   STATE   │
                                  └───────────┘

TestState()                       #Req: TEST_IN
                                  #Res: TEST_OUT

TEST_IN.definition                #STR
TEST_IN.input                     #STR
TEST_IN.revealSecrets             #BOOL
TEST_IN.roleArn                   #STR
TEST_IN.variables                 #STR

TEST_OUT.error                    #STR
TEST_OUT.cause                    #STR
TEST_OUT.nextState                #STR
TEST_OUT.output                   #STR
TEST_OUT.status                   #STR

TEST_IN.inspectionLevel           #STR
TEST_OUT.inspectionData           #TEST_DATA
TEST_DATA.afterArguments          #STR
TEST_DATA.afterInputPath          #STR
TEST_DATA.afterParameters         #STR
TEST_DATA.afterResultPath         #STR
TEST_DATA.afterResultSelector     #STR
TEST_DATA.input                   #STR
TEST_DATA.result                  #STR
TEST_DATA.variables               #STR

TEST_DATA.request                 #TEST_REQ
TEST_REQ.body                     #STR
TEST_REQ.headers                  #STR
TEST_REQ.method                   #STR
TEST_REQ.protocol                 #STR
TEST_REQ.url                      #STR

TEST_DATA.response                #TEST_RES
TEST_RES.body                     #STR
TEST_RES.headers                  #STR
TEST_RES.protocol                 #STR
TEST_RES.statusCode               #STR
TEST_RES.statusMessage            #STR

AVAILABLE EVENT_TYPES ==>         #TaskStateEntered TaskStateExited TaskStateAborted
                                  #SucceedStateEntered SucceedStateExited
                                  #PassStateEntered PassStateExited
                                  #ChoiceStateEntered ChoiceStateExited
                                  #FailStateEntered
                                  #ParallelStateEntered ParallelStateExited ParallelStateStarted ParallelStateSucceeded
                                  #ParallelStateAborted ParallelStateFailed
                                  #WaitStateEntered WaitStateExited WaitStateAborted

                                  ┌───────────────┐
                                  │   TRANSFORM   │
                                  └───────────────┘

AVAILABLE EVENT_TYPES ==>         #EvaluationFailed
EVENT_INFO.location               #STR
                                  #With EVENT_TYPE EvaluationFailed
EVENT_INFO.state                  #STR
                                  #With EVENT_TYPE EvaluationFailed

                                  ┌────────────┐
                                  │   LAMBDA   │
                                  └────────────┘

AVAILABLE EVENT_TYPES ==>         #LambdaFunctionScheduled LambdaFunctionScheduleFailed LambdaFunctionStarted
                                  #LambdaFunctionStartFailed LambdaFunctionSucceeded LambdaFunctionTimedOut LambdaFunctionFailed
EVENT_INFO.resource               #STR
                                  #With EVENT_TYPE LambdaFunctionScheduled

                                  ┌──────────┐
                                  │   TAGS   │
                                  └──────────┘

TagResource()                     #Req: TAGS
                                  #Res: empty
ListTagsForResource()             #Req: TAGS
                                  #  - only resourceArn
                                  #Res: TAGS
                                  #  - no resourceArn
UntagResource()                   #Req: TAGS
                                  #  - tags -> tagKeys 'TAG'_ARR
                                  #Res: empty

TAGS.resourceArn                  #'MACHINE_ARN|ACTIVITY_ARN'
TAGS.tags
MACHINE|ACTIVITY.tags             #TAG_PAIRS

                                  ┌────────────────┐
                                  │   DEFINITION   │
                                  └────────────────┘

DEFINITION                        #'DMACHINE_JSON'
D*                                #Fields in 'DMACHINE_JSON'
DMACHINE.Version                  #Always '1.0' (def)
                                  #Only for top-level MACHINE

DMACHINE|DSTATE.Comment           #STR. Description
                                  #Only for top-level MACHINE

DMACHINE.States.STATE             #DSTATE. Either a task or flow control
                                  #'STATE' name max 80 chars
DSTATE.Type                       #'STATE_TYPE'
DSTATE.*                          #STATE_TYPE-specific

DMACHINE.StartAt                  #'STATE'. First state

TRANSITION ==>                    #DSTATE|DCHOICE.Next
                                  #Cannot target a 'STATE' in parent|child MACHINEs
DSTATE.Next                       #'STATE'. Next state

TERMINAL STATE ==>                #Last STATE of a MACHINE, i.e. STATE_SUCCEED|FAIL or DSTATE.End true
DSTATE.End                        #BOOL (def: false). Ends MACHINE successfully, but not parent ones
                                  #Not with STATE_CHOICE|SUCCEED|FAIL
DSTATE.Type                       #'Succeed'. STATE is STATE_SUCCEED
                                  #End MACHINE successfully, but not parent ones

ERRORS ==>                        #STATEs can throw ERRORs
                                  #In addition to ERRORs documented here, any STATE might fail due to network ERRORs
                                  #ERRORs are propagated to parent STATE|MACHINEs
                                  #When ERROR reaches top-level MACHINE, ends it with failure, using ERROR as OUTPUT
ERROR_OUTPUT.Error                #'ERROR_CODE'
                                  #'States.*' reserved, i.e. should not use inside STATE_TASK
ERROR_OUTPUT.Cause                #'MESSAGE'

DSTATE.Type                       #'Fail'. STATE is STATE_FAIL
                                  #End MACHINE with failure, including parent ones
                                  #OUTPUT is ERROR_OUTPUT
DSTATE.Error                      #'ERROR_CODE'[_DDPATH] (def: ???). ERROR_OUTPUT.Error
DSTATE.Cause                      #'MESSAGE'[_DDPATH] (def: none). ERROR_OUTPUT.Cause

DSTATE.Catch                      #DCATCH_ARR. Executes some logic on ERROR
                                  #Only with STATE_TASK|PARALLEL|MAP
DCATCH.ErrorEquals                #'ERROR_CODE'_ARR. Required, not empty
                                  #Can be ['States.ALL'] to match any ERROR_CODE
                                  #  - must be last DCATCH in DCATCH_ARR
                                  #  - does not match ERROR_CODE 'States.DataLimitExceeded' nor 'States.Runtime'
DCATCH.Next                       #Like DSTATE.*. Required
DCATCH's INPUT ==>                #In first matching DCATCH: STATE's INPUT
                                  #In next ones: previous matching DCATCH's OUTPUT
DCATCH.Output                     #ERROR_OUTPUT
                                  #Def: current ERROR (not INPUT)
DCATCH.Assign|ResultPath          #Like DSTATE.*

DSTATE.Retry                      #DRETRY_ARR. Retry STATE if throws
                                  #If a retry succeeds:
                                  #  - STATE does not throw anymore
                                  #  - CATCHs not run
                                  #Def: no retry
                                  #Only with STATE_TASK|PARALLEL|MAP
DRETRY.ErrorEquals                #Same as DCATCH.ErrorEquals
DRETRY.MaxAttempts                #NUM (def: 3). Max NUM of retries
                                  #Can be 0 to not retry
DRETRY.IntervalSeconds            #NUM (in secs, def: 1). Initial delay
DRETRY.MaxDelaySeconds            #NUM (def: none). Max delay
                                  #Does not decrease max NUM of retries
DRETRY.BackoffRate                #NUM (def: 2). Multiplies delay after each retry
DRETRY.JitterStrategy             #'NONE' (def) or 'FULL'. Applies random jitter to delay, which helps spread the load

DMACHINE.TimeoutSeconds           #NUM (def: none). After NUMs, throw ERROR_CODE 'States.Timeout'
                                  #Only for top-level MACHINE
DSTATE_TASK.TimeoutSeconds        #NUM_DDPATH (in secs, def: 60).
                                  #On timeout, throw ERROR_CODE 'States.Timeout'
DSTATE_TASK.HeartbeatSeconds      #NUM_DDPATH (in secs, def: none). Heartbeat timeout, reset after each heartbeat
                                  #On timeout, throw ERROR_CODE 'States.HeartbeatTimeout' + 'States.Timeout'
                                  #Must be < TimeoutSeconds

INPUT                             #'VAL_JSON' (def: '{}') passed to each STATE
                                  #INPUT to first STATE is set by caller, for a given EXEC
                                  #INPUT to other STATEs is OUTPUT of previous STATE
                                  #Max 256KB (else throw ERROR_CODE 'States.DataLimitExceeded')
OUTPUT                            #'VAL_JSON' (def: INPUT) returned by each STATE
                                  #OUTPUT from final STATE is EXEC's output
                                  #Max 256KB (else throw ERROR_CODE 'States.DataLimitExceeded')

CONTEXT                           #'OBJ_JSON' passed to each STATE
                                  #Set by caller, for a given EXEC

DSTATE.Assign.DVAR                #VAL. "State machine variable"
                                  #Sets $DVAR in any later STATE (not current STATE)
                                  #To use inside JSONPath|JSONata
                                  #Child DMACHINEs:
                                  #  - have their own DVAR scope
                                  #  - can use upper scope's DVARs, but not set them
                                  #  - cannot use lower|sibling scopes' DVARs
                                  #DVAR:
                                  #  - max 80 chars
                                  #  - ID_Continue: letters-like, numbers-like, _, diacretics, U+200C U+200D (zero-width space)
                                  #  - first char: ID_Start: letters-like
                                  #Not with STATE_SUCCEED|FAIL

DMACHINE|DSTATE.QueryLanguage     #'JSONPath' (def) or 'JSONata'
                                  #Not inherited by child DMACHINEs
                                  #Only for top-level MACHINE

JSONPATH ==>                      #
$...                              #JSONPath (see its doc) applied on INPUT (after transforming)
                                  #Exception: applied on OUTPUT (after transforming) in *.Assign (except DSTATE_CHOICE|WAIT.Assign)
                                  #Cannot use [(EXPR)] and [?(EXPR)]
$$...                             #JSONPath applied on CONTEXT

DPATH                             #'$...' or '$$...'
                                  #Substituted by its result, which can be any JSON type
DDPATH                            #DPATH but result must be a single value
                                  #Can only use .VAR [NUM]
                                  #No * .. [...,...] [...:...:...]
VAL[_DDPATH]                      #Means VAL can be a DDPATH, providing key is appended with 'Path'
                                  #E.g. DSTATE_TASK.TimeoutSecondsPath NUM_DDPATH
DEXPR                             #DPATH or 'DFUNC(...)'
DEXPR_OBJ                         #OBJ where top|nested PROPs can be DEXPR
                                  #To use DEXPR as value, key must be 'PROP.$', which becomes 'PROP'

TRANSFORMS ==>                    #Each defaults to keeping INPUT|OUTPUT as is
                                  #Order is:
                                  #  - InputPath -> Parameters
                                  #  - ResultSelector -> ResultPath -> OutputPath
DSTATE.InputPath                  #DPATH. Transforms INPUT
                                  #null sets INPUT as empty OBJ
                                  #Not with STATE_FAIL
DSTATE.Parameters                 #DEXPR_OBJ. Transforms INPUT
                                  #Throws ERROR_CODE 'States.ParameterPathFailure' if no DPATH match
                                  #Only with STATE_TASK|MAP|PARALLEL|PASS

DSTATE.ResultSelector             #DEXPR_OBJ. Transforms OUTPUT
                                  #Only with STATE_TASK|MAP|PARALLEL
DSTATE.ResultPath                 #DDPATH. Sets OUTPUT as {...INPUT, DDPATH: OUTPUT}
                                  #Overrides INPUT.DDPATH, does not merge to it
                                  #null sets OUTPUT as {...INPUT}
                                  #Cannot use CONTEXT nor $DVAR
                                  #Throws ERROR_CODE 'States.ResultPathMatchFailure' if no DPATH match
                                  #Only with STATE_TASK|MAP|PARALLEL|PASS
DSTATE.OutputPath                 #DPATH. Transforms OUTPUT
                                  #null sets OUTPUT as empty OBJ
                                  #Not with STATE_FAIL

DVAR states                       #Always empty

JSONATA ==>                       #
                                  #On error, throws ERROR_CODE 'States.QueryEvaluationError'
DSTATE.Output                     #Not with STATE_FAIL
DSTATE.Arguments                  #Only with STATE_TASK|PARALLEL|MAP
DVAR states                       #

DFUNC([ARG[_DEXPR],...])          #"Intrinsic function"
                                  #ARG can be '-quoted STR, NUM or null
                                  #Must \-escape ' { } \
                                  #Throws ERROR_CODE 'States.IntrinsicFailure' if syntax error
States.*                          #Available DFUNCs, among the following
Format(STR, VAL,...)->STR         #Replaces any {} with each VAL
                                  #VAL must be STR|NUM|BOOL|null, not OBJ|ARR
Array(VAL,...)->ARR               #
ArrayRange(NUM, NUM2, NUM3)->ARR  #From NUM (included) to NUM2 (included) with step NUM3
                                  #ARR max length 1e3
ArrayLength(ARR)->NUM             #ARR.length
ArrayGetItem(ARR, NUM)->VAL       #ARR[NUM]
ArrayContains(ARR, VAL)->BOOL     #ARR.includes()
ArrayUnique(ARR)->ARR             #[...new Set(ARR)]
ArrayPartition(ARR, NUM)->ARR_ARR #Chunks into sub-ARRs of length NUM
StringToJson('JSON')->VAL         #JSON.parse()
JsonToString(DPATH)->'JSON'       #JSON.stringify()
Base64Encode(STR)->'BASE64'       #STR max 1e4 chars
Base64Decode('BASE64')->STR       #STR max 1e4 chars
Hash(STR, 'ALGO')->'HASH'         #ALGO can be 'MD5' or 'SHA-1|256|384|512'
                                  #STR max 1e4 chars
UUID()->'UUIDv4'                  #

DSTATE.Type                       #'Pass'. STATE is STATE_PASS
                                  #Noop. Potential goals: set OUTPUT, set DVARs, apply parent STATE_MAP
DSTATE_PASS.Result                #OUTPUT (def: INPUT)
                                  #Cannot use DPATH|DFUNCs

DSTATE.Type                       #'Choice'. STATE is STATE_CHOICE
                                  #Like a `switch` statement
DSTATE_CHOICE.Default             #'STATE'
                                  #Def: throw ERROR_CODE 'States.NoChoiceMatched'
DSTATE_CHOICE.Choices             #DCHOICE_ARR
                                  #Cannot be empty
DCHOICE.Next                      #Like DSTATE.*. Required
DCHOICE.Assign                    #Like DSTATE.*
                                  #DSTATE_CHOICE.Assign is not used if any DCHOICE matches (even if it has no DCHOICE.Assign)

DCHOICE.*                         #DCOND, i.e. condition deciding whether to pick DCHOICE
DCHOICE.Variable                  #DPATH. VAL to compare

DCOND.Not                         #DCOND2
DCOND.And|Or                      #DCOND_ARR
                                  #Cannot be empty

DCOND.IsPresent                   #BOOL. VAL !== undefined
DCOND.IsNull                      #BOOL. VAL === null

DCOND.IsBoolean                   #BOOL. VAL is a BOOL
DCOND.BooleanEquals               #BOOL[_DPATH]. VAL === BOOL

DCOND.IsNumeric                   #BOOL. VAL is a NUM
DCOND.NumericEquals               #NUM[_DPATH]. VAL === NUM
DCOND
 .NumericLess|GreaterThan[Equals] #NUM[_DPATH]. VAL < <= > >= NUM

DCOND.IsString                    #BOOL. VAL is a STR
DCOND.StringEquals                #STR[_DPATH]. VAL === STR
DCOND.StringMatches               #'GLOB'. VAL matches GLOB
                                  #GLOB can only use *
                                  #Must \-escape * \
DCOND
 .StringLess|GreaterThan[Equals]  #STR[_DPATH]. VAL < <= > >= STR

DCOND.IsTimestamp                 #BOOL. VAL is a DATE
DCOND.TimestampEquals             #'DATE'[_DPATH]. VAL === DATE
DCOND
.TimestampLess|GreaterThan[Equals]#'DATE'[_DPATH]. VAL < <= > >= DATE

DSTATE.Type                       #'Parallel'. STATE is STATE_PARALLEL
                                  #Executes multiple child MACHINEs in parallel, with same INPUT
                                  #OUTPUT is ARR of their OUTPUTs
                                  #If any child MACHINE throws, other childs are terminated
                                  #On error, throws ERROR_CODE 'States.BranchFailed'
DSTATE_PARALLEL.Branches          #DMACHINE_ARR

DSTATE.Type                       #'Map'. STATE is STATE_MAP
                                  #Executes one child MACHINEs per ITEM_ARR, in parallel
                                  #OUTPUT is ARR of their OUTPUTs
                                  #Order is InputPath -> ItemReader -> ItemsPath -> ItemSelector -> ItemBatcher
DSTATE_MAP.ItemProcessor          #DMACHINE

DMACHINE.ProcessorConfig.Mode     #DMAP_CONF
                                  #Only on a child DMACHINE inside DSTATE_MAP.ItemProcessor
DMAP_CONF.Mode                    #'INLINE' or 'DISTRIBUTED'???
DMAP_CONF.ExecutionType           #'STANDARD' (def) or 'EXPRESS'???
                                  #Only if DMAP_CONF.Mode 'DISTRIBUTED'

DSTATE_MAP.ItemReader             #DREADER. Set INPUT using S3 OBJECTs
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.ItemReaderFailed': else
DREADER.Resource                  #Always 'arn:aws:states:::s3:getObject'
DREADER.Parameters                #DREADER_PARAMS, as DEXPR_OBJ
DREADER_PARAMS.Bucket             #S3 'BUCKET'
                                  #Must be in same ACCOUNT|REGION as MACHINE
DREADER_PARAMS.Prefix             #'PREFIX'. S3 OBJECT prefix. Does ListObjectsV2()
                                  #New INPUT is response's OBJECTS.Contents OBJECT_ARR
                                  #Excludes proper FOLDERs, i.e. 'OBJECT' ends with delimiter (e.g. /) and has empty contents
                                  #See also S3 JOB_LAMBDA, as an alternative
                                  #Must allow:
                                  #  - PACTION s3:ListBucket
                                  #  - on MACHINE.roleArn
                                  #  - Resource BUCKET
                                  #  - COND_KEY s3:prefix 'PREFIX'
DREADER_PARAMS.Key                #S3 'OBJECT'. Alternative to DREADER_PARAMS.Prefix, doing GetObject()
                                  #New INPUT is ARR items contained in OBJECT
                                  #Must allow:
                                  #  - PACTION s3:GetObject
                                  #  - on MACHINE.roleArn
                                  #  - Resource:
                                  #     - JSON|CSV: OBJECT
                                  #     - MANIFEST:
                                  #        - arn:aws:s3:::DEST_PREFIX/SOURCE_BUCKET/INVENTORY/YYYY-MM-DDTHH-MMZ/manifest.json
                                  #        - arn:aws:s3:::DEST_PREFIX/SOURCE_BUCKET/INVENTORY/data/*
DREADER.ReaderConfig              #DREADER_CONF
                                  #Only if DEADER_PARAMS.Key used
DREADER_CONF.InputType            #One of:
                                  #  - 'JSON': OBJ_ARR
                                  #     - max 8MB
                                  #     - max 256KB after DSTATE_MAP.ItemsPath|ItemSelector applied
                                  #  - 'CSV'
                                  #     - values are always considered STRs
                                  #     - same limits as CSV
                                  #  - 'MANIFEST': S3 INVENTORY MANIFEST
                                  #     - New INPUT is INVENTORY_LINE_ARR
                                  #     - max 10GB
DREADER_CONF.MaxItems             #NUM[_DDPATH] (def|max: 1e8). Only use first NUM items
DREADER_CONF.CSVHeaderLocation    #Whether OBJ keys are specified:
                                  #  - 'FIRST_ROW' (def): as first CSV row
                                  #  - 'GIVEN': with DREADER_CONF.CSVHeaders
                                  #OBJ keys max 10KB
                                  #Only if DREADER_CONF.InputType 'CSV'
DREADER_CONF.CSVHeaders           #'KEY'_ARR

DSTATE_MAP.ItemsPath              #DDPATH selecting ITEM_ARR
                                  #Def: INPUT, which must be an ARR
DSTATE_MAP.ItemSelector           #DEXPR_OBJ, transforming each ITEM
                                  #Def: keep ITEM as is
                                  #Like other DPATHs, $ is INPUT (not ITEM_ARR nor ITEM)
                                  #  - i.e. uses DSTATE_MAP.InputPath's result, but not DSTATE_MAP.ItemsPath
                                  #$$.Map.Item:
                                  #  - Value VAL: ITEM's value
                                  #     - i.e. uses both DSTATE_MAP.InputPath|ItemsPath
                                  #  - Index NUM (0-based)

DSTATE_MAP.ItemBatcher            #DBATCH. Pass BATCHs to each MACHINE, i.e. groups of multiple ITEMs
                                  #INPUT becomes {Items ITEM_ARR, BatchInput VAL}
                                  #OUTPUT is ARR of each MACHINE's OUTPUT, i.e. one item per BATCH
                                  #Def: no BATCHs
DBATCH.MaxItemsPerBatch           #Max NUM[_DDPATH] of ITEMs per BATCH
DBATCH.MaxInputBytesPerBatch      #Max NUM[_DDPATH] (in bytes, def|max 256KB) total size per BATCH
                                  #Must be explicitly set if no MaxItemsPerBatch
                                  #Combined with MaxItemsPerBatch (if any)
DBATCH.BatchInput                 #VAL (def: undefined), to set as INPUT.BatchInput

DSTATE_MAP.ResultWriter           #DWRITER. Write each OUTPUT item as a JSON S3 OBJECT, using PutObject()
                                  #Each OUTPUT item is a DWRITER_OUTPUT
                                  #Order is ResultWriter -> ResultSelector -> ResultPath -> OutputPath
                                  #No size limit initial total OUTPUT (can be > 256KB)
                                  #  - as opposed to total DWRITER_OUTPUTs, which is max 256KB
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.ResultWriterFailed': else
DWRITER.Resource                  #Always 'arn:aws:states:::s3:putObject'
DWRITER.Parameters                #DWRITER_PARAMS, as DEXPR_OBJ
DWRITER_PARAMS.Bucket             #S3 'BUCKET'
                                  #Must be in same ACCOUNT|REGION as MACHINE
DREADER_PARAMS.Prefix             #'PREFIX'. S3 OBJECT prefix
                                  #Where is it written to???
                                  #Must allow:
                                  #  - PACTION s3:PutObject|GetObject|ListMultipartUploadParts|AbortMultipartUpload
                                  #  - on MACHINE.roleArn
                                  #  - Resource BUCKET/PREFIX/*
DWRITER_OUTPUT.statusCode         #STATUS_NUM
DWRITER_OUTPUT.inputReceived      #OBJ. OUTPUT item

DSTATE_MAP.MaxConcurrency         #NUM[_DDPATH] (def: 0, i.e. unlimited) of MACHINEs to run at once
                                  #Can be 1 for serial

DSTATE_MAP.ToleratedFailureCount  #When > NUM[_DDPATH] (def: 0) ITEMs throw:
                                  #  - terminate every child MACHINE
                                  #  - make DSTATE_MAP throw ERROR_CODE 'States.ExceedToleratedFailureThreshold'
                                  #Else, ITEMs that throw produce ERROR_OUTPUTs
DSTATE_MAP
 .ToleratedFailurePercentage      #Same but as NUM[_DDPATH] 0-100 percentage (def: 0)

DSTATE.Type                       #'Wait'. STATE is STATE_WAIT
                                  #Wait for a specific duration
DSTATE_WAIT.Timestamp             #'DATE'[_DDPATH]
DSTATE_WAIT.Seconds               #NUM[_DDPATH]. Alternative to Timestamp

DSTATE.Type                       #'Task'. STATE is STATE_TASK
                                  #Om error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.TaskFailed': else
DSTATE_TASK.Resource              #'ARN'. Can be:
                                  #  - 'TASK_ARN'
                                  #  - 'FUNC_ARN': run Lambda FUNCTION, with INPUT|OUTPUT as REQ|RES
DSTATE_TASK.Credentials           #DCREDS, as DEXPR_OBJ
DCREDS.RoleArn                    #'ROLE_ARN' assumed by Resource
