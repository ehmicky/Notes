
                                  ┏━━━━━━━━━━━━━━━━━━━━┓
                                  ┃   STEP_FUNCTIONS   ┃
                                  ┗━━━━━━━━━━━━━━━━━━━━┛

VERSION ==>                       #2024-11-28

TODO:
  - CDK:
     - check new_services doc, CDK section
     - https://github.com/aws/aws-cdk/tree/main/packages/aws-cdk-lib/aws-stepfunctions
     - https://github.com/aws/aws-cdk/tree/main/packages/aws-cdk-lib/aws-stepfunctions-tasks
     - document which properties are supported by --hotswap
     - API Gateway:
        - StepFunctionsIntegration:
           - v1: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/lib/integrations/stepfunctions.ts
           - v2: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/lib/http/stepfunctions.ts
        - StepFunctionsRestApi: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/lib/stepfunctions-api.ts
        - https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/README.md#aws-stepfunctions-backed-apis
     - https://docs.aws.amazon.com/step-functions/latest/dg/tutorial-lambda-state-machine-cdk.html
     - https://docs.aws.amazon.com/step-functions/latest/dg/tutorial-step-functions-rest-api-integration-cdk.html
     - DCALL*.waitForAssertions() usage of MACHINE
     - Provider() usage of MACHINE
  - cdk-monitoring-constructs
     - check its section in new_services doc
  - SAM:
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-statemachine.html
        - RESPROP Policies: document like AWS::Serverless::Function, i.e. just refer to SAM_POLICIES
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification-generated-resources-statemachine.html
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-step-functions-in-sam.html
     - `aws cloudformation package` and `sam package` can be used with:
        - AWS::StepFunctions::StateMachine RESPROP DefinitionS3Location
        - AWS::Serverless::StateMachine RESPROP DefinitionUri
     - document that hot reloading is supported by `sam sync`
        - including part which documents that contents caching is done using MACHINE definition
     - move documentation about `sam remote invoke`
     - move documentation about AWS::Serverless::Connector
     - move POLICY_TEMPLATE doc from SAM transform doc
     - mention that SAM_POLICIES apply to AWS::Serverless::StateMachine RESPROP Policies too
     - see example of how to document this with AWS::Serverless::Function documentation in CloudWatch Logs
     - test locally using sam-translate binary
     - https://docs.aws.amazon.com/step-functions/latest/dg/concepts-sam-sfn.html
     - mention that Events.Api* can be done in Infrastructure Composer UI by linking API to MACHINE
  - https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html
     - already done:
        - Developing workflows:
           - Using Workflow studio
           - Create a state machine with CloudFormation
        - Starting state machines:
           - Redriving state machines
           - Redriving map runs
        - Processing input and output:
           - Map state input and output fields in Step Functions
        - Logging and monitoring
        - Service quotas
  - https://aws.amazon.com/step-functions/faqs
  - search GitHub for related projects
  - add summary
  - change description in new_services
  - compare with SWF
  - JSONata
  - remove resources related to Step Functions and CloudFormation from my AWS account

                                  ┌─────────┐
                                  │   API   │
                                  └─────────┘

NAME ==>                          #Sometimes abbreviated as SFN

SERVICE                           #'states'
SERVICE_DOMAIN                    #'[sync-]states.amazonaws.com'
                                  #'sync' is when using StartSyncExecution()

FORMAT ==>                        #JSON REQ|RES with REQ.Action|Version

PAGINATION ==>                    #Uses REQ.maxResults (def 100, max 1000) + REQ|RES.nextToken
                                  #ValidateStateMachineDefinition(): REQ.maxResults (def|max 100), no REQ|RES.nextToken, RES.truncated BOOL
                                  #No pagination: ListTagsForResource()
                                  #No pagination in SDK: ListStateMachineVersions|Aliases(), ValidateStateMachineDefinition()

EVENTUAL CONSISTENCY ==>          #Create|update|delete take up to a few minutes

                                  ┌─────────┐
                                  │   SDK   │
                                  └─────────┘

@aws-sdk/client-sfn               #

                                  ┌─────────┐
                                  │   CLI   │
                                  └─────────┘

aws stepfunctions ...             #

                                  ┌────────────────┐
                                  │   THROTTLING   │
                                  └────────────────┘

THROTTLING ==>                    #Per ACCOUNT + REGION
                                  #All soft. Many are REGION-specific
                                  #Following means RATE_LIMIT (burst BURST_LIMIT) (see token bucket algorithm doc)
                                  # 1/s (burst 0): TestState()
                                  # 1/s (burst 100):
                                  #   - Create*|Publish*|Update*|Delete*()
                                  #   - ValidateStateMachineDefinition()
                                  #   - ListStateMachineVersions|Aliases(), ListMapRuns(), ListTagsForResource()
                                  # 1/s (burst 200): Describe*(), [Un]tagResource()
                                  # 5/s (burst 100): ListStateMachines()
                                  # 5/s (burst 200): ListExecutions()
                                  # 10/s (burst 100): ListActivities()
                                  # 15/s (burst 300): DescribeExecution()
                                  # 20/s (burst 200): DescribeStateMachine()
                                  # 20/s (burst 400): GetExecutionHistory()
                                  # 200/s (burst 1000): StopExecution()
                                  # 300/s (burst 1300): RedriveExecution()
                                  # 500/s (burst 3000): GetActivityTask(), SendTask*()
                                  # 1300/s (burst 300): StartExecution()
                                  # None: StartSyncExecution()

                                  ┌────────────────────────┐
                                  │   THROTTLING METRICS   │
                                  └────────────────────────┘

AWS/States/ProvisionedRefillRate  #RATE_LIMIT
AWS/States/ProvisionedBucketSize  #BURST_LIMIT
AWS/States/ConsumedCapacity       #NUM of requests per second
AWS/States/ThrottledEvents        #NUM of throttled requests

DVAR APIName                      #'ACTION'. With above METRICs

                                  ┌─────────────┐
                                  │   PRICING   │
                                  └─────────────┘

PRICING ==>                       #Not Express: 1$ per 4e4 STATE_EXECs
                                  #  - free: 4e3
                                  #Express:
                                  #  - 1$ per 1e6 EXECs
                                  #  - 1$ per 1e6 EXECs with 1s duration and 64MB memory
                                  #     - proportional to duration
                                  #        - rounded up by 100ms per EXEC
                                  #        - 2x cheaper after 1000h, 4x after 5000h
                                  #     - proportional to memory
                                  #        - memory is sum of:
                                  #           - 50MB
                                  #           - DEFINITION
                                  #           - max(INPUT, OUTPUT)
                                  #           - for each child MACHINE run: max(INPUT, OUTPUT)
                                  #        - rounded up by 64MB per EXEC
                                  #  - "EXEC" is either top|child
                                  #     - i.e. include ITERs
                                  #ENCRYPT: no KMS charge if type 'AWS_OWNED_KEY'
                                  #Recommendations:
                                  #  - Express much cheaper
                                  #     - especially if STEPs are fast and use low memory
                                  #  - with Express, what matters more:
                                  #     - if <= 1s * 64MB: NUM of EXECs
                                  #     - else: duration and memory
                                  #  - Step Functions Express is roughly same price as Lambda
                                  #  - NUM of ITERs can multiply cost, for both Express and not
                                  #  - use BATCHs

EXEC.billingDetails               #EXEC_BILLING
EXEC_BILLING
 .billedDurationInMilliseconds    #NUM of ms charged, after rounding up
EXEC_BILLING.billedMemoryUsedInMB #NUM of MB charged, after rounding up

                                  ┌─────────────────────┐
                                  │   PRICING METRICS   │
                                  └─────────────────────┘

AWS/States/
 ExpressExecutionBilledDuration   #NUM of ms charged, after rounding up
AWS/States/ExpressExecutionMemory #NUM of MB charged, before rounding up
AWS/States/
 ExpressExecutionBilledMemory     #NUM of MB charged, after rounding up

DVAR StateMachineArn              #'MACHINE_ARN'. With above METRICs
                                  #MACHINE is also a TELEMETRY_ENTITY

                                  ┌──────────┐
                                  │   AUTH   │
                                  └──────────┘

AWSStepFunctionsFullAccess        #AWS managed POLICY. Allows all 'states:*' PACTIONs
AWSStepFunctionsConsoleFullAccess #Same but also allows:
                                  #  - iam:PassRole on ROLE 'service-role/StatesExecutionRole*'
                                  #  - iam:ListRoles
                                  #  - lambda:ListFunctions
                                  #Meant for browsing Step Functions UI
AWSStepFunctionsReadOnlyAccess    #Allows all read-only 'states:*' PACTIONs

                                  ┌─────────────┐
                                  │   MACHINE   │
                                  └─────────────┘

MACHINE                           #Creation is idempotent (if same REQ)
                                  #Update must specify at least either MACHINE.definition|roleArn (even if unchanged)
                                  #Delete aborts ongoing EXECs and wait for them to fail
                                  #Delete also delete VERSIONs|ALIASs
                                  #Max 1e4 (soft up to 2.5e4) per ACCOUNT
MACHINE.stateMachineArn           #In output: 'MACHINE_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:stateMachine:MACHINE'
                                  #In input: 'QUALIFIED_MACHINE_ARN'
MACHINE.name                      #'MACHINE'
                                  #Max 80 chars, [:alnum:]-_
MACHINE.creationDate              #DATE_NUM

MACHINE.status                    #'ACTIVE' or 'DELETING'

                                  ┌────────────────┐
                                  │   MACHINE UI   │
                                  └────────────────┘

WORKFLOW STUDIO ==>               #UI to view|edit a MACHINE, as a graph
                                  #Can create|deploy as a CloudFormation STACK

                                  ┌─────────────────┐
                                  │   MACHINE API   │
                                  └─────────────────┘

CreateStateMachine()              #Req: MACHINE + NEW_VERSION
                                  #  - no creationDate, label, status
                                  #  - no stateMachineArn
                                  #  - only one with tags
                                  #Res: VERSION
                                  #  - no updateDate, revisionId
UpdateStateMachine()              #Req: MACHINE + NEW_VERSION
                                  #  - no creationDate, label, status
                                  #  - no name, type
                                  #Res: VERSION
                                  #  - no stateMachineArn, creationDate
ListStateMachines()               #Req: empty
                                  #Res: stateMachines MACHINE_ARR
                                  #  - only stateMachineArn, name, creationDate, type
DescribeStateMachine()            #Req:
                                  #  - MACHINE: only stateMachineArn
                                  #  - MACHINE_GET
                                  #Res:
                                  #  - MACHINE
                                  #  - VERSION: no stateMachineVersionArn, updateDate
DescribeStateMachineForExecution()#Req:
                                  #  - [ITEM_]EXEC: only executionArn
                                  #  - MACHINE_GET
                                  #Res:
                                  #  - MACHINE: no creationDate, status, type
                                  #  - VERSION: no stateMachineVersionArn, description
                                  #  - ITEM_EXEC: only mapRunArn
DeleteStateMachine()              #Req: MACHINE
                                  #  - only stateMachineArn
                                  #Res: empty

                                  ┌─────────────────┐
                                  │   MACHINE IAC   │
                                  └─────────────────┘

AWS::StepFunctions::StateMachine  #RESPROPs: StateMachineName
                                  #RESATTRs: Arn, Name

new StateMachine
 (...CARGS, CMACHINE_OPTS)
 ->CMACHINE                       #
StateMachine.fromStateMachineArn
 (...CARGS, 'MACHINE_ARN')
 ->ICMACHINE                      #
StateMachine.fromStateMachineName
 (...CARGS, 'MACHINE')->ICMACHINE #

CMACHINE_OPTS.stateMachineName    #MACHINE.name
ICMACHINE.activityName            #'MACHINE'[_STR_TK]
ICMACHINE.activityArn             #'MACHINE_ARN'[_STR_TK]
CMACHINE_OPTS.removalPolicy       #Passed to CZRESOURCE.applyRemovalPolicy()
                                  #Def: RemovalPolicy.DESTROY

                                  ┌──────────────────────┐
                                  │   MACHINE COMPOSER   │
                                  └──────────────────────┘

MACHINE ENHANCED COMPONENT ==>    #Includes MACHINE + POLICYs
                                  #Can switch to Workflow studio
                                  #  - to edit MACHINE and its DEFINITION
                                  #  - a few features are missing when accessed this way

                                  ┌──────────────────┐
                                  │   MACHINE LINT   │
                                  └──────────────────┘

DIAG_ERROR
 STATE_MACHINE_NAME_EMPTY         #MACHINE.name must be set

DIAG_ERROR
 STATE_MACHINE_NAME_TOO_LONG      #MACHINE.name must be <= 80 chars

DIAG_ERROR
 STATE_MACHINE_NAME_INVALID       #MACHINE.name must be valid

DIAG_ERROR
 STATE_MACHINE_NAME_ALREADY_EXISTS#MACHINE with same name must not already exists

                                  ┌─────────────────────┐
                                  │   MACHINE TOOLKIT   │
                                  └─────────────────────┘

MACHINE CRUD ==>                  #Can be done in "Explorer"

                                  ┌──────────────────┐
                                  │   MACHINE ROLE   │
                                  └──────────────────┘

MACHINE|TEST_IN.roleArn           #'ROLE_ARN'. Required
                                  #Must be assumable by Principal.Service 'states.amazonaws.com'

EVENT_INFO.roleArn                #'ROLE_ARN'
                                  #With EVENT_TYPE ExecutionStarted

                                  ┌───────────────────────┐
                                  │   MACHINE ROLE AUTH   │
                                  └───────────────────────┘

PACTION iam:PassRole              #Must be allowed on current PRINCIPAL

                                  ┌─────────────────────┐
                                  │   MACHINE ROLE UI   │
                                  └─────────────────────┘

ROLE 'service-role
 /StatesExecutionRole*'           #Created by Workflow studio for common MACHINE.roleArn use cases

                                  ┌──────────────────────┐
                                  │   MACHINE ROLE IAC   │
                                  └──────────────────────┘

AWS::StepFunctions::StateMachine  #RESPROPs: RoleArn
                                  #MACHINE must DependsOn ROLE

CMACHINE[_OPTS].role              #ICROLE. MACHINE.roleArn
                                  #Def: new one assumable by Principal.Service 'states.amazonaws.com'
                                  #CMACHINE (not ICMACHINE) is YGRANTABLE|KGRANTABLE using this ROLE

ICMACHINE.grant
 (YGRANTABLE, 'PACTION',...)
 ->CGRANT                         #Allow PACTION on Resource MACHINE_ARN
ICMACHINE.grantRead(YGRANTABLE)   #Allows PACTIONs:
 ->CGRANT                         #  - states:ListStateMachines|ListExecutions on MACHINE
                                  #  - states:DescribeStateMachine|ListActivities on any MACHINE
                                  #  - states:Describe[StateMachineFor]Execution|GetExecutionHistory on any EXEC in this MACHINE
                                  #  - states:DescribeActivity on any ACTIVITY
ICMACHINE.grantRead(YGRANTABLE)
 ->CGRANT                         #See above

                                  ┌─────────────┐
                                  │   VERSION   │
                                  └─────────────┘

VERSION                           #Public immutable version of a MACHINE
                                  #Previous VERSIONs not automatically deleted
                                  #PublishStateMachineVersion() is idempotent (if same REQ)
                                  #Delete waits for ongoing EXECs to complete (and does not abort them)
                                  #Cannot delete if there is an associated ALIAS
                                  #Max 1e3 (soft) per MACHINE
VERSION.stateMachineVersionArn    #'VERSION_ARN'. 'MACHINE_ARN:VERSION_NUM'
VERSION_NUM                       #Automatically incremented by PublishStateMachineVersion(), starting at 1
                                  #Similar to a git commit `hash`
                                  #ListStateMachineVersions() sorts by it
VERSION.description
NEW_VERSION.versionDescription    #STR. Max 256 chars
VERSION.creationDate              #DATE_NUM
VERSION.updateDate                #DATE_NUM

VERSION.stateMachineArn           #'MACHINE_ARN'

NEW_VERSION.publish               #BOOL (def: false). Calls PublishStateMachineVersion()

VERSION.revisionId                #'REVISION_ID' (see aws_network doc)
                                  #Is 'INITIAL' after create, before first update

EVENT_INFO.stateMachineVersionArn #'VERSION_ARN'
                                  #With EVENT_TYPE ExecutionStarted

                                  ┌──────────────────┐
                                  │   VERSION AUTH   │
                                  └──────────────────┘

PACTION
 states:PublishStateMachineVersion#Required for NEW_VERSION.publish true

                                  ┌─────────────────┐
                                  │   VERSION API   │
                                  └─────────────────┘

PublishStateMachineVersion()      #Req: VERSION
                                  #  - no stateMachineVersionArn, *Date
                                  #  - only one with description
                                  #Res: VERSION
                                  #  - only stateMachineVersionArn, creationDate
ListStateMachineVersions()        #Req: MACHINE
                                  #  - only stateMachineArn
                                  #Res: stateMachineVersions VERSION_ARR
                                  #  - only stateMachineVersionArn, creationDate
DeleteStateMachineVersion()       #Req: VERSION
                                  #  - only stateMachineVersionArn
                                  #Res: empty
CreateStateMachine()
UpdateStateMachine()
DescribeStateMachine()            #Return VERSION too (see above)

                                  ┌─────────────────┐
                                  │   VERSION IAC   │
                                  └─────────────────┘

AWS::StepFunctions::              #RESPROPs:
 StateMachineVersion              #  - StateMachineArn, Description
                                  #  - StateMachineRevisionId
                                  #     - to create a new VERSION everytime MACHINE changes, can set to !GetAtt MACHINE.StateMachineRevisionId
                                  #     - to point to a fixed VERSION, set a specific REVISION_ID instead
                                  #RESATTRs: Arn
                                  #With Cloud Control, cannot update (replace only)

AWS::StepFunctions::StateMachine  #Includes RESATTR: StateMachineRevisionId

CMACHINE.stateMachineRevisionId   #'REVISION_ID'_CSATTR

                                  ┌─────────────────────┐
                                  │   VERSION METRICS   │
                                  └─────────────────────┘

AWS/States/VersionCount           #NUM of VERSIONs
                                  #DVAR ResourceArn 'VERSION_NUM'

DVAR Version                      #'VERSION_NUM'. With AWS/States/Execution*

                                  ┌───────────┐
                                  │   ALIAS   │
                                  └───────────┘

ALIAS                             #'ALIAS' pointing to a VERSION
                                  #Can change its target, similar to a git tag
                                  #Create|update is idempotent (if same REQ)
                                  #Delete does not delete any associated VERSION
                                  #Max 100 (soft) per MACHINE
ALIAS.stateMachineAliasArn        #'ALIAS_ARN'. 'MACHINE_ARN:ALIAS'
ALIAS.name                        #'ALIAS'
                                  #Should avoid being a 'NUM', to prevent confusion with 'VERSION_NUM'
                                  #Max 80 chars, [:alnum:]-_.
ALIAS.description                 #STR
                                  #Max 256 chars
ALIAS.creationDate                #DATE_NUM
ALIAS.updateDate                  #DATE_NUM

EVENT_INFO.stateMachineAliasArn   #'ALIAS_ARN'
                                  #With EVENT_TYPE ExecutionStarted

QUALIFIER                         #'VERSION_NUM|ALIAS'
QUALIFIED_MACHINE_ARN             #'MACHINE_ARN[:QUALIFIER]' (def: latest VERSION)

                                  ┌────────────────┐
                                  │   ALIAS AUTH   │
                                  └────────────────┘

COND_KEY                          #'VERSION_NUM|ALIAS'
 states:StateMachineQualifier     #Only with DeleteStateMachineVersion(), *Alias*(), DescribeStateMachine(),
                                  #Start[Sync]Execution|ListExecutions()

                                  ┌───────────────┐
                                  │   ALIAS API   │
                                  └───────────────┘

CreateStateMachineAlias()         #Req: ALIAS
                                  #  - no stateMachineAliasArn, *Date
                                  #Res: ALIAS
                                  #  - only stateMachineAliasArn, creationDate
UpdateStateMachineAlias()         #Req: ALIAS
                                  #  - no name, *Date
                                  #Res: ALIAS
                                  #  - only updateDate
ListStateMachineAliases()         #Req: MACHINE
                                  #  - only stateMachineArn
                                  #Res: stateMachineAliases ALIAS_ARR
                                  #  - only stateMachineAliasArn, creationDate
DescribeStateMachineAlias()       #Req: ALIAS
                                  #  - only stateMachineAliasArn
                                  #Res: ALIAS
DeleteStateMachineAlias()         #Req: ALIAS
                                  #  - only stateMachineAliasArn
                                  #Res: empty

                                  ┌───────────────┐
                                  │   ALIAS IAC   │
                                  └───────────────┘

AWS::StepFunctions::              #RESPROPs: Name, Description, RoutingConfiguration
 StateMachineAlias                #RESATTRs: Arn

                                  ┌───────────────────┐
                                  │   ALIAS METRICS   │
                                  └───────────────────┘

AWS/States/AliasCount             #NUM of ALIASs
                                  #DVAR ResourceArn 'ALIAS_ARN'

DVAR Alias                        #'ALIAS_ARN'. With AWS/States/Execution*

                                  ┌────────────────┐
                                  │   DEPLOYMENT   │
                                  └────────────────┘

ALIAS.routingConfiguration        #ALIAS_ROUTING_ARR. Randomly execute one of several VERSIONs
                                  #Min 1 item, max 2 items, i.e. meant for transitioning between 2 VERSIONs
ALIAS_ROUTING
 .stateMachineVersionArn          #'VERSION_ARN'
ALIAS_ROUTING.weight              #NUM. 0 to 100
                                  #Sum of all ALIAS_ROUTING.weight must be 100

ALIAS_DEPLOY                      #Alternative to ALIAS_ROUTING, which automates it
                                  #When ALIAS created, progressively shift traffic from previous VERSION to new one
                                  #Can only be set from IaC
ALIAS_DEPLOY
 .StateMachineVersionArn          #'VERSION_ARN'
ALIAS_DEPLOY.Type                 #How many increments to shift traffic:
                                  #  - 'ALL_AT_ONCE': 1
                                  #  - 'CANARY': 2
                                  #  - 'LINEAR': multiple
ALIAS_DEPLOY.Interval             #NUM (max 35h) of minutes between 2 increments
ALIAS_DEPLOY.Percentage           #1-99 percentage of traffic increase with each increment (except last one)
ALIAS_DEPLOY.Alarms               #CloudWatch 'ALARM'_ARR. Rollback if any has StateValue 'ALARM'
                                  #Max 100 items

                                  ┌────────────────────┐
                                  │   DEPLOYMENT IAC   │
                                  └────────────────────┘

AWS::StepFunctions::
 StateMachineAlias                #RESPROPs: DeploymentPreference ALIAS_DEPLOY

                                  ┌─────────────┐
                                  │   EXPRESS   │
                                  └─────────────┘

MACHINE.type                      #Either 'STANDARD' (def) or 'EXPRESS'
DMAP_CONF.ExecutionType           #Same but for child MACHINE

EXCLUSIVE FEATURES ==>            #Different pricing (see above), usually cheaper
                                  #  - including EXEC_BILLING and AWS/States/Express* METRICs
                                  #More scalable:
                                  #  - no max EXECs nor STATE_EXECs at once
                                  #  - less throttling on StartExecution(): 6000 (burst 6000)
                                  #StartSyncExecution()

MISSING FEATURES ==>              #DescribeStateMachineForExecution(), ListExecutions(), StopExecution()
                                  #DescribeExecution(): only with ITEM_EXEC, not EXEC
                                  #EVENT
                                  #REDRIVE
                                  #  - not for top-level EXECs: no RedriveExecution()
                                  #  - but can re-run failed ITERs by passing STATE_MAP_ARN to StartExecution()
                                  #     - however, already successful STATEs in a failed ITER are re-run
                                  #  - no ITEM_EXEC.redriveDate
                                  #ACTIVITY_TASK

DIFFERENCES ==>                   #Creating an EXEC is not idempotent
                                  #Def|max DMACHINE.TimeoutSeconds: 5m
                                  #Def MACHINE_LOGGING.level 'ERROR'

EXEC_ARN                          #'arn:aws:states:REGION:ACCOUNT_ID:express:MACHINE:EXEC:EXPRESS_MID'
ITEM_EXEC_ARN                     #'arn:aws:states:REGION:ACCOUNT_ID:express:MACHINE/STATE_MAP_LABEL:EXEC:EXPRESS_MID'

                                  ┌─────────────────┐
                                  │   EXPRESS IAC   │
                                  └─────────────────┘

AWS::StepFunctions::StateMachine  #Includes RESPROPs: StateMachineType

CMACHINE[_OPTS].stateMachineType  #MACHINE.type

                                  ┌────────────────┐
                                  │   DEFINITION   │
                                  └────────────────┘

MACHINE.definition                #DEFINITION. 'DMACHINE_JSON'
                                  #Format is ASL (Amazon States Language)
                                  #  - has a spec, i.e. abstract enough to have other implementors than Step Functions API
                                  #Max 1MB

D*                                #Fields in 'DMACHINE_JSON'
DMACHINE.Version                  #Always '1.0' (def)
                                  #Only for top-level MACHINE

DMACHINE.Comment                  #STR. Description

                                  ┌───────────────────┐
                                  │   DEFINITION UI   │
                                  └───────────────────┘

GRAPH ==>                         #UI shows DEFINITION as a graph
                                  #Can be exported as SVG|PNG

WORKFLOW STUDIO ==>               #Shows DEFINITION as a graph
                                  #Can be exported as SVG|PNG

                                  ┌────────────────────┐
                                  │   DEFINITION IAC   │
                                  └────────────────────┘

AWS::StepFunctions::StateMachine  #Include RESPROP either:
                                  #  - DefinitionString 'DMACHINE_JSON'
                                  #  - DefinitionS3Location OBJ: Bucket 'BUCKET', Key 'OBJECT', Version 'VERSION_MID'
                                  #     - contains 'DMACHINE_JSON' or 'DMACHINE_YAML'
                                  #     - can use `aws cloudformation package` or `sam package`
                                  #  - Definition DMACHINE_OBJ
                                  #  - DefinitionSubstitutions.KEY STR:
                                  #     - replace any '${KEY}' by STR
                                  #     - inside contents of Definition*

CMACHINE_OPTS
 .definitionSubstitutions         #OBJ. RESPROP DefinitionSubstitutions

CMACHINE_OPTS.definitionBody      #MACHINE.definition. Can be:
                                  #  - DefinitionBody.fromString('DMACHINE_JSON')
                                  #     - passed to RESPROP DefinitionString
                                  #  - DefinitionBody.fromFile('DEFINITION_PATH'[, HFOPTS])
                                  #     - uses a HFASSET
                                  #     - passed to RESPROP DefinitionS3Location
                                  #  - DefinitionBody.fromChainable(CCHAINABLE)
                                  #     - passed to RESPROP DefinitionString

CCHAINABLE:
  - tree starting at CSTATE and ending with 1|n CCHAINABLEs
  - CSTATE|CCHAIN|CFRAGMENT
  - for a single MACHINE, i.e. does not include child DMACHINEs from STATE_PARALLEL|MAP
CCHAINABLE.id 'CONSTRUCT'
CCHAINABLE.startState CSTATE
CCHAINABLE.endStates CCHAINABLE_ARR

CSTATE.startState is itself
CSTATE.endStates is:
  - if terminal (Succeed, Fail): none
  - if Choice: each CHOICE's endState if .afterwards(), none else
  - else: itself
CSTATE.next(CCHAINABLE)->CCHAIN
  - DSTATE.Next 'STATE2'
  - if not called: sets DSTATE.End true instead
  - only with: CustomState, Pass, Wait, Parallel, Map, others???
     - not with Succeed, Fail, Choice
CCHAIN|CFRAGMENT.next(CCHAINABLE)->CCHAIN2
  - CCHAIN|CFRAGMENT.endStates[*] = CCHAIN|CFRAGMENT.endStates[*].next(CCHAINABLE)

CCHAIN: tree of CSTATEs|CCHAINABLEs
Chain.*(...)->CCHAIN: set CCHAIN.startState, endStates, id
Chain.start(CCHAINABLE)->CCHAIN: CCHAINABLE.startState + CCHAINABLE.endStates + CCHAINABLE's 'CONSTRUCT'
Chain.sequence(CCHAINABLE, CCHAINABLE2)->CCHAIN: CCHAINABLE.startState + CCHAINABLE2.endStates + CCHAINABLE2's 'CONSTRUCT'
Chain.custom(CSTATE, CCHAINABLE_ARR, CCHAINABLE)->CCHAIN: CSTATE + CCHAINABLE_ARR + CCHAINABLE's 'CONSTRUCT'

CFRAGMENT: custom CCHAINABLE
  - must inherit from StateMachineFragment
  - constructor must set this.startState|endStates
CFRAGMENT.prefixStates([STR])->CFRAGMENT:
  - prepends STR to 'STATE' name on all CSTATEs deeply
  - using CFRAGMENT's CONSTRUCT tree
  - def STR: 'CONSTRUCT: '

State.findReachable[End]States(CSTATE[, OPTS])->CSTATE2_ARR
  - all DSTATE|DCHOICE.Next + DSTATE_CHOICE.Default
  - if OPTS.includeErrorHandlers true, also DCATCH.Next
  - if 'End', only terminal STATEs

Graph: internal not used directly
new Graph(CSTATE): add start CSTATE (DMACHINE.StartAt)
  - DefinitionBody.fromChainable() calls it for top-level GRAPH
  - STATE_PARALLEL|MAP adds one for each child DMACHINE
GRAPH.registerState(CSTATE): add a DSTATE
  - done automatically for each CSTATE
GRAPH.registerSuperGraph(PARENT_GRAPH): declare a child DMACHINE
  - done automatically by CSTATE.processor|iteration GRAPH and CSTATE.branches GRAPH_ARR
GRAPH.toGraphJSON() -> DMACHINE_OBJ
GRAPH.registerPolicyStatement(CSTATEMENT): allowed to MACHINE.roleArn

new State(...CARGS, CSTATE_OPTS)
  - base class not used directly
CSTATE_OPTS.stateName, CSTATE.stateId 'STATE' (def: 'CONSTRUCT' name)
CSTATE.toStateJson() -> DSTATE
CSTATE.validateState(): called at end of construction, for validation

CSTATE_OPTS.comment: DSTATE.Comment
  - only with Succeed, Fail, Pass, Wait, Choice, Parallel, Map, others???
     - not with CustomState

CSTATE_OPTS.inputPath: DSTATE.InputPath
  - only with Succeed, Pass, Choice, Parallel, Map, others???
     - not with CustomState, Fail, Wait

CSTATE_OPTS.parameters: DSTATE.Parameters
  - only with Pass, Parallel, Map, others???
     - not with CustomState, Succeed, Fail, Wait, Choice
  - can be a DOEXPR
     - not with Parallel, DISTRIBUTED Map

CSTATE_OPTS.outputPath: DSTATE.OutputPath
  - only with Succeed, Pass, Choice, Parallel, Map, others???
     - not with CustomState, Fail, Wait

CSTATE_OPTS.resultPath: DSTATE.ResultPath
  - only with Pass, Parallel, Map, others???
     - not with CustomState, Succeed, Fail, Pass, Wait, Choice

CSTATE_OPTS.resultSelector: DSTATE.ResultSelector
  - only with Parallel, Map, others???
     - not with CustomState, Succeed, Fail, Pass, Wait, Choice
  - can be a DOEXPR

CSTATE.addRetry(CRETRY_OPTS)->CSTATE
  - only with: CustomState, Parallel, Map, others???
CRETRY_OPTS.errors: DRETRY.ErrorEquals
  - def: ['States.ALL']
  - 'States.ALL' always at the end
  - can use Errors.ERROR_CODE (uppercase'd) for 'States.ERROR_CODE'
     - e.g. Errors.HEARTBEAT_TIMEOUT -> 'States.HeartbeatTimeout'
CRETRY_OPTS.maxAttemps: DRETRY.MaxAttempts
CRETRY_OPTS.interval: DURATION. DRETRY.IntervalSeconds
CRETRY_OPTS.backoffRate: DRETRY.BackoffRate
CRETRY_OPTS.jitterStrategy: DRETRY.JitterStrategy
CRETRY_OPTS.maxDelay: DURATION. DRETRY.MaxDelaySeconds

CSTATE.addCatch(CCHAINABLE[, CCATCH_OPTS])->CSTATE
  - only with: CustomState, Parallel, Map, others???
  - CCHAINABLE.startState is DCATCH.Next
CCATCH_OPTS.errors: DCATCH.ErrorEquals
  - rest is like CRETRY_OPTS.errors
CCATCH_OPTS.resultPath: DCATCH.ResultPath
Cannot set DCATCH.Comment|Output|Assign???

new CustomState(...CARGS, CCUSTOM_STATE_OPTS)
  - inherits from CSTATE
  - CSTATE with custom values
CCUSTOM_STATE_OPTS.stateJson DSTATE_OBJ

new Succeed(...CARGS[, CSUCCEED_OPTS])
  - inherits from CSTATE
  - STATE_SUCCEED
CSUCCEED_OPTS.*: CSTATE_OPTS.*

new Fail(...CARGS[, CFAIL_OPTS])
  - inherits from CSTATE
  - STATE_FAIL
CFAIL_OPTS.*: CSTATE_OPTS.*
CFAIL_OPTS.error[Path]|cause[Path]: DSTATE_FAIL.Error[Path]|Cause[Path]

new Pass(...CARGS[, CPASS_OPTS])
  - inherits from CSTATE
  - STATE_PASS
CPASS_OPTS.*: CSTATE_OPTS.*
CPASS_OPTS.result: DSTATE_PASS.Result
  - must be Result.fromString(STR), Result.fromNumber(NUM), Result.fromBoolean(BOOL), Result.fromObject(OBJ), Result.fromArray(ARR)

new Wait(...CARGS[, CWAIT_OPTS])
  - inherits from CSTATE
  - STATE_WAIT
CWAIT_OPTS.*: CSTATE_OPTS.*
CWAIT_OPTS.time:
  - DPASS.Seconds|Timestamp
  - must be one of:
     - WaitTime.timestamp('DATE')
     - WaitTime.duration(DURATION)
     - WaitTime.timestampPath('DATE'_CDZEXPR)
     - WaitTime.secondsPath(NUM_CDZEXPR)

new Choice(...CARGS[, CCHOICE_OPTS])
  - inherits from CSTATE
  - STATE_CHOICE
CCHOICE_OPTS.*: CSTATE_OPTS.*
CCHOICE.otherwise(CCHAINABLE)->CCHOICE: DSTATE_CHOICE.Default
CCHOICE.when(CCOND, CCHAINABLE[, OPTS])->CCHOICE: DCHOICE: Next, Comment (OPTS.Comment), DCOND
Condition.not(CCOND)->CCOND2: DCOND.Not
Condition.and|or(CCOND,...)->CCOND2: DCOND.And|Or
Condition.is[Not]*(CDSEXPR)->CCOND: DCOND.Variable + DCOND.Is* true|false
Condition.*Equals|Than(CDSEXPR, VAL)->CCOND: DCOND.Variable + DCOND.*Equals|Than
Condition.*Equals|ThanJsonPath(CDSEXPR, CDZEXPR)->CCOND: DCOND.Variable + DCOND.*Equals|Than
Condition.stringMatches(CDSEXPR, STR)->CCOND: DCOND.Variable + DCOND.StringMatches
CCHOICE.afterwards([OPTS])->CCHAIN
  - endStates are of the ones of DSTATE_CHOICE.Default + every DCHOICE
     - except ones without possible DSTATE.Next
  - OPTS.includeErrorHandlers BOOL (def: false): include DCATCH.Next
  - OPTS.includeOtherwise BOOL (def: false): when CCHAIN.next(CCHAINABLE) called, adds a DSTATE_CHOICE.Default CCHAINABLE
     - not if DSTATE_CHOICE.Default already exists

new Parallel(...CARGS[, CPARALLEL_OPTS])
  - inherits from CSTATE
  - STATE_PARALLEL
CPARALLEL_OPTS.*: CSTATE_OPTS.*
CPARALLEL.branch(CCHAINABLE,...)->CPARALLEL: DSTATE_PARALLEL.Branches
CCHAIN.toSingleState(...CARGS[, CPARALLEL_OPTS])->CPARALLEL: turn into a DSTATE_PARALLEL with a single branch
CFRAGMENT.toSingleState(...CARGS[, CPARALLEL_OPTS])->CPARALLEL: same but also calls CFRAGMENT.prefixStates([CPARALLEL_OPTS.prefixStates])

new [Distributed]Map(...CARGS[, CMAP_OPTS])
  - inherits from CSTATE
  - STATE_MAP
  - Map|DistributedMap uses DMAP_CONF.Mode 'INLINE|DISTRIBUTED'
  - allows to MACHINE.roleArn PACTIONs:???
     - states:StartExecution on Resource MACHINE_ARN
     - states:DescribeExection|StopExecution on Resource MACHINE_ARN:* (i.e. any EXEC in MACHINE)
CMAP_OPTS.*: CSTATE_OPTS.*
CMAP.itemProcessor(CCHAINABLE)->CMAP: DSTATE_MAP.ItemProcessor
CMAP_OPTS.mapExecutionType: DMAP_CONF.ExecutionType
CMAP_OPTS.maxConcurrency|toleratedFailurePercentage|toleratedFailureCount|label: DSTATE_MAP.*
CMAP_OPTS.maxConcurrencyPath|itemsPath|toleratedFailurePercentagePath|toleratedCountPath CDZEXPR: DSTATE_MAP.*
CMAP_OPTS.itemSelector CDOEXPR: DSTATE_MAP.ItemSelector
CMAP_OPTS.resultWriter new ResultWriter(OPTS): DSTATE_MAP.ResultWriter
  OPTS.bucket ICBUCKET: DWRITER_PARAMS.Bucket
    - ICBUCKET.bucketName can be CDFEXPR
  OPTS.prefix STR|CDFEXPR: DWRITER_PARAMS.Prefix
  Automatically allows right PACTIONs as described above
CMAP_OPTS.itemReader: DREADER. One of:
  - new S3ObjectsItemReader(OPTS)
      OPTS.prefix STR: DREADER_PARAMS.*
      Automatically allows PACTIONs described as above except:
        - no COND_KEY s3:prefix
        - Resource '*' if OPTS.bucketNamePath (instead of OPTS.bucket)
  - new S3Json|CSV|ManifestItemReader(OPTS)
      OPTS.key STR: DREADER_PARAMS.*
      OPTS.csvHeaders: DREADER_CONF.CSV* among:
        CsvHeaders.useFirstRow()
        CsvHeaders.use('KEY'_ARR)
      Automatically allows PACTIONs described as above except:
       - Resource 'BUCKET_ARN:*'
  - both:
      OPTS.bucket ICBUCKET or OPTS.bucketNamePath 'BUCKET': DREADER_PARAMS.Bucket
      OPTS.maxItems STR|DZEXPR: DREADER_CONF.MaxItems
CMAP_OPTS.itemBatcher: DBATCH. new ItemBatcher(OPTS)
  OPTS.max*|batchInput: DBATCH.*
  OPTS.max*Path CDZEXPR: DBATCH.*

JsonPath|Data|Context.*:
  - CD*EXPR
  - returned as a STR_TK
  - resolved as 'DSEXPR|DZEXPR|DFEXPR'
  - can be in an OBJ, for DOEXPR
     - automatically appends the key with '.$'
     - must use FieldUtils.renderObject(OBJ)->OBJ internally

FieldUtils.containsTaskToken(OBJ)->BOOL
  - used only internally, to validate that OBJ contains '$$.Task.Token', when using SERVICE_TASK_PATTERN waitForTaskToken

JsonPath.DISCARD: null, i.e. no JSONPath

Data.stringAt('DSEXPR')
JsonPath.stringAt('DFEXPR')
Context.stringAt('$$...')

Data.numberAt('DSEXPR')
JsonPath.numberAt('DFEXPR')
Context.numberAt('$$...')
Data|JsonPath.listAt('DSEXPR')
JsonPath.objectAt('DFEXPR')
  - same but as NUM_TK, ARR_TK, RV
  - see JsonPath.DFUNC() for purpose

JsonPath|Data.entirePayload: '$'
JsonPath|Context.entireContext: '$$'

JsonPath.execution*: '$$.Execution.*' (no Redrive*)
JsonPath.state*: '$$.State.*'
JsonPath.stateMachine*: '$$.StateMachine.*'
JsonPath|Context.taskToken: '$$.Task.Token'

JsonPath.DFUNC(ARG,...): 'States.DFUNC(...)'
  - DFUNC is camelCase'd
  - ARG can be:
     - a CD*EXPR
        - if ARG is NUM|ARR|OBJ, must use numberAt|listAt|objectAt(...) (see above)
     - a direct value
        - only for NUM|STR, not ARR|OBJ|BOOL
        - if STR, automatically escapes it

JsonPath.isEncodedJsonPath(STR)->BOOL: if is a CD*EXPR that is a STR_TK
Data.isJsonPathString(STR)->BOOL: same

CMACHINE_OPTS.comment             #DMACHINE.Comment
                                  #Must use DefinitionBody.fromChainable()

Still to do:
  - each STATE in https://github.com/aws/aws-cdk/tree/main/packages/aws-cdk-lib/aws-stepfunctions/lib/states
  - https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-stepfunctions/lib/input.ts
  - https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-stepfunctions/lib/task-credentials.ts
  - https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-stepfunctions/lib/state-transition-metrics.ts

                                  ┌─────────────────────────┐
                                  │   DEFINITION COMPOSER   │
                                  └─────────────────────────┘

MACHINE ENHANCED COMPONENT ==>    #Can use external file for AWS::Serverless::StateMachine RESPROP DefinitionUri

                                  ┌─────────────────────┐
                                  │   DEFINITION LINT   │
                                  └─────────────────────┘

DIAG_ERROR
 INVALID_JSON_DESCRIPTION
statelint                         #DEFINITION must be valid JSON

DIAG_ERROR MISSING_DESCRIPTION    #DEFINITION must not be empty

DIAG_ERROR
 SCHEMA_VALIDATION_FAILED
statelint                         #DEFINITION must have no syntax error

cfn-lint E3601                    #DEFINITION must have no syntax error
                                  #Works with DefinitionSubstitutions

                                  ┌────────────────────────┐
                                  │   DEFINITION TOOLKIT   │
                                  └────────────────────────┘

DOWNLOAD DEFINITION ==>           #Can be done in "Explorer"

DEFINITION TEMPLATES ==>          #Can be used for scaffolding either full DEFINITION or small parts ("snippets")

                                  ┌───────────────────┐
                                  │   GRAPH TOOLKIT   │
                                  └───────────────────┘

VISUALIZE DEFINITION ==>          #Can visualize DEFINITION as a graph

                                  ┌──────────────┐
                                  │   VALIDATE   │
                                  └──────────────┘

VALIDATE_REQ                      #Validate DEFINITION for syntax errors
VALIDATE_REQ.definition|type      #MACHINE.*
VALIDATE_REQ.diagnostic           #Minimum DIAG.severity (def: 'ERROR', i.e. no WARNINGs)

VALIDATE_RES.result               #'OK' or 'FAIL'. Whether any DIAG with severity 'ERROR'

VALIDATE_RES.diagnostics          #DIAG_ARR. Paginated
                                  #'CODE|MESSAGE' might change in the future, i.e. should not rely on current list
                                  #The full list is documented in this doc
DIAG.code                         #'DIAG_CODE'
DIAG.message                      #'MESSAGE'
DIAG.severity                     #Either:
                                  #  - 'ERROR': prevents Create|UpdateStateMachine()
                                  #  - 'WARNING': does not prevent Create|UpdateStateMachine()
DIAG.location                     #STR. VAR's location, as JSON pointer, e.g. '/States/STATE/Output'

                                  ┌──────────────────┐
                                  │   VALIDATE API   │
                                  └──────────────────┘

ValidateStateMachineDefinition()  #Req: VALIDATE_REQ
                                  #Res: VALIDATE_RES

                                  ┌──────────┐
                                  │   LINT   │
                                  └──────────┘

statelint PATH ...                #Validate DEFINITION files
                                  #Compared to ValidateStateMachineDefinition(), pros:
                                  #  - run locally, no API calls
                                  #Cons:
                                  #  - might be less well maintained
                                  #  - installed with Ruby
                                  #Their checks overlap, but they each some unique ones
                                  #I.e. should use both
                                  #Version 0.8 (2024-11-21)

                                  ┌─────────────┐
                                  │   LINT UI   │
                                  └─────────────┘

WORKFLOW STUDIO ==>               #Lints, autocompletes and prettifies

                                  ┌──────────────────┐
                                  │   LINT TOOLKIT   │
                                  └──────────────────┘

LINTING ==>                       #Lints, autocompletes and prettifies

                                  ┌───────────────┐
                                  │   EXECUTION   │
                                  └───────────────┘

EXEC                              #Execution of a MACHINE
                                  #Create is idempotent (if same REQ and another is ongoing)
                                  #EXECs at once: max 1e6 (soft) per ACCOUNT + REGION
                                  #  - else throw ERROR_CODE 'States.ExecutionLimitExceeded'
EXEC.executionArn                 #'EXEC_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:execution:MACHINE:EXEC'
EXEC.name                         #'EXEC' (def: random UUID)
                                  #Max 80 chars, [:alnum:]-_
EXEC.startDate                    #DATE_NUM
EXEC.stopDate                     #DATE_NUM

EXEC.stateMachineArn              #In input: 'QUALIFIED_MACHINE_ARN'
                                  #In output: 'MACHINE_ARN'
EXEC.stateMachineVersionArn       #'VERSION_ARN' (if specified)
EXEC.stateMachineAliasArn         #'ALIAS_ARN' (if specified)

SYNC EXECUTION ==>                #When using StartSyncExecution()
                                  #Similar to StartExecution() + waiting for completion + returning DescribeExecution()
                                  #EXEC.stateMachineArn must be 'MACHINE_ARN', not 'QUALIFIED_MACHINE_ARN'
                                  #Not logged by CloudTrail

EXEC.status                       #One of:
                                  #  - PENDING_REDRIVE
                                  #  - RUNNING
                                  #  - SUCCEEDED
                                  #  - FAILED
                                  #  - TIMED_OUT
                                  #  - ABORTED: StopExecution()

EVENT_TYPE ExecutionStarted
EVENT_TYPE ExecutionSucceeded
EVENT_TYPE ExecutionFailed
EVENT_TYPE ExecutionAborted       #On EXEC start|end

API GATEWAY ==>                   #Can use first-class integration (see its doc) for Start[Sync]Execution|StopExecution()

                                  ┌──────────────────┐
                                  │   EXECUTION UI   │
                                  └──────────────────┘

WORKFLOW STUDIO ==>               #Can start an EXEC
                                  #Not when accessed from Infrastructure Composer

                                  ┌───────────────────┐
                                  │   EXECUTION API   │
                                  └───────────────────┘

StartExecution()                  #Req: EXEC
                                  #  - only stateMachineArn, name, input, traceHeader
                                  #Res: EXEC
                                  #  - only executionArn, startDate
StartSyncExecution()              #Req:
                                  #  - EXEC: only stateMachineArn, name, input, traceHeader
                                  #  - EXEC_GET
                                  #Res: EXEC
                                  #  - no mapRunArn, redrive*, stateMachineVersionArn|stateMachineAliasArn
                                  #  - only one with billingDetails
ListExecutions()                  #Req: [ITEM_]EXEC
                                  #  - only either EXEC.stateMachineArn or ITEM_EXEC.mapRunArn
                                  #  - only status -> statusFilter
                                  #  - only one with redriveFilter
                                  #Res: executions [ITEM_]EXEC_ARR
                                  #  - no cause, error, input*|output*, redriveStatus[Reason], traceHeader
                                  #  - only one with itemCount
DescribeExecution()               #Req:
                                  #  - [ITEM_]EXEC: only executionArn
                                  #  - EXEC_GET
                                  #Res: [ITEM_]EXEC
StopExecution()                   #Req: [ITEM_]EXEC
                                  #  - only executionArn, cause, error
                                  #Res: [ITEM_]EXEC
                                  #  - only stopDate

                                  ┌───────────────────┐
                                  │   EXECUTION IAC   │
                                  └───────────────────┘

ICMACHINE.grantExecution
 (YGRANTABLE, 'PACTION',...)      #Allows PACTION on any EXEC in this MACHINE
 ->CGRANT                         #I.e. Resource 'arn:aws:states:REGION:ACCOUNT_ID:execution:MACHINE:*'

ICMACHINE
 .grantStart[Sync]Execution
 (YGRANTABLE)->CGRANT             #Allows PACTION 'states:Start[Sync]Execution' to MACHINE
ICMACHINE.grantRead(YGRANTABLE)
 ->CGRANT                         #See above

                                  ┌───────────────────┐
                                  │   EXECUTION SAM   │
                                  └───────────────────┘

StepFunctionsExecutionPolicy_v2   #SAM POLICY_TEMPLATE (see its doc) that allows:
                                  #  - PACTION states:Start[Sync]Execution
                                  #  - on 'MACHINE'
                                  #     - using POLICY_TEMPLATE_PARAMS.StateMachineName

AWS::Serverless::Connector        #Can be used with:
                                  #  - Source: Lambda FUNCTION (RESOURCE_REF.RoleName)
                                  #  - Destination: MACHINE (RESOURCE_REF.Arn + RESOURCE_REF.Name)
                                  #  - Permissions 'Read' and|or 'Write'
                                  #Transformed to a MPOLICY on 'ROLE':
                                  #  - allowing on MACHINE (from Arn):
                                  #     - Read: states:ListExecutions|DescribeStateMachine
                                  #     - Write: states:Start[Sync]Execution
                                  #  - allowing on EXECUTION/* (from Name):
                                  #     - Read: states:DescribeExecution|DescribeStateMachineForExecution|GetExecutionHistory
                                  #     - Write: states:StopExecution

                                  ┌───────────────────────┐
                                  │   EXECUTION METRICS   │
                                  └───────────────────────┘

AWS/States/ExecutionTime          #EXEC duration (in ms)
AWS/States/ExecutionsStarted      #NUM of EXEC starts
AWS/States/ExecutionsSucceeded    #NUM of EXEC success
AWS/States/ExecutionsAborted      #NUM of EXEC aborted
AWS/States/ExecutionsFailed       #NUM of EXEC failed

AWS/States/OpenExecutionCount     #NUM of ongoing EXECs
                                  #Very approximate, e.g. if <1e4, might show 0
                                  #  - i.e. should use STAT 'Maximum'
AWS/States/OpenExecutionLimit     #Max allowed NUM of ongoing EXECs

DVAR StateMachineArn              #'MACHINE_ARN'. With above METRICs
                                  #MACHINE is also a TELEMETRY_ENTITY

                                  ┌───────────────────────────┐
                                  │   EXECUTION METRICS IAC   │
                                  └───────────────────────────┘

ICMACHINE.metric
 ('METRIC'[, CMETRIC_OPTS])
 ->CMETRIC                        #Sets DVAR StateMachineArn, statistic 'Sum'
ICMACHINE.metricMETRIC            #Same except 'METRIC' omits 'Execution' prefix, e.g. CACTIVITY.metricTime()
 ([CMETRIC_OPTS])->CMETRIC        #Also uses statistic 'Average' for ExecutionTime

                                  ┌───────────────────────┐
                                  │   EXECUTION TOOLKIT   │
                                  └───────────────────────┘

START EXECUTION ==>               #Can be done in "Explorer"

                                  ┌────────────┐
                                  │   EVENTS   │
                                  └────────────┘

EVENTS_REQ                        #Paginated
EVENTS_REQ.executionArn           #'[ITEM_]EXEC_ARN'

EVENT                             #Part of an EXEC, mostly lifecycle of STATEs
                                  #Max 2.5e4 EVENTs per [ITEM_]EXEC
                                  #Only for last 90 days
EVENT.id                          #EVENT_MID. Serial NUM
                                  #Initial implied EVENT_MID is 0
EVENT.previousEventId             #EVENT_MID, if any

EVENT.timestamp                   #DATE_NUM
EVENTS_REQ.reverseOrder           #BOOL. If false (def), oldest first

EVENT.type                        #'EVENT_TYPE' (PascalCase)
                                  #Available ones documented in this doc
EVENT.EVENT_TYPEEventDetails      #EVENT_TYPE-specific EVENT_INFO
                                  #EVENT_TYPE is camelCase
                                  #EVENT_TYPE STATE_TYPEStateEntered|StateExited -> stateEntered|stateExited
                                  #undefined with some EVENT_TYPEs

                                  ┌────────────────┐
                                  │   EVENTS API   │
                                  └────────────────┘

GetExecutionHistory()             #Req: EVENTS_REQ
                                  #Res: events EVENT_ARR

                                  ┌────────────────┐
                                  │   EVENTS IAC   │
                                  └────────────────┘

ICMACHINE.grantRead(YGRANTABLE)
 ->CGRANT                         #See above

                                  ┌───────────┐
                                  │   DEBUG   │
                                  └───────────┘

TEST_IN                           #Executes a single STATE, for debugging purpose
                                  #Does not support:
                                  #  - STATE_MAP, STATE_PARALLEL
                                  #  - ACTIVITY
                                  #  - SERVICE_CALLBACK_TASK, SERVICE_SYNC_TASK

TEST_IN.inspectionLevel           #Fields to omit in TEST_OUT.*. One of:
                                  #  - 'TRACE': none
                                  #  - 'DEBUG': TEST_DATA.request|response
                                  #  - 'INFO' (def): TEST_DATA.*
TEST_OUT.inspectionData           #TEST_DATA

TEST_OUT.status                   #One of:
                                  #  - 'SUCCEEDED': no ERROR
                                  #  - 'RETRIABLE': ERROR but would RETRY
                                  #  - 'CAUGHT_ERROR': ERROR but caught
                                  #  - 'FAILED': other ERROR

                                  ┌──────────────┐
                                  │   DEBUG UI   │
                                  └──────────────┘

WORKFLOW STUDIO ==>               #Can start a TEST_IN
                                  #Not when accessed from Infrastructure Composer

                                  ┌───────────────┐
                                  │   DEBUG API   │
                                  └───────────────┘

TestState()                       #Req: TEST_IN
                                  #Res: TEST_OUT

                                  ┌───────────┐
                                  │   INPUT   │
                                  └───────────┘

EXEC.input                        #Initial 'INPUT_JSON' (def: '{}')
TEST_IN|TEST_DATA|ACTIVITY_TASK
 .input                           #State 'INPUT_JSON' (def: '{}')

INPUT                             #VAL passed to each STATE
                                  #INPUT to first STATE is EXEC.input
                                  #INPUT to other STATEs is previous STATE's OUTPUT
                                  #JSON types only
                                  #Max 256KB (else throw ERROR_CODE 'States.DataLimitExceeded')

TRANSFORM INPUT ==>               #By default, INPUT is kept as is

DSTATE.Arguments                 %#DOEXPR (def: keep as is). Transforms INPUT
                                 %#Only with STATE_TASK|MAP|PARALLEL
$states.input                    %#INPUT
TEST_DATA.afterArguments         %#'INPUT_JSON' after DSTATE.Arguments

DSTATE.InputPath                 $#DSEXPR. Transforms INPUT
                                 $#null is same as empty OBJ
                                 $#Not with STATE_FAIL
DSTATE.Parameters                $#DOEXPR. Transforms INPUT
                                 $#Done after InputPath
                                 $#Throws ERROR_CODE 'States.ParameterPathFailure' if some DSEXPR does not match
                                 $#Only with STATE_TASK|PARALLEL|PASS
TEST_DATA
 .afterInputPath|afterParameters $#'INPUT_JSON' after DSTATE.InputPath|Parameters

EVENT_INFO.input                  #'INPUT_JSON'
                                  #With EVENT_TYPEs:
                                  #  - ExecutionStarted
                                  #  - STATE_TYPEStateEntered
                                  #  - LambdaFunctionScheduled
                                  #  - ActivityScheduled
EVENTS_REQ.includeExecutionData   #BOOL (def: true). If false, do not set EVENT_INFO.input*|output*

                                  ┌────────────┐
                                  │   OUTPUT   │
                                  └────────────┘

OUTPUT                            #VAL (def: INPUT) returned by each STATE
                                  #OUTPUT from final STATE is EXEC's output
                                  #JSON types only
                                  #Max 256KB (else throw ERROR_CODE 'States.DataLimitExceeded')

TRANSFORM OUTPUT ==>              #By default, OUTPUT is kept as is

DSTATE.Output                    %#DOEXPR (def: keep as is). Transforms OUTPUT
                                 %#Not with STATE_FAIL
$states.result                   %#OUTPUT
                                 %#Only in DSTATE.Output|Assign
                                 %#Only with STATE_TASK|MAP|PARALLEL

DSTATE.ResultSelector            $#DOEXPR. Transforms OUTPUT
                                 $#Only with STATE_TASK|MAP|PARALLEL
DSTATE.ResultPath                $#DZEXPR. Sets OUTPUT as {...INPUT, DZEXPR: OUTPUT}
                                 $#If INPUT.DZEXPR already exists, overrides it
                                 $#null sets OUTPUT as {...INPUT}
                                 $#Cannot use CONTEXT nor $DVAR
                                 $#Done after ResultSelector
                                 $#Throws ERROR_CODE 'States.ResultPathMatchFailure' if some DSEXPR does not match
                                 $#Only with STATE_TASK|MAP|PARALLEL|PASS
DSTATE.OutputPath                $#DSEXPR. Transforms OUTPUT
                                 $#null is same as empty OBJ
                                 $#Done after ResultPath
                                 $#Not with STATE_FAIL
TEST_DATA.afterResultSelector
 |afterResultPath                $#'OUTPUT_JSON' after DSTATE.ResultSelector|ResultPath

TEST_DATA.result                  #'OUTPUT_JSON' before DSTATE.Output|ResultSelector

EXEC.output                       #Final 'OUTPUT_JSON'. Not if ERROR_OUTPUT
TEST_OUT|ACTIVITY_TASK.output     #State 'OUTPUT_JSON'. Not if ERROR_OUTPUT

EVENT_INFO.output                 #'OUTPUT_JSON'
                                  #With EVENT_TYPEs:
                                  #  - ExecutionSucceeded
                                  #  - STATE_TYPEStateExited
                                  #  - LambdaFunctionSucceeded
                                  #  - ActivitySucceeded
                                  #  - TaskSubmitted, TaskSucceeded
EVENTS_REQ.includeExecutionData   #BOOL (def: true). If false, do not set EVENT_INFO.input*|output*

                                  ┌─────────────┐
                                  │   CONTEXT   │
                                  └─────────────┘

CONTEXT                           #'OBJ_JSON' passed to each STATE
                                  #Set by caller, for a given EXEC

$states.context                  %#CONTEXT
$$...                            $#Like $... but root value is CONTEXT instead

                                  ┌───────────────┐
                                  │   VARIABLES   │
                                  └───────────────┘

DSTATE.Assign.DVAR                #VAL. "State machine variable"
                                  #Sets $DVAR in any later STATE (not current STATE)
                                  #Can only reference $DVAR inside JSONPath|JSONata
                                 %#$DVAR cannot be set inside a query
                                 %#Other variables assigned inside a query ($VAR := VAL) can only be used inside that query
                                  #Child MACHINEs:
                                  #  - have their own DVAR scope
                                  #  - can use upper scope's DVARs, but not set them
                                  #  - cannot use lower|sibling scopes' DVARs
                                  #DVAR:
                                  #  - max 80 chars
                                  #  - ID_Continue: letters-like, numbers-like, _, diacretics, U+200C U+200D (zero-width space)
                                  #  - first char: ID_Start: letters-like
                                  #Not with STATE_SUCCEED|FAIL

TEST_IN.variables                 #Initial '{DVAR: VAL,...}_JSON'
TEST_DATA.variables               #Final '{DVAR: VAL,...}_JSON'

EVENT_INFO.assignedVariables.DVAR #'VAL'
                                  #With EVENT_TYPE STATE_TYPEStateExited

MACHINE.variableReferences.STATE  #'DVAR'_ARR used by this STATE
                                  #If none, undefined (not empty ARR)

                                  ┌───────────┐
                                  │   STATE   │
                                  └───────────┘

TEST_IN.definition                #'DSTATE_JSON'
                                  #Max 1MB

DMACHINE.States.STATE             #DSTATE. Like `case` in a `switch` statement
                                  #Parent|child|siblings MACHINEs cannot reuse same 'STATE' name
                                  #'STATE' name max 80 chars
                                  #Required

DSTATE.Type                       #'STATE_TYPE'. Required
DSTATE_*.*                        #STATE_TYPE-specific, e.g. DSTATE_CHOICE.Default

DSTATE.Comment                    #STR. Description

                                  ┌──────────────┐
                                  │   STATE UI   │
                                  └──────────────┘

WORKFLOW STUDIO ==>               #Can view|edit STATEs

                                  ┌────────────────┐
                                  │   STATE LINT   │
                                  └────────────────┘

DIAG_ERROR DUPLICATE_STATE_NAME
statelint                         #Child STATEs must not reuse same names

DIAG_ERROR INVALID_STATE_NAME     #'STATE' name must be valid

                                  ┌──────────┐
                                  │   FLOW   │
                                  └──────────┘

DMACHINE.StartAt                  #'STATE'. First STATE
                                  #Required

DSTATE.Next                       #'STATE'. Next STATE
                                  #Cannot target a 'STATE' in parent|child MACHINEs
                                  #Not with STATE_PASS|FAIL|CHOICE, or if DSTATE.End true. Required otherwise
TEST_OUT.nextState                #'STATE' or undefined

DSTATE.Type                       #'Succeed'. STATE is STATE_SUCCEED
                                  #End MACHINE successfully
                                  #Continue parent MACHINEs

DSTATE.End                        #BOOL (def: false). If true, same as using DSTATE.Next towards STATE_SUCCEED except:
                                  #  - pro: cheaper since no additional STATE
                                  #  - con: no conditional logic, i.e. not on DCHOICE.*
                                  #Not with STATE_CHOICE|SUCCEED|FAIL
                                  #Together with STATE_SUCCEED|FAIL, called "terminal STATE" (of a MACHINE)

EVENT_TYPE STATE_TYPEStateEntered #On STATE start
EVENT_TYPE STATE_TYPEStateExited  #On STATE success
                                  #Not with STATE_FAIL
EVENT_INFO.name                   #'STATE' name
                                  #With EVENT_TYPEs STATE_TYPEStateEntered|Exited

STATE_EXEC                        #Starting executing a STATE
                                  #Each RETRY counts as 1 STATE_EXEC
                                  #Each ITER has its own count of STATE_EXECs
                                  #Max 5e3/s RATE_LIMIT, 5e3 BURST_LIMIT (REGION-specific, soft) (see token bucket algorithm doc) per ACCOUNT + REGION

                                  ┌──────────────────┐
                                  │   FLOW METRICS   │
                                  └──────────────────┘

AWS/States/ExecutionThrottled     #NUM of throttled STATE_EXECs

DVAR StateMachineArn              #'MACHINE_ARN'. With above METRIC
                                  #MACHINE is also a TELEMETRY_ENTITY

AWS/States/ProvisionedRefillRate
AWS/States/ProvisionedBucketSize
AWS/States/ConsumedCapacity
AWS/States/ThrottledEvents        #Same as above

DVAR ServiceMetric                #Must be 'true' with the above 4 METRICs to show STATE_EXEC throttling

                                  ┌──────────────────────┐
                                  │   FLOW METRICS IAC   │
                                  └──────────────────────┘

ICMACHINE.metricThrottled
 ([CMETRIC_OPTS])->CMETRIC        #Sets DVAR StateMachineArn, statistic 'Sum'

                                  ┌───────────────┐
                                  │   FLOW LINT   │
                                  └───────────────┘

DIAG_ERROR
 MISSING_TRANSITION_TARGET
statelint                         #DSTATE.Next must point to existing 'STATE'

statelint                         #Every 'STATE' must be a target for a transition from another one

DIAG_ERROR MISSING_END_STATE
statelint                         #>= 1 terminal STATE

                                  ┌────────────┐
                                  │   CHOICE   │
                                  └────────────┘

DSTATE.Type                       #'Choice'. STATE is STATE_CHOICE
                                  #Like a `switch` statement

DSTATE_CHOICE.Default             #'STATE'
                                  #Def: throw ERROR_CODE 'States.NoChoiceMatched'

DSTATE_CHOICE.Choices             #DCHOICE_ARR
                                  #Cannot be empty
DCHOICE.Comment                   #STR. Description
DCHOICE.Next                      #Like DSTATE.Next. Required

DCHOICE.Assign                    #Like DSTATE_CHOICE.Assign
                                  #DSTATE_CHOICE.Assign is not used if any DCHOICE matches (even if it has no DCHOICE.Assign)

                                  ┌─────────────────┐
                                  │   CHOICE LINT   │
                                  └─────────────────┘

DIAG_ERROR
 MISSING_TRANSITION_TARGET
statelint                         #DSTATE_CHOICE.Default and DCHOICE.Next must point to existing 'STATE'

                                  ┌───────────────┐
                                  │   CONDITION   │
                                  └───────────────┘

DCHOICE.Condition                %#BOOL_DOEXPR. Required
DCHOICE.Output                   %#OUTPUT_DOEXPR (def: keep as is). Transforms OUTPUT

DCHOICE.*                        $#DCOND, i.e. condition deciding whether to pick DCHOICE
DCHOICE.Variable                 $#DSEXPR. VAL to compare

DCOND.Not                        $#DCOND2
DCOND.And|Or                     $#DCOND_ARR
                                 $#Cannot be empty

DCOND.IsPresent                  $#BOOL. VAL !== undefined
DCOND.IsNull                     $#BOOL. VAL === null

DCOND.IsBoolean                  $#BOOL. VAL is a BOOL
DCOND.BooleanEquals              $#BOOL[_DZEXPR]. VAL === BOOL

DCOND.IsNumeric                  $#BOOL. VAL is a NUM
DCOND.NumericEquals              $#NUM[_DZEXPR]. VAL === NUM
DCOND
.NumericLess|GreaterThan[Equals] $#NUM[_DZEXPR]. VAL < <= > >= NUM

DCOND.IsString                   $#BOOL. VAL is a STR
DCOND.StringEquals               $#STR[_DZEXPR]. VAL === STR
DCOND.StringMatches              $#'GLOB'. VAL matches GLOB
                                 $#GLOB can only use *
                                 $#Must \-escape * \
DCOND
 .StringLess|GreaterThan[Equals] $#STR[_DZEXPR]. VAL < <= > >= STR

DCOND.IsTimestamp                $#BOOL. VAL is a DATE
DCOND.TimestampEquals            $#'DATE'[_DZEXPR]. VAL === DATE
DCOND.TimestampLess
 |GreaterThan[Equals]            $#'DATE'[_DZEXPR]. VAL < <= > >= DATE

                                  ┌───────────┐
                                  │   ERROR   │
                                  └───────────┘

ERROR                             #STATEs can throw ERRORs
                                  #In addition to ERRORs documented in this doc, any STATE might fail due to network ERRORs
                                  #ERRORs are propagated to parent STATE|MACHINEs
                                  #When ERROR reaches top-level MACHINE, ends it with failure, using ERROR as OUTPUT

ERROR_OUTPUT                      #On error, used as OUTPUT
ERROR_OUTPUT.Error                #'ERROR_CODE'. Can be undefined
                                  #'States.*' reserved, i.e. should not use inside STATE_TASK
                                  #Max 256 chars
ERROR_OUTPUT.Cause                #'MESSAGE'. Can be undefined
                                  #Max 32KB

EXEC|TEST_OUT|ACTIVITY_TASK
 .error|cause                     #ERROR_OUTPUT.*

EVENT_INFO.error|cause            #ERROR_OUTPUT.*
                                  #With EVENT_TYPEs:
                                  #  - *Failed (except MapIterationFailed, MapStateFailed, ParallelStateFailed)
                                  #  - *TimedOut
                                  #  - ExecutionAborted

                                  ┌──────────┐
                                  │   FAIL   │
                                  └──────────┘

DSTATE.Type                       #'Fail'. STATE is STATE_FAIL
                                  #End MACHINE with failure, including parent ones
                                  #OUTPUT is ERROR_OUTPUT
DSTATE.Error                      #'ERROR_CODE'[_DZEXPR] (def: none). ERROR_OUTPUT.Error
DSTATE.Cause                      #'MESSAGE'[_DZEXPR] (def: none). ERROR_OUTPUT.Cause

                                  ┌─────────────┐
                                  │   TIMEOUT   │
                                  └─────────────┘

DMACHINE.TimeoutSeconds           #NUM (def|max: 1y). Timeout for an EXEC
                                  #After NUMs, throw ERROR_CODE 'States.Timeout'
                                  #With TEST_IN: always 5m
                                  #Only for top-level MACHINE
DSTATE_TASK.TimeoutSeconds        #NUM[_DZEXPR] (in secs, def|max: 60). Same but on STATE_TASK

DSTATE_TASK.HeartbeatSeconds      #NUM[_DZEXPR] (in secs, def: none). Heartbeat timeout, reset after each heartbeat
                                  #On timeout, throw ERROR_CODE 'States.HeartbeatTimeout' + 'States.Timeout'
                                  #Must be < TimeoutSeconds
                                  #Only for:
                                  #  - ACTIVITY_TASK
                                  #  - SERVICE_CALLBACK_TASK
                                  #     - starts once SERVICE_TASK_ACTION completed
                                  #        - except for Lambda with INVOCATION_REQ.InvocationType 'Event', where it starts right away
                                  #  - SERVICE_SYNC_TASK

EXEC.status                       #Can be 'TIMED_OUT'

MAP_COUNT.timedOut                #NUM timed out

EVENT_TYPE ExecutionTimedOut      #On EXEC timeout
EVENT_TYPE TaskTimedOut           #On TASK timeout
EVENT_TYPE LambdaFunctionTimedOut #On Lambda FUNC_VERSION.Timeout
EVENT_TYPE ActivityTimedOut       #On ACTIVITY_TASK timeout

EVENT_INFO.timeoutInSeconds       #NUM
                                  #With EVENT_TYPEs ActivityScheduled, TaskScheduled, LambdaFunctionScheduled
EVENT_INFO.heartbeatInSeconds     #NUM
                                  #With EVENT_TYPEs ActivityScheduled, TaskScheduled

                                  ┌─────────────────┐
                                  │   TIMEOUT API   │
                                  └─────────────────┘

SendTaskHeartbeat()               #Req: ACTIVITY_TASK
                                  #Res: empty

                                  ┌─────────────────┐
                                  │   TIMEOUT IAC   │
                                  └─────────────────┘

CMACHINE_OPTS.timeout             #DURATION. DMACHINE.TimeoutSeconds
                                  #Must use DefinitionBody.fromChainable()

ICMACHINE.grantTaskResponse
 (YGRANTABLE)->CGRANT             #See below

                                  ┌─────────────────────┐
                                  │   TIMEOUT METRICS   │
                                  └─────────────────────┘

AWS/States/ExecutionsTimedOut     #NUM of EXECs timed out
AWS/States/LambdaFunctionsTimedOut#NUM of LAMBDA_TASKs timed out
AWS/States/
 ServiceIntegrationsTimedOut      #NUM of SERVICE_TASKs timed out
AWS/States/ActivitiesTimedOut     #NUM of ACTIVITY_TASKs timed out
AWS/States/
 ActivitiesHeartbeatTimedOut      #NUM of ACTIVITY_TASKs timed out due to heartbeat

DVAR StateMachineArn
 |LambdaFunctionArn
 |ServiceIntegrationResourceArn
 |ActivityArn                     #See below

                                  ┌─────────────────────────┐
                                  │   TIMEOUT METRICS IAC   │
                                  └─────────────────────────┘

ICMACHINE.metricTimedOut
 ([CMETRIC_OPTS])->CMETRIC        #Sets DVAR StateMachineArn, statistic 'Sum'
CACTIVITY
 .metric[Heartbeat]TimedOut
 ([CMETRIC_OPTS])->CMETRIC        #Sets DVAR ActivityArn, statistic 'Sum'

                                  ┌───────────┐
                                  │   CATCH   │
                                  └───────────┘

DSTATE.Catch                      #DCATCH_ARR. On error, execute some logic
                                  #Only with STATE_TASK|MAP|PARALLEL
DCATCH.Comment                    #STR. Description
DCATCH.Next                       #Like DSTATE.Next. Required

DCATCH.ErrorEquals                #'ERROR_CODE'_ARR. Required, not empty
'States.ALL'                      #Special ERROR_CODE, matching any ERROR_CODE
                                  #  - except 'States.DataLimitExceeded|Runtime'
                                  #Only in DCATCH|DRETRY.ErrorEquals
                                  #Must be in last DCATCH|DRETRY of its ARR

DCATCH's INPUT ==>                #In first matching DCATCH: STATE's INPUT
                                  #In next ones: previous matching DCATCH's ERROR_OUTPUT

DCATCH.Output                    %#ERROR_OUTPUT_DOEXPR (def: keep as is). Transforms ERROR_OUTPUT
$states.errorOutput              %#ERROR_OUTPUT
                                 %#Only in DCATCH.Output|Assign
                                 %#Only with STATE_TASK|MAP|PARALLEL
DCATCH.ResultPath                $#Like DSTATE.ResultPath, but on ERROR_OUTPUT

DCATCH.Assign                     #Like DSTATE.Assign

                                  ┌───────────┐
                                  │   RETRY   │
                                  └───────────┘

DSTATE.Retry                      #DRETRY_ARR. Retry STATE if throws
                                  #If a retry succeeds:
                                  #  - STATE does not throw anymore
                                  #  - CATCHs not run
                                  #Def: no retry
                                  #Only with STATE_TASK|MAP|PARALLEL

DRETRY.ErrorEquals                #Same as DCATCH.ErrorEquals

DRETRY.MaxAttempts                #NUM (def: 3). Max NUM of retries
                                  #Can be 0 to not retry
DRETRY.IntervalSeconds            #NUM (in secs, def: 1). Initial delay
DRETRY.BackoffRate                #NUM (def: 2). Multiplies delay after each retry
DRETRY.JitterStrategy             #'NONE' (def) or 'FULL'. Applies random jitter to delay, which helps spread the load
DRETRY.MaxDelaySeconds            #NUM (def: none). Max delay
                                  #If reached, continues to retry, but with this delay

                                  ┌─────────────────┐
                                  │   REDRIVE TOP   │
                                  └─────────────────┘

REDRIVE                           #Retry an EXEC that failed
                                  #For any failure, including timeout
                                  #Does not repeat already successful STATEs
                                  #  - i.e. restart from where it stopped
                                  #Resets timeouts and RETRYs
                                  #Uses the exact same EXEC.* parameters
                                  #Must have failed in last 14 days

REDRIVE.executionArn              #'EXEC_ARN'. Same one, i.e. does not create a new EXEC_ARN
REDRIVE.clientToken               #STR. Idempotency token (see aws_network doc)
                                  #Valid for 15m

ITEM_EXEC.redriveFilter           #'REDRIVEN|NOT_REDRIVEN'. Whether >= 1 REDRIVE started
EXEC|MAP_RUN.redriveCount         #NUM of REDRIVEs started
EXEC|MAP_RUN.redriveDate          #DATE_NUM of last REDRIVE. null if none
EXEC.redriveStatus                #One of:
                                  #  - 'REDRIVABLE': can do a REDRIVE on [ITEM_]EXEC
                                  #  - 'REDRIVABLE_BY_MAP_RUN': can do a REDRIVE on ITEM_EXECs, not EXEC
                                  #  - 'NOT_REDRIVABLE': cannot do a REDRIVE on [ITEM_]EXEC, e.g. due to:
                                  #     - did not fail
                                  #     - hit max limits
EXEC.redriveStatusReason          #'MESSAGE' if redriveStatus 'NOT_REDRIVABLE'
ITEM_EXEC.status                  #Is 'PENDING_REDRIVE' when waiting due to MAP_RUN.maxConcurrency

MAP_COUNT.pendingRedrive          #NUM waiting to REDRIVE
MAP_COUNT.failuresNotRedrivable   #NUM that tried to REDRIVE but could not

EVENT_TYPE ExecutionRedriven      #On REDRIVE
EVENT_INFO.redriveCount           #EXEC.redriveCount
                                  #With EVENT_TYPE ExecutionRedriven

                                  ┌─────────────────────┐
                                  │   REDRIVE TOP API   │
                                  └─────────────────────┘

RedriveExecution()                #Req: REDRIVE
                                  #Res: EXEC
                                  #  - only redriveDate

                                  ┌─────────────────────────┐
                                  │   REDRIVE TOP METRICS   │
                                  └─────────────────────────┘

AWS/States/ExecutionsRedriven     #NUM of REDRIVEs
AWS/States/
 RedrivenExecutionsSucceeded      #NUM of REDRIVEs succeeded
AWS/States/
 RedrivenExecutionsAborted        #NUM of REDRIVEs aborted
AWS/States/
 RedrivenExecutionsTimedOut       #NUM of REDRIVEs timed out
AWS/States/
 RedrivenExecutionsFailed         #NUM of REDRIVEs failed

DVAR StateMachineArn              #'MACHINE_ARN'. With above METRICs
                                  #MACHINE is also a TELEMETRY_ENTITY

                                  ┌───────────────────┐
                                  │   REDRIVE CHILD   │
                                  └───────────────────┘

REDRIVE ITERS ==>                 #REDRIVE includes all ITERs
                                  #  - cannot target one specific individual ITER
                                  #Does not repeat:
                                  #  - already successful ITERs
                                  #  - already successful STATEs in a failed ITER
                                  #  - unless EXEC failed with 'States.DataLimitExceeded|Runtime'

EVENT_TYPE MapRunRedriven         #When MAP_RUN repeated as part of a REDRIVE
                                  #Max 1e3 REDRIVEs per MAP_RUN
EVENT_INFO.redriveCount           #MAP_RUN.redriveCount
                                  #With EVENT_TYPE MapRunRedriven
EVENT_INFO.mapRunArn              #'MAP_RUN_ARN'
                                  #With EVENT_TYPE MapRunRedriven

                                  ┌──────────┐
                                  │   PASS   │
                                  └──────────┘

DSTATE.Type                       #'Pass'. STATE is STATE_PASS
                                  #Noop. Potential goals: set OUTPUT, set DVARs, apply parent STATE_MAP

DSTATE_PASS.Output               %#OUTPUT_DOEXPR (def: INPUT). Transforms OUTPUT, like other STATEs
DSTATE_PASS.Result               $#OUTPUT (def: INPUT). Sets OUTPUT
                                 $#Cannot use DSEXPR|DFUNCs

                                  ┌───────────────┐
                                  │   PASS LINT   │
                                  └───────────────┘

DIAG_WARNING
 PASS_RESULT_IS_STATIC            #Must not use DSEXPR in DSTATE_PASS.Result

                                  ┌───────────────┐
                                  │   ITERATION   │
                                  └───────────────┘

ITER                              #Run of a child MACHINE, i.e. either:
                                  #  - STATE_PARALLEL branch
                                  #  - STATE_MAP ITEM
                                  #When a MACHINE fails, child MACHINEs are aborted

                                  ┌──────────────┐
                                  │   PARALLEL   │
                                  └──────────────┘

DSTATE.Type                       #'Parallel'. STATE is STATE_PARALLEL
                                  #Executes multiple child MACHINEs in parallel, with same INPUT
                                  #OUTPUT is ARR of their OUTPUTs
                                  #If any child MACHINE throws, other childs are aborted
                                  #On error, throws ERROR_CODE 'States.BranchFailed'

DSTATE_PARALLEL.Branches          #DMACHINE_ARR. Required

EVENT_TYPE ParallelStateStarted   #On STATE_PARALLEL's ITERs start
EVENT_TYPE ParallelStateSucceeded #On STATE_PARALLEL's ITERs success
EVENT_TYPE ParallelStateAborted   #On STATE_PARALLEL abort
EVENT_TYPE ParallelStateFailed    #On STATE_PARALLEL failure

                                  ┌──────────────┐
                                  │   MAP MAIN   │
                                  └──────────────┘

DSTATE.Type                       #'Map'. STATE is STATE_MAP
                                  #Executes one child MACHINEs per ITEM_ARR, in parallel
                                  #OUTPUT is ARR of their OUTPUTs

EVENT_TYPE MapStateStarted        #On STATE_MAP's ITERs start
EVENT_TYPE MapStateSucceeded      #On STATE_MAP's ITERs success
EVENT_TYPE MapStateAborted        #On STATE_MAP abort
EVENT_TYPE MapStateFailed         #On STATE_MAP failure

                                  ┌───────────────────┐
                                  │   MAP MAIN AUTH   │
                                  └───────────────────┘

PACTION states:StartExecution     #Must be allowed on MACHINE.roleArn, with Resource MACHINE_ARN (itself)
                                  #Not if DMAP_CONF.Mode 'INLINE'

                                  ┌───────────────────┐
                                  │   MAP MAIN LINT   │
                                  └───────────────────┘

DIAG_ERROR TOO_DEEPLY_NESTED      #Must be hit child STATE max depth (which is it???)

                                  ┌───────────────┐
                                  │   MAP LABEL   │
                                  └───────────────┘

DSTATE_MAP.Label                  #'STATE_MAP_LABEL' (def: random ID). STATE_MAP name
                                  #Used by executor, as opposed to 'STATE' which is used inside DEFINITION
                                  #Must be unique per MACHINE
                                  #Max 40 chars, [:alnum:]-_

STATE_MAP_ARN                     #'MACHINE_ARN/STATE_MAP_LABEL'. STATE_MAP's child MACHINE
                                  #Can be used as MACHINE.stateMachineArn

MACHINE.stateMachineArn           #In input (read, not write), can be a 'STATE_MAP_ARN' to target child MACHINE
MACHINE.label                     #'STATE_MAP_LABEL', when using a STATE_MAP_ARN

                                  ┌────────────────────┐
                                  │   MAP LABEL LINT   │
                                  └────────────────────┘

DIAG_ERROR DUPLICATE_LABEL_NAME   #'STATE_MAP_LABEL' must be unique per MACHINE

DIAG_ERROR INVALID_LABEL_NAME     #'STATE_MAP_LABEL' must be valid

                                  ┌───────────────┐
                                  │   MAP ITEMS   │
                                  └───────────────┘

ORDER ==>                        %#Arguments -> ItemReader -> Items -> ItemSelector -> ItemBatcher
                                 $#InputPath -> ItemReader -> ItemsPath -> ItemSelector -> ItemBatcher

DSTATE_MAP.ItemProcessor          #DMACHINE, performed on each ITEM

DSTATE_MAP.Items                 %
DSTATE_MAP.ItemsPath             $#DZEXPR selecting ITEM_ARR
                                  #Def: INPUT, i.e. must be an ARR then
                                  #Max 1e4 ITEMs

DSTATE_MAP.ItemSelector           #DOEXPR, transforming each ITEM
                                  #Def: keep ITEM as is
CONTEXT.Map.Item.Index            #NUM (0-based)
                                  #Only in DSTATE_MAP.ItemSelector
CONTEXT.Map.Item.Value            #VAL. ITEM's value
                                  #Uses both:
                                 %#  - DSTATE_MAP.Arguments|Items
                                 $#  - DSTATE_MAP.InputPath|ItemsPath
                                  #Only in DSTATE_MAP.ItemSelector

DSTATE_MAP.**                     #In any DZEXPR|DOEXPR, does not use ITEM_ARR, ITEM nor DSTATE_MAP.Item*:
                                 %#  - $states.input is INPUT
                                 %#     - i.e. uses only DSTATE_MAP.Arguments's result
                                 $#  - $ is INPUT
                                 $#     - i.e. uses only DSTATE_MAP.InputPath's result

                                  ┌─────────────┐
                                  │   MAP RUN   │
                                  └─────────────┘

MAP_RUN                           #STATE_MAP in a given EXEC
                                  #Throttled at 1e3 at once
MAP_RUN.mapRunArn                 #'MAP_RUN_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:mapRun:MACHINE/STATE_MAP_LABEL:MAP_RUN_MID'
MAP_RUN.startDate                 #DATE_NUM
MAP_RUN.stopDate                  #DATE_NUM

MAP_RUN.executionArn              #'EXEC_ARN'
MAP_RUN.stateMachineArn           #'MACHINE_ARN'

MAP_RUN.status                    #One of: 'RUNNING', 'SUCCEEDED', 'ABORTED', 'FAILED'

EVENT_TYPE MapRunStarted          #On MAP_RUN start
EVENT_INFO.mapRunArn              #'MAP_RUN_ARN'
                                  #With EVENT_TYPE MapRunStarted
EVENT_TYPE MapRunSucceeded
EVENT_TYPE MapRunAborted
EVENT_TYPE MapRunFailed           #On MAP_RUN end

                                  ┌─────────────────┐
                                  │   MAP RUN API   │
                                  └─────────────────┘

UpdateMapRun()                    #Req: MAP_RUN
                                  #  - no *Date, status, executionArn, redrive*, *Counts
                                  #Res: empty
ListMapRuns()                     #Req: MAP_RUN
                                  #  - only executionArn
                                  #Res: mapRuns MAP_RUN_ARR
                                  #  - only mapRunArn, executionArn, startDate, stopDate
                                  #  - only one with stateMachineArn
DescribeMapRun()                  #Req: MAP_RUN
                                  #  - only mapRunArn
                                  #Res: MAP_RUN

                                  ┌────────────────────┐
                                  │   MAP ITEMS EXEC   │
                                  └────────────────────┘

ITEM_EXEC                         #ITEM in a given MAP_RUN
ITEM_EXEC.executionArn            #ITEM_EXEC_ARN. 'arn:aws:states:REGION:ACCOUNT_ID:execution:MACHINE/STATE_MAP_LABEL:EXEC'
ITEM_EXEC.mapRunArn               #'MAP_RUN_ARN'
ITEM_EXEC.*                       #Like EXEC.*

MAP_RUN.itemCounts                #MAP_COUNT. NUM of ITEMs
MAP_RUN.executionCounts           #MAP_COUNT. NUM of ITEM_EXECs, i.e. including RETRYs and REDRIVEs
MAP_COUNT.total                   #NUM
ITEM_EXEC.itemCount               #Same as MAP_RUN.itemCounts.total
MAP_COUNT.pending                 #NUM started but not running
MAP_COUNT.running                 #NUM ongoing
MAP_COUNT.succeeded               #NUM successfully completed
MAP_COUNT.aborted                 #NUM aborted
MAP_COUNT.failed                  #NUM errored

EVENT_TYPE MapIterationStarted    #On ITEM start
EVENT_INFO.length                 #NUM of ITEMs
                                  #With EVENT_TYPE MapStateStarted
EVENT_TYPE MapIterationSucceeded
EVENT_TYPE MapIterationAborted
EVENT_TYPE MapIterationFailed     #On ITEM end
EVENT_INFO.index                  #Index NUM of ITEM
                                  #With EVENT_TYPEs MapIteration*
EVENT_INFO.name                   #'STATE_MAP'
                                  #With EVENT_TYPEs MapIteration*

                                  ┌─────────────────────────┐
                                  │   MAP ITEMS EXEC AUTH   │
                                  └─────────────────────────┘

MAP_RUN_ARN                       #Used as Resource for ListExecutions() when returning ITEM_EXECs (i.e. ITEM_EXEC.mapRunArn set)

ITEM_EXEC_ARN                     #Used as Resource when targetting ITEM_EXECs with Describe[StateMachineFor]Execution(),
                                  #StopExecution(), RedriveExecution(), GetExecutionHistory()

                                  ┌────────────────────────┐
                                  │   MAP ITEMS EXEC API   │
                                  └────────────────────────┘

DescribeStateMachineForExecution()#Can return ITEM_EXEC's child MACHINE
ListExecutions()
DescribeExecution()
StopExecution()
GetExecutionHistory()             #Can operate on ITEM_EXECs by specifying an ITEM_EXEC_ARN

                                  ┌────────────────┐
                                  │   MAP CONFIG   │
                                  └────────────────┘

DMACHINE.ProcessorConfig.Mode     #DMAP_CONF
                                  #Only on a child MACHINE inside DSTATE_MAP.ItemProcessor
DMAP_CONF.Mode                    #Either:
                                  #  - 'DISTRIBUTED'
                                  #  - 'INLINE' (def):
                                  #      - pros:
                                  #         - initial STATE for each ITER is free
                                  #      - cons:
                                  #         - max child MACHINEs???
                                  #         - no BATCH???
                                  #         - no DREADER|DWRITER???
                                  #         - no MAP_RUN nor ITEM_EXEC
                                  #         - no DMAP_CONF.ExecutionType
                                  #         - no DMAP_CONF.ToleratedFailure*???
                                  #         - no STATE_MAP_LABEL|STATE_MAP_ARN???

MAP_RUN|DSTATE_MAP.MaxConcurrency #NUM[_DZEXPR] (def: 0, i.e. unlimited) of MACHINEs to run at once
                                  #Can be 1 for serial

MAP_RUN|DSTATE_MAP                #When > NUM[_DZEXPR] (def: 0) ITEMs throw:
 .ToleratedFailureCount           #  - abort every child MACHINE
                                  #  - make DSTATE_MAP throw ERROR_CODE 'States.ExceedToleratedFailureThreshold'
                                  #Else, ITEMs that throw:
                                  #  - do not make parent MACHINE throw
                                  #  - produce ERROR_OUTPUTs
MAP_RUN|DSTATE_MAP
 .ToleratedFailurePercentage      #Same but as NUM[_DZEXPR] 0-100 percentage (def: 0)

                                  ┌───────────────┐
                                  │   MAP BATCH   │
                                  └───────────────┘

DSTATE_MAP.ItemBatcher            #DBATCH. Pass BATCHs to each MACHINE, i.e. groups of multiple ITEMs
                                  #INPUT becomes {Items ITEM_ARR, BatchInput VAL}
                                  #OUTPUT is ARR of each MACHINE's OUTPUT, i.e. one output element per BATCH
                                  #Def: no BATCHs
                                  #Goal: reduce cost (price, Lambda startup, etc.) associated with high NUM of ITEMs

DBATCH.MaxItemsPerBatch           #Max NUM[_DZEXPR] of ITEMs per BATCH
DBATCH.MaxInputBytesPerBatch      #Max NUM[_DZEXPR] (in bytes, def|max 256KB) total size per BATCH
                                  #Must be explicitly set if no MaxItemsPerBatch
                                  #Combined with MaxItemsPerBatch (if any)

DBATCH.BatchInput                 #DOEXPR (def: undefined), to set as INPUT.BatchInput

                                  ┌─────────────────┐
                                  │   MAP S3 READ   │
                                  └─────────────────┘

DSTATE_MAP.ItemReader             #DREADER. Set INPUT using S3 OBJECTs
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.ItemReaderFailed': else

DREADER.Arguments                %
DREADER.Parameters               $#DREADER_PARAMS, as DOEXPR
DREADER_PARAMS.Bucket             #S3 'BUCKET'
                                  #Must be in same ACCOUNT|REGION as MACHINE

DREADER.Resource                  #'arn:aws:states:::s3:listObjectsV2'. Does ListObjectsV2()
DREADER_PARAMS.Prefix             #'PREFIX'. S3 OBJECT prefix
                                  #New INPUT is response's OBJECTS.Contents OBJECT_ARR
                                  #Excludes proper FOLDERs, i.e. 'OBJECT' ends with delimiter (e.g. /) and has empty contents
                                  #See also S3 JOB_LAMBDA, as an alternative

DREADER.Resource                  #'arn:aws:states:::s3:getObject'. Alternative, doing GetObject() instead
DREADER_PARAMS.Key                #S3 'OBJECT'
                                  #New INPUT is ARR items contained in OBJECT
DREADER.ReaderConfig              #DREADER_CONF
                                  #Only if DEADER_PARAMS.Key used
DREADER_CONF.MaxItems             #NUM[_DZEXPR] (def|max: 1e8). Only use first NUM items
DREADER_CONF.InputType            #'JSON', 'CSV' or 'MANIFEST'

DREADER_CONF.InputType 'JSON'     #OBJ_ARR
                                  #Max 8MB
                                  #Max 256KB after DSTATE_MAP.Item* applied

DREADER_CONF.InputType 'CSV'      #Values are always considered STRs
                                  #Same limits as JSON
DREADER_CONF.CSVHeaderLocation    #Whether OBJ keys are specified:
                                  #  - 'FIRST_ROW' (def): as first CSV row
                                  #  - 'GIVEN': with DREADER_CONF.CSVHeaders
                                  #OBJ keys max 10KB
DREADER_CONF.CSVHeaders           #'KEY'_ARR

DREADER_CONF.InputType 'MANIFEST' #S3 INVENTORY MANIFEST
                                  #New INPUT is INVENTORY_LINE_ARR
                                  #Max 10GB
                                  #Max 256KB after DSTATE_MAP.Item* applied

                                  ┌────────────────────┐
                                  │   MAP S3 READ UI   │
                                  └────────────────────┘

WORKFLOW STUDIO ==>               #Can view|edit DREADERs

                                  ┌──────────────────────┐
                                  │   MAP S3 READ AUTH   │
                                  └──────────────────────┘

PACTION s3:ListBucket             #If DREADER_PARAMS.Prefix, must be allowed:
                                  #  - on MACHINE.roleArn
                                  #  - Resource BUCKET
                                  #  - COND_KEY s3:prefix 'PREFIX'

PACTION s3:GetObject              #If DREADER_PARAMS.Key, must be allowed:
                                  #  - on MACHINE.roleArn
                                  #  - Resource:
                                  #     - if JSON|CSV: OBJECT
                                  #     - if MANIFEST:
                                  #        - arn:aws:s3:::DEST_PREFIX/SOURCE_BUCKET/INVENTORY/YYYY-MM-DDTHH-MMZ/manifest.json
                                  #        - arn:aws:s3:::DEST_PREFIX/SOURCE_BUCKET/INVENTORY/data/*

                                  ┌──────────────────┐
                                  │   MAP S3 WRITE   │
                                  └──────────────────┘

DSTATE_MAP.ResultWriter           #DWRITER. Write each OUTPUT item as a JSON S3 OBJECT, using PutObject()
                                  #Order is:
                                 %#  - ResultWriter -> Output
                                 $#  - ResultWriter -> ResultSelector -> ResultPath -> OutputPath
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.ResultWriterFailed': else

DWRITER.Resource                  #Always 'arn:aws:states:::s3:putObject'

DWRITER.Arguments                %
DWRITER.Parameters               $#DWRITER_PARAMS, as DOEXPR
DWRITER_PARAMS.Bucket             #'BUCKET'
                                  #Must be in same ACCOUNT|REGION as MACHINE
DWRITER_PARAMS.Prefix             #'PREFIX'. OBJECT prefix
                                  #Where is it written to???

DWRITER_OUTPUT                    #No size limit initial total OUTPUT (can be > 256KB)
DWRITER_OUTPUT.MapRunArn          #'MAP_RUN_ARN'
DWRITER_OUTPUT.ResultWriterDetails#DWRITER_PARAMS_OUTPUT
DWRITER_PARAMS_OUTPUT.Bucket      #'BUCKET'

DWRITER_PARAMS_OUTPUT.Key         #'DWRITER_MANIFEST_PATH'
PREFIX/UUID/manifest.json         #DWRITER_MANIFEST_PATH, containing DWRITER_MANIFEST
PREFIX/UUID/*_NUM.json            #NUM starts at 0. Rotates to a new file every 5GB
PREFIX/UUID/SUCCEEDED_NUM.json    #Successful OUTPUTs
PREFIX/UUID/FAILED_NUM.json       #Failed OUTPUTs
PREFIX/UUID/PENDING_NUM.json      #Aborted OUTPUTs

MAP_COUNT.resultsWritten          #NUM that completed using DWRITER

                                  ┌───────────────────────┐
                                  │   MAP S3 WRITE AUTH   │
                                  └───────────────────────┘

PACTION s3:PutObject|GetObject    #Must be allowed:
 |ListMultipartUploadParts        #  - on MACHINE.roleArn
 |AbortMultipartUpload            #  - Resource BUCKET/PREFIX/*

                                  ┌──────────┐
                                  │   WAIT   │
                                  └──────────┘

DSTATE.Type                       #'Wait'. STATE is STATE_WAIT
                                  #Wait for a specific duration

DSTATE_WAIT.Timestamp             #'DATE'[_DZEXPR]
                                  #If in the past, no wait
DSTATE_WAIT.Seconds               #NUM[_DZEXPR]. Alternative to Timestamp

EVENT_TYPE WaitStateAborted       #On STATE_WAIT abort

                                  ┌───────────────┐
                                  │   TASK MAIN   │
                                  └───────────────┘

DSTATE.Type                       #'Task'. STATE is STATE_TASK
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.TaskFailed': else

DSTATE_TASK.Resource              #'ARN'. Available ones documented below
                                  #Required

EVENT_TYPE TaskSubmitted          #On TASK submit success???
EVENT_TYPE TaskSubmitFailed       #On TASK submit failure???
EVENT_TYPE TaskScheduled          #On TASK schedule???
EVENT_TYPE TaskStarted            #On TASK start success
EVENT_TYPE TaskStartFailed        #On TASK start failure???
EVENT_TYPE TaskSucceeded          #On TASK end success
EVENT_TYPE TaskStateAborted       #On TASK end abort
EVENT_TYPE TaskFailed             #On TASK end failure

EVENT_INFO.resource               #DSTATE_TASK.Resource
                                  #With EVENT_TYPEs Task* (except TaskState*)
EVENT_INFO.resourceType           #'RESTYPE' of DSTATE_TASK.Resource
                                  #With EVENT_TYPEs Task* (except TaskState*)
EVENT_INFO.region                 #'REGION' of DSTATE_TASK.Resource
                                  #With EVENT_TYPE TaskScheduled
EVENT_INFO.parameters             #'INPUT_OBJ'
                                  #With EVENT_TYPE TaskScheduled

                                  ┌────────────────────┐
                                  │   TASK MAIN AUTH   │
                                  └────────────────────┘

DSTATE_TASK.Credentials           #DCREDS, as DOEXPR
DCREDS.RoleArn                    #'ROLE_ARN' assumed by Resource

EVENT_INFO.taskCredentials.roleArn#'ROLE_ARN'
                                  #With EVENT_TYPEs LambdaFunctionScheduled and TaskScheduled

                                  ┌────────────────────┐
                                  │   TASK MAIN LINT   │
                                  └────────────────────┘

DIAG_ERROR INVALID_RESOURCE       #DSTATE_TASK.Resource must be valid

                                  ┌─────────────────┐
                                  │   TASK LAMBDA   │
                                  └─────────────────┘

DSTATE_TASK.Resource              #'FUNC_VERSION_ARN[.SERVICE_TASK_PATTERN]'. LAMBDA_TASK
                                  #Calls Lambda Invoke()
                                  #Cannot use INVOCATION_RES.LogResult, InvokeWithResponseStream()
                                  #Can use SERVICE_TASK_PATTERN waitForTaskToken
INPUT.FunctionName                #'FUNC_ARN' of INVOCATION_REQ.FunctionArn
INPUT.Qualifier                   #'QUALIFIER' of INVOCATION_REQ.FunctionArn
INPUT.InvocationType              #INVOCATION_REQ.InvocationType (def: 'RequestResponse')
INPUT.Payload|ClientContext       #INVOCATION_REQ.*

OUTPUT.StatusCode|Payload
 |ExecutedVersion                 #INVOCATION_RES.*
OUTPUT
 .SdkResponseMetadata.RequestId   #'REQ_ID'
OUTPUT.SdkHttpMetadata.HttpHeaders#HEADERS_OBJ

ERROR_OUTPUT                      #On invocation|FUNCTION error

SERVICE_TASK_ACTION lambda:invoke #Same except run as a SERVICE_TASK

EVENT_TYPE LambdaFunctionScheduled#Like EVENT_TYPE Task*
EVENT_INFO.resource               #'FUNC_ARN'
                                  #With EVENT_TYPE LambdaFunctionScheduled
EVENT_TYPE
 LambdaFunctionScheduleFailed
EVENT_TYPE LambdaFunctionStarted
EVENT_TYPE
 LambdaFunctionStartFailed
EVENT_TYPE LambdaFunctionSucceeded
EVENT_TYPE LambdaFunctionFailed   #Like EVENT_TYPE Task*

                                  ┌──────────────────────┐
                                  │   TASK LAMBDA AUTH   │
                                  └──────────────────────┘

PACTION lambda:InvokeFunction     #Must be allowed for MACHINE.roleArn

                                  ┌─────────────────────┐
                                  │   TASK LAMBDA SAM   │
                                  └─────────────────────┘

AWS::Serverless::Connector        #Can be used with:
                                  #  - Source: MACHINE (RESOURCE_REF.RoleName)
                                  #  - Destination: Lambda FUNCTION (RESOURCE_REF.Arn)
                                  #  - Permissions 'Write'
                                  #Transformed to a MPOLICY on 'ROLE':
                                  #  - allowing lambda:InvokeFunction
                                  #  - on FUNCTION

                                  ┌──────────────────────────┐
                                  │   TASK LAMBDA COMPOSER   │
                                  └──────────────────────────┘

MACHINE ENHANCED COMPONENT ==>    #Can use Lambda FUNCTION as source
                                  #Adds POLICYs and pass identifiers as ENVVARs to FUNCTION

                                  ┌─────────────────────────┐
                                  │   TASK LAMBDA METRICS   │
                                  └─────────────────────────┘

AWS/States/LambdaFunctionRunTime  #Duration (in ms) of LAMBDA_TASKs
AWS/States/
 LambdaFunctionScheduleTime       #Duration (in ms) of LAMBDA_TASKs, scheduling time only
AWS/States/LambdaFunctionTime     #Duration (is ms) of LAMBDA_TASKs, excluding scheduling

AWS/States/LambdaFunctionsStarted #NUM of LAMBDA_TASKs started
AWS/States/
 LambdaFunctionsScheduled         #NUM of LAMBDA_TASKs scheduled
AWS/States/
 LambdaFunctionsSucceeded         #NUM of LAMBDA_TASKs successful
AWS/States/LambdaFunctionsFailed  #NUM of LAMBDA_TASKs failed

DVAR LambdaFunctionArn            #'FUNC_ARN'. With AWS/States/LambdaFunction*

                                  ┌──────────────────┐
                                  │   TASK SERVICE   │
                                  └──────────────────┘

DSTATE_TASK.Resource              #'arn:aws:states:[REGION???]:[ACCOUNT_ID|aws-sdk???]:SERVICE_TASK_ACTION[.SERVICE_TASK_PATTERN]'
                                  #SERVICE_TASK. Run specific AWS SERVICE ACTION
                                  #Only specific ones, documented in their respective docs
                                  #Available SERVICE_TASK_ACTIONs depend on SERVICE
INPUT.*                           #SERVICE_TASK_ACTION-specific, but usually mostly correspond to an ACTION PARAMS.*
OUTPUT.*                          #Same for ACTION RES.*

SERVICE_TASK_PATTERN              #SERVICE_CALLBACK_TASK, "callback pattern"
 waitForTaskToken                 #Completion requires both:
                                  #  - SERVICE_TASK_ACTION's response|failure
                                  #  - SendTask*() calls
                                  #I.e. meant for async tasks which last longer than SERVICE_TASK_ACTION
CONTEXT.Task.Token                #'ACTIVITY_TASK_MID'

SERVICE_TASK_PATTERN sync         #SERVICE_SYNC_TASK, "job pattern"???

                                  ┌─────────────────────┐
                                  │   TASK SERVICE UI   │
                                  └─────────────────────┘

WORKFLOW STUDIO ==>               #Can view|edit SERVICE_TASKs

                                  ┌───────────────────────┐
                                  │   TASK SERVICE AUTH   │
                                  └───────────────────────┘

PACTION states:
 SendTaskSuccess|Failure|Heartbeat#Must be allowed in SERVICE to use SERVICE_TASK_PATTERN waitForTaskToken

                                  ┌──────────────────────┐
                                  │   TASK SERVICE SAM   │
                                  └──────────────────────┘

StepFunctionsCallbackPolicy       #SAM POLICY_TEMPLATE (see its doc) that allows:
                                  #  - PACTION states:SendTaskFailure|SendTaskHeartbeat|SendTaskSuccess
                                  #  - on 'MACHINE'
                                  #     - using POLICY_TEMPLATE_PARAMS.StateMachineName

AWS::Serverless::Connector        #Can be used with:
                                  #  - Source: MACHINE (RESOURCE_REF.RoleName)
                                  #  - Destination: QUEUE (RESOURCE_REF.Arn)
                                  #  - Permissions 'Write'
                                  #Transformed to a MPOLICY on 'ROLE':
                                  #  - allowing sqs:SendMessage
                                  #  - on QUEUE

                                  ┌───────────────────────────┐
                                  │   TASK SERVICE COMPOSER   │
                                  └───────────────────────────┘

MACHINE ENHANCED COMPONENT ==>    #Can add SERVICE_TASK by linking UI components
                                  #Must first add RESPROP DefinitionSubstitutions.KEY and use it as value in SERVICE-specific INPUT
                                  #E.g. for Lambda: INPUT.FunctionName '${KEY}'

                                  ┌──────────────────────────┐
                                  │   TASK SERVICE METRICS   │
                                  └──────────────────────────┘

AWS/States/
 ServiceIntegrationRunTime        #Duration (in ms) of SERVICE_TASKs
AWS/States/
 ServiceIntegrationScheduleTime   #Duration (in ms) of SERVICE_TASKs, scheduling time only
AWS/States/ServiceIntegrationTime #Duration (is ms) of SERVICE_TASKs, excluding scheduling

AWS/States/
 ServiceIntegrationsStarted       #NUM of SERVICE_TASKs started
AWS/States/
 ServiceIntegrationsScheduled     #NUM of SERVICE_TASKs scheduled
AWS/States/
 ServiceIntegrationsSucceeded     #NUM of SERVICE_TASKs successful
AWS/States/
 ServiceIntegrationsFailed        #NUM of SERVICE_TASKs failed

DVAR ServiceIntegrationResourceArn#DSTATE_TASK.Resource. With AWS/States/ServiceIntegration*

                                  ┌─────────────────────────────┐
                                  │   TASK SERVICE NESTED SAM   │
                                  └─────────────────────────────┘

AWS::Serverless::Connector        #Can be used with:
                                  #  - Source: MACHINE (RESOURCE_REF.RoleName)
                                  #  - Destination: MACHINE2 (RESOURCE_REF.Arn + RESOURCE_REF.Name)
                                  #  - Permissions 'Read' and|or 'Write'
                                  #Transformed to a MPOLICY on 'ROLE':
                                  #  - allowing on MACHINE2 (from Arn):
                                  #     - Write: states:StartExecution
                                  #  - allowing on EXECUTION/* (from Name):
                                  #     - Read: states:DescribeExecution
                                  #     - Write: states:StopExecution
                                  #  - allowing on RULE 'StepFunctionsGetEventsForStepFunctionsExecutionRule':
                                  #     - Read: states:DescribeRule
                                  #     - Write: states:PutRule|PutTargets

                                  ┌──────────────────────────────────┐
                                  │   TASK SERVICE NESTED COMPOSER   │
                                  └──────────────────────────────────┘

MACHINE ENHANCED COMPONENT ==>    #Includes nested MACHINE

                                  ┌───────────────┐
                                  │   TASK HTTP   │
                                  └───────────────┘

DSTATE_TASK.Resource              #'arn:aws:states:::http:invoke'. HTTP_TASK
                                  #Call an HTTP request
                                  #Throttles 300/s RATE_LIMIT, 300 BURST_LIMIT (soft) (see token bucket algorithm doc) per ACCOUNT + REGION

INPUT.ApiEndpoint                 #'URL'
INPUT.Method                      #'HTTP_METHOD'
INPUT.QueryParameters             #QUERY_OBJ
INPUT.Headers                     #HEADERS_OBJ
INPUT.RequestBody                 #OBJ
INPUT.Authentication.ConnectionArn#???

TEST_DATA.request                 #TEST_REQ
TEST_REQ.url                      #'URL'
TEST_REQ.protocol                 #STR
TEST_REQ.method                   #'HTTP_METHOD'
TEST_REQ.headers                  #'HEADERS_OBJ'
TEST_REQ.body                     #'OBJ'

TEST_DATA.response                #TEST_RES
TEST_RES.protocol                 #STR
TEST_RES.statusCode               #'STATUS_NUM'
TEST_RES.statusMessage            #'STATUS'
TEST_RES.headers                  #'HEADERS_OBJ'
TEST_RES.body                     #'OBJ'

TEST_IN.revealSecrets             #BOOL. If false (def), fail if TEST_OUT includes some known secret fields
                                  #At the moment, this seems to be only authentication with HTTP TASK

                                  ┌──────────────────┐
                                  │   TASK HTTP UI   │
                                  └──────────────────┘

WORKFLOW STUDIO ==>               #Can view|edit HTTP_TASKs

                                  ┌────────────────────┐
                                  │   TASK HTTP AUTH   │
                                  └────────────────────┘

PACTION states:InvokeHTTPEndpoint #Must be allowed to MACHINE.roleArn for Resource MACHINE_ARN to use TASK_HTTP
COND_KEY HTTPMethod               #'HTTP_METHOD'. Only with states:InvokeHttpEndpoint
COND_KEY HTTPEndpoint             #'URL'. Only with states:InvokeHttpEndpoint

PACTION states:RevealSecrets      #Must be allowed on current PRINCIPAL if TEST_IN.revealSecrets true

                                  ┌───────────────────────┐
                                  │   TASK HTTP LOGGING   │
                                  └───────────────────────┘

CLOUDTRAIL ==>                    #TASK_HTTP requests are logged with CloudTrail as data EVENTs
                                  #MACHINE is LOG_RESOURCE

CLOUDTRAIL_SMETADATA.httpMethod   #'HTTP_METHOD'
CLOUDTRAIL_SMETADATA.httpEndpoint #'URL'

                                  ┌───────────────────────────┐
                                  │   TASK ACTIVITY DECLARE   │
                                  └───────────────────────────┘

ACTIVITY                          #Sets of ACTIVITY_TASKs
                                  #Create is idempotent
                                  #Max 1e4 (soft up to 1.5e4) per ACCOUNT
ACTIVITY.activityArn              #'ACTIVITY_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:activity:ACTIVITY'
ACTIVITY.name                     #'ACTIVITY'
                                  #Max 80 chars, [:alnum:]-_
ACTIVITY.creationDate             #DATE_NUM

DSTATE_TASK.Resource              #'ACTIVITY_ARN'

                                  ┌───────────────────────────────┐
                                  │   TASK ACTIVITY DECLARE API   │
                                  └───────────────────────────────┘

CreateActivity()                  #Req: ACTIVITY
                                  #  - no activityArn
                                  #  - only one with tags
                                  #Res: ACTIVITY
                                  #  - no name, encryptionConfiguration
ListActivities()                  #Req: empty
                                  #Res: activities ACTIVITY_ARR
                                  #  - no encryptionConfiguration
DescribeActivity()                #Req: ACTIVITY
                                  #  - only activityArn
                                  #Res: ACTIVITY
DeleteActivity()                  #Req: ACTIVITY
                                  #  - only activityArn
                                  #Res: empty

                                  ┌───────────────────────────────┐
                                  │   TASK ACTIVITY DECLARE IAC   │
                                  └───────────────────────────────┘

AWS::StepFunctions::Activity      #RESPROPs: Name
                                  #RESATTRs: Arn, Name

new Activity
 (...CARGS[, CACTIVITY_OPTS])     #CACTIVITY
Activity.fromActivityArn
 (...CARGS, 'ACTIVITY_ARN')
 ->ICACTIVITY                     #
Activity.fromActivityName
 (...CARGS, 'ACTIVITY')
 ->ICACTIVITY                     #

CACTIVITY_OPTS.activityName       #ACTIVITY.name (def: CID)
ICACTIVITY.activityName           #'ACTIVITY'[_STR_TK]
ICACTIVITY.activityArn            #'ACTIVITY_ARN'[_STR_TK]

ICMACHINE.grantRead(YGRANTABLE)
 ->CGRANT                         #See above

                                  ┌───────────────────────┐
                                  │   TASK ACTIVITY RUN   │
                                  └───────────────────────┘

ACTIVITY_TASK                     #TASK started|ended on a user-controlled compute (serverless, long running, local)
ACTIVITY_TASK.taskToken           #'ACTIVITY_TASK_MID'
                                  #Empty STR if long polled for 1m, i.e. must retry

ACTIVITY_TASK_GET                 #Get an ACTIVITY_TASK
                                  #ACTIVITY_TASK is created when an EXEC runs a STATE_TASK
                                  #that uses DSTATE_TASK.Resource 'ACTIVITY_ARN'
                                  #Until created, long polls for it
                                  #"Scheduled" is when created but not fetched by ACTIVITY_TASK_GET yet
                                  #On success|failure, must call SendTaskSuccess|Failure()
                                  #Not logged by CloudTrail
                                  #Max 1e3 at once
ACTIVITY_TASK_GET.activityArn     #'ACTIVITY_ARN'
ACTIVITY_TASK_GET.workerName      #'ACTIVITY_WORKER'. Only used for logging purpose, with EVENT_INFO.workerName

EVENT_TYPE ActivityScheduled      #
EVENT_INFO.resource               #'ACTIVITY_ARN'
                                  #With EVENT_TYPE ActivityScheduled
EVENT_TYPE ActivityScheduleFailed #
EVENT_TYPE ActivityStarted        #
EVENT_INFO.workerName             #'ACTIVITY_WORKER'
                                  #With EVENT_TYPE ActivityStarted
EVENT_TYPE ActivitySucceeded
EVENT_TYPE ActivityFailed         #

                                  ┌───────────────────────────┐
                                  │   TASK ACTIVITY RUN API   │
                                  └───────────────────────────┘

GetActivityTask()                 #Req: ACTIVITY_TASK_GET
                                  #Res: ACTIVITY_TASK
                                  #  - only one with input
SendTaskSuccess()                 #Req: ACTIVITY_TASK
                                  #  - only one with output
                                  #Res: empty
SendTaskFailure()                 #Req: ACTIVITY_TASK
                                  #  - only one with error, cause
                                  #Res: empty

                                  ┌───────────────────────────┐
                                  │   TASK ACTIVITY RUN IAC   │
                                  └───────────────────────────┘

CACTIVITY.grant
 (YGRANTABLE, 'PACTION',...)
 ->CGRANT                         #Allow PACTION on Resource ACTIVITY_ARN

ICMACHINE.grantTaskResponse
 (YGRANTABLE)->CGRANT             #Allows PACTION 'states:SendTaskSuccess|SendTaskFailure|SendTaskHeartbeat' to MACHINE

                                  ┌───────────────────────────────┐
                                  │   TASK ACTIVITY RUN METRICS   │
                                  └───────────────────────────────┘

AWS/States/ActivityRunTime        #Duration (in ms) of ACTIVITY_TASKs
AWS/States/ActivityScheduleTime   #Duration (in ms) of ACTIVITY_TASKs, scheduling time only
AWS/States/ActivityTime           #Duration (is ms) of ACTIVITY_TASKs, excluding scheduling

AWS/States/ActivitiesStarted      #NUM of ACTIVITY_TASKs started
AWS/States/ActivitiesScheduled    #NUM of ACTIVITY_TASKs scheduled
AWS/States/ActivitiesSucceeded    #NUM of ACTIVITY_TASKs successful
AWS/States/ActivitiesFailed       #NUM of ACTIVITY_TASKs failed

DVAR ActivityArn                  #'ACTIVITY_ARN'. With AWS/States/Activit*
                                  #ACTIVITY is also a TELEMETRY_ENTITY

                                  ┌───────────────────────────────────┐
                                  │   TASK ACTIVITY RUN METRICS IAC   │
                                  └───────────────────────────────────┘

CACTIVITY.metric
 ('METRIC'[, CMETRIC_OPTS])
 ->CMETRIC                        #Sets DVAR ActivityArn, statistic 'Sum'
CACTIVITY.metricMETRIC            #Same except 'METRIC' omits 'Activity' prefix, e.g. CACTIVITY.metricRunTime()
 ([CMETRIC_OPTS])->CMETRIC        #Also uses statistic 'Average' for ActivityRuntime|ActivityScheduleTime

                                  ┌────────────────┐
                                  │   ENCRYPTION   │
                                  └────────────────┘

MACHINE.encryptionConfiguration   #ENCRYPT. Encrypts 'DMACHINE_JSON' and EVENTs at rest
                                  #Also encrypts EXEC.input|output and (unless undefined) EXEC.error|cause
ACTIVITY.encryptionConfiguration  #ENCRYPT. Encrypts ACTIVITY_TASK.input|output and (unless undefined) ACTIVITY_TASK.error|cause

ENCRYPT.type                      #Either:
                                  #  - 'AWS_OWNED_KEY' (def): AWS managed KMS KEY
                                  #  - 'CUSTOMER_MANAGED_KMS_KEY': ENCRYPT.kmsKeyId
ENCRYPT.kmsKeyId                  #KMS 'KEY_ARN' or (if same ACCOUNT) 'KEY_MID'

ENCRYPT
 .kmsDataKeyReusePeriodSeconds    #NUM of secs (min 1m, def 5m, max 15m) to re-use KMS data key, for performance and cost

MACHINE_GET.includedData          #Whether to return MACHINE.definition: 'ALL_DATA' (yes, def) or 'METADATA_ONLY' (no)
                                  #Meant when ENCRYPT.kmsKeyId used and caller does not have KMS permission
EXEC_GET.includedData             #Same but with EXEC.input|output
EXEC.inputDetails|outputDetails
 .included                        #Same as BOOL

                                  ┌─────────────────────┐
                                  │   ENCRYPTION AUTH   │
                                  └─────────────────────┘

PACTION                           #If ENCRYPT.kmsKeyId, must be allowed on Resource KEY
 kms:Decrypt|GenerateDataKey      #For MACHINE:
                                  #  - Principal MACHINE.roleArn
                                  #  - COND_KEY kms:EncryptionContext:aws:states:stateMachineArn MACHINE_ARN
                                  #For ACTIVITY:
                                  #  - Principal.Service 'states.amazonaws.com'
                                  #  - COND_KEY kms:EncryptionContext:aws:states:activityArn ACTIVITY_ARN

                                  ┌────────────────────┐
                                  │   ENCRYPTION IAC   │
                                  └────────────────────┘

AWS::StepFunctions::
 StateMachine|Activity            #Includes RESPROPs: EncryptionConfiguration

CMACHINE.encryptionConnfiguration #ENCRYPT. Can be:
CACTIVITY[_OPTS]                  #  - new AwsOwnedEncryptionConfiguration()
 .encryptionConfiguration         #  - new CustomerManagedEncryptionConfiguration(IKEY[, DURATION])
                                  #Automatically allows kms:* as described above

                                  ┌─────────────┐
                                  │   LOGGING   │
                                  └─────────────┘

MACHINE.loggingConfiguration      #MACHINE_LOGGING. Log EVENTs to CloudWatch Logs
                                  #MACHINE is also a LOGGING_ENTITY
MACHINE_LOGGING.destinations[0]
 .cloudWatchLogsLogGroup          #'LOG_GROUP_ARN'
 .logGroupArn                     #'LOG_GROUP' must start with '/aws/vendedlogs/states' and end with ':*'

MACHINE_LOGGING.level             #Which EVENT_TYPEs are logged among:
                                  #  - 'OFF' (def): none
                                  #  - 'FATAL': ExecutionAborted|Failed|TimedOut
                                  #  - 'ERROR': *Aborted|Failed|TimedOut, FailStateEntered
                                  #  - 'ALL': all

MACHINE_LOGGING
 .includeExecutionData            #Like EVENTS_REQ.includeExecutionData

EVENT_INFO.input|output
 |assignedVariablesDetails        #BOOL. Whether EVENT_INFO.input|output|assignedVariables truncated at 248KB
 .truncated                       #With same EVENT_TYPEs as EVENT_INFO.input|output|assignedVariables

                                  ┌──────────────────┐
                                  │   LOGGING AUTH   │
                                  └──────────────────┘

PACTION logs:CreateLogDelivery
 |GetLogDelivery
 |UpdateLogDelivery
 |DeleteLogDelivery
 |ListLogDeliveries
 |PutResourcePolicy
 |DescribeResourcePolicies
 |DescribeLogGroups               #Must be allowed on Resource '*' for MACHINE.roleArn
PACTION                           #Must be allowed for MACHINE.roleArn
 logs:CreateLogStream|PutLogEvents#On Resource LOG_STREAM, but which LOG_STREAM is used is not documented

PACTION kms:GenerateDataKey       #If ENCRYPT.kmsKeyId, must be allowed on:
                                  #  - Resource KEY_ARN
                                  #  - Principal MACHINE.roleArn
                                  #  - COND_KEY kms:EncryptionContext:SourceArn 'arn:aws:logs:REGION:ACCOUNT_ID:*'
PACTION kms:Decrypt*              #If ENCRYPT.kmsKeyId, must be allowed on:
                                  #  - Resource '*'
                                  #  - Principal.Service 'delivery.logs.amazonaws.com'

                                  ┌─────────────────┐
                                  │   LOGGING IAC   │
                                  └─────────────────┘

AWS::StepFunctions::StateMachine  #Includes RESPROPs: LoggingConfiguration

CMACHINE_OPTS.logs                #CMACHINE_LOGGING. MACHINE.loggingConfiguration
                                  #Automatically allows logs:* and kms:* as described above
                                  #Does not allow PACTION logs:CreateLogStream|PutLogEvents
CMACHINE_LOGGING.destination      #ICLOG_GROUP. MACHINE_LOGGING.destinations[0].cloudWatchLogsLogGroup.logGroupArn
CMACHINE_LOGGING.level            #MACHINE_LOGGING.level. Def 'ERROR' if CMACHINE_OPTS.logs set, 'OFF' else
CMACHINE_LOGGING
 .includeExecutionData            #MACHINE_LOGGING.*

                                  ┌─────────────────┐
                                  │   LOGGING SAM   │
                                  └─────────────────┘

sam logs                          #Can search logs on a MACHINE (see CloudWatch logs doc)

                                  ┌──────────────────────┐
                                  │   LOGGING COMPOSER   │
                                  └──────────────────────┘

MACHINE ENHANCED COMPONENT ==>    #Includes MACHINE_LOGGING

                                  ┌─────────────┐
                                  │   TRACING   │
                                  └─────────────┘

MACHINE
 .tracingConfiguration.enabled    #BOOL (def: false). Enables X-Ray

EXEC.traceHeader                  #STR. X-Ray header

                                  ┌──────────────────┐
                                  │   TRACING AUTH   │
                                  └──────────────────┘

PACTION xray:PutTraceSegments
 |PutTelemetryRecords
 |GetSamplingRules
 |GetSamplingTargets              #Must be allowed for MACHINE.roleArn on Resource '*'

                                  ┌─────────────────┐
                                  │   TRACING IAC   │
                                  └─────────────────┘

AWS::StepFunctions::StateMachine  #Includes RESPROPs: TracingConfiguration

CMACHINE_OPTS.tracingEnabled      #MACHINE.tracingConfiguration.enabled
                                  #Automatically allows xray:* as described above

                                  ┌─────────────────────┐
                                  │   TRACING LINTING   │
                                  └─────────────────────┘

cfn-lint-serverless
 aws_sfn_state_machine_tracing
 WS5000                           #MACHINE.TracingConfiguration.Enabled must be true

                                  ┌────────────────────┐
                                  │   QUERY LANGUAGE   │
                                  └────────────────────┘

DMACHINE.QueryLanguage            #'JSONPath' (def) or 'JSONata'
                                  #Prefer JSONata: simpler, more features, better maintained
                                  #Inherited by child MACHINEs
                                  #Only for top-level MACHINE
DSTATE.QueryLanguage              #'JSONPath|JSONata'. Override for a given STATE
                                  #Not inherited by child MACHINEs

                                  ┌─────────────┐
                                  │   JSONATA   │
                                  └─────────────┘

NOTATION ==>                     %#Notation for JSONata-specific documentation

DSEXPR|DZEXPR|DFEXPR|DOEXPR      %#All mean the same thing: any value can be "{% ... %}" where ... is a JSONata query
                                 %#Substituted with its result
                                 %#On error, throws ERROR_CODE 'States.QueryEvaluationError'
                                 %#Does not error if no match, just substitute with undefined

$states.*                        %#Special DVARs, documented below
                                 %#Cannot be set
                                 %#Every query must start with either $states or $DVAR
                                 %#  - not with $$ nor implicit|explicit $
                                 %#     - e.g. $$.VAR, $.VAR or VAR
                                 %#  - but can use nested implicit|explicit $
                                 %#     - e.g. $states.input[VAR = true] or $states.input[$.VAR = true]

EVENT_TYPE EvaluationFailed       #On JSONata query error
EVENT_INFO.state                  #'STATE' name
                                  #With EVENT_TYPE EvaluationFailed
EVENT_INFO.location               #JSONata ERROR.location
                                  #With EVENT_TYPE EvaluationFailed

                                  ┌──────────────────┐
                                  │   JSONATA LINT   │
                                  └──────────────────┘

statelint                        %#Currently ignores JSONata fields, i.e. does not lint them, but does not fail either

                                  ┌──────────────┐
                                  │   JSONPATH   │
                                  └──────────────┘

NOTATION ==>                     $#Notation for JSONPath-specific documentation

$...                             $#JSONPath (see its doc)
                                 $#Root value is INPUT (after transforming)
                                 $#Exception: root value is OUTPUT (after transforming) in *.Assign (except DSTATE_CHOICE|WAIT.Assign)
                                 $#Cannot use [(EXPR)] and [?(EXPR)]

DSEXPR                           $#"Path". '$...' or '$$...'
                                 $#Substituted with its result, which can be any JSON type
DZEXPR                           $#"Reference path". DSEXPR but result must be a single value
                                 $#Can only use .VAR [NUM]
                                 $#No * .. [...,...] [...:...:...]
VAL[_DZEXPR]                     $#Means VAL can be a DZEXPR, providing key is appended with 'Path'
                                 $#E.g. DSTATE_TASK.TimeoutSecondsPath NUM_DZEXPR

DFEXPR                           $#DSEXPR or 'DFUNC(...)'
DOEXPR                           $#"Payload template". OBJ where top|nested PROPs:
                                 $#  - value can be DFEXPR
                                 $#  - providing key is 'PROP.$' (which becomes 'PROP')

                                  ┌───────────────────┐
                                  │   JSONPATH LINT   │
                                  └───────────────────┘

statelint                        $#Valid JSONPath in DSEXPR|DZEXPR|DFEXPR (not inside DOEXPR)

DIAG_WARNING NO_PATH
statelint                        $#If VAL is DZEXPR, key must be appended with 'Path'

DIAG_WARNING NO_DOLLAR
statelint                        $#DOEXPR key must be 'PROP.$' if value is DFEXPR

                                  ┌───────────────────────┐
                                  │   INTRISIC FUNCTION   │
                                  └───────────────────────┘

DFUNC([ARG[_DFEXPR],...])        $#"Intrinsic function"
                                 $#ARG can be '-quoted STR, NUM or null
                                 $#Must \-escape ' { } \
                                 $#On syntax error, throws ERROR_CODE 'States.IntrinsicFailure'

States.*                         $#Available DFUNCs, among the following

MathAdd(NUM, NUM2)->NUM3         $#NUM + NUM2

Format(STR, VAL,...)->STR        $#Replaces any {} with each VAL
                                 $#VAL must be STR|NUM|BOOL|null, not OBJ|ARR
StringSplit(STR, "CHAR")
 ->STR2_ARR                      $#STR.split("CHAR")

JsonMerge(OBJ, OBJ2, BOOL)->OBJ3 $#Merge. BOOL is whether deep

Array(VAL,...)->ARR              $#
ArrayRange(NUM, NUM2, NUM3)->ARR $#From NUM (included) to NUM2 (included) with step NUM3
                                 $#ARR max length 1e3
ArrayLength(ARR)->NUM            $#ARR.length
ArrayGetItem(ARR, NUM)->VAL      $#ARR[NUM]
ArrayContains(ARR, VAL)->BOOL    $#ARR.includes()
ArrayUnique(ARR)->ARR            $#[...new Set(ARR)]
ArrayPartition(ARR, NUM)
 ->ARR_ARR                       $#Chunks into sub-ARRs of length NUM

StringToJson('JSON')->VAL        $#JSON.parse()
JsonToString(DSEXPR)->'JSON'     $#JSON.stringify()
Base64Encode(STR)->'BASE64'      $#STR max 1e4 chars
Base64Decode('BASE64')->STR      $#STR max 1e4 chars

Hash(STR, 'ALGO')->'HASH'        $#ALGO can be 'MD5' or 'SHA-1|256|384|512'
                                 $#STR max 1e4 chars

MathRandom(INT, INT2)->INT3      $#From INT (included) to INT2 (included). Pseudo-random
UUID()->'UUIDv4'                 $#

                                  ┌──────────┐
                                  │   TAGS   │
                                  └──────────┘

TAGS.resourceArn                  #'MACHINE_ARN|ACTIVITY_ARN'
TAGS.tags
MACHINE|ACTIVITY.tags             #TAG_PAIRS

                                  ┌───────────────┐
                                  │   TAGS AUTH   │
                                  └───────────────┘

COND_KEY aws:ResourceTag/TAG      #Can apply to EXEC too

                                  ┌──────────────┐
                                  │   TAGS API   │
                                  └──────────────┘

TagResource()                     #Req: TAGS
                                  #Res: empty
ListTagsForResource()             #Req: TAGS
                                  #  - only resourceArn
                                  #Res: TAGS
                                  #  - no resourceArn
UntagResource()                   #Req: TAGS
                                  #  - tags -> tagKeys 'TAG'_ARR
                                  #Res: empty

                                  ┌──────────────┐
                                  │   TAGS IAC   │
                                  └──────────────┘

AWS::StepFunctions::
 StateMachine|Activity            #Includes RESPROPs: Tags TAG_PAIRS
