
                                  ┏━━━━━━━━━━━━━━━━━━━━┓
                                  ┃   STEP_FUNCTIONS   ┃
                                  ┗━━━━━━━━━━━━━━━━━━━━┛

VERSION ==>                       #2024-11-28

TODO:
  - https://docs.aws.amazon.com/step-functions/latest/apireference/Welcome.html
  - part in https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultwriter.html:
     - from "If you export the child workflow execution results,"
     - to "to record the remaining results"
  - new_services doc
     - already done:
        - https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsstepfunctions.html
  - CDK:
     - document which properties are supported by --hotswap
     - API Gateway:
        - StepFunctionsIntegration:
           - v1: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/lib/integrations/stepfunctions.ts
           - v2: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigatewayv2-integrations/lib/http/stepfunctions.ts
        - StepFunctionsRestApi: https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/lib/stepfunctions-api.ts
        - https://github.com/aws/aws-cdk/blob/main/packages/aws-cdk-lib/aws-apigateway/README.md#aws-stepfunctions-backed-apis
  - SAM:
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-resource-statemachine.html
        - RESPROP Policies: document like AWS::Serverless::Function, i.e. just refer to SAM_POLICIES
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/sam-specification-generated-resources-statemachine.html
     - https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-step-functions-in-sam.html
     - `aws cloudformation package` and `sam package` can be used with:
        - AWS::StepFunctions::StateMachine RESPROP DefinitionS3Location
        - AWS::Serverless::StateMachine RESPROP DefinitionUri
     - document that hot reloading is supported by `sam sync`
        - including part which documents that contents caching is done using STATE_MACHINE definition
     - move documentation about `sam remote invoke`
     - move documentation about AWS::Serverless::Connector
     - move POLICY_TEMPLATE doc from SAM transform doc
     - mention that SAM_POLICIES apply to AWS::Serverless::StateMachine RESPROP Policies too
     - see example of how to document this with AWS::Serverless::Function documentation in CloudWatch Logs
     - test locally using sam-translate binary
  - Infrastructure Composer
     - https://docs.aws.amazon.com/infrastructure-composer/latest/dg/using-composer-services-sf.html
     - https://docs.aws.amazon.com/infrastructure-composer/latest/dg/using-composer-external-files-new.html
     - connection from API Gateway API to Step Functions STATE_MACHINE
  - JSONata
  - https://docs.aws.amazon.com/step-functions/latest/dg/welcome.html
     - already done:
        - Starting state machines:
           - Redriving state machines
        - Processing input and output:
           - Map state input and output fields in Step Functions
  - add summary
  - compare with SWF

                                  ┌─────────┐
                                  │   API   │
                                  └─────────┘

SERVICE                           #'states'
SERVICE_DOMAIN                    #'[sync-]states.amazonaws.com'
                                  #'sync' is when using StartSyncExecution()

FORMAT ==>                        #JSON REQ|RES

PAGINATION ==>                    #Uses REQ.maxResults (def 100, max 1000) + REQ|RES.nextToken
                                  #ValidateStateMachineDefinition(): REQ.maxResults (def|max 100), no REQ|RES.nextToken, RES.truncated BOOL
                                  #No pagination: ListTagsForResource()

EVENTUAL CONSISTENCY ==>          #Create|update|delete take up to a few minutes

PRICING ==>                       #Not Express: 1$ per 4e4 TRANSITIONs
                                  #  - free: 4e3
                                  #Express:
                                  #  - 1$ per 1e6 EXECs
                                  #  - 1$ per 1e6 EXECs with 1s duration and 64MB memory
                                  #     - proportional to duration
                                  #        - rounded up by 100ms per EXEC
                                  #        - 2x cheaper after 1000h, 4x after 5000h
                                  #     - proportional to memory
                                  #        - memory is sum of:
                                  #           - 50MB
                                  #           - DEFINITION
                                  #           - max(INPUT, OUTPUT)
                                  #           - for each child MACHINE run: max(INPUT, OUTPUT)
                                  #        - rounded up by 64MB per EXEC
                                  #  - "EXEC" is either top|child
                                  #     - i.e. include STEP_ITERs
                                  #ENCRYPT: no KMS charge if type 'AWS_OWNED_KEY'
                                  #Recommendations:
                                  #  - Express much cheaper
                                  #     - especially if STEPs are fast and use low memory
                                  #  - with Express, what matters more:
                                  #     - if <= 1s * 64MB: NUM of EXECs
                                  #     - else: duration and memory
                                  #  - STEP_ITERs can be expensive
                                  #  - use BATCHs

                                  ┌─────────────┐
                                  │   MACHINE   │
                                  └─────────────┘

CreateStateMachine()              #Req: MACHINE + NEW_VERSION
                                  #  - no creationDate, label, status
                                  #  - no stateMachineArn
                                  #  - only one with tags
                                  #Res: VERSION
                                  #  - no updateDate, revisionId
UpdateStateMachine()              #Req: MACHINE + NEW_VERSION
                                  #  - no creationDate, label, status
                                  #  - no name, type
                                  #Res: VERSION
                                  #  - no stateMachineArn, creationDate
ListStateMachines()               #Req: empty
                                  #Res: stateMachines MACHINE_ARR
                                  #  - only stateMachineArn, name, creationDate, type
DescribeStateMachine()            #Req:
                                  #  - MACHINE: only stateMachineArn
                                  #  - MACHINE_GET
                                  #Res:
                                  #  - MACHINE
                                  #  - VERSION: no stateMachineVersionArn, updateDate
DescribeStateMachineForExecution()#Req:
                                  #  - [ITEM_]EXEC: only executionArn
                                  #  - MACHINE_GET
                                  #Res:
                                  #  - MACHINE: no creationDate, status, type
                                  #  - VERSION: no stateMachineVersionArn, description
                                  #  - ITEM_EXEC: only mapRunArn
DeleteStateMachine()              #Req: MACHINE
                                  #  - only stateMachineArn
                                  #Res: empty

MACHINE                           #Creation is idempotent (if same REQ)
                                  #Update must specify at least either MACHINE.definition|roleArn (even if unchanged)
                                  #Delete terminate ongoing EXECs and wait for them to fail
                                  #Delete also delete VERSIONs|ALIASs
MACHINE.stateMachineArn           #In output: 'MACHINE_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:stateMachine:MACHINE'
                                  #In input: 'QUALIFIED_MACHINE_ARN'
MACHINE.name                      #'MACHINE'
                                  #Max 80 chars, [:alnum:]-_
MACHINE.creationDate              #DATE_NUM

MACHINE.status                    #'ACTIVE' or 'DELETING'

                                  ┌──────────────────┐
                                  │   MACHINE AUTH   │
                                  └──────────────────┘

MACHINE.roleArn                   #'ROLE_ARN'. Required

EVENT_INFO.roleArn                #STR
                                  #With EVENT_TYPE ExecutionStarted

TEST_IN.roleArn                   #STR

PACTION iam:PassRole              #Must be allowed on current PRINCIPAL

                                  ┌──────────────────┐
                                  │   MACHINE LINT   │
                                  └──────────────────┘

DIAG_ERROR
 STATE_MACHINE_NAME_EMPTY         #MACHINE.name must be set

DIAG_ERROR
 STATE_MACHINE_NAME_TOO_LONG      #MACHINE.name must be <= 80 chars

DIAG_ERROR
 STATE_MACHINE_NAME_INVALID       #MACHINE.name must be valid

DIAG_ERROR
 STATE_MACHINE_NAME_ALREADY_EXISTS#MACHINE with same name must not already exists

                                  ┌─────────────┐
                                  │   VERSION   │
                                  └─────────────┘

PublishStateMachineVersion()      #Req: VERSION
                                  #  - no stateMachineVersionArn, *Date
                                  #  - only one with description
                                  #Res: VERSION
                                  #  - only stateMachineVersionArn, creationDate
ListStateMachineVersions()        #Req: MACHINE
                                  #  - only stateMachineArn
                                  #Res: stateMachineVersions VERSION_ARR
                                  #  - only stateMachineVersionArn, creationDate
DeleteStateMachineVersion()       #Req: VERSION
                                  #  - only stateMachineVersionArn
                                  #Res: empty
CreateStateMachine()
UpdateStateMachine()
DescribeStateMachine()            #Return VERSION too (see above)

VERSION                           #Public immutable version of a MACHINE
                                  #Previous VERSIONs not automatically deleted
                                  #PublishStateMachineVersion() is idempotent (if same REQ)
                                  #Delete waits for ongoing EXECs to complete (and does not terminate them)
                                  #Cannot delete if there is an associated ALIAS
                                  #Max 1000 per MACHINE
VERSION.stateMachineVersionArn    #'VERSION_ARN'. 'MACHINE_ARN:VERSION_NUM'
VERSION_NUM                       #Automatically incremented by PublishStateMachineVersion(), starting at 1
                                  #Similar to a git commit `hash`
                                  #ListStateMachineVersions() sorts by it
VERSION.description
NEW_VERSION.versionDescription    #STR. Max 256 chars
VERSION.creationDate              #DATE_NUM
VERSION.updateDate                #DATE_NUM

VERSION.stateMachineArn           #'MACHINE_ARN'

NEW_VERSION.publish               #BOOL (def: false). Calls PublishStateMachineVersion()

VERSION.revisionId                #'REVISION_ID' (see aws_network doc)
                                  #Is 'INITIAL' after create, before first update

                                  ┌──────────────────┐
                                  │   VERSION AUTH   │
                                  └──────────────────┘

PACTION
 states:PublishStateMachineVersion#Required for NEW_VERSION.publish true

                                  ┌───────────┐
                                  │   ALIAS   │
                                  └───────────┘

CreateStateMachineAlias()         #Req: ALIAS
                                  #  - no stateMachineAliasArn, *Date
                                  #Res: ALIAS
                                  #  - only stateMachineAliasArn, creationDate
UpdateStateMachineAlias()         #Req: ALIAS
                                  #  - no name, *Date
                                  #Res: ALIAS
                                  #  - only updateDate
ListStateMachineAliases()         #Req: STATE_MACHINE
                                  #  - only stateMachineArn
                                  #Res: stateMachineAliases ALIAS_ARR
                                  #  - only stateMachineAliasArn, creationDate
DescribeStateMachineAlias()       #Req: ALIAS
                                  #  - only stateMachineAliasArn
                                  #Res: ALIAS
DeleteStateMachineAlias()         #Req: ALIAS
                                  #  - only stateMachineAliasArn
                                  #Res: empty

ALIAS                             #'ALIAS' pointing to a VERSION
                                  #Can change its target, similar to a git tag
                                  #Create|update is idempotent (if same REQ)
                                  #Delete does not delete any associated VERSION
                                  #Max 100 per MACHINE
ALIAS.stateMachineAliasArn        #'ALIAS_ARN'. 'MACHINE_ARN:ALIAS'
ALIAS.name                        #'ALIAS'
                                  #Should avoid being a 'NUM', to prevent confusion with 'VERSION_NUM'
                                  #Max 80 chars, [:alnum:]-_.
ALIAS.description                 #STR
                                  #Max 256 chars
ALIAS.creationDate                #DATE_NUM
ALIAS.updateDate                  #DATE_NUM

ALIAS.routingConfiguration        #ALIAS_ROUTING_ARR. Randomly execute one of several VERSIONs
                                  #Min 1 item, max 2 items, i.e. meant for transitioning between 2 VERSIONs
ALIAS_ROUTING
 .stateMachineVersionArn          #'VERSION_ARN'
ALIAS_ROUTING.weight              #NUM. 0 to 100
                                  #Sum of all ALIAS_ROUTING.weight must be 100

QUALIFIER                         #'VERSION_NUM|ALIAS'
QUALIFIED_MACHINE_ARN             #'MACHINE_ARN[:QUALIFIER]' (def: latest VERSION)

                                  ┌────────────────┐
                                  │   ALIAS AUTH   │
                                  └────────────────┘

COND_KEY                          #'VERSION_NUM|ALIAS'
 states:StateMachineQualifier     #Only with DeleteStateMachineVersion(), *Alias*(), DescribeStateMachine(),
                                  #Start[Sync]Execution|ListExecutions()

                                  ┌─────────────┐
                                  │   EXPRESS   │
                                  └─────────────┘

MACHINE.type                      #Either 'STANDARD' (def) or 'EXPRESS'
DMAP_CONF.ExecutionType           #Same but for child MACHINE
                                  #Not if DMAP_CONF.Mode 'INLINE'

EXCLUSIVE FEATURES ==>            #StartSyncExecution()
                                  #EXEC_BILLING

MISSING FEATURES ==>              #DescribeStateMachineForExecution()
                                  #ListExecutions()
                                  #StopExecution()
                                  #DescribeExecution() (except if EXEC.mapRunArn set)
                                  #REDRIVE

DIFFERENCES ==>                   #Creating an EXEC is not idempotent

EXEC_ARN                          #'arn:aws:states:REGION:ACCOUNT_ID:express:MACHINE:EXEC:EXPRESS_MID'
ITEM_EXEC_ARN                     #'arn:aws:states:REGION:ACCOUNT_ID:express:MACHINE/STATE_MAP_LABEL:EXEC:EXPRESS_MID'

                                  ┌────────────────┐
                                  │   DEFINITION   │
                                  └────────────────┘

MACHINE.definition                #DEFINITION. 'DMACHINE_JSON'
                                  #Format is ASL (Amazon States Language)
                                  #  - has a spec, i.e. abstract enough to have other implementors than Step Functions API
                                  #Max 1MB

TEST_IN.definition                #STR

D*                                #Fields in 'DMACHINE_JSON'
DMACHINE.Version                  #Always '1.0' (def)
                                  #Only for top-level MACHINE

DMACHINE.Comment                  #STR. Description

                                  ┌─────────────────────┐
                                  │   DEFINITION LINT   │
                                  └─────────────────────┘

DIAG_ERROR
 INVALID_JSON_DESCRIPTION
statelint                         #DEFINITION must be valid JSON

DIAG_ERROR MISSING_DESCRIPTION    #DEFINITION must not be empty

DIAG_ERROR
 SCHEMA_VALIDATION_FAILED
statelint                         #DEFINITION must have no syntax error

                                  ┌──────────────┐
                                  │   VALIDATE   │
                                  └──────────────┘

ValidateStateMachineDefinition()  #Req: VALIDATE_REQ
                                  #Res: VALIDATE_RES

VALIDATE_REQ                      #Validate DEFINITION for syntax errors
VALIDATE_REQ.definition|type      #MACHINE.*
VALIDATE_REQ.diagnostic           #Minimum DIAG.severity (def: 'ERROR', i.e. no WARNINGs)

VALIDATE_RES.result               #'OK' or 'FAIL'. Whether any DIAG with severity 'ERROR'

VALIDATE_RES.diagnostics          #DIAG_ARR. Paginated
                                  #'CODE|MESSAGE' might change in the future, i.e. should not rely on current list
                                  #The full list is documented in this doc
DIAG.code                         #'DIAG_CODE'
DIAG.message                      #'MESSAGE'
DIAG.severity                     #Either:
                                  #  - 'ERROR': prevents Create|UpdateStateMachine()
                                  #  - 'WARNING': does not prevent Create|UpdateStateMachine()
DIAG.location                     #STR. VAR's location, as JSON pointer, e.g. '/States/STATE/Output'

                                  ┌──────────┐
                                  │   LINT   │
                                  └──────────┘

statelint PATH ...                #Validate DEFINITION files
                                  #Compared to ValidateStateMachineDefinition(), pros:
                                  #  - run locally, no API calls
                                  #Cons:
                                  #  - might be less well maintained
                                  #  - installed with Ruby
                                  #Their checks overlap, but they each some unique ones
                                  #I.e. should use both
                                  #Version 0.8 (2024-11-21)

                                  ┌───────────────┐
                                  │   EXECUTION   │
                                  └───────────────┘

StartExecution()                  #Req: EXEC
                                  #  - only stateMachineArn, name, input, traceHeader
                                  #Res: EXEC
                                  #  - only executionArn, startDate
StartSyncExecution()              #Req:
                                  #  - EXEC: only stateMachineArn, name, input, traceHeader
                                  #  - EXEC_GET
                                  #Res: EXEC
                                  #  - no mapRunArn, redrive*, stateMachineVersionArn|stateMachineAliasArn
                                  #  - only one with billingDetails
ListExecutions()                  #Req: [ITEM_]EXEC
                                  #  - only either EXEC.stateMachineArn or ITEM_EXEC.mapRunArn
                                  #  - only status -> statusFilter
                                  #  - only one with redriveFilter
                                  #Res: executions [ITEM_]EXEC_ARR
                                  #  - no cause, error, input*|output*, redriveStatus[Reason], traceHeader
                                  #  - only one with itemCount
DescribeExecution()               #Req:
                                  #  - [ITEM_]EXEC: only executionArn
                                  #  - EXEC_GET
                                  #Res: [ITEM_]EXEC
StopExecution()                   #Req: [ITEM_]EXEC
                                  #  - only executionArn, cause, error
                                  #Res: [ITEM_]EXEC
                                  #  - only stopDate

EXEC                              #Execution of a MACHINE
                                  #Create is idempotent (if same REQ and another is ongoing)
EXEC.executionArn                 #'EXEC_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:execution:MACHINE:EXEC'
EXEC.name                         #'EXEC' (def: random UUID)
                                  #Max 80 chars, [:alnum:]-_
EXEC.startDate                    #DATE_NUM
EXEC.stopDate                     #DATE_NUM

EXEC.stateMachineArn              #In input: 'QUALIFIED_MACHINE_ARN'
                                  #In output: 'MACHINE_ARN'
EXEC.stateMachineVersionArn       #'VERSION_ARN' (if specified)
EXEC.stateMachineAliasArn         #'ALIAS_ARN' (if specified)

SYNC EXECUTION ==>                #When using StartSyncExecution()
                                  #Similar to StartExecution() + waiting for completion + returning DescribeExecution()
                                  #EXEC.stateMachineArn must be 'MACHINE_ARN', not 'QUALIFIED_MACHINE_ARN'
                                  #Not logged by CloudTrail

EXEC.status                       #One of:
                                  #  - PENDING_REDRIVE
                                  #  - RUNNING
                                  #  - SUCCEEDED
                                  #  - FAILED
                                  #  - TIMED_OUT
                                  #  - ABORTED: StopExecution()

EVENT_TYPE ExecutionStarted
EVENT_TYPE ExecutionSucceeded
EVENT_TYPE ExecutionFailed
EVENT_TYPE ExecutionAborted       #

EVENT_INFO.stateMachineAliasArn   #STR
                                  #With EVENT_TYPE ExecutionStarted
EVENT_INFO.stateMachineVersionArn #STR
                                  #With EVENT_TYPE ExecutionStarted

                                  ┌─────────────┐
                                  │   REDRIVE   │
                                  └─────────────┘

RedriveExecution()                #Req: REDRIVE
                                  #Res: EXEC
                                  #  - only redriveDate

TODO: move under RETRY???

REDRIVE                           #Retry an EXEC that failed
                                  #For any failure, including timeout
                                  #Does not repeat previous successful STATEs
                                  #  - i.e. restart from where it stopped
                                  #Resets timeouts and RETRYs
                                  #Uses the exact same EXEC.* parameters
                                  #Must have failed in last 14 days
REDRIVE.executionArn              #'EXEC_ARN'. Same one, i.e. does not create a new EXEC_ARN
REDRIVE.clientToken               #STR

EXEC|MAP_RUN.redriveCount         #NUM of REDRIVEs done
                                  #Check again in https://docs.aws.amazon.com/step-functions/latest/apireference/API_DescribeExecution.html#API_DescribeExecution_ResponseElements ???
EXEC|MAP_RUN.redriveDate          #DATE_NUM of last REDRIVE
                                  #Check again in https://docs.aws.amazon.com/step-functions/latest/apireference/API_DescribeExecution.html#API_DescribeExecution_ResponseElements ???
EXEC.redriveStatus                #STR
                                  #Check again in https://docs.aws.amazon.com/step-functions/latest/apireference/API_DescribeExecution.html#API_DescribeExecution_ResponseElements ???
EXEC.redriveStatusReason          #STR
                                  #Check again in https://docs.aws.amazon.com/step-functions/latest/apireference/API_DescribeExecution.html#API_DescribeExecution_ResponseElements ???
EXEC.redriveFilter                #STR
                                  #Check again in https://docs.aws.amazon.com/step-functions/latest/apireference/API_ListExecutions.html ???
EXEC.status                       #Can be 'PENDING_REDRIVE'

EVENT_TYPE ExecutionRedriven      #On REDRIVE

EVENT_INFO.redriveCount           #NUM
                                  #With EVENT_TYPEs ExecutionRedriven and MapRunRedriven
                                  #Different descriptions in
                                  #https://docs.aws.amazon.com/step-functions/latest/apireference/API_ExecutionRedrivenEventDetails.html#StepFunctions-Type-ExecutionRedrivenEventDetails-redriveCount???
                                  #And
                                  #https://docs.aws.amazon.com/step-functions/latest/apireference/API_MapRunRedrivenEventDetails.html#StepFunctions-Type-MapRunRedrivenEventDetails-redriveCount???

CHILD MACHINES ==>                #REDRIVE includes all STEP_ITERs, which are not repeated if already successful
                                  #  - unless EXEC failed with States.DataLimitExceeded|Runtime
                                  #However, cannot target one specific individual STEP_ITER
EVENT_TYPE MapRunRedriven         #When MAP_RUN repeated as part of a REDRIVE
                                  #Max 1e3 REDRIVEs per MAP_RUN
EVENT_INFO.mapRunArn              #'MAP_RUN_ARN'
                                  #With EVENT_TYPE MapRunRedriven

                                  ┌────────────┐
                                  │   EVENTS   │
                                  └────────────┘

GetExecutionHistory()             #Req: EVENTS_REQ
                                  #Res: events EVENT_ARR

EVENTS_REQ.executionArn           #'[ITEM_]EXEC_ARN'

EVENT                             #Max 2.5e4 EVENTs per [ITEM_]EXEC
EVENT.id                          #EVENT_MID. Serial NUM, 1-indexed
EVENT.previousEventId             #EVENT_MID, if any

EVENT.timestamp                   #DATE_NUM
EVENTS_REQ.reverseOrder           #BOOL

EVENT.type                        #'EVENT_TYPE' (PascalCase)
                                  #Available ones documented in this doc
EVENT.EVENT_TYPEEventDetails      #EVENT_TYPE-specific EVENT_INFO
                                  #EVENT_TYPE is camelCase
                                  #EVENT_TYPE *StateEntered|StateExited -> stateEntered|stateExited
                                  #undefined some EVENT_TYPEs

                                  ┌───────────┐
                                  │   DEBUG   │
                                  └───────────┘

TestState()                       #Req: TEST_IN
                                  #Res: TEST_OUT

TEST_OUT.status                   #STR

TEST_IN.inspectionLevel           #STR
TEST_OUT.inspectionData           #TEST_DATA

TEST_IN.revealSecrets             #BOOL

                                  ┌────────────────┐
                                  │   DEBUG AUTH   │
                                  └────────────────┘

PACTION states:RevealSecrets      #Required for TEST_IN.revealSecrets true

                                  ┌───────────┐
                                  │   INPUT   │
                                  └───────────┘

EXEC.input                        #'INPUT_JSON' (def: '{}')

INPUT                             #VAL passed to each STATE
                                  #INPUT to first STATE is EXEC.input
                                  #INPUT to other STATEs is previous STATE's OUTPUT
                                  #JSON types only
                                  #Max 256KB (else throw ERROR_CODE 'States.DataLimitExceeded')

TRANSFORM INPUT ==>               #By default, INPUT is kept as is

DSTATE.Arguments                 %#DOEXPR (def: keep as is). Transforms INPUT
                                 %#Only with STATE_TASK|MAP|PARALLEL
$states.input                    %#INPUT

DSTATE.InputPath                 $#DSEXPR. Transforms INPUT
                                 $#null is same as empty OBJ
                                 $#Not with STATE_FAIL
DSTATE.Parameters                $#DOEXPR. Transforms INPUT
                                 $#Done after InputPath
                                 $#Throws ERROR_CODE 'States.ParameterPathFailure' if some DSEXPR does not match
                                 $#Only with STATE_TASK|PARALLEL|PASS

TEST_IN.input                     #STR
TEST_DATA.input                   #STR
TEST_DATA.afterArguments          #STR
TEST_DATA.afterInputPath          #STR
TEST_DATA.afterParameters         #STR

TASK.input                        #STR

EVENT_INFO.input                  #'JSON'
                                  #Max 260KB
                                  #With EVENT_TYPEs:
                                  #  - ExecutionStarted
                                  #  - *StateEntered
                                  #  - LambdaFunctionScheduled
                                  #  - ActivityScheduled
EVENT_INFO.inputDetails.truncated #BOOL
                                  #With same EVENT_TYPEs as EVENT_INFO.input
EVENTS_REQ.includeExecutionData   #BOOL (def: true). If false, do not set EVENT_INFO.input*|output*

                                  ┌────────────┐
                                  │   OUTPUT   │
                                  └────────────┘

OUTPUT                            #VAL (def: INPUT) returned by each STATE
                                  #OUTPUT from final STATE is EXEC's output
                                  #JSON types only
                                  #Max 256KB (else throw ERROR_CODE 'States.DataLimitExceeded')

TRANSFORM OUTPUT ==>              #By default, OUTPUT is kept as is

DSTATE.Output                    %#DOEXPR (def: keep as is). Transforms OUTPUT
                                 %#Not with STATE_FAIL
$states.result                   %#OUTPUT
                                 %#Only in DSTATE.Output|Assign
                                 %#Only with STATE_TASK|MAP|PARALLEL

DSTATE.ResultSelector            $#DOEXPR. Transforms OUTPUT
                                 $#Only with STATE_TASK|MAP|PARALLEL
DSTATE.ResultPath                $#DZEXPR. Sets OUTPUT as {...INPUT, DZEXPR: OUTPUT}
                                 $#If INPUT.DZEXPR already exists, overrides it
                                 $#null sets OUTPUT as {...INPUT}
                                 $#Cannot use CONTEXT nor $DVAR
                                 $#Done after ResultSelector
                                 $#Throws ERROR_CODE 'States.ResultPathMatchFailure' if some DSEXPR does not match
                                 $#Only with STATE_TASK|MAP|PARALLEL|PASS
DSTATE.OutputPath                $#DSEXPR. Transforms OUTPUT
                                 $#null is same as empty OBJ
                                 $#Done after ResultPath
                                 $#Not with STATE_FAIL

EXEC.output                       #'OUTPUT_JSON'. Not if ERROR_OUTPUT

TEST_OUT.output                   #STR
TEST_DATA.afterResultPath         #STR
TEST_DATA.afterResultSelector     #STR
TEST_DATA.result                  #STR

TASK.output                       #STR

EVENT_INFO.output                 #'JSON'
                                  #Max 260KB
                                  #With EVENT_TYPEs:
                                  #  - ExecutionSucceeded
                                  #  - *StateExited
                                  #  - LambdaFunctionSucceeded
                                  #  - ActivitySucceeded
                                  #  - TaskSubmitted, TaskSucceeded
EVENT_INFO.outputDetails.truncated#BOOL
                                  #With same EVENT_TYPEs as EVENT_INFO.output
EVENTS_REQ.includeExecutionData   #BOOL (def: true). If false, do not set EVENT_INFO.input*|output*

                                  ┌─────────────┐
                                  │   CONTEXT   │
                                  └─────────────┘

CONTEXT                           #'OBJ_JSON' passed to each STATE
                                  #Set by caller, for a given EXEC

$states.context                  %#CONTEXT
$$...                            $#Like $... but root value is CONTEXT instead

                                  ┌───────────────┐
                                  │   VARIABLES   │
                                  └───────────────┘

DSTATE.Assign.DVAR                #VAL. "State machine variable"
                                  #Sets $DVAR in any later STATE (not current STATE)
                                  #Can only reference $DVAR inside JSONPath|JSONata
                                 %#$DVAR cannot be set inside a query
                                 %#Other variables assigned inside a query ($VAR := VAL) can only be used inside that query
                                  #Child MACHINEs:
                                  #  - have their own DVAR scope
                                  #  - can use upper scope's DVARs, but not set them
                                  #  - cannot use lower|sibling scopes' DVARs
                                  #DVAR:
                                  #  - max 80 chars
                                  #  - ID_Continue: letters-like, numbers-like, _, diacretics, U+200C U+200D (zero-width space)
                                  #  - first char: ID_Start: letters-like
                                  #Not with STATE_SUCCEED|FAIL

MACHINE.variableReferences.STATE  #'DVAR'_ARR used by this STATE
                                  #If none, undefined (not empty ARR)

TEST_IN.variables                 #STR
TEST_DATA.variables               #STR

EVENT_INFO.assignedVariables.STR  #STR
                                  #With EVENT_TYPE *StateExited
EVENT_INFO
 .assignedVariablesDetails        #BOOL
 .truncated                       #With EVENT_TYPE *StateExited

                                  ┌───────────┐
                                  │   STATE   │
                                  └───────────┘

DMACHINE.States.STATE             #DSTATE. Like `case` in a `switch` statement
                                  #Child STATEs cannot reuse same name
                                  #'STATE' name max 80 chars
                                  #Required

DSTATE.Type                       #'STATE_TYPE'. Required
DSTATE_*.*                        #STATE_TYPE-specific, e.g. DSTATE_CHOICE.Default

DSTATE.Comment                    #STR. Description

                                  ┌────────────────┐
                                  │   STATE LINT   │
                                  └────────────────┘

DIAG_ERROR DUPLICATE_STATE_NAME
statelint                         #Child STATEs must not reuse same names

DIAG_ERROR INVALID_STATE_NAME     #'STATE' name must be valid

                                  ┌──────────┐
                                  │   FLOW   │
                                  └──────────┘

DMACHINE.StartAt                  #'STATE'. First STATE
                                  #Required

DSTATE.Next                       #'STATE'. Next STATE
                                  #Cannot target a 'STATE' in parent|child MACHINEs
                                  #Not with STATE_PASS|FAIL|CHOICE, or if DSTATE.End true. Required otherwise

TRANSITION                        #Starting a new STATE:
                                  #  - EXEC|REDRIVE: initial STATE
                                  #  - DSTATE|DCHOICE.Next, DSTATE_CHOICE.Default: next STATE
                                  #  - RETRYs
                                  #For each STEP_ITER, each STATE priced as 1 TRANSITION
                                  #  - i.e. NUM of STEP_ITERs can multiply the cost
                                  #  - free: initial STATE for each STEP_ITER, if DMAP_CONF.Mode 'INLINE'

DSTATE.End                        #BOOL (def: false). End MACHINE successfully
                                  #Continue parent MACHINEs
                                  #Not with STATE_CHOICE|SUCCEED|FAIL
                                  #Together with STATE_SUCCEED|FAIL, called "terminal STATE" (of a MACHINE)

DSTATE.Type                       #'Succeed'. STATE is STATE_SUCCEED
                                  #End MACHINE successfully
                                  #Continue parent MACHINEs

TEST_OUT.nextState                #STR

EVENT_TYPE SucceedStateEntered
EVENT_TYPE SucceedStateExited     #

                                  ┌───────────────┐
                                  │   FLOW LINT   │
                                  └───────────────┘

DIAG_ERROR
 MISSING_TRANSITION_TARGET
statelint                         #DSTATE.Next must point to existing 'STATE'

statelint                         #Every 'STATE' must be a target for a transition from another one

DIAG_ERROR MISSING_END_STATE
statelint                         #>= 1 terminal STATE

                                  ┌────────────┐
                                  │   CHOICE   │
                                  └────────────┘

DSTATE.Type                       #'Choice'. STATE is STATE_CHOICE
                                  #Like a `switch` statement

DSTATE_CHOICE.Default             #'STATE'
                                  #Def: throw ERROR_CODE 'States.NoChoiceMatched'

DSTATE_CHOICE.Choices             #DCHOICE_ARR
                                  #Cannot be empty
DCHOICE.Comment                   #STR. Description
DCHOICE.Next                      #Like DSTATE.Next. Required

DCHOICE.Assign                    #Like DSTATE_CHOICE.Assign
                                  #DSTATE_CHOICE.Assign is not used if any DCHOICE matches (even if it has no DCHOICE.Assign)

EVENT_TYPE ChoiceStateEntered
EVENT_TYPE ChoiceStateExited      #

                                  ┌─────────────────┐
                                  │   CHOICE LINT   │
                                  └─────────────────┘

DIAG_ERROR
 MISSING_TRANSITION_TARGET
statelint                         #DSTATE_CHOICE.Default and DCHOICE.Next must point to existing 'STATE'

                                  ┌───────────────┐
                                  │   CONDITION   │
                                  └───────────────┘

DCHOICE.Condition                %#BOOL_DOEXPR. Required
DCHOICE.Output                   %#OUTPUT_DOEXPR (def: keep as is). Transforms OUTPUT

DCHOICE.*                        $#DCOND, i.e. condition deciding whether to pick DCHOICE
DCHOICE.Variable                 $#DSEXPR. VAL to compare

DCOND.Not                        $#DCOND2
DCOND.And|Or                     $#DCOND_ARR
                                 $#Cannot be empty

DCOND.IsPresent                  $#BOOL. VAL !== undefined
DCOND.IsNull                     $#BOOL. VAL === null

DCOND.IsBoolean                  $#BOOL. VAL is a BOOL
DCOND.BooleanEquals              $#BOOL[_DZEXPR]. VAL === BOOL

DCOND.IsNumeric                  $#BOOL. VAL is a NUM
DCOND.NumericEquals              $#NUM[_DZEXPR]. VAL === NUM
DCOND
.NumericLess|GreaterThan[Equals] $#NUM[_DZEXPR]. VAL < <= > >= NUM

DCOND.IsString                   $#BOOL. VAL is a STR
DCOND.StringEquals               $#STR[_DZEXPR]. VAL === STR
DCOND.StringMatches              $#'GLOB'. VAL matches GLOB
                                 $#GLOB can only use *
                                 $#Must \-escape * \
DCOND
 .StringLess|GreaterThan[Equals] $#STR[_DZEXPR]. VAL < <= > >= STR

DCOND.IsTimestamp                $#BOOL. VAL is a DATE
DCOND.TimestampEquals            $#'DATE'[_DZEXPR]. VAL === DATE
DCOND.TimestampLess
 |GreaterThan[Equals]            $#'DATE'[_DZEXPR]. VAL < <= > >= DATE

                                  ┌───────────┐
                                  │   ERROR   │
                                  └───────────┘

ERROR                             #STATEs can throw ERRORs
                                  #In addition to ERRORs documented in this doc, any STATE might fail due to network ERRORs
                                  #ERRORs are propagated to parent STATE|MACHINEs
                                  #When ERROR reaches top-level MACHINE, ends it with failure, using ERROR as OUTPUT

ERROR_OUTPUT                      #On error, used as OUTPUT
ERROR_OUTPUT.Error                #'ERROR_CODE'. Can be undefined
                                  #'States.*' reserved, i.e. should not use inside STATE_TASK
                                  #Max 256 chars
ERROR_OUTPUT.Cause                #'MESSAGE'. Can be undefined
                                  #Max 32KB

EXEC.error
EXEC.cause                        #ERROR_OUTPUT.*

TEST_OUT.error                    #STR
TEST_OUT.cause                    #STR

TASK.error                        #STR
TASK.cause                        #STR

EVENT_INFO.error                  #STR
                                  #With EVENT_TYPEs:
                                  #  - *Failed (except MapIterationFailed, MapStateFailed, ParallelStateFailed)
                                  #  - *TimedOut
                                  #  - ExecutionAborted
EVENT_INFO.cause                  #STR
                                  #With same EVENT_TYPEs as EVENT_INFO.error

                                  ┌──────────┐
                                  │   FAIL   │
                                  └──────────┘

DSTATE.Type                       #'Fail'. STATE is STATE_FAIL
                                  #End MACHINE with failure, including parent ones
                                  #OUTPUT is ERROR_OUTPUT
DSTATE.Error                      #'ERROR_CODE'[_DZEXPR] (def: none). ERROR_OUTPUT.Error
DSTATE.Cause                      #'MESSAGE'[_DZEXPR] (def: none). ERROR_OUTPUT.Cause

EVENT_TYPE FailStateEntered       #

                                  ┌───────────┐
                                  │   CATCH   │
                                  └───────────┘

DSTATE.Catch                      #DCATCH_ARR. On error, execute some logic
                                  #Only with STATE_TASK|MAP|PARALLEL
DCATCH.Comment                    #STR. Description
DCATCH.Next                       #Like DSTATE.Next. Required

DCATCH.ErrorEquals                #'ERROR_CODE'_ARR. Required, not empty
'States.ALL'                      #Special ERROR_CODE, matching any ERROR_CODE
                                  #  - except 'States.DataLimitExceeded|Runtime'
                                  #Only in DCATCH|DRETRY.ErrorEquals
                                  #Must be in last DCATCH|DRETRY of its ARR

DCATCH's INPUT ==>                #In first matching DCATCH: STATE's INPUT
                                  #In next ones: previous matching DCATCH's ERROR_OUTPUT

DCATCH.Output                    %#ERROR_OUTPUT_DOEXPR (def: keep as is). Transforms ERROR_OUTPUT
$states.errorOutput              %#ERROR_OUTPUT
                                 %#Only in DCATCH.Output|Assign
                                 %#Only with STATE_TASK|MAP|PARALLEL
DCATCH.ResultPath                $#Like DSTATE.ResultPath, but on ERROR_OUTPUT

DCATCH.Assign                     #Like DSTATE.Assign

                                  ┌───────────┐
                                  │   RETRY   │
                                  └───────────┘

DSTATE.Retry                      #DRETRY_ARR. Retry STATE if throws
                                  #If a retry succeeds:
                                  #  - STATE does not throw anymore
                                  #  - CATCHs not run
                                  #Def: no retry
                                  #Only with STATE_TASK|MAP|PARALLEL

DRETRY.ErrorEquals                #Same as DCATCH.ErrorEquals

DRETRY.MaxAttempts                #NUM (def: 3). Max NUM of retries
                                  #Can be 0 to not retry
DRETRY.IntervalSeconds            #NUM (in secs, def: 1). Initial delay
DRETRY.BackoffRate                #NUM (def: 2). Multiplies delay after each retry
DRETRY.JitterStrategy             #'NONE' (def) or 'FULL'. Applies random jitter to delay, which helps spread the load
DRETRY.MaxDelaySeconds            #NUM (def: none). Max delay
                                  #If reached, continues to retry, but with this delay

                                  ┌─────────────┐
                                  │   TIMEOUT   │
                                  └─────────────┘

DMACHINE.TimeoutSeconds           #NUM (def: none). Timeout for an EXEC
                                  #After NUMs, throw ERROR_CODE 'States.Timeout'
                                  #Only for top-level MACHINE
DSTATE_TASK.TimeoutSeconds        #NUM[_DZEXPR] (in secs, def: 60). Same but on STATE_TASK

DSTATE_TASK.HeartbeatSeconds      #NUM[_DZEXPR] (in secs, def: none). Heartbeat timeout, reset after each heartbeat
                                  #On timeout, throw ERROR_CODE 'States.HeartbeatTimeout' + 'States.Timeout'
                                  #Must be < TimeoutSeconds

EVENT_INFO.timeoutInSeconds       #NUM
                                  #With EVENT_TYPEs *Scheduled

EVENT_INFO.heartbeatInSeconds     #NUM
                                  #With EVENT_TYPEs ActivityScheduled and TaskScheduled

EXEC.status                       #Can be 'TIMED_OUT'

EVENT_TYPE ExecutionTimedOut      #

                                  ┌──────────┐
                                  │   PASS   │
                                  └──────────┘

DSTATE.Type                       #'Pass'. STATE is STATE_PASS
                                  #Noop. Potential goals: set OUTPUT, set DVARs, apply parent STATE_MAP

DSTATE_PASS.Output               %#OUTPUT_DOEXPR (def: INPUT). Transforms OUTPUT, like other STATEs
DSTATE_PASS.Result               $#OUTPUT (def: INPUT). Sets OUTPUT
                                 $#Cannot use DSEXPR|DFUNCs

EVENT_TYPE PassStateEntered
EVENT_TYPE PassStateExited        #

                                  ┌───────────────┐
                                  │   PASS LINT   │
                                  └───────────────┘

DIAG_WARNING
 PASS_RESULT_IS_STATIC            #Must not use DSEXPR in DSTATE_PASS.Result

                                  ┌──────────────┐
                                  │   PARALLEL   │
                                  └──────────────┘

DSTATE.Type                       #'Parallel'. STATE is STATE_PARALLEL
                                  #Executes multiple child MACHINEs in parallel, with same INPUT
                                  #OUTPUT is ARR of their OUTPUTs
                                  #If any child MACHINE throws, other childs are terminated
                                  #On error, throws ERROR_CODE 'States.BranchFailed'

DSTATE_PARALLEL.Branches          #DMACHINE_ARR. Required

STEP_ITER                         #Run of a child MACHINE, i.e. either a STATE_PARALLEL branch or a STATE_MAP ITEM
                                  #When a MACHINE fails, child MACHINEs are terminated

EVENT_TYPE ParallelStateEntered
EVENT_TYPE ParallelStateExited
EVENT_TYPE ParallelStateStarted
EVENT_TYPE ParallelStateSucceeded
EVENT_TYPE ParallelStateAborted
EVENT_TYPE ParallelStateFailed    #

                                  ┌──────────────┐
                                  │   MAP MAIN   │
                                  └──────────────┘

DSTATE.Type                       #'Map'. STATE is STATE_MAP
                                  #Executes one child MACHINEs per ITEM_ARR, in parallel
                                  #OUTPUT is ARR of their OUTPUTs

EVENT_TYPE MapStateEntered
EVENT_TYPE MapStateExited
EVENT_TYPE MapStateStarted
EVENT_TYPE MapStateSucceeded
EVENT_TYPE MapStateAborted
EVENT_TYPE MapStateFailed         #

EVENT_INFO.length                 #NUM
                                  #With EVENT_TYPE MapStateStarted

                                  ┌───────────────────┐
                                  │   MAP MAIN LINT   │
                                  └───────────────────┘

DIAG_ERROR TOO_DEEPLY_NESTED      #Must be hit child STATE max depth (which is it???)

                                  ┌───────────────┐
                                  │   MAP LABEL   │
                                  └───────────────┘

DSTATE_MAP.Label                  #'STATE_MAP_LABEL' (def: random ID). STATE_MAP name
                                  #Used by executor, as opposed to 'STATE' which is used inside DEFINITION
                                  #Must be unique per MACHINE
                                  #Max 40 chars, [:alnum:]-_

STATE_MAP_ARN                     #'MACHINE_ARN/STATE_MAP_LABEL'. STATE_MAP's child MACHINE
                                  #Can be used as MACHINE.stateMachineArn

MACHINE.stateMachineArn           #In input (read, not write), can be a 'STATE_MAP_ARN' to target child MACHINE
MACHINE.label                     #'STATE_MAP_LABEL', when using a STATE_MAP_ARN

                                  ┌────────────────────┐
                                  │   MAP LABEL LINT   │
                                  └────────────────────┘

DIAG_ERROR DUPLICATE_LABEL_NAME   #'STATE_MAP_LABEL' must be unique per MACHINE

DIAG_ERROR INVALID_LABEL_NAME     #'STATE_MAP_LABEL' must be valid

                                  ┌───────────────┐
                                  │   MAP ITEMS   │
                                  └───────────────┘

ORDER ==>                        %#Arguments -> ItemReader -> Items -> ItemSelector -> ItemBatcher
                                 $#InputPath -> ItemReader -> ItemsPath -> ItemSelector -> ItemBatcher

DSTATE_MAP.ItemProcessor          #DMACHINE, performed on each ITEM

DSTATE_MAP.Items                 %
DSTATE_MAP.ItemsPath             $#DZEXPR selecting ITEM_ARR
                                  #Def: INPUT, i.e. must be an ARR then

DSTATE_MAP.ItemSelector           #DOEXPR, transforming each ITEM
                                  #Def: keep ITEM as is
CONTEXT.Map.Item.Index            #NUM (0-based)
                                  #Only in DSTATE_MAP.ItemSelector
CONTEXT.Map.Item.Value            #VAL. ITEM's value
                                  #Uses both:
                                 %#  - DSTATE_MAP.Arguments|Items
                                 $#  - DSTATE_MAP.InputPath|ItemsPath
                                  #Only in DSTATE_MAP.ItemSelector

DSTATE_MAP.**                     #In any DZEXPR|DOEXPR, does not use ITEM_ARR, ITEM nor DSTATE_MAP.Item*:
                                 %#  - $states.input is INPUT
                                 %#     - i.e. uses only DSTATE_MAP.Arguments's result
                                 $#  - $ is INPUT
                                 $#     - i.e. uses only DSTATE_MAP.InputPath's result

EVENT_TYPE MapIterationStarted
EVENT_TYPE MapIterationSucceeded
EVENT_TYPE MapIterationAborted
EVENT_TYPE MapIterationFailed     #

EVENT_INFO.index                  #NUM
                                  #With EVENT_TYPEs MapIteration*
EVENT_INFO.name                   #'STATE'
                                  #Max 80 chars, [:alnum:]-_
                                  #With EVENT_TYPEs MapIteration*, *StateEntered, *StateExited

                                  ┌─────────────┐
                                  │   MAP RUN   │
                                  └─────────────┘

UpdateMapRun()                    #Req: MAP_RUN
                                  #  - no *Date, status, executionArn, redrive*, *Counts
                                  #Res: empty
ListMapRuns()                     #Req: MAP_RUN
                                  #  - only executionArn
                                  #Res: mapRuns MAP_RUN_ARR
                                  #  - only mapRunArn, executionArn, startDate, stopDate
                                  #  - only one with stateMachineArn
DescribeMapRun()                  #Req: MAP_RUN
                                  #  - only mapRunArn
                                  #Res: MAP_RUN

MAP_RUN                           #STATE_MAP in a given EXEC
                                  #Not if DMAP_CONF.Mode 'INLINE'
MAP_RUN.mapRunArn                 #'MAP_RUN_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:mapRun:MACHINE/STATE_MAP_LABEL:MAP_RUN_MID'
MAP_RUN.startDate                 #DATE_NUM
MAP_RUN.stopDate                  #DATE_NUM

MAP_RUN.executionArn              #'EXEC_ARN'
MAP_RUN.stateMachineArn           #'MACHINE_ARN'

MAP_RUN.status                    #STR

EVENT_TYPE MapRunStarted
EVENT_TYPE MapRunSucceeded
EVENT_TYPE MapRunAborted
EVENT_TYPE MapRunFailed           #On MAP_RUN start|end

EVENT_INFO.mapRunArn              #'MAP_RUN_ARN'
                                  #With EVENT_TYPE MapRunStarted

                                  ┌────────────────────┐
                                  │   MAP ITEMS EXEC   │
                                  └────────────────────┘

DescribeStateMachineForExecution()#Can return ITEM_EXEC's child MACHINE
ListExecutions()
DescribeExecution()
StopExecution()
GetExecutionHistory()             #Can operate on ITEM_EXECs by specifying an ITEM_EXEC_ARN

ITEM_EXEC                         #ITEM in a given MAP_RUN
ITEM_EXEC.executionArn            #ITEM_EXEC_ARN. 'arn:aws:states:REGION:ACCOUNT_ID:execution:MACHINE/STATE_MAP_LABEL:EXEC'
ITEM_EXEC.mapRunArn               #'MAP_RUN_ARN'
ITEM_EXEC.*                       #Like EXEC.*

MAP_RUN.executionCounts           #MAP_COUNT
MAP_RUN.itemCounts                #MAP_COUNT
MAP_COUNT.aborted                 #NUM
MAP_COUNT.failed                  #NUM
MAP_COUNT.failuresNotRedrivable   #NUM
MAP_COUNT.pending                 #NUM
MAP_COUNT.pendingRedrive          #NUM
MAP_COUNT.resultsWritten          #NUM
MAP_COUNT.running                 #NUM
MAP_COUNT.succeeded               #NUM
MAP_COUNT.timedOut                #NUM
MAP_COUNT.total                   #NUM
ITEM_EXEC.itemCount               #Same as MAP_RUN.itemCounts.total???

                                  ┌─────────────────────────┐
                                  │   MAP ITEMS EXEC AUTH   │
                                  └─────────────────────────┘

MAP_RUN_ARN                       #Used as Resource for ListExecutions() when returning ITEM_EXECs (i.e. ITEM_EXEC.mapRunArn set)

ITEM_EXEC_ARN                     #Used as Resource when targetting ITEM_EXECs with Describe[StateMachineFor]Execution(),
                                  #StopExecution(), RedriveExecution(), GetExecutionHistory()

                                  ┌────────────────┐
                                  │   MAP CONFIG   │
                                  └────────────────┘

MAP_RUN.maxConcurrency            #NUM
MAP_RUN.toleratedFailureCount     #NUM
MAP_RUN.toleratedFailurePercentage#NUM

DMACHINE.ProcessorConfig.Mode     #DMAP_CONF
                                  #Only on a child MACHINE inside DSTATE_MAP.ItemProcessor
DMAP_CONF.Mode                    #Either:
                                  #  - 'DISTRIBUTED'
                                  #  - 'INLINE': cheaper, but max child MACHINEs???
                                  #      - cannot use BATCH???

DSTATE_MAP.MaxConcurrency         #NUM[_DZEXPR] (def: 0, i.e. unlimited) of MACHINEs to run at once
                                  #Can be 1 for serial

DSTATE_MAP.ToleratedFailureCount  #When > NUM[_DZEXPR] (def: 0) ITEMs throw:
                                  #  - terminate every child MACHINE
                                  #  - make DSTATE_MAP throw ERROR_CODE 'States.ExceedToleratedFailureThreshold'
                                  #Else, ITEMs that throw:
                                  #  - do not make parent MACHINE throw
                                  #  - produce ERROR_OUTPUTs
DSTATE_MAP
 .ToleratedFailurePercentage      #Same but as NUM[_DZEXPR] 0-100 percentage (def: 0)

                                  ┌───────────────┐
                                  │   MAP BATCH   │
                                  └───────────────┘

DSTATE_MAP.ItemBatcher            #DBATCH. Pass BATCHs to each MACHINE, i.e. groups of multiple ITEMs
                                  #INPUT becomes {Items ITEM_ARR, BatchInput VAL}
                                  #OUTPUT is ARR of each MACHINE's OUTPUT, i.e. one output element per BATCH
                                  #Def: no BATCHs
                                  #Goal: reduce cost (price, Lambda startup, etc.) associated with high NUM of ITEMs

DBATCH.MaxItemsPerBatch           #Max NUM[_DZEXPR] of ITEMs per BATCH
DBATCH.MaxInputBytesPerBatch      #Max NUM[_DZEXPR] (in bytes, def|max 256KB) total size per BATCH
                                  #Must be explicitly set if no MaxItemsPerBatch
                                  #Combined with MaxItemsPerBatch (if any)

DBATCH.BatchInput                 #DOEXPR (def: undefined), to set as INPUT.BatchInput

                                  ┌─────────────────┐
                                  │   MAP S3 READ   │
                                  └─────────────────┘

DSTATE_MAP.ItemReader             #DREADER. Set INPUT using S3 OBJECTs
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.ItemReaderFailed': else

DREADER.Resource                  #Always 'arn:aws:states:::s3:getObject'

DREADER.Arguments                %
DREADER.Parameters               $#DREADER_PARAMS, as DOEXPR
DREADER_PARAMS.Bucket             #S3 'BUCKET'
                                  #Must be in same ACCOUNT|REGION as MACHINE

DREADER_PARAMS.Prefix             #'PREFIX'. S3 OBJECT prefix. Does ListObjectsV2()
                                  #New INPUT is response's OBJECTS.Contents OBJECT_ARR
                                  #Excludes proper FOLDERs, i.e. 'OBJECT' ends with delimiter (e.g. /) and has empty contents
                                  #See also S3 JOB_LAMBDA, as an alternative

DREADER_PARAMS.Key                #S3 'OBJECT'. Alternative to DREADER_PARAMS.Prefix, doing GetObject()
                                  #New INPUT is ARR items contained in OBJECT
DREADER.ReaderConfig              #DREADER_CONF
                                  #Only if DEADER_PARAMS.Key used
DREADER_CONF.MaxItems             #NUM[_DZEXPR] (def|max: 1e8). Only use first NUM items
DREADER_CONF.InputType            #'JSON', 'CSV' or 'MANIFEST'

DREADER_CONF.InputType 'JSON'     #OBJ_ARR
                                  #Max 8MB
                                  #Max 256KB after DSTATE_MAP.Item* applied

DREADER_CONF.InputType 'CSV'      #Values are always considered STRs
                                  #Same limits as JSON
DREADER_CONF.CSVHeaderLocation    #Whether OBJ keys are specified:
                                  #  - 'FIRST_ROW' (def): as first CSV row
                                  #  - 'GIVEN': with DREADER_CONF.CSVHeaders
                                  #OBJ keys max 10KB
DREADER_CONF.CSVHeaders           #'KEY'_ARR

DREADER_CONF.InputType 'MANIFEST' #S3 INVENTORY MANIFEST
                                  #New INPUT is INVENTORY_LINE_ARR
                                  #Max 10GB
                                  #Max 256KB after DSTATE_MAP.Item* applied

                                  ┌──────────────────────┐
                                  │   MAP S3 READ AUTH   │
                                  └──────────────────────┘

PACTION s3:ListBucket             #If DREADER_PARAMS.Prefix, must be allowed:
                                  #  - on MACHINE.roleArn
                                  #  - Resource BUCKET
                                  #  - COND_KEY s3:prefix 'PREFIX'

PACTION s3:GetObject              #If DREADER_PARAMS.Key, must be allowed:
                                  #  - on MACHINE.roleArn
                                  #  - Resource:
                                  #     - if JSON|CSV: OBJECT
                                  #     - if MANIFEST:
                                  #        - arn:aws:s3:::DEST_PREFIX/SOURCE_BUCKET/INVENTORY/YYYY-MM-DDTHH-MMZ/manifest.json
                                  #        - arn:aws:s3:::DEST_PREFIX/SOURCE_BUCKET/INVENTORY/data/*

                                  ┌──────────────────┐
                                  │   MAP S3 WRITE   │
                                  └──────────────────┘

DSTATE_MAP.ResultWriter           #DWRITER. Write each OUTPUT item as a JSON S3 OBJECT, using PutObject()
                                  #Order is:
                                 %#  - ResultWriter -> Output
                                 $#  - ResultWriter -> ResultSelector -> ResultPath -> OutputPath
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.ResultWriterFailed': else

DWRITER.Resource                  #Always 'arn:aws:states:::s3:putObject'

DWRITER.Arguments                %
DWRITER.Parameters               $#DWRITER_PARAMS, as DOEXPR
DWRITER_PARAMS.Bucket             #S3 'BUCKET'
                                  #Must be in same ACCOUNT|REGION as MACHINE
DREADER_PARAMS.Prefix             #'PREFIX'. S3 OBJECT prefix
                                  #Where is it written to???

DWRITER_OUTPUT                    #Each OUTPUT item
                                  #No size limit initial total OUTPUT (can be > 256KB)
                                  #  - as opposed to total DWRITER_OUTPUTs, which is max 256KB
DWRITER_OUTPUT.statusCode         #STATUS_NUM
DWRITER_OUTPUT.inputReceived      #OBJ. OUTPUT item

                                  ┌───────────────────────┐
                                  │   MAP S3 WRITE AUTH   │
                                  └───────────────────────┘

PACTION s3:PutObject|GetObject    #Must be allowed:
 |ListMultipartUploadParts        #  - on MACHINE.roleArn
 |AbortMultipartUpload            #  - Resource BUCKET/PREFIX/*

                                  ┌──────────┐
                                  │   WAIT   │
                                  └──────────┘

DSTATE.Type                       #'Wait'. STATE is STATE_WAIT
                                  #Wait for a specific duration

DSTATE_WAIT.Timestamp             #'DATE'[_DZEXPR]
                                  #If in the past, no wait
DSTATE_WAIT.Seconds               #NUM[_DZEXPR]. Alternative to Timestamp

EVENT_TYPE WaitStateEntered
EVENT_TYPE WaitStateExited
EVENT_TYPE WaitStateAborted       #

                                  ┌──────────┐
                                  │   TASK   │
                                  └──────────┘

DSTATE.Type                       #'Task'. STATE is STATE_TASK
                                  #On error, throws ERROR_CODE:
                                  #  - 'States.Permissions': auth-related
                                  #  - 'States.TaskFailed': else

DSTATE_TASK.Resource              #'ARN'. Available ones documented below
                                  #Required

EVENT_TYPE TaskSubmitted
EVENT_TYPE TaskSubmitFailed
EVENT_TYPE TaskScheduled
EVENT_TYPE TaskStarted
EVENT_TYPE TaskStartFailed
EVENT_TYPE TaskSucceeded
EVENT_TYPE TaskTimedOut
EVENT_TYPE TaskFailed             #

EVENT_INFO.resource               #STR
                                  #With EVENT_TYPEs Task* (except TaskState*)
EVENT_INFO.resourceType           #STR
                                  #With same EVENT_TYPEs as EVENT_INFO.resource
EVENT_INFO.parameters             #STR
                                  #With EVENT_TYPE TaskScheduled
EVENT_INFO.region                 #STR
                                  #With EVENT_TYPE TaskScheduled

EVENT_TYPE TaskStateEntered
EVENT_TYPE TaskStateExited
EVENT_TYPE TaskStateAborted       #

                                  ┌───────────────┐
                                  │   TASK AUTH   │
                                  └───────────────┘

DSTATE_TASK.Credentials           #DCREDS, as DOEXPR
DCREDS.RoleArn                    #'ROLE_ARN' assumed by Resource

EVENT_INFO.taskCredentials.roleArn#'ROLE_ARN'
                                  #With EVENT_TYPEs LambdaFunctionScheduled and TaskScheduled

                                  ┌───────────────┐
                                  │   TASK LINT   │
                                  └───────────────┘

DIAG_ERROR INVALID_RESOURCE       #DSTATE_TASK.Resource must be valid

                                  ┌──────────────┐
                                  │   ACTIVITY   │
                                  └──────────────┘

CreateActivity()                  #Req: ACTIVITY
                                  #  - no activityArn
                                  #  - only one with tags
                                  #Res: ACTIVITY
                                  #  - no name, encryptionConfiguration
ListActivities()                  #Req: empty
                                  #Res: activities ACTIVITY_ARR
                                  #  - no encryptionConfiguration
DescribeActivity()                #Req: ACTIVITY
                                  #  - only activityArn
                                  #Res: ACTIVITY
DeleteActivity()                  #Req: ACTIVITY
                                  #  - only activityArn
                                  #Res: empty

ACTIVITY.activityArn              #'ACTIVITY_ARN'. 'arn:aws:states:REGION:ACCOUNT_ID:activity:ACTIVITY'
ACTIVITY.name                     #'ACTIVITY'
ACTIVITY.creationDate             #DATE_NUM

EVENT_TYPE ActivityScheduled
EVENT_TYPE ActivityScheduleFailed
EVENT_TYPE ActivityStarted
EVENT_TYPE ActivitySucceeded
EVENT_TYPE ActivityTimedOut
EVENT_TYPE ActivityFailed         #

EVENT_INFO.resource               #STR
                                  #With EVENT_TYPE ActivityScheduled
EVENT_INFO.workerName             #STR
                                  #With EVENT_TYPE ActivityStarted

                                  ┌───────────────────┐
                                  │   ACTIVITY TASK   │
                                  └───────────────────┘

DSTATE_TASK.Resource              #'TASK_ARN'

GetActivityTask()                 #Req: TASK_GET
                                  #Res: TASK
                                  #  - only one with input
SendTaskSuccess()                 #Req: TASK
                                  #  - only one with output
                                  #Res: empty
SendTaskFailure()                 #Req: TASK
                                  #  - only one with error, cause
                                  #Res: empty
SendTaskHeartbeat()               #Req: TASK
                                  #Res: empty

TASK.taskToken                    #'TASK_MID'
TASK_GET.activityArn              #
TASK_GET.workerName               #

                                  ┌────────────┐
                                  │   LAMBDA   │
                                  └────────────┘

DSTATE_TASK.Resource              #'FUNC_ARN': run Lambda FUNCTION, with INPUT|OUTPUT as REQ|RES

EVENT_TYPE LambdaFunctionScheduled
EVENT_TYPE
 LambdaFunctionScheduleFailed
EVENT_TYPE LambdaFunctionStarted
EVENT_TYPE
 LambdaFunctionStartFailed
EVENT_TYPE LambdaFunctionSucceeded
EVENT_TYPE LambdaFunctionTimedOut
EVENT_TYPE LambdaFunctionFailed   #

EVENT_INFO.resource               #STR
                                  #With EVENT_TYPE LambdaFunctionScheduled

                                  ┌──────────┐
                                  │   HTTP   │
                                  └──────────┘

TEST_DATA.request                 #TEST_REQ
TEST_REQ.body                     #STR
TEST_REQ.headers                  #STR
TEST_REQ.method                   #STR
TEST_REQ.protocol                 #STR
TEST_REQ.url                      #STR

TEST_DATA.response                #TEST_RES
TEST_RES.body                     #STR
TEST_RES.headers                  #STR
TEST_RES.protocol                 #STR
TEST_RES.statusCode               #STR
TEST_RES.statusMessage            #STR

                                  ┌───────────────┐
                                  │   HTTP AUTH   │
                                  └───────────────┘

PACTION states:InvokeHTTPEndpoint #???

                                  ┌────────────────┐
                                  │   ENCRYPTION   │
                                  └────────────────┘

MACHINE.encryptionConfiguration   #ENCRYPT. Encrypts 'DMACHINE_JSON' and EVENTs at rest
                                  #Also encrypts EXEC.input|output and (unless undefined) EXEC.error|cause
ACTIVITY.encryptionConfiguration  #ENCRYPT

ENCRYPT.type                      #Either:
                                  #  - 'AWS_OWNED_KEY' (def): AWS managed KMS KEY
                                  #  - 'CUSTOMER_MANAGED_KMS_KEY': ENCRYPT.kmsKeyId
ENCRYPT.kmsKeyId                  #KMS 'KEY_ARN' or (if same ACCOUNT) 'KEY_MID'

ENCRYPT
 .kmsDataKeyReusePeriodSeconds    #NUM of secs (min 1m, def 5m, max 15m) to re-use KMS data key, for performance and cost

MACHINE_GET.includedData          #Whether to return MACHINE.definition: 'ALL_DATA' (yes, def) or 'METADATA_ONLY' (no)
                                  #Meant when ENCRYPT.kmsKeyId used and caller does not have KMS permission
EXEC_GET.includedData             #Same but with EXEC.input|output
EXEC.inputDetails|outputDetails
 .included                        #Same as BOOL

                                  ┌─────────────┐
                                  │   LOGGING   │
                                  └─────────────┘

MACHINE.loggingConfiguration      #MACHINE_LOGGING. Log EVENTs to CloudWatch Logs
MACHINE_LOGGING.destinations[0]
 .cloudWatchLogsLogGroup
 .logGroupArn                     #'LOG_GROUP_ARN'

MACHINE_LOGGING.level             #One of 'OFF' (def), 'ERROR', 'FATAL' (???) or 'ALL'

MACHINE_LOGGING
 .includeExecutionData            #Like EVENTS_REQ.includeExecutionData

                                  ┌─────────────┐
                                  │   TRACING   │
                                  └─────────────┘

MACHINE
 .tracingConfiguration.enabled    #BOOL (def: false). Enables X-Ray

EXEC.traceHeader                  #STR. X-Ray header

                                  ┌─────────────┐
                                  │   BILLING   │
                                  └─────────────┘

EXEC.billingDetails               #EXEC_BILLING
EXEC_BILLING
 .billedDurationInMilliseconds    #NUM of ms charged
EXEC_BILLING.billedMemoryUsedInMB #NUM of MB charged

                                  ┌────────────────────┐
                                  │   QUERY LANGUAGE   │
                                  └────────────────────┘

DMACHINE.QueryLanguage            #'JSONPath' (def) or 'JSONata'
                                  #Prefer JSONata: simpler, more features, better maintained
                                  #Inherited by child MACHINEs
                                  #Only for top-level MACHINE
DSTATE.QueryLanguage              #'JSONPath|JSONata'. Override for a given STATE
                                  #Not inherited by child MACHINEs

EVENT_TYPE EvaluationFailed       #

EVENT_INFO.location               #STR
                                  #With EVENT_TYPE EvaluationFailed
EVENT_INFO.state                  #STR
                                  #With EVENT_TYPE EvaluationFailed

                                  ┌─────────────┐
                                  │   JSONATA   │
                                  └─────────────┘

NOTATION ==>                     %#Notation for JSONata-specific documentation

DSEXPR|DZEXPR|DFEXPR|DOEXPR      %#All mean the same thing: any value can be "{% ... %}" where ... is a JSONata query
                                 %#Substituted with its result
                                 %#On error, throws ERROR_CODE 'States.QueryEvaluationError'
                                 %#Does not error if no match, just substitute with undefined

$states.*                        %#Special DVARs, documented below
                                 %#Cannot be set
                                 %#Every query must start with either $states or $DVAR
                                 %#  - not with $$ nor implicit|explicit $
                                 %#     - e.g. $$.VAR, $.VAR or VAR
                                 %#  - but can use nested implicit|explicit $
                                 %#     - e.g. $states.input[VAR = true] or $states.input[$.VAR = true]

                                  ┌──────────────────┐
                                  │   JSONATA LINT   │
                                  └──────────────────┘

statelint                        %#Currently ignores JSONata fields, i.e. does not lint them, but does not fail either

                                  ┌──────────────┐
                                  │   JSONPATH   │
                                  └──────────────┘

NOTATION ==>                     $#Notation for JSONPath-specific documentation

$...                             $#JSONPath (see its doc)
                                 $#Root value is INPUT (after transforming)
                                 $#Exception: root value is OUTPUT (after transforming) in *.Assign (except DSTATE_CHOICE|WAIT.Assign)
                                 $#Cannot use [(EXPR)] and [?(EXPR)]

DSEXPR                           $#"Path". '$...' or '$$...'
                                 $#Substituted with its result, which can be any JSON type
DZEXPR                           $#"Reference path". DSEXPR but result must be a single value
                                 $#Can only use .VAR [NUM]
                                 $#No * .. [...,...] [...:...:...]
VAL[_DZEXPR]                     $#Means VAL can be a DZEXPR, providing key is appended with 'Path'
                                 $#E.g. DSTATE_TASK.TimeoutSecondsPath NUM_DZEXPR

DFEXPR                           $#DSEXPR or 'DFUNC(...)'
DOEXPR                           $#"Payload template". OBJ where top|nested PROPs:
                                 $#  - value can be DFEXPR
                                 $#  - providing key is 'PROP.$' (which becomes 'PROP')

                                  ┌───────────────────┐
                                  │   JSONPATH LINT   │
                                  └───────────────────┘

statelint                        $#Valid JSONPath in DSEXPR|DZEXPR|DFEXPR (not inside DOEXPR)

DIAG_WARNING NO_PATH
statelint                        $#If VAL is DZEXPR, key must be appended with 'Path'

DIAG_WARNING NO_DOLLAR
statelint                        $#DOEXPR key must be 'PROP.$' if value is DFEXPR

                                  ┌───────────────────────┐
                                  │   INTRISIC FUNCTION   │
                                  └───────────────────────┘

DFUNC([ARG[_DFEXPR],...])        $#"Intrinsic function"
                                 $#ARG can be '-quoted STR, NUM or null
                                 $#Must \-escape ' { } \
                                 $#On syntax error, throws ERROR_CODE 'States.IntrinsicFailure'

States.*                         $#Available DFUNCs, among the following

MathAdd(NUM, NUM2)->NUM3         $#NUM + NUM2

Format(STR, VAL,...)->STR        $#Replaces any {} with each VAL
                                 $#VAL must be STR|NUM|BOOL|null, not OBJ|ARR
StringSplit(STR, "CHAR")
 ->STR2_ARR                      $#STR.split("CHAR")

JsonMerge(OBJ, OBJ2, BOOL)->OBJ3 $#Merge. BOOL is whether deep

Array(VAL,...)->ARR              $#
ArrayRange(NUM, NUM2, NUM3)->ARR $#From NUM (included) to NUM2 (included) with step NUM3
                                 $#ARR max length 1e3
ArrayLength(ARR)->NUM            $#ARR.length
ArrayGetItem(ARR, NUM)->VAL      $#ARR[NUM]
ArrayContains(ARR, VAL)->BOOL    $#ARR.includes()
ArrayUnique(ARR)->ARR            $#[...new Set(ARR)]
ArrayPartition(ARR, NUM)
 ->ARR_ARR                       $#Chunks into sub-ARRs of length NUM

StringToJson('JSON')->VAL        $#JSON.parse()
JsonToString(DSEXPR)->'JSON'     $#JSON.stringify()
Base64Encode(STR)->'BASE64'      $#STR max 1e4 chars
Base64Decode('BASE64')->STR      $#STR max 1e4 chars

Hash(STR, 'ALGO')->'HASH'        $#ALGO can be 'MD5' or 'SHA-1|256|384|512'
                                 $#STR max 1e4 chars

MathRandom(INT, INT2)->INT3      $#From INT (included) to INT2 (included). Pseudo-random
UUID()->'UUIDv4'                 $#

                                  ┌──────────┐
                                  │   TAGS   │
                                  └──────────┘

TagResource()                     #Req: TAGS
                                  #Res: empty
ListTagsForResource()             #Req: TAGS
                                  #  - only resourceArn
                                  #Res: TAGS
                                  #  - no resourceArn
UntagResource()                   #Req: TAGS
                                  #  - tags -> tagKeys 'TAG'_ARR
                                  #Res: empty

TAGS.resourceArn                  #'MACHINE_ARN|ACTIVITY_ARN'
TAGS.tags
MACHINE|ACTIVITY.tags             #TAG_PAIRS

aws:ResourceTag/TAG               #Can apply to EXEC too
