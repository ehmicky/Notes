
                                  ┏━━━━━━━━━┓
                                  ┃   SQS   ┃
                                  ┗━━━━━━━━━┛

Composer:
  - Lambda:
     - LAMBDA.Layers
     - Lambda:
        - ENVVARs + POLICY to invoke other FUNCTION
  - API Gateway:
     - Lambda:
        - ENVVARs + POLICY to invoke API
        - Lambda INTEGRATION
     - SQS: SQS INTEGRATION
  - S3:
     - Lambda:
        - ENVVARs + POLICY to read|write OBJECTs
  - SQS:
     - QUEUE
     - SNS: SQS SUBSCRIPTION
     - SQS: dead-letter QUEUE
     - Lambda:
        - ENVVARs + POLICY to send to SQS
        - SQS EVENT_SOURCE

To learn:
  - new_services doc
     - stopped at CloudFormation > Composer
  - https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/welcome.html
     - stopped at Managing a queue
     - already done: Temporary queues, Quotas, Security, Related resources, Document history
  - @aws-sdk/middleware-sdk-sqs
  - Lambda on SQS
     - move my current doc
     - https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html
     - https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AWSLambdaSQSQueueExecutionRole.html
     - event source: if different ACCOUNT, cannot use SSE-SQS (but can use SSE-KMS or no encryption)
     - dead-letter queues: not with FIFO
     - batching:
        - link to @aws-lambda-powertools/batch and @middy/sqs-partial-batch-failure
        - https://docs.powertools.aws.dev/lambda/typescript/latest/utilities/batch/#key-features
     - @middy/event-normalizer: https://github.com/middyjs/middy/blob/fb69ef17fe36b3c15c1641c7ff982837d3c3e655/packages/event-normalizer/index.js#L120
        - see documentation of it under S3
  - S3 notifications to SQS
     - see https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-key-management.html#sqs-what-permissions-for-sse
  - SAM:
     - move documentation about `sam remote invoke`
     - move documentation about AWS::Serverless::Connector
     - move POLICY_TEMPLATE doc from SAM transform doc
  - search "SQS" in my docs
  - add "Summary" section

VERSION ==>                       #2024-11-15

                                  ┌─────────┐
                                  │   API   │
                                  └─────────┘

NAME ==>                          #Simple Queue Service

SERVICE_DOMAIN                    #sqs.amazonaws.com

FORMAT ==>                        #Use either:
                                  #  - X-Amz-Target: AmazonSQS[_VERSION].ACTION [C], JSON request|response
                                  #  - REQ.Action|Version, query string request (ARR uses VAR.NUM), XML response

REQ_ID                            #RES.ResponseMetadata.RequestId

PAGINATION ==>                    #Uses REQ.MaxResults (def|max: 1e3) + REQ|RES.NextToken
                                  #Only REQ.MaxResults (def: 1, max: 10): ListMessageMoveTasks()
                                  #No pagination: ListQueueTags()

EVENTUAL CONSISTENCY ==>          #Updating|deleting take up to 1m
                                  #  - including *.Approximate*, which need that time to stabilize

PRICING ==>                       #1$ per 2.5e6 API calls
                                  #  - for any API call
                                  #     - including SendMessage(), SendMessageBatch(), ReceiveMessage(), DeleteMessage(), GetQueueUrl(), etc.
                                  #     - i.e. 1$ per 8e5 MESSAGEs (non-batched) or 8e6 MESSAGEs (batches)
                                  #        - since each MESSAGE requires SendMessage[Batch]() + ReceiveMessage() + DeleteMessage[Batch]()
                                  #  - free: first 1e6/month
                                  #  - 25% more expensive with FIFO
                                  #  - 25% cheaper after 1e8 calls, 40% cheaper after 2e8 calls (with FIFO: 20%, 30%)
                                  #  - if request payload >64KB, (size % 64KB) times more expensive
                                  #1$ per 11GB of API's response payload
                                  #  - not request payload
                                  #  - free: first 15GB/month, shared with all other AWS services
                                  #  - 6% cheaper after 10TB, 22% after 50TB, 44% after 150TB
                                  #  - max 500 TB/month (soft)
                                  #  - free for EC2|Lambda to SQS, if same REGION
                                  #Recommendations:
                                  #  - mostly proportional to:
                                  #     - if MESSAGE|batch <12KB: NUM of MESSAGEs
                                  #     - else: size of MESSAGEs
                                  #  - use batches when sending, receiving and deleting
                                  #  - polling:
                                  #     - use long polling
                                  #     - reduce polling rate
                                  #     - avoid polling when no MESSAGEs available
                                  #  - avoid failed messages
                                  #     - fix underlying issue before dead-letter QUEUEs gets filled up
                                  #  - avoid duplicate sends

                                  ┌──────────┐
                                  │   AUTH   │
                                  └──────────┘

AmazonSQSFullAccess               #AWS managed POLICY. Grants all 'sqs:*' PACTIONs
AmazonSQSReadOnlyAccess           #Same but readonly

                                  ┌───────────┐
                                  │   QUEUE   │
                                  └───────────┘

QUEUE                             #CreateQueue() is idempotent, if using exact same QUEUE.*
                                  #Deleting removes all MESSAGEs
                                  #GetQueue*() and List*Queue*() are not logged by CloudTrail
                                  #No limits on NUM of QUEUEs

QUEUE_ATTRS.QueueArn              #'QUEUE_ARN'. 'arn:aws:sqs:REGION:ACCOUNT_ID:QUEUE'
QUEUE.QueueUrl                    #QUEUE_URL. 'https://sqs.REGION.amazonaws.com/ACCOUNT_ID/QUEUE'
QUEUE.QueueName                   #'QUEUE'
                                  #Max 80 chars, [:alnum:]-_
QUEUE.QueueOwnerAWSAccountId      #'ACCOUNT_ID' (def: current)

QUEUE_ATTRS.CreatedTimestamp      #DATE_NUM
QUEUE_ATTRS.LastModifiedTimestamp #DATE_NUM

QUEUE.Attributes                  #QUEUE_ATTRS

                                  ┌───────────────┐
                                  │   QUEUE API   │
                                  └───────────────┘

CreateQueue()                     #Req: QUEUE
                                  #  - no QueueUrl
                                  #  - only one with tags
                                  #  - no QUEUE_ATTRS: QueueArn, *Timestamp, Approximate*
                                  #Res: QUEUE
                                  #  - only QueueUrl
SetQueueAttributes()              #Req: QUEUE
                                  #  - only QueueUrl, Attributes
                                  #  - no QUEUE_ATTRS: QueueArn, *Timestamp, Approximate*, FifoQueue
                                  #Res: empty
GetQueueAttributes()              #Req: QUEUE
                                  #  - only QueueUrl, Attributes -> AttributeNames 'PROP'_ARR or ['All']
                                  #Res: QUEUE
                                  #  - only Attributes
GetQueueUrl()                     #Req: QUEUE
                                  #  - only QueueName
                                  #  - only one with QueueOwnerAWSAccountId
                                  #Res: QUEUE
                                  #  - only QueueUrl
ListQueues()                      #Req: QUEUE
                                  #  - only QueueName -> QueueNamePrefix
                                  #Res: QUEUE
                                  #  - only QueueUrl -> QueueUrls ARR
DeleteQueue()                     #Req: QUEUE
                                  #  - only QueueUrl
                                  #Res: empty

                                  ┌───────────────┐
                                  │   QUEUE IAC   │
                                  └───────────────┘

AWS::SQS::Queue                   #RESPROPs:
                                  #  - QueueName
                                  #     - def|recommended: random ID
                                  #     - if provided, cannot set QUEUE.FifoQueue
                                  #RESATTRs:
                                  #  - Arn, QueueName
                                  #  - QueueUrl: returned by { Ref }

                                  ┌───────────────────┐
                                  │   QUEUE METRICS   │
                                  └───────────────────┘

DVAR QueueName                    #'QUEUE', sent with all METRICs
                                  #QUEUE is also sent as a METRIC_ENTITY

INACTIVE QUEUE ==>                #QUEUE without any activity for 6h+
                                  #Does not send any more METRICs
                                  #"Activity" includes GetQueueAttributes(), i.e. can be used to re-activate
                                  #Re-activating takes up to 15m

                                  ┌──────────┐
                                  │   FIFO   │
                                  └──────────┘

STANDARD QUEUE ==>                #Non-FIFO QUEUE
                                  #Receiving order is randomly sampled among MESSAGEs available
                                  #Pros:
                                  #  - Receiver can process MESSAGEs in parallel
                                  #  - No throttling
                                  #Cons:
                                  #  - Order is not guaranteed, although does a best effort
                                  #  - At-most-once delivery + processing, i.e. processing should be idempotent
DATA REDUNDANCY ==>               #With non-FIFO QUEUE, MESSAGEs are replicated on multiple servers

QUEUE_ATTRS.FifoQueue             #BOOL (def: false). FIFO, i.e. ensures that receiving order is same as sending order
                                  #'QUEUE' must end with '.fifo'
                                  #Receiver must process MESSAGEs serially (within a given MESSAGE_GROUP)
                                  #  - i.e. failed MESSAGEs prevent further consumption, unless there is a dead-letter QUEUE2

MESSAGE_SEND|SYS_ATTRS            #'MESSAGE_GROUP_ID'. FIFO ordering applies per-MESSAGE_GROUP
 .MessageGroupId                  #I.e. MESSAGE_GROUPs are interleaved
                                  #Only with FIFO. Required
                                  #Max 128 chars, [:graph:]
                                  #No limits on NUM of MESSAGE_GROUPs
MESSAGE_SEND_RES|SYS_ATTRS        #'NUM'. Increases monotonically (but not necessarily consecutively) per MESSAGE within a given MESSAGE_GROUP
 .SequenceNumber                  #Always 128 chars, padded with 0s

MESSAGE_SEND|SYS_ATTRS            #'MESSAGE_SEND_DID'. If 2 SendMessage*() with the same MESSAGE_SEND_DID are sent (within 5m),
 .MessageDeduplicationId          #the second one is ignored
                                  #I.e. exactly-once delivery, avoiding duplicate sends
                                  #Only with FIFO. Required
                                  #Max 128 chars, [:graph:]
QUEUE_ATTRS
 .ContentBasedDeduplication       #BOOL (def: false). Make MESSAGE_SEND_DID default to SHA-256 of 'MESSAGE_BODY'
QUEUE_ATTRS.DeduplicationScope    #Whether to namespace MESSAGE_SEND_DID with MESSAGE_GROUP_ID: 'queue' (no), 'messageGroup' (yes)

MESSAGES_RCV                      #'MESSAGE_RCV_DID'. If 2 ReceiveMessage*() with the same MESSAGE_RCV_DID are sent (within 5m),
 .ReceiveRequestAttemptId         #the first one fails if it tries to DeleteMessage*()
                                  #I.e. exactly-once processing, avoiding duplicate processing
                                  #Only with FIFO. Required for retries
                                  #Max 128 chars, [:graph:]

QUEUE_ATTRS.FifoThroughputLimit   #Throttles either:
                                  #  - 'perQueue' (def): max 300 (hard) SendMessage[Batch]() per second per QUEUE
                                  #  - 'perMessageGroupId' (recommended): max 7e4 (soft, REGION-specific) SendMessage[Batch]() per second per MESSAGE_GROUP
                                  #The same quota applies separetely for DeleteMessage[Batch](), and for ReceiveMessage()
                                  #If 'perMessageGroupId', QUEUE_ATTRS.DeduplicationScope must be 'messageGroup'
                                  #Only with FIFO

                                  ┌──────────────┐
                                  │   FIFO IAC   │
                                  └──────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: FifoQueue, ContentBasedDeduplication, DeduplicationScope, FifoThroughputLimit

                                  ┌──────────────────┐
                                  │   FIFO METRICS   │
                                  └──────────────────┘

AWS/SQS/ApproximateNumberOfGroups
 WithInflightMessages             #NUM of MESSAGE_GROUPs with in-flight MESSAGEs
AWS/SQS/
 NumberOfDeduplicatedSentMessages #NUM of duplicate sends ignored thanks to MESSAGE_SEND_DID

                                  ┌─────────────┐
                                  │   MESSAGE   │
                                  └─────────────┘

MESSAGE                           #*Message*() are logged with CloudTrail as data EVENTs
                                  #  - except *MessageMoveTask*()
                                  #  - QUEUE is LOG_RESOURCE

MESSAGE_DELETE                    #PurgeQueue() deletes all MESSAGEs
                                  #DeleteMessage*() is idempotent, i.e. duplicate deletions are allowed
                                  #  - whether with same MESSAGE_RCV_MID (i.e. same retry) or not

MESSAGE_SEND|MESSAGES_RCV
 |MESSAGE_DELETE|MESSAGE_VSB
 .QueueUrl                        #'QUEUE_URL'

SYS_ATTRS.SentTimestamp           #DATE_NUM of first SendMessage()
SYS_ATTRS
 .ApproximateFirstReceiveTimestamp#DATE_NUM of first ReceiveMessage()

MESSAGE_SEND_RES|MESSAGE_RCV_RES
 .MessageId                       #'MESSAGE_SEND_MID'
MESSAGE_RCV_RES|MESSAGE_DELETE
 |MESSAGE_VSB.ReceiptHandle       #'MESSAGE_RCV_MID'

                                  ┌─────────────────┐
                                  │   MESSAGE API   │
                                  └─────────────────┘

SendMessage()                     #Req: MESSAGE_SEND
                                  #Res: MESSAGE_SEND_RES
ReceiveMessage()                  #Req: MESSAGES_RCV
                                  #Res: MESSAGES_RCV_RES
DeleteMessage()                   #Req: MESSAGE_DELETE
                                  #Res: empty
PurgeQueue()                      #Res: MESSAGE_DELETE
                                  #  - only QueueUrl
                                  #Res: empty

                                  ┌──────────────────────┐
                                  │   MESSAGE SDK JAVA   │
                                  └──────────────────────┘

JMS CLIENT ==>                    #"Java Messaging Library"
                                  #Client built on top of Java SDK, to make it compatible with JMS,
                                  #which is a Java-specific Messaging API
                                  #Repository is awslabs/amazon-sqs-java-messaging-lib

                                  ┌─────────────────────┐
                                  │   MESSAGE METRICS   │
                                  └─────────────────────┘

AWS/SQS/NumberOfMessagesSent      #NUM of MESSAGEs sent
                                  #Includes duplicate sends
                                  #If dead-letter QUEUE, only MESSAGEs sent manually, not through dead-letter mechanism
AWS/SQS/NumberOfMessagesReceived  #NUM of MESSAGEs received
                                  #Includes retries
AWS/SQS/NumberOfMessagesDeleted   #NUM of MESSAGEs deleted
                                  #Includes duplicate deletions

                                  ┌─────────────┐
                                  │   CONTENT   │
                                  └─────────────┘

MESSAGE_SEND.MessageBody          #'MESSAGE_BODY'
MESSAGE_RCV_RES.Body              #Must be URL encoded

MESSAGE_SEND.MessageAttributes    #MESSAGE_ATTRS. Custom metadata
                                  #Max 10 items
MESSAGE_ATTRS.MESSAGE_ATTR        #ATTR_VALUE
                                  #MESSAGE_ATTR max 256 chars, [:alnum:]_-. and cannot start with . AWS. or Amazon.
MESSAGES_RCV.MessageAttributeNames#'MESSAGE_ATTR'_ARR to receive in MESSAGE_RCV_RES.MessageAttributes
                                  #Can be 'All' (def) or use *
MESSAGE_RCV_RES.MessageAttributes #MESSAGE_ATTRS

MESSAGE_SEND                      #SYS_ATTRS. Known metadata, with specific 'SYS_ATTR' documented in this doc
 .MessageSystemAttributes         #Computed by API, except for 'AWSTraceHeader'
SYS_ATTRS.SYS_ATTR                #ATTR_VALUE
MESSAGES_RCV                      #'SYS_ATTR'_ARR to set in MESSAGE_RCV.Attributes
 .MessageSystemAttributeNames     #Can be 'All' (def)
                                  #Cannot be 'AWSTraceHeader' nor 'SqsManagedSseEnabled'
MESSAGE_RCV_RES
 .Attributes.SYS_ATTR             #STR

ATTR_VALUE.DataType               #Value's type among 'String', 'Number' or 'Binary'
ATTR_VALUE.StringValue            #STR. Value, when DataType 'String|Number'
                                  #Must be URL encoded
ATTR_VALUE.BinaryValue            #STR. Value, when DataType 'Binary'
                                  #Must be base64'd

QUEUE_ATTRS.MaximumMessageSize    #NUM (in bytes, min 1KB, def|max 256KB)
                                  #Max size of MESSAGE_SEND

MESSAGE_SEND_RES.MD5OfMessageBody #MD5 'HASH' of 'MESSAGE_BODY', after URL|base64 decoding
MESSAGE_RCV_RES.MD5OfBody         #Meant for integrity checking
MESSAGE_SEND_RES|MESSAGE_RCV_RES
 .MD5OfMessageAttributes          #Same for MessageAttributes
MESSAGE_SEND_RES
 .MD5OfMessageSystemAttributes    #Same for MessageSystemAttributes

SYS_ATTRS.AWSTraceHeader          #STR. Set by user (unlike other SYS_ATTRS)

                                  ┌─────────────────┐
                                  │   CONTENT SDK   │
                                  └─────────────────┘

EXTENDED CLIENT LIBRARY ==>       #Client built on top of Java|Python SDK, that automatically uploads|downloads|cleans up
                                  #big payloads to S3, replacing MESSAGE_BODY with S3 URL
                                  #Only meant to get over the size limit, since it does not lower cost (replacing SQS costs with S3 costs)
                                  #Repository is awslabs/amazon-sqs-python|java-extended-client-lib
                                  #Shared logic with SNS extended client libary is at awslabs/payload-offloading-java-common-lib-for-aws

                                  ┌─────────────────┐
                                  │   CONTENT IAC   │
                                  └─────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: MaximumMessageSize

                                  ┌─────────────────────┐
                                  │   CONTENT METRICS   │
                                  └─────────────────────┘

AWS/SQS/SentMessageSize           #Total size of all MESSAGE_SENDs

                                  ┌─────────────┐
                                  │   POLLING   │
                                  └─────────────┘

QUEUE_ATTRS                       #NUM (in secs, def 0, max|recommended 20)
 .ReceiveMessageWaitTimeSeconds   #If no MESSAGE available, wait up to NUMs before returning
MESSAGES_RCV.WaitTimeSeconds      #I.e. long polling

                                  ┌─────────────────┐
                                  │   POLLING SDK   │
                                  └─────────────────┘

MESSAGES_RCV.WaitTimeSeconds      #Def: 20

                                  ┌─────────────────┐
                                  │   POLLING IAC   │
                                  └─────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: ReceiveMessageWaitTimeSeconds

                                  ┌─────────────────────┐
                                  │   POLLING METRICS   │
                                  └─────────────────────┘

AWS/SQS/NumberOfEmptyReceives     #NUM of ReceiveMessage*() that returned 0 MESSAGEs

                                  ┌──────────────┐
                                  │   TIMELINE   │
                                  └──────────────┘

QUEUE_ATTRS                       #NUM of MESSAGEs "stored", i.e. not received yet
 .ApproximateNumberOfMessages     #No limits

QUEUE_ATTRS|MESSAGE_SEND          #NUM (in secs, def: 0, max: 15m)
 .DelaySeconds                    #Period after MESSAGE sending when MESSAGE cannot be received
                                  #Not with FIFO QUEUEs
QUEUE_ATTRS.Approximate
 NumberOfMessagesDelayed          #NUM of delayed MESSAGEs

QUEUE_ATTRS|MESSAGES_RCV          #Max NUM (min 0, def 30s, max 12h) of secs for consumers to process a MESSAGE
 |MESSAGE_VSB.VisibilityTimeout   #I.e. like a processing lock
                                  #Period starts when MESSAGE is received
                                  #During that time, MESSAGE cannot be received again ("in-flight")
                                  #  - i.e. if too low, risk of multiple consumers receiving same MESSAGE
                                  #Once processed, MESSAGE must be deleted
                                  #Else, MESSAGE reception is considered failed ("poison pill")
                                  #  - i.e. if too high, slows down retrying failed consumption
                                  #Can increase processing time with ChangeMessageVisibility()
                                  #  - it sets VisibilityTimeout from the time it is called
QUEUE_ATTRS.Approximate           #NUM of in-flight MESSAGEs
 NumberOfMessagesNotVisible       #Max 12e4 (soft) if non-FIFO, 2e4 (hard) if FIFO

PREFETCHING ==>                   #Receiver can prefetch|buffer MESSAGEs
                                  #Pro: reduces latency
                                  #Con: must increase VisibilityTimeout so prefetched MESSAGEs do not fail

SYS_ATTRS.ApproximateReceiveCount #NUM of times this MESSAGE failed

QUEUE_ATTRS.MessageRetentionPeriod#NUM (in secs, min 1m, def 4d, max 14d)
                                  #Delete MESSAGEs older than NUMs
                                  #Updates impact existing MESSAGEs, and take up to 15m

PRICING ==>                       #None of the above impact pricing since storage is free

                                  ┌──────────────────┐
                                  │   TIMELINE API   │
                                  └──────────────────┘

ChangeMessageVisibility()         #Req: MESSAGE_VSB
                                  #Res: empty

                                  ┌──────────────────┐
                                  │   TIMELINE IAC   │
                                  └──────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: DelaySeconds, VisibilityTimeout, MessageRetentionPeriod

                                  ┌──────────────────────┐
                                  │   TIMELINE METRICS   │
                                  └──────────────────────┘

AWS/SQS/Approximate
 NumberOfMessagesDelayed
AWS/SQS/Approximate
 NumberOfMessages[Not]Visible     #QUEUE_ATTRS.*

AWS/SQS/                          #Age (NUM of seconds) of oldest MESSAGE
 ApproximateAgeOfOldestMessage    #If not FIFO, MESSAGEs that are retried 3+ times have their age reset
                                  #Excludes failed MESSAGEs

                                  ┌─────────────────┐
                                  │   DEAD-LETTER   │
                                  └─────────────────┘

QUEUE_ATTRS.RedrivePolicy         #'REDRIVE_POLICY_JSON'. Send failed MESSAGEs from this QUEUE ("source") to a dead-letter QUEUE2
REDRIVE_POLICY.deadLetterTargetArn#QUEUE2_ARN
                                  #Can be in different REGION|ACCOUNT, but less performant
REDRIVE_POLICY.maxReceiveCount    #NUM (def: 10) of MESSAGE failures before moving MESSAGE to dead-letter QUEUE2
                                  #I.e. max NUM of retries

QUEUE_ATTRS.RedriveAllowPolicy    #'REDRIVE_APOLICY_JSON'. Restrict which other QUEUE2 can use this QUEUE as dead-letter
                                  #Must be in same REGION + ACCOUNT, unless redrivePermission 'byQueue'
                                  #If QUEUE2 is [not] FIFO, so must be QUEUE
REDRIVE_APOLICY.redrivePermission #'allowAll' (def), 'denyAll' or 'byQueue'
REDRIVE_APOLICY.sourceQueueArns   #Specific 'QUEUE2_ARN'_ARR, when using redrivePermission 'byQueue'
                                  #Max 10 items

                                  ┌──────────────────────┐
                                  │   DEAD-LETTER AUTH   │
                                  └──────────────────────┘

PACTION sqs:SendMessage           #Must be allowed for the source QUEUE, on the dead-letter QUEUE2
PACTION sqs:GetQueueAttributes
 |ReceiveMessage
 |ChangeMessageVisibility
 |DeleteMessage                   #Must be allowed for dead-letter QUEUE2, on the source QUEUE

                                  ┌─────────────────────┐
                                  │   DEAD-LETTER API   │
                                  └─────────────────────┘

ListDeadLetterSourceQueues()      #Req: QUEUE
                                  #  - only QueueUrl
                                  #Res: QUEUE
                                  #  - only QueueUrl -> QueueUrls ARR

                                  ┌─────────────────────┐
                                  │   DEAD-LETTER IAC   │
                                  └─────────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: RedrivePolicy OBJ, RedriveAllowPolicy OBJ

                                  ┌──────────┐
                                  │   MOVE   │
                                  └──────────┘

MOVE                              #Move all MESSAGEs from a dead-letter QUEUE to another QUEUE2
                                  #E.g. back to source QUEUE2 to retry dead-letter MESSAGEs, after fixing the underlying problem
                                  #Max 1 per QUEUE at a time
MOVE.TaskHandle                   #'MOVE_MID'
MOVE.SourceArn                    #'QUEUE_ARN'. Must be dead-letter
MOVE.DestinationArn               #'QUEUE2_ARN'
                                  #Def: the dead-letter's source
MOVE.StartedTimestamp             #DATE_NUM

MOVE.Status                       #Among 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLING', 'CANCELLED'
                                  #Cancelling does not rollback
MOVE.FailureReason                #STR, when Status 'FAILED'

MOVE.MaxNumberOfMessagesPerSecond #NUM (def: undocumented, max: 500) of MESSAGEs per sec
MOVE
.ApproximateNumberOfMessagesToMove#Total NUM of MESSAGEs
MOVE
 .ApproximateNumberOfMessagesMoved#NUM of MESSAGEs moved

                                  ┌───────────────┐
                                  │   MOVE AUTH   │
                                  └───────────────┘

PACTION sqs:GetQueueAttributes    #Must be allowed for source QUEUE (using COND_KEY aws:SourceArn), on the dead-letter QUEUE2,
                                  #for Start|List|CancelMessageMoveTask()
PACTION
 sqs:ReceiveMessage|DeleteMessage #Same for Start|CancelMessageMoveTask()
PACTION sqs:SendMessage           #Same for StartMessageMoveTask()

                                  ┌──────────────┐
                                  │   MOVE API   │
                                  └──────────────┘

StartMessageMoveTask()            #Req: MOVE
                                  #  - only SourceArn, DestinationArn, MaxNumberOfMessagesPerSecond
                                  #Res: MOVE
                                  #  - only TaskHandle
ListMessageMoveTasks()            #Req: MOVE
                                  #  - only SourceArn
                                  #Res: Results MOVE_ARR
CancelMessageMoveTask()           #Req: MOVE
                                  #  - only TaskHandle
                                  #Res: MOVE
                                  #  - only ApproximateNumberOfMessagesMoved

                                  ┌───────────┐
                                  │   BATCH   │
                                  └───────────┘

BATCH.QueueUrl                    #'QUEUE_URL'
BATCH.Entries                     #BATCH_ENTRY_ARR
                                  #Max 10 items
BATCH_ENTRY.Id                    #'BATCH_ENTRY_MID'. Required
                                  #Max 80 chars, [:alnum:]_-
BATCH_ENTRY.*                     #With:
                                  #  - SendMessageBatch(): MESSAGE_SEND
                                  #  - DeleteMessageBatch(): MESSAGE_DELETE
                                  #  - ChangeMessageVisibilityBatch(): MESSAGE_VSB
                                  #No QueueUrl

BATCH_RES.Successful              #BATCH_SUCCESS_ARR
BATCH_SUCCESS.Id                  #'BATCH_ENTRY_MID'
BATCH_SUCCESS.*                   #MESSAGE_SEND_RES (only with SendMessageBatch())

BATCH_RES.Failed                  #BATCH_ERROR_ARR
BATCH_ERROR.Id                    #'BATCH_ENTRY_MID'
BATCH_ERROR.Code                  #'CODE'
BATCH_ERROR.Message               #'MESSAGE'
BATCH_ERROR.SenderFault           #BOOL. Whether caused by user or by API

QUEUE_ATTRS.MaximumMessageSize    #Is max size of whole BATCH

MESSAGES_RCV_RES.Messages         #MESSAGE_RCV_RES_ARR
MESSAGES_RCV.MaxNumberOfMessages  #NUM (min|def: 1, max|recommended: 10). Max size of MESSAGES_RCV_RES.Messages
                                  #Migh receive less, including 0, even when more are available

FIFO ==>                          #Within a batch, can process MESSAGEs in parallel
                                  #Throttling limit is per API call, i.e. eased by batching

BUFFERING ==>                     #Client can buffer:
                                  #  - holding SendMessage(), to increase batch size
                                  #  - prefetching ReceiveMessage(), to decrease latency to process MESSAGEs
                                  #Can be cased either on MESSAGE count threshold, or on duration frequency

                                  ┌────────────────┐
                                  │   BATCH AUTH   │
                                  └────────────────┘

PACTION sqs:SendMessage
 |DeleteMessage                   #Includes sqs:SendMessageBatch|DeleteMessageBatch|ChangeMessageVisibilityBatch()
 |ChangeMessageVisibility         #(which do not have their own PACTION)

                                  ┌───────────────┐
                                  │   BATCH API   │
                                  └───────────────┘

SendMessageBatch()                #Req: BATCH
                                  #Res: BATCH_RES
DeleteMessageBatch()              #Req: BATCH
                                  #Res: BATCH_RES
ChangeMessageVisibilityBatch()    #Req: BATCH
                                  #Res: BATCH_RES

                                  ┌────────────────────┐
                                  │   BATCH SDK JAVA   │
                                  └────────────────────┘

BUFFERED ASYNCHRONOUS CLIENT ==>  #AmazonSQSBufferedAsyncClient, part of Java SDK
                                  #Automatically batches SendMessage|DeleteMessage|ChangeMessageVisibility()
                                  #Also prefetches ReceiveMessage()
                                  #Not with FIFOs

                                  ┌───────────────────┐
                                  │   BATCH METRICS   │
                                  └───────────────────┘

AWS/SQS/SentMessageSize           #Is total size of whole BATCHs

                                  ┌───────────────┐
                                  │   MULTIPLEX   │
                                  └───────────────┘

TEMPORARY|VIRTUAL QUEUE ==>       #Logical namespace within a QUEUE, e.g. using a MESSAGE_ATTR, as opposed to a different QUEUE
                                  #Cheaper: no API calls to CRUD the QUEUE
                                  #For performance, should use distinct MESSAGE_GROUPs

REQUEST-RESPONSE QUEUE ==>        #Using one queue for input, another for output back to original consumer
                                  #Can use temporary queues to identify|trace client connection

                                  ┌────────────────────────┐
                                  │   MULTIPLEX SDK JAVA   │
                                  └────────────────────────┘

TEMPORARY QUEUE CLIENT ==>        #Built on top of Java SDK
                                  #Meant for request-response queue, using temporary queues
                                  #Repository is awslabs/amazon-sqs-java-temporary-queues-client

                                  ┌────────────────┐
                                  │   ENCRYPTION   │
                                  └────────────────┘

QUEUE_ATTRS|SYS_ATTRS             #BOOL (def: true). "SSE-SQS". Encrypts MESSAGE_BODY at rest using SQS-managed KMS key 'aws/sqs'
 .SqsManagedSseEnabled            #Does not encrypt other parts of MESSAGE.* (e.g. MESSAGE_ATTRS)
                                  #If using a dead-letter QUEUE2, uses source QUEUE's encryption settings:
                                  #  - if QUEUE encrypted but not QUEUE2, QUEUE2 won't decrypt it on ReceiveMessage()
                                  #  - if QUEUE2 encrypted but not QUEUE, MESSAGEs in QUEUE2 won't be encrypted
                                  #SendMessage|ReceiveMessage() cannot be anonymous

QUEUE_ATTRS.KmsMasterKeyId        #KMS_ID (def: none). "SSE-KMS". Same but with custom key

QUEUE_ATTRS
 .KmsDataKeyReusePeriodSeconds    #NUM of secs (min 1m, def 5m, max 1d) to re-use KMS data key, for performance and cost

                                  ┌─────────────────────┐
                                  │   ENCRYPTION AUTH   │
                                  └─────────────────────┘

PACTION                           #Must be allowed on
 kms:Decrypt|GenerateDataKey      #  - senders
                                  #  - receivers (kms:Decrypt only)
                                  #With SSE-SQS, automatically allowed to any PRINCIPAL in current ACCOUNT (not others)
                                  #Should use COND_KEY SourceArn|SourceAccount

                                  ┌────────────────────┐
                                  │   ENCRYPTION IAC   │
                                  └────────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: SqsManagedSseEnabled, KmsMasterKeyId, KmsDataKeyReusePeriodSeconds

                                  ┌────────────┐
                                  │   POLICY   │
                                  └────────────┘

QUEUE_ATTRS.Policy                #IAM 'POLICY_DOC'. QUEUE_POLICY
                                  #Resource-level on a QUEUE, i.e. Resource is QUEUE_ARN
                                  #Principal:
                                  #  - must be 'ACCOUNT_ID', which can worked around using either:
                                  #     - COND_KEY aws:PrincipalArn or aws:SourceArn|SourceAccount
                                  #     - identity-level POLICY instead
                                  #  - can be from another ACCOUNT
                                  #  - '*' allows anonymous requests
                                  #Max 8KB, 20 STATEMENTs, 50 PRINCIPALs, 7 PACTIONs, 10 COND_KEYs
                                  #Def: allow sqs:ReceiveMessage to any

PERMISSION                        #Sets QUEUE_ATTRS.Policy
PERMISSION.Label                  #STATEMENT.Sid
PERMISSION.QueueUrl               #'QUEUE_URL'. STATEMENT.Resource
PERMISSION.Actions                #'PACTION|*'_ARR. STATEMENT.Actions
PERMISSION.AWSAccountIds          #'ACCOUNT_ID'_ARR. STATEMENT.Principal
                                  #Required

SYS_ATTRS.SenderId                #USER_MID|ROLE_MID that called SendMessage*()

                                  ┌─────────────────┐
                                  │   POLICY AUTH   │
                                  └─────────────────┘

PACTION sqs:*Message*|PurgeQueue
 |GetQueue*                       #Only PACTIONs which can be cross-ACCOUNT
 |ListDeadLetterSourceQueues      #Not for *MessageMoveTask

PACTION sqs:AddPermission
 |RemovePermission                #Do not require PACTION sqs:SetQueueAttributes, even though they set QUEUE_ATTRS.Policy

root-task/S3UnlockQueuePolicy     #AWS managed POLICY. Allows sqs:Set|GetQueueAttributes and sqs:ListQueues|GetQueueUrl
                                  #Meant to fix QUEUE_POLICY that accidentally forbid all PRINCIPALs to sqs:SetQueueAttributes
                                  #See IAM doc for root-task/*

                                  ┌────────────────┐
                                  │   POLICY API   │
                                  └────────────────┘

AddPermission()                   #Req: PERMISSION
                                  #Res: empty
RemovePermission()                #Req: PERMISSION
                                  #  - only QueueUrl, Label
                                  #Res: empty

                                  ┌────────────────┐
                                  │   POLICY IAC   │
                                  └────────────────┘

AWS::SQS::QueueInlinePolicy       #RESPROPs: QueuePolicyDocument POLICY_DOC_OBJ, Queue 'QUEUE_URL'
                                  #Is QUEUE_ATTRS.Policy, i.e. resource-level
                                  #With Cloud Control, cannot list

AWS::SQS::QueuePolicy             #RESPROPs: QueuePolicyDocument POLICY_DOC_OBJ, Queue 'QUEUE_URL'_ARR
                                  #RESATTR: Id POLICY_MID
                                  #Is a MPOLICY, i.e. identity-level
                                  #With Cloud Control, cannot read|list

                                  ┌──────────┐
                                  │   TAGS   │
                                  └──────────┘

QUEUE_TAGS.QueueUrl               #'QUEUE_URL'
QUEUE.tags
QUEUE_TAGS.Tags                   #TAGS OBJ

                                  ┌──────────────┐
                                  │   TAGS API   │
                                  └──────────────┘

TagQueue()                        #Req: QUEUE_TAGS
                                  #Res: empty
ListQueueTags()                   #Req: QUEUE_TAGS
                                  #  - only QueueUrl
                                  #Res: QUEUE_TAGS
                                  #  - only Tags
UntagQueue()                      #Req: QUEUE_TAGS
                                  #  - Tags OBJ -> TagKeys STR_ARR
                                  #Res: empty

                                  ┌──────────────┐
                                  │   TAGS IAC   │
                                  └──────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: Tags TAG_PAIRS
