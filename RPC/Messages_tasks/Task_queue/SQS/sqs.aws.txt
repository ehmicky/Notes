
                                  ┏━━━━━━━━━┓
                                  ┃   SQS   ┃
                                  ┗━━━━━━━━━┛

VERSION ==>                       #2024-11-15

SUMMARY ==>                       #Queue: multiplex, policy
                                  #[Non-]FIFO: double processing, ordering, blocking, throttling, message groups
                                  #Message: send|receive|delete, body|attributes|system, retention, delay, batch, encryption
                                  #Receive: long polling, VisibillityTimeout
                                  #Dead letter: max failures, allow policy, redrive
                                  #Lambda: batch size, concurrency, filter, partial batch
                                  #Local

                                  ┌─────────┐
                                  │   API   │
                                  └─────────┘

NAME ==>                          #Simple Queue Service

SERVICE_DOMAIN                    #sqs.amazonaws.com

FORMAT ==>                        #X-Amz-Target: AmazonSQS.ACTION [C]
                                  #Request|response: JSON

REQ_ID                            #x-amzn-RequestId [S]

ERROR_OBJ                         #__type, message

LEGACY FORMAT ==>                 #SERVICE_DOMAIN is QUEUE_URL, i.e. SERVICE_DOMAIN/ACCOUNT_ID/QUEUE
                                  #  - except with CreateQueue(), ListQueues(), GetQueueUrl() and *MessageMoveTask*()
                                  #REQ.Action
                                  #Request: query string (ARR uses VAR.NUM)
                                  #Response: XML
                                  #REQ_ID: RES.ResponseMetadata.RequestId
                                  #ERROR_OBJ: Code, Message, Type
                                  #Slower

PAGINATION ==>                    #Uses REQ.MaxResults (def|max: 1e3) + REQ|RES.NextToken
                                  #Only REQ.MaxResults (def: 1, max: 10): ListMessageMoveTasks()
                                  #No pagination: ListQueueTags()

EVENTUAL CONSISTENCY ==>          #Updating|deleting take up to 1m
                                  #  - including *.Approximate*, which need that time to stabilize

PRICING ==>                       #1$ per 2.5e6 API calls
                                  #  - for any API call
                                  #     - including SendMessage(), SendMessageBatch(), ReceiveMessage(), DeleteMessage(), GetQueueUrl(), etc.
                                  #     - i.e. 1$ per 8e5 MESSAGEs (non-batched) or 8e6 MESSAGEs (batches)
                                  #        - since each MESSAGE requires SendMessage[Batch]() + ReceiveMessage() + DeleteMessage[Batch]()
                                  #  - free: 1e6/month
                                  #  - 25% more expensive with FIFO
                                  #  - 25% cheaper after 1e8 calls, 40% cheaper after 2e8 calls (with FIFO: 20%, 30%)
                                  #  - if request payload >64KB, (size % 64KB) times more expensive
                                  #1$ per 11GB of API's response payload
                                  #  - not request payload
                                  #  - free: first 15GB/month, shared with all other AWS services
                                  #  - 6% cheaper after 10TB, 22% after 50TB, 44% after 150TB
                                  #  - max 500 TB/month (soft)
                                  #  - free for EC2|Lambda to SQS, if same REGION
                                  #Recommendations:
                                  #  - mostly proportional to:
                                  #     - if MESSAGE|batch <12KB: NUM of MESSAGEs
                                  #     - else: size of MESSAGEs
                                  #  - use batches when sending, receiving and deleting
                                  #  - polling:
                                  #     - use long polling
                                  #     - reduce polling rate
                                  #     - avoid polling when no MESSAGEs available
                                  #  - avoid failed messages
                                  #     - fix underlying issue before dead-letter QUEUEs gets filled up
                                  #  - avoid duplicate sends

                                  ┌──────────┐
                                  │   AUTH   │
                                  └──────────┘

AmazonSQSFullAccess               #AWS managed POLICY. Grants all 'sqs:*' PACTIONs
AmazonSQSReadOnlyAccess           #Same but readonly

                                  ┌───────────┐
                                  │   QUEUE   │
                                  └───────────┘

QUEUE                             #CreateQueue() is idempotent, if using exact same QUEUE.*
                                  #DeleteQueue() removes all MESSAGEs
                                  #No limits on NUM of QUEUEs

QUEUE_ATTRS.QueueArn              #'QUEUE_ARN'. 'arn:aws:sqs:REGION:ACCOUNT_ID:QUEUE'
QUEUE.QueueUrl                    #QUEUE_URL. 'https://sqs.REGION.amazonaws.com/ACCOUNT_ID/QUEUE'
QUEUE.QueueName                   #'QUEUE'
                                  #Max 80 chars, [:alnum:]-_
QUEUE.QueueOwnerAWSAccountId      #'ACCOUNT_ID' (def: current)

QUEUE_ATTRS.CreatedTimestamp      #DATE_NUM
QUEUE_ATTRS.LastModifiedTimestamp #DATE_NUM

QUEUE.Attributes                  #QUEUE_ATTRS

                                  ┌────────────────┐
                                  │   QUEUE AUTH   │
                                  └────────────────┘

PACTION sqs:GetQueueAttributes
 |GetQueueUrl                     #Often allowed to senders|receivers

                                  ┌───────────────┐
                                  │   QUEUE API   │
                                  └───────────────┘

CreateQueue()                     #Req: QUEUE
                                  #  - no QueueUrl
                                  #  - only one with tags
                                  #  - no QUEUE_ATTRS: QueueArn, *Timestamp, Approximate*
                                  #Res: QUEUE
                                  #  - only QueueUrl
SetQueueAttributes()              #Req: QUEUE
                                  #  - only QueueUrl, Attributes (patch, not full replace)
                                  #  - no QUEUE_ATTRS: QueueArn, *Timestamp, Approximate*, FifoQueue
                                  #Res: empty
GetQueueAttributes()              #Req: QUEUE
                                  #  - only QueueUrl, Attributes -> AttributeNames 'PROP'_ARR or ['All'] (def: [])
                                  #Res: QUEUE
                                  #  - only Attributes
GetQueueUrl()                     #Req: QUEUE
                                  #  - only QueueName
                                  #  - only one with QueueOwnerAWSAccountId
                                  #Res: QUEUE
                                  #  - only QueueUrl
ListQueues()                      #Req: QUEUE
                                  #  - only QueueName -> QueueNamePrefix
                                  #Res: QUEUE
                                  #  - only QueueUrl -> QueueUrls ARR
DeleteQueue()                     #Req: QUEUE
                                  #  - only QueueUrl
                                  #Res: empty

                                  ┌───────────────┐
                                  │   QUEUE SDK   │
                                  └───────────────┘

COPTS.useQueueUrlAsEndpoint       #BOOL (def: true). If false, allow setting PARAMS.QueueUrl 'QUEUE' (instead of 'QUEUE_URL')

                                  ┌──────────────────────┐
                                  │   QUEUE SDK PYTHON   │
                                  └──────────────────────┘

sqs-workers                       #Python client with many features: polling, batched sends|writes, etc.
                                  #Not documented yet

                                  ┌───────────────┐
                                  │   QUEUE IAC   │
                                  └───────────────┘

AWS::SQS::Queue                   #RESPROPs: QueueName
                                  #  - def|recommended: random ID
                                  #  - if provided, cannot set QUEUE.FifoQueue
                                  #RESATTRs:
                                  #  - Arn, QueueName
                                  #  - QueueUrl: returned by { Ref }

new Queue(...CARGS[, CQUEUE_OPTS])#CQUEUE
Queue.fromQueueAttributes         #Using OPTS:
 (...CARGS, OPTS)->ICQUEUE        #  - queueArn 'QUEUE_ARN': required
                                  #  - queueName, queueUrl: def guessed from queueArn
                                  #  - keyArn 'KMS_KEY_ARN'
                                  #  - fifo BOOL
Queue.fromQueueArn
 (...CARGS, 'QUEUE_ARN')->ICQUEUE #Same but only setting OPTS.queueArn

ICQUEUE.queueArn                  #'QUEUE_ARN'[_TK]
ICQUEUE.queueUrl                  #'QUEUE_URL', as a CFNREF_STR_TK resolving to { Ref }
CQUEUE_OPTS.queueName             #QUEUE.*
ICQUEUE.queueName                 #'QUEUE'[_TK]
CQUEUE_OPTS.removalPolicy         #Passed to CZRESOURCE.applyRemovalPolicy()
                                  #Def: RemovalPolicy.DESTROY

CQUEUE.grantSendMessages
 |grantConsumeMessages|grantPurge
 (...)                            #See below. Also allows sqs:GetQueueAttributes|GetQueueUrl

                                  ┌────────────────────┐
                                  │   QUEUE COMPOSER   │
                                  └────────────────────┘

QUEUE ENHANCED COMPOSER ==>       #For QUEUE

                                  ┌───────────────────┐
                                  │   QUEUE METRICS   │
                                  └───────────────────┘

DVAR QueueName                    #'QUEUE', sent with all METRICs
                                  #QUEUE is also sent as a metric TELEMETRY_ENTITY

INACTIVE QUEUE ==>                #QUEUE without any API calls for 6h+
                                  #Does not send any more METRICs
                                  #API calls includes GetQueueAttributes(), i.e. can be used to re-activate
                                  #Re-activating takes up to 15m

                                  ┌───────────────────────┐
                                  │   QUEUE METRICS IAC   │
                                  └───────────────────────┘

ICQUEUE.metric
 ('METRIC'[, CMETRIC_OPTS])
 ->CMETRIC                        #Also sets DVAR QueueName

CFACADE.monitorQueue
 (CXMONITORING_OPTS)              #See cdk-monitoring-constructs doc
CXMONITORING_OPTS.queue           #ICQUEUE

CFACADE.monitorQueueWithDlq       #Same but, for the dead-letter QUEUE2, adds:
 (CXMONITORING_OPTS)              #  - METRICs|WIDGETs for ApproximateNumberOfMessagesVisible (max), NumberOfMessagesSent (sum),
                                  #    ApproximateAgeOfOldestMessage
                                  #  - MALARMs QueueMaxSize, QueueMaxIncomingMessages, QueueMaxMessageAge
                                  #     - name prepended with 'DeadLetter'
CXMONITORING_OPTS.queue           #ICQUEUE
CXMONITORING_OPTS.deadLetterQueue #ICQUEUE2
CXMONITORING_OPTS.addDeadLetter
 QueueToSummaryDashboard          #BOOL (def: false). Whether to include WIDGETs in summary CDASHBOARD

                                  ┌───────────────────┐
                                  │   QUEUE LOGGING   │
                                  └───────────────────┘

CLOUDTRAIL ==>                    #GetQueue*() and List*Queue*() are not logged by CloudTrail

                                  ┌──────────────┐
                                  │   NON-FIFO   │
                                  └──────────────┘

STANDARD QUEUE ==>                #Non-FIFO QUEUE
                                  #Preferred unless either:
                                  #  - processing cannot be idempotent
                                  #  - delivery has to be exactly ordered
                                  #All of the features below are the opposite with FIFOs

THROTTLING ==>                    #Pro. No throttling

PROCESSING ==>                    #Pro. Receivers can process MESSAGEs in parallel

ORDER ==>                         #Con. Best effort, might be out-of-order

AT-MOST ONCE PROCESSING ==>       #Con. Processing must be idempotent due to following risks:
                                  #double sending|receiving|storing|processing
                                  #All result in a MESSAGE:
                                  #  - sent with 1 SendMessage()
                                  #  - processed by 2 ReceiveMessage()
                                  #FIFO does not have those problems, i.e. has exactly-once processing
                                  #  - except double processing risk, but mitigated with high enough VisibilityTimeout
DOUBLE SENDING ==>                #Either:
                                  #  - 2 concurrent senders at the same time
                                  #  - sending fails (e.g. network error) and is repeated
MISSED RECEIVING ==>              #ReceiveMessage() fails (e.g. network error) but API acknowledged it
                                  #When repeated, MESSAGE is now considered already received,
                                  #I.e. client never received it and cannot process it
DOUBLE STORING ==>                #If an AZ goes down, while other AZs are up and deliver that MESSAGE
                                  #I.e. the former does not know that MESSAGE was already delivered
                                  #As opposed to FIFO, which can determine where it left thanks to order
DOUBLE PROCESSING ==>             #When VisibilityTimeout too low, i.e. second receivers starts while another is ongoing

                                  ┌──────────┐
                                  │   FIFO   │
                                  └──────────┘

QUEUE_ATTRS.FifoQueue             #BOOL (def: false). Whether is FIFO QUEUE
                                  #'QUEUE' must end with '.fifo'
                                  #Everything in this section is only for FIFO

ORDER ==>                         #Ensures that receiving order is same as sending order

MESSAGE|SYS_ATTRS.MessageGroupId  #'MESSAGE_GROUP_ID'. FIFO ordering applies per-MESSAGE_GROUP
                                  #I.e. MESSAGE_GROUPs are interleaved
                                  #Receivers cannot select MESSAGE_GROUPs, they get random ones
                                  #High NUM of MESSAGE_GROUPs has better performance:
                                  #  - higher parallelism for receivers, since VisibilityTimeout locks per-MESSAGE_GROUP
                                  #  - lower throttling, when it is per-MESSAGE_GROUP
                                  #Required
                                  #Max 128 chars, [:graph:]
                                  #No limits on NUM of MESSAGE_GROUPs
MESSAGE_RES|SYS_ATTRS             #'NUM'. Increases monotonically (but not consecutively) per MESSAGE within a given MESSAGE_GROUP
 .SequenceNumber                  #Always 16 chars

MESSAGE|SYS_ATTRS                 #'MESSAGE_DID'. If 2 SendMessage*() with the same MESSAGE_DID are sent:
 .MessageDeduplicationId          #  - within 5m
                                  #  - then only the first successful one is used
                                  #I.e. avoid double sending (see above)
                                  #Continues working even after MESSAGE has been received and|or deleted
                                  #Required
                                  #Max 128 chars, [:graph:]
QUEUE_ATTRS
 .ContentBasedDeduplication       #BOOL (def: false). Make MESSAGE_DID default to SHA-256 of 'MESSAGE_BODY'
QUEUE_ATTRS.DeduplicationScope    #Whether to namespace MESSAGE_DID with MESSAGE_GROUP_ID: 'queue' (no), 'messageGroup' (yes)

PROCESSING ==>                    #VisibilityTimeout locks the whole MESSAGE_GROUP, not just the MESSAGE
                                  #I.e. each MESSAGE_GROUP is processed by at most once ReceiveMessage() at a time
                                  #  - but one ReceiveMessage() might be processing multiple MESSAGE_GROUPs at a time
                                  #Receiver must process MESSAGEs serially, within a given MESSAGE_GROUP
                                  #I.e. failed MESSAGEs prevent further consumption of their MESSAGE_GROUP
                                  #  - if no dead-letter QUEUE2, completely blocks it
                                  #If all MESSAGE_GROUPs are in-flight, ReceiveMessage() will be return empty

MESSAGES_RCV                      #'MESSAGE_RCV_DID'. If 2 ReceiveMessage*() with the same MESSAGE_RCV_DID are sent:
 .ReceiveRequestAttemptId         #  - within min(5m, VisibilityTimeout)
                                  #  - then the second one is not impacted by the VisibilityTimeout lock from the first
                                  #I.e. avoid missed receiving (see above)
                                  #Not if ChangeMessageVisibility() or DeleteMessage() already called
                                  #Optional but recommends setting a unique one per request, re-using it on network retries
                                  #Max 128 chars, [:graph:]

QUEUE_ATTRS.FifoThroughputLimit   #Throttles either:
                                  #  - 'perQueue' (def): max 300 (hard) SendMessage[Batch]() per second per QUEUE
                                  #  - 'perMessageGroupId' (recommended):
                                  #     - max 7e4 (soft, REGION-specific) SendMessage[Batch]() per second per MESSAGE_GROUP
                                  #     - requires QUEUE_ATTRS.DeduplicationScope 'messageGroup'
                                  #The same quota applies separately for DeleteMessage[Batch]() and for ReceiveMessage()

                                  ┌──────────────┐
                                  │   FIFO IAC   │
                                  └──────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: FifoQueue true|undefined, ContentBasedDeduplication, DeduplicationScope, FifoThroughputLimit

ICQUEUE[_OPTS].fifo               #BOOL. QUEUE.FifoQueue
                                  #Def: true if 'QUEUE' ends with '.fifo' or if QUEUE.*Deduplication*|FifoThroughputLimit set
CQUEUE_OPTS
 .contentBasedDeduplication
 |deduplicationScope
 |fifoThroughputLimit             #QUEUE_ATTRS.*

                                  ┌──────────────────┐
                                  │   FIFO METRICS   │
                                  └──────────────────┘

AWS/SQS/ApproximateNumberOfGroups
 WithInflightMessages             #NUM of MESSAGE_GROUPs with in-flight MESSAGEs
AWS/SQS/
 NumberOfDeduplicatedSentMessages #NUM of duplicate sends ignored thanks to MESSAGE_DID

                                  ┌─────────────┐
                                  │   MESSAGE   │
                                  └─────────────┘

MESSAGE_DELETE                    #PurgeQueue() deletes all MESSAGEs
                                  #DeleteMessage*() is idempotent, i.e. duplicate deletions are allowed
                                  #  - whether with same MESSAGE_RCV_MID (i.e. same retry) or not

MESSAGE[_RCV|DELETE|VSB].QueueUrl #'QUEUE_URL'

SYS_ATTRS.SentTimestamp           #DATE_NUM of first SendMessage()
SYS_ATTRS
 .ApproximateFirstReceiveTimestamp#DATE_NUM of first ReceiveMessage()

MESSAGE[_RCV]_RES.MessageId       #'MESSAGE_MID'
MESSAGE_RCV_RES|MESSAGE_DELETE    #'MESSAGE_RCV_MID'
 |MESSAGE_VSB.ReceiptHandle       #Created during ReceiveMessage(), used by ChangeMessageVisibility|DeleteMessage()
                                  #If multiple ReceiveMessage() for a given MESSAGE, ChangeMessageVisibility|DeleteMessage()
                                  #must use the most recent 'MESSAGE_RCV_MID'

DATA REDUNDANCY ==>               #MESSAGEs are replicated on multiple AZs
                                  #Fot both FIFO and non-FIFO

                                  ┌──────────────────┐
                                  │   MESSAGE AUTH   │
                                  └──────────────────┘

PACTION sqs:ReceiveMessage
 |ChangeMessageVisibility
 |DeleteMessage                   #Should all be allowed to receivers

                                  ┌─────────────────┐
                                  │   MESSAGE API   │
                                  └─────────────────┘

SendMessage()                     #Req: MESSAGE
                                  #Res: MESSAGE_RES
ReceiveMessage()                  #Req: MESSAGES_RCV
                                  #Res: MESSAGES_RCV_RES
DeleteMessage()                   #Req: MESSAGE_DELETE
                                  #Res: empty
PurgeQueue()                      #Res: MESSAGE_DELETE
                                  #  - only QueueUrl
                                  #Res: empty

                                  ┌──────────────────────┐
                                  │   MESSAGE SDK JAVA   │
                                  └──────────────────────┘

JMS CLIENT ==>                    #"Java Messaging Library"
                                  #Client built on top of Java SDK, to make it compatible with JMS,
                                  #which is a Java-specific Messaging API
                                  #Repository is awslabs/amazon-sqs-java-messaging-lib

                                  ┌─────────────────┐
                                  │   MESSAGE SAM   │
                                  └─────────────────┘

sam remote invoke ['QUEUE']       #Calls SendMessage()
                                  #Def: guessed if only one possible in current STACK

--event|-e                        #'MESSAGE_BODY' (def: '')
--event-file                      #Same but as 'FILE' or '-' (stdin)

--parameter                       #'PARAM=VAL ...'. REQ.*
                                  #Always sets REQ.QueueUrl
                                  #If set, REQ.Message[System]Attributes must be 'JSON'

--output                          #Either 'text' (def) or 'json'

                                  ┌─────────────────┐
                                  │   MESSAGE IAC   │
                                  └─────────────────┘

CQUEUE.grantSendMessages
 (YGRANTABLE)->CGRANT             #Allows sqs:SendMessage
CQUEUE.grantConsumeMessages
 (YGRANTABLE)->CGRANT             #Allows sqs:ReceiveMessage|ChangeMessageVisibility|DeleteMessage
CQUEUE.grantPurge
 (YGRANTABLE)->CGRANT             #Allows sqs:PurgeQueue

                                  ┌─────────────────────┐
                                  │   MESSAGE METRICS   │
                                  └─────────────────────┘

AWS/SQS/NumberOfMessagesSent      #NUM of MESSAGEs sent
                                  #Includes duplicate sends
                                  #If DLQ
                                  #  - only MESSAGEs sent manually, not through dead-letter mechanism
                                  #  - i.e. should use use AWS/SQS/ApproximateNumberOfMessages[Not]Visible instead
                                  #cdk-monitoring-constructs:
                                  #  - sum: METRIC, summary WIDGET, MALARM QueueMin|MaxIncomingMessages < CXALARM_OPTS.min|maxIncomingMessagesCount
                                  #  - rate: METRIC, summary WIDGET

AWS/SQS/NumberOfMessagesReceived  #NUM of MESSAGEs received
                                  #Includes retries

AWS/SQS/NumberOfMessagesDeleted   #NUM of MESSAGEs deleted
                                  #Includes duplicate deletions
                                  #cdk-monitoring-constructs:
                                  #  - sum: METRIC
                                  #  - rate: METRIC, summary WIDGET

                                  ┌─────────────────────────┐
                                  │   MESSAGE METRICS IAC   │
                                  └─────────────────────────┘

ICQUEUE.metricNumberOfMessagesSent
 |metricNumberOfMessagesReceived
 |metricNumberOfMessagesDeleted
 ([CMETRIC_OPTS])->CMETRIC        #Use statistic 'Sum'

                                  ┌─────────────────────┐
                                  │   MESSAGE LOGGING   │
                                  └─────────────────────┘

CLOUDTRAIL ==>                    #*Message*() (except *MessageMoveTask*()) are logged with CloudTrail as data EVENTs
                                  #QUEUE is LOG_RESOURCE

                                  ┌─────────────────┐
                                  │   MESSAGE SAM   │
                                  └─────────────────┘

SQSSendMessagePolicy              #SAM POLICY_TEMPLATE (see its doc) that allows:
                                  #  - PACTION sqs:SendMessage*
                                  #  - on 'QUEUE'
                                  #     - using POLICY_TEMPLATE_PARAMS.QueueName

SQSPollerPolicy                   #SAM POLICY_TEMPLATE (see its doc) that allows:
                                  #  - PACTION sqs:ChangeMessageVisibility[Batch]|DeleteMessage[Batch]
                                  #    |GetQueueAttributes|ReceiveMessage
                                  #  - on 'QUEUE'
                                  #     - using POLICY_TEMPLATE_PARAMS.QueueName

AWS::Serverless::Connector        #Can be used with:
                                  #  - Source: FUNCTION (RESOURCE_REF.RoleName)
                                  #  - Destination: QUEUE (RESOURCE_REF.Arn)
                                  #  - Permissions 'Read' and|or 'Write'
                                  #Transformed to a MPOLICY on 'ROLE':
                                  #  - allowing:
                                  #     - Read: sqs:ReceiveMessage|GetQueueAttributes
                                  #     - Write: sqs:DeleteMessage|SendMessage|ChangeMessageVisibility|PurgeQueue
                                  #  - on QUEUE

                                  ┌─────────────┐
                                  │   CONTENT   │
                                  └─────────────┘

MESSAGE.MessageBody
MESSAGE_RCV_RES.Body              #'MESSAGE_BODY'

MESSAGE.MessageAttributes         #MESSAGE_ATTRS. Custom metadata
                                  #Max 10 items
MESSAGE_ATTRS.MESSAGE_ATTR        #ATTR_VALUE
                                  #MESSAGE_ATTR max 256 chars, [:alnum:]_-. and cannot start with . AWS. or Amazon.
MESSAGES_RCV.MessageAttributeNames#'MESSAGE_ATTR'_ARR (def: []) to receive in MESSAGE_RCV_RES.MessageAttributes
                                  #Can be 'All' or use *
MESSAGE_RCV_RES.MessageAttributes #MESSAGE_ATTRS

MESSAGE.MessageSystemAttributes   #SYS_ATTRS. Known metadata, with specific 'SYS_ATTR' documented in this doc
                                  #Computed by API, except for 'AWSTraceHeader'
SYS_ATTRS.SYS_ATTR                #ATTR_VALUE
MESSAGES_RCV                      #'SYS_ATTR'_ARR (def: []) to set in MESSAGE_RCV.Attributes
 .MessageSystemAttributeNames     #Can be 'All'
                                  #Cannot be 'AWSTraceHeader' nor 'SqsManagedSseEnabled'
MESSAGE_RCV_RES
 .Attributes.SYS_ATTR             #STR

ATTR_VALUE.DataType               #Value's type among 'String', 'Number' or 'Binary'
                                  #Can append with any '.DESCRIPTION', e.g. 'Number.float', max 256 chars
ATTR_VALUE.StringValue            #STR. Value, when DataType 'String|Number'
                                  #'NUM' must be single-precision float
ATTR_VALUE.BinaryValue            #STR. Value, when DataType 'Binary'
                                  #Must be base64'd

QUEUE_ATTRS.MaximumMessageSize    #NUM (in bytes, min 1KB, def|max 256KB)
                                  #Max size of MESSAGE

MESSAGE_RES.MD5OfMessageBody      #MD5 'HASH' of 'MESSAGE_BODY', after base64 decoding
MESSAGE_RCV_RES.MD5OfBody         #Meant for integrity checking
MESSAGE[_RCV]_RES                 #Same for MessageAttributes
 .MD5OfMessageAttributes          #Computation:
                                  #  - concatenation of all MESSAGE_ATTRs
                                  #     - sorted by 'MESSAGE_ATTR'
                                  #  - each MESSAGE_ATTR concatenates:
                                  #     - 'MESSAGE_ATTR'
                                  #     - DataType
                                  #     - DataType === 'Binary'
                                  #     - StringValue|BinaryValue
                                  #  - each of those is encoded as:
                                  #     - 4 bytes for length, then value
                                  #     - for `DataType === 'Binary'`: single byte 1 (not Binary) or 2 (Binary)
MESSAGE_RES
 .MD5OfMessageSystemAttributes    #Same for MessageSystemAttributes

SYS_ATTRS.AWSTraceHeader          #STR. Set by user (unlike other SYS_ATTRS)

                                  ┌─────────────────┐
                                  │   CONTENT SDK   │
                                  └─────────────────┘

ATTR_VALUE.BinaryValue            #INPUT_BLOB|OUTPUT_BLOB

@aws-sdk/middleware-sdk-sqs       #MFUNC used internally for COPTS.md5|useQueueUrlAsEndpoint
COPTS.md5                         #undefined (def) or false. Cannot be true, although undefined means true
                                  #Automatically validates MESSAGE_RES.MD5OfMessageBody and MESSAGE_RCV_RES.MD5OfBody

EXTENDED CLIENT LIBRARY ==>       #Client built on top of Java|Python SDK, that automatically uploads|downloads|cleans up
                                  #big payloads to S3, replacing MESSAGE_BODY with S3 URL
                                  #Only meant to get over the size limit, since it does not lower cost (replacing SQS costs with S3 costs)
                                  #Repository is awslabs/amazon-sqs-python|java-extended-client-lib
                                  #Shared logic with SNS extended client libary is at awslabs/payload-offloading-java-common-lib-for-aws

                                  ┌─────────────────┐
                                  │   CONTENT IAC   │
                                  └─────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: MaximumMessageSize

CQUEUE_OPTS.maxMessageSizeBytes   #NUM. QUEUE_ATTRS.MaximumMessageSize

                                  ┌─────────────────────┐
                                  │   CONTENT METRICS   │
                                  └─────────────────────┘

AWS/SQS/SentMessageSize           #Total size of all MESSAGEs
                                  #cdk-monitoring-constructs:
                                  #  - average: METRIC, WIDGET

                                  ┌─────────────────────────┐
                                  │   CONTENT METRICS IAC   │
                                  └─────────────────────────┘

ICQUEUE.metricSentMessageSize
 ([CMETRIC_OPTS])->CMETRIC        #Uses statistic 'Average'

                                  ┌─────────────┐
                                  │   POLLING   │
                                  └─────────────┘

QUEUE_ATTRS                       #NUM (in secs, def 0, max|recommended 20)
 .ReceiveMessageWaitTimeSeconds   #If no MESSAGE available, wait up to NUMs before returning
MESSAGES_RCV.WaitTimeSeconds      #I.e. long polling
                                  #Must be > client's HTTP request timeout

BACKOFF ==>                       #For cost and throttling, it is recommended to wait some time after ReceiveMessage() either:
                                  #  - returns 0 MESSAGEs
                                  #  - has an AWS_ERROR (including timeout, auth, network, etc.)

                                  ┌─────────────────┐
                                  │   POLLING SDK   │
                                  └─────────────────┘

MESSAGES_RCV.WaitTimeSeconds      #Def: 20

                                  ┌─────────────────┐
                                  │   POLLING IAC   │
                                  └─────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: ReceiveMessageWaitTimeSeconds

CQUEUE_OPTS.receiveMessageWaitTime#DURATION. QUEUE_ATTRS.ReceiveMessageWaitTimeSeconds

                                  ┌─────────────────────┐
                                  │   POLLING METRICS   │
                                  └─────────────────────┘

AWS/SQS/NumberOfEmptyReceives     #NUM of ReceiveMessage*() that returned 0 MESSAGEs

                                  ┌─────────────────────────┐
                                  │   POLLING METRICS IAC   │
                                  └─────────────────────────┘

ICQUEUE
 .metricNumberOfEmptyReceives
 ([CMETRIC_OPTS])->CMETRIC        #Uses statistic 'Sum'

                                  ┌───────────────┐
                                  │   RETENTION   │
                                  └───────────────┘

QUEUE_ATTRS                       #NUM of MESSAGEs "stored", i.e. not received yet
 .ApproximateNumberOfMessages     #No limits

QUEUE_ATTRS.MessageRetentionPeriod#NUM (in secs, min 1m, def 4d, max 14d)
                                  #Delete MESSAGEs older than NUMs
                                  #When updating:
                                  #  - take up to 15m
                                  #  - might delete existing MESSAGEs, if under the threshold
                                  #If DLQ + non-FIFO, includes time spent in source QUEUE
                                  #  - i.e. MessageRetentionPeriod should be > source QUEUE's, to avoid risk of expiring right away
                                  #Recommends max value for DLQs
                                  #Does not impact pricing since storage is free

                                  ┌───────────────────┐
                                  │   RETENTION IAC   │
                                  └───────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: MessageRetentionPeriod

CQUEUE_OPTS.retentionPeriod       #DURATION. QUEUE_ATTRS.MessageRetentionPeriod

                                  ┌───────────────────────┐
                                  │   RETENTION METRICS   │
                                  └───────────────────────┘

AWS/SQS/                          #Age (NUM of seconds) of oldest MESSAGE
 ApproximateAgeOfOldestMessage    #If not FIFO, MESSAGEs that fail 3 times have their age reset
                                  #If DLQ, based on when sent to DLQ (not source QUEUE), regardless of whether FIFO or not
                                  #Excludes failed MESSAGEs
                                  #cdk-monitoring-constructs:
                                  #  - max: METRIC, summary WIDGET, MALARM QueueMaxMessageAge > CXALARM_OPTS.maxAgeInSeconds

                                  ┌───────────────────────────┐
                                  │   RETENTION METRICS IAC   │
                                  └───────────────────────────┘

ICQUEUE
 .ApproximateAgeOfOldestMessage
 ([CMETRIC_OPTS])->CMETRIC        #Uses statistic 'Maximum'

                                  ┌────────────────────┐
                                  │   RETENTION LINT   │
                                  └────────────────────┘

cfn-lint I3013                    #Must explicitely set QUEUE_ATTRS.MessageRetentionPeriod

                                  ┌───────────┐
                                  │   DELAY   │
                                  └───────────┘

QUEUE_ATTRS.DelaySeconds          #NUM (in secs, def: 0, max: 15m)
                                  #Period after MESSAGE sending when MESSAGE cannot be received
                                  #Updates are applied on existing MESSAGEs with FIFO, but not with non-FIFO
MESSAGE.DelaySeconds              #Same for individual MESSAGE
                                  #Not with FIFO QUEUEs
                                  #Named "message timer"
QUEUE_ATTRS.Approximate
 NumberOfMessagesDelayed          #NUM of delayed MESSAGEs

                                  ┌───────────────┐
                                  │   DELAY IAC   │
                                  └───────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: DelaySeconds

CQUEUE_OPTS.deliveryDelay         #DURATION. QUEUE_ATTRS.DelaySeconds

                                  ┌───────────────────┐
                                  │   DELAY METRICS   │
                                  └───────────────────┘

AWS/SQS/Approximate
 NumberOfMessagesDelayed          #QUEUE_ATTRS.ApproximateNumberOfMessagesDelayed

                                  ┌───────────────────────┐
                                  │   DELAY METRICS IAC   │
                                  └───────────────────────┘

ICQUEUE.metricApproximateNumberOf
 MessagesDelayed([CMETRIC_OPTS])
 ->CMETRIC                        #Uses statistic 'Maximum'

                                  ┌────────────────┐
                                  │   VISIBILITY   │
                                  └────────────────┘

QUEUE_ATTRS|MESSAGES_RCV          #NUM (min 0, def 30s, max 12h)
 |MESSAGE_VSB.VisibilityTimeout   #Locks MESSAGE for NUM secs after each ReceiveMessage()
                                  #During that time, any other ReceiveMessage() will not receive that MESSAGE
                                  #Must be > max duration to:
                                  #  - resolve ReceiveMessage(), including:
                                  #     - HTTP request timeout, e.g. SOPTS.requestTimeout or --cli-read-timeout
                                  #     - throttling and retries
                                  #  - process the MESSAGE
                                  #Used on both first ReceiveMessage() and any retry

IN-FLIGHT MESSAGE ==>             #MESSAGE under VisibilityTimeout lock
                                  #This prevents multiple receivers receiving same MESSAGE
                                  #I.e. if VisibilityTimeout too low, risk of double processing
QUEUE_ATTRS.Approximate           #NUM of in-flight MESSAGEs
 NumberOfMessagesNotVisible       #Max 12e4 (soft) if non-FIFO, 2e4 (hard) if FIFO
                                  #To go over the limit, can create additional QUEUEs

PROCESSING SUCCESS ==>            #Must call DeleteMessage() to acknowledge success

PROCESSING EXTENSION ==>          #Can increase processing time with ChangeMessageVisibility()
                                  #It sets VisibilityTimeout from the time it is called
                                  #E.g. using the same VisibilityTimeout restarts it
                                  #Max value is 12h - (time spent since ReceiveMessage())

PROCESSING TIMEOUT ==>            #When VisibilityTimeout reached before DeleteMessage()
                                  #MESSAGE is considered failed ("poison pill")
                                  #Other receivers can now retry that MESSAGE though

PROCESSING FAILURE ==>            #If processing failed, should ChangeMessageVisibility()
                                  #  - as opposed to processing timing out, i.e. before VisibilityTimeout
                                  #This sets the min duration before next retry
                                  #Can be 0 to allow retries right away
                                  #Recommended, else the VisibilityTimeout left would be used instead
                                  #  - would depend on time spent before processing failed
                                  #  - i.e. might not be the most optimal duration to retry
                                  #I.e. if VisibilityTimeout too high, it slows down retries when ChangeMessageVisibility() could not be called
                                  #  - e.g. due to unknown errors|bugs
SYS_ATTRS.ApproximateReceiveCount #NUM of times this MESSAGE was returned by ReceiveMessage()

HEARTBEAT ==>                     #Calling ChangeMessageVisibility() at regular intervals
                                  #Typically using same VisibilityTimeout, and at frequency a little lower than VisibilityTimeout
                                  #Pros:
                                  #  - works with unknown (or hard to estimate) max processing time
                                  #  - allows VisibilityTimeout to be short, i.e. fast retry on unknown error|bug or ghost receive
                                  #Cons:
                                  #  - cost of additional ChangeVisibilityTimeout() calls
                                  #  - might require separate logic for processing timeout
                                  #     - which would then call ChangeVisibilityTimeout() with 0

GHOST RECEIVE ==>                 #In rare occasions, ReceiveMessage() might:
                                  #  - fetch a MESSAGE and start its VisibilityTimeout
                                  #  - but not return it as MESSAGE_RES
                                  #  - due to API internal problems
                                  #Receiver cannot know, i.e. MESSAGE will fail once VisibilityTimeout expires

FIFO ==>                          #The whole MESSAGE_GROUP is locked instead, not just the MESSAGE
                                  #I.e. processing that MESSAGE_GROUP is blocked

PREFETCHING ==>                   #Receiver can prefetch|buffer MESSAGEs
                                  #Pro: reduces latency
                                  #Con: must increase VisibilityTimeout so prefetched MESSAGEs do not fail

DIFFERENT VISIBILITY TIMEOUTS ==> #Some MESSAGEs might have different optimal VisibilityTimeout than others
                                  #Then it is recommended to use multiple QUEUEs with different VisibilityTimeout
                                  #As opposed to setting MESSAGES_RCV.VisibilityTimeout
                                  #Reason: more uniform flow|metrics for each QUEUE

                                  ┌────────────────────┐
                                  │   VISIBILITY API   │
                                  └────────────────────┘

ChangeMessageVisibility()         #Req: MESSAGE_VSB
                                  #Res: empty

                                  ┌────────────────────┐
                                  │   VISIBILITY IAC   │
                                  └────────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: VisibilityTimeout

CQUEUE_OPTS.visibilityTimeout     #DURATION. QUEUE_ATTRS.VisibillityTimeout

                                  ┌────────────────────────┐
                                  │   VISIBILITY METRICS   │
                                  └────────────────────────┘

AWS/SQS/Approximate
 NumberOfMessagesNotVisible       #QUEUE_ATTRS.ApproximateNumberOfMessagesNotVisible

AWS/SQS/Approximate               #QUEUE_ATTRS.ApproximateNumberOfMessages - QUEUE_ATTRS.ApproximateNumberOfMessagesNotVisible
 NumberOfMessagesVisible          #cdk-monitoring-constructs:
                                  #  - max: METRIC, summary WIDGET, MALARM QueueMin|MaxSize <|> CXALARM_OPTS.min|maxMessageCount
                                  #  - draining rate (in secs):
                                  #     - METRIC, summary WIDGET, MALARM QueueMaxTimeToDrainMessages > CXALARM_OPTS.maxTimeToDrain
                                  #     - estimated duration to have 0 MESSAGEs stored
                                  #     - comparing NUM of MESSAGEs stored vs rate of MESSAGEs / MESSAGE_DELETEs

                                  ┌────────────────────────────┐
                                  │   VISIBILITY METRICS IAC   │
                                  └────────────────────────────┘

ICQUEUE.ApproximateNumberOf
 Messages[Not]Visible
 ([CMETRIC_OPTS])->CMETRIC        #Uses statistic 'Maximum'

                                  ┌─────────────────┐
                                  │   DEAD-LETTER   │
                                  └─────────────────┘

QUEUE_ATTRS.RedrivePolicy         #'REDRIVE_POLICY_JSON'
                                  #Send repeatedly failed MESSAGEs from this QUEUE ("source") to a dead-letter QUEUE2 ("DLQ")
                                  #Preserves everything
                                  #  - including MESSAGE_MID
                                  #  - including SYS_ATTRS.*: SentTimestamp, ApproximateFirstReceiveTimestamp, ApproximateReceiveCount, etc.
                                  #Recommended to ensure:
                                  #  - no unprocesses MESSAGEs
                                  #  - no blocked FIFOs due to MESSAGE failures (see above)
                                  #Can either:
                                  #  - fix underlying problem, then redrive MESSAGEs
                                  #     - i.e. not consume the MESSAGEs
                                  #  - process the MESSAGEs from the dead-letter QUEUE by another receiver
REDRIVE_POLICY.deadLetterTargetArn#QUEUE2_ARN
                                  #Can be in different REGION|ACCOUNT, but less performant
REDRIVE_POLICY.maxReceiveCount    #NUM (def: 10) of MESSAGE failures before moving MESSAGE to dead-letter QUEUE2
                                  #For example, if 3:
                                  #  - first 2 ReceiveMessage() return the MESSAGE, but do not delete it before VisibilityTimeout
                                  #  - MESSAGE not moved to DLQ yet
                                  #  - third ReceiveMessage() is called, finds the MESSAGE, but ignores it
                                  #  - MESSAGE now moved to DLQ
                                  #Should be at least 2, due to the risk of ghost receives

QUEUE_ATTRS.RedriveAllowPolicy    #'REDRIVE_APOLICY_JSON'. Restrict which other QUEUE2 can use this QUEUE as dead-letter
                                  #Must be in same REGION + ACCOUNT, unless redrivePermission 'byQueue'
                                  #If QUEUE2 is [not] FIFO, so must be QUEUE
REDRIVE_APOLICY.redrivePermission #'allowAll' (def), 'denyAll' or 'byQueue'
REDRIVE_APOLICY.sourceQueueArns   #Specific 'QUEUE2_ARN'_ARR, when using redrivePermission 'byQueue'
                                  #Max 10 items

                                  ┌──────────────────────┐
                                  │   DEAD-LETTER AUTH   │
                                  └──────────────────────┘

PACTION sqs:SendMessage           #Must be allowed for the source QUEUE, on the dead-letter QUEUE2
PACTION sqs:GetQueueAttributes
 |ReceiveMessage
 |ChangeMessageVisibility
 |DeleteMessage                   #Must be allowed for dead-letter QUEUE2, on the source QUEUE

                                  ┌─────────────────────┐
                                  │   DEAD-LETTER API   │
                                  └─────────────────────┘

ListDeadLetterSourceQueues()      #Req: QUEUE
                                  #  - only QueueUrl
                                  #Res: QUEUE
                                  #  - only QueueUrl -> QueueUrls ARR

                                  ┌─────────────────────┐
                                  │   DEAD-LETTER IAC   │
                                  └─────────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: RedrivePolicy OBJ, RedriveAllowPolicy OBJ

CQUEUE[_OPTS].deadLetterQueue     #CREDRIVE_POLICY. QUEUE_ATTRS.RedrivePolicy
CREDRIVE_POLICY.queue             #ICQUEUE. REDRIVE_POLICY.deadLetterTargetArn
CREDRIVE_POLICY.maxReceiveCount   #REDRIVE_POLICY.*

CQUEUE_OPTS.redriveAllowPolicy    #CREDRIVE_APOLICY. QUEUE_ATTRS.RedriveAllowPolicy
CREDRIVE_APOLICY.redrivePermission#REDRIVE_APOLICY.RedrivePermission
                                  #Def: 'byQueue' if sourceQueues set, 'allowAll' else
CREDRIVE_APOLICY.sourceQueues     #ICQUEUE_ARR. REDRIVE_APOLICY.sourceQueueArns

                                  ┌──────────────────────────┐
                                  │   DEAD-LETTER COMPOSER   │
                                  └──────────────────────────┘

QUEUE ENHANCED COMPONENT ==>      #Can connect a QUEUE to its dead-letter QUEUE2

                                  ┌──────────────────────┐
                                  │   DEAD-LETTER LINT   │
                                  └──────────────────────┘

cfn-lint-serverless
 aws_sqs_queue_redrive_policy
ES6000                            #QUEUE.RedrivePolicy must be set

cdk-nag SQSQueueDLQ               #Every non-dead-letter QUEUE must have a dead-letter QUEUE

                                  ┌──────────┐
                                  │   MOVE   │
                                  └──────────┘

MOVE                              #Move all MESSAGEs from a dead-letter QUEUE to another QUEUE2
                                  #"Redrive": when back to source QUEUE2
                                  #  - to retry dead-letter MESSAGEs, after fixing the underlying problem
                                  #MESSAGEs are re-sent
                                  #  - i.e. new SentTimestamp, MESSAGE_MID, etc.
                                  #Both QUEUEs must be FIFO or not
                                  #Max 1 per QUEUE at a time, 100 per ACCOUNT at a time
                                  #36h timeout
MOVE.TaskHandle                   #'MOVE_MID'
MOVE.SourceArn                    #'QUEUE_ARN'. Must be DLQ
MOVE.DestinationArn               #'QUEUE2_ARN'
                                  #Def: the DLQ's source
MOVE.StartedTimestamp             #DATE_NUM

MOVE.Status                       #Among 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLING', 'CANCELLED'
                                  #Cancelling does not rollback
MOVE.FailureReason                #STR, when Status 'FAILED'

MOVE.MaxNumberOfMessagesPerSecond #NUM (def: variable, max: 500) of MESSAGEs per sec
MOVE
.ApproximateNumberOfMessagesToMove#Total NUM of MESSAGEs
MOVE
 .ApproximateNumberOfMessagesMoved#NUM of MESSAGEs moved

                                  ┌───────────────┐
                                  │   MOVE AUTH   │
                                  └───────────────┘

PACTION sqs:GetQueueAttributes    #Must be allowed for source QUEUE (using COND_KEY aws:SourceArn), on the dead-letter QUEUE2,
                                  #for Start|List|CancelMessageMoveTask()
PACTION
 sqs:ReceiveMessage|DeleteMessage #Same for Start|CancelMessageMoveTask()
PACTION sqs:SendMessage           #Same for StartMessageMoveTask()

                                  ┌──────────────┐
                                  │   MOVE API   │
                                  └──────────────┘

StartMessageMoveTask()            #Req: MOVE
                                  #  - only SourceArn, DestinationArn, MaxNumberOfMessagesPerSecond
                                  #Res: MOVE
                                  #  - only TaskHandle
ListMessageMoveTasks()            #Req: MOVE
                                  #  - only SourceArn
                                  #Res: Results MOVE_ARR
CancelMessageMoveTask()           #Req: MOVE
                                  #  - only TaskHandle
                                  #Res: MOVE
                                  #  - only ApproximateNumberOfMessagesMoved

                                  ┌───────────┐
                                  │   BATCH   │
                                  └───────────┘

BATCH.QueueUrl                    #'QUEUE_URL'
BATCH.Entries                     #BATCH_ENTRY_ARR
                                  #Max 10 items
BATCH_ENTRY.Id                    #'BATCH_ENTRY_MID'. Required
                                  #Max 80 chars, [:alnum:]_-
BATCH_ENTRY.*                     #With:
                                  #  - SendMessageBatch(): MESSAGE
                                  #  - DeleteMessageBatch(): MESSAGE_DELETE
                                  #  - ChangeMessageVisibilityBatch(): MESSAGE_VSB
                                  #No QueueUrl

BATCH_RES.Successful              #BATCH_SUCCESS_ARR
BATCH_SUCCESS.Id                  #'BATCH_ENTRY_MID'
BATCH_SUCCESS.*                   #MESSAGE_RES (only with SendMessageBatch())

BATCH_RES.Failed                  #BATCH_ERROR_ARR
BATCH_ERROR.Id                    #'BATCH_ENTRY_MID'
BATCH_ERROR.Code                  #'CODE'
BATCH_ERROR.Message               #'MESSAGE'
BATCH_ERROR.SenderFault           #BOOL. Whether caused by user or by API

QUEUE_ATTRS.MaximumMessageSize    #Is max size of whole BATCH

MESSAGES_RCV_RES.Messages         #MESSAGE_RCV_RES_ARR
MESSAGES_RCV.MaxNumberOfMessages  #NUM (min|def: 1, max|recommended: 10). Max size of MESSAGES_RCV_RES.Messages
                                  #Might receive less

EMPTY RECEIVE ==>                 #When receiving 0 MESSAGEs
                                  #Can happen even some MESSAGEs are stored ("false empty receive"):
                                  #  - short polling: because randomly samples AZs
                                  #  - long polling: uses all AZs so less likely
                                  #     - however, can still happen if internal requests used by API timed out
                                  #     - this is rare but more likely if WaitTimeSeconds is low

FIFO ==>                          #Throttling limit is per API call, i.e. eased by batching
                                  #When sending a batch:
                                  #  - more efficient with MESSAGEs of the same MESSAGE_GROUP
                                  #  - because MESSAGEs with same MESSAGE_GROUP are physically located close to each other
                                  #When receiving a batch:
                                  #  - API tries to give MESSAGEs of the same MESSAGE_GROUP
                                  #     - but does not guarantee it
                                  #  - can process MESSAGEs with same MESSAGE_GROUP in parallel
                                  #     - can delete in any order, although DeleteMessageBatch() is cheaper and more efficient

BUFFERING ==>                     #Client can buffer:
                                  #  - holding SendMessage(), to increase batch size
                                  #  - prefetching ReceiveMessage(), to decrease latency to process MESSAGEs
                                  #Can be cased either on MESSAGE count threshold, or on duration frequency

                                  ┌────────────────┐
                                  │   BATCH AUTH   │
                                  └────────────────┘

PACTION sqs:SendMessage
 |DeleteMessage                   #Includes sqs:SendMessageBatch|DeleteMessageBatch|ChangeMessageVisibilityBatch()
 |ChangeMessageVisibility         #(which do not have their own PACTION)

                                  ┌───────────────┐
                                  │   BATCH SDK   │
                                  └───────────────┘

sqs-producer                      #Helpers to call SendMessageBatch() multiple times when sending many MESSAGEs
sqs-bulk-loader                   #See their docs

sqs-grep                          #Bulk MESSAGEs read, copy, delete, move, publish to SNS
                                  #Can filter|transform. See its doc

                                  ┌───────────────┐
                                  │   BATCH API   │
                                  └───────────────┘

SendMessageBatch()                #Req: BATCH
                                  #Res: BATCH_RES
DeleteMessageBatch()              #Req: BATCH
                                  #Res: BATCH_RES
ChangeMessageVisibilityBatch()    #Req: BATCH
                                  #Res: BATCH_RES

                                  ┌────────────────────┐
                                  │   BATCH SDK JAVA   │
                                  └────────────────────┘

BUFFERED ASYNCHRONOUS CLIENT ==>  #AmazonSQSBufferedAsyncClient, part of Java SDK
                                  #Automatically batches SendMessage|DeleteMessage|ChangeMessageVisibility()
                                  #Also prefetches ReceiveMessage()
                                  #Not with FIFOs

                                  ┌───────────────────┐
                                  │   BATCH METRICS   │
                                  └───────────────────┘

AWS/SQS/SentMessageSize           #Is total size of whole BATCHs

                                  ┌───────────────┐
                                  │   MULTIPLEX   │
                                  └───────────────┘

TEMPORARY|VIRTUAL QUEUE ==>       #Logical namespace within a QUEUE, e.g. using a MESSAGE_ATTR, as opposed to a different QUEUE
                                  #Cheaper: no API calls to CRUD the QUEUE
                                  #To avoid blocking each other, should use distinct MESSAGE_GROUPs

REQUEST-RESPONSE QUEUE ==>        #Using one queue for input, another for output back to original sender
                                  #Can use temporary queues to identify|trace client connection

                                  ┌────────────────────────┐
                                  │   MULTIPLEX SDK JAVA   │
                                  └────────────────────────┘

TEMPORARY QUEUE CLIENT ==>        #Built on top of Java SDK
                                  #Meant for request-response queue, using temporary queues
                                  #Repository is awslabs/amazon-sqs-java-temporary-queues-client

                                  ┌────────────────┐
                                  │   ENCRYPTION   │
                                  └────────────────┘

QUEUE_ATTRS|SYS_ATTRS             #BOOL (def|recommended: true). "SSE-SQS"
 .SqsManagedSseEnabled            #Encrypts MESSAGE_BODY at rest using AWS managed KMS key 'aws/sqs'
                                  #Does not encrypt other parts of MESSAGE.* (e.g. MESSAGE_ATTRS)
                                  #If using a dead-letter QUEUE2, uses source QUEUE's encryption settings:
                                  #  - if QUEUE encrypted but not QUEUE2, QUEUE2 won't decrypt it on ReceiveMessage()
                                  #  - if QUEUE2 encrypted but not QUEUE, MESSAGEs in QUEUE2 won't be encrypted
                                  #SendMessage|ReceiveMessage() cannot be anonymous

QUEUE_ATTRS.KmsMasterKeyId        #KMS_ID (def: none). "SSE-KMS". Same but with custom key
                                  #Can also re-use AWS managed KMS key 'aws/sqs', with same behavior as SSE-SQS

QUEUE_ATTRS
 .KmsDataKeyReusePeriodSeconds    #NUM of secs (min 1m, def 5m, max 1d) to re-use KMS data key, for performance and cost

                                  ┌─────────────────────┐
                                  │   ENCRYPTION AUTH   │
                                  └─────────────────────┘

PACTION                           #Must be allowed on
 kms:Decrypt|GenerateDataKey      #  - senders
                                  #  - receivers (kms:Decrypt only)
                                  #With SSE-SQS, automatically allowed to any PRINCIPAL in current ACCOUNT (not others)
                                  #Should use COND_KEY SourceArn|SourceAccount

                                  ┌────────────────────┐
                                  │   ENCRYPTION IAC   │
                                  └────────────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: SqsManagedSseEnabled, KmsMasterKeyId, KmsDataKeyReusePeriodSeconds

CQUEUE_OPTS.encryption            #QUEUE_ATTRS.SqsManagedSseEnabled. One of:
ICQUEUE.encryptionType            #  - 'NONE'
                                  #  - 'SQS_MANAGED' (def): SSE-SQS
                                  #  - 'KMS' (def if CQUEUE_OPTS.encryptionMasterKey): SSE-KMS
                                  #  - 'KMS_MANAGED': SSE-KMS
CQUEUE_OPTS.encryptionMasterKey   #ICKEY. QUEUE_ATTRS.KmsMasterKeyId
ICQUEUE.encryptionMasterKey       #With CQUEUE_OPTS.encryption:
                                  #  - 'KMS': def new ICKEY
                                  #  - 'KMS_MANAGER': always use 'aws/sqs' (but does not set ICQUEUE.encryptionMasterKey)
CQUEUE_OPTS.dataKeyReuse          #DURATION. QUEUE_ATTRS.KmsDataKeyReusePeriodSeconds

CQUEUE_OPTS.enforceSSL            #BOOL (def: false, recommended: true). Adds a POLICY which denies sqs:* on QUEUE from any PRINCIPAL
                                  #if COND_KEY aws:SecureTransport false

CQUEUE.grantSendMessages
 (YGRANTABLE)->CGRANT             #See above. Also calls ICKEY.grantEncryptDecrypt(YGRANTABLE), if CQUEUE_OPTS.encryption 'KMS'
CQUEUE.grantConsumeMessages
 (YGRANTABLE)->CGRANT             #Same but uses ICKEY.grantDecrypt(YGRANTABLE) instead

                                  ┌─────────────────────┐
                                  │   ENCRYPTION LINT   │
                                  └─────────────────────┘

cdk-nag SQSQueueSSE               #Must use SSE-SQS or SSE-KMS
cdk-nag SQSQueueSSLRequestsOnly   #Must set CQUEUE_OPTS.enforceSSL true

AWSSamples::SQSPolicyEncryption
 ::Hook                           #Must set CQUEUE_OPTS.enforceSSL true

                                  ┌────────────┐
                                  │   POLICY   │
                                  └────────────┘

QUEUE_ATTRS.Policy                #IAM 'POLICY_DOC'. QUEUE_POLICY
                                  #Resource-level on a QUEUE, i.e. Resource is QUEUE_ARN
                                  #Principal must be 'ACCOUNT_ID'
                                  #  - this can worked around using either:
                                  #     - COND_KEY aws:PrincipalArn or aws:SourceArn|SourceAccount
                                  #     - identity-level POLICY instead
                                  #PACTIONs are only cross-account ones
                                  #Max 8KB, 20 STATEMENTs, 50 PRINCIPALs, 7 PACTIONs, 10 COND_KEYs
                                  #Def: empty

PERMISSION                        #Sets QUEUE_ATTRS.Policy
                                  #POLICY_DOC.Id is 'arn:aws:sqs:REGION:ACCOUNT_ID/QUEUE/SQSDefaultPolicy'
PERMISSION.Label                  #STATEMENT.Sid
PERMISSION.QueueUrl               #'QUEUE_URL'. STATEMENT.Resource
PERMISSION.Actions                #'PACTION|*'_ARR. STATEMENT.Actions
PERMISSION.AWSAccountIds          #'ACCOUNT_ID'_ARR. STATEMENT.Principal.AWS
                                  #Required

SYS_ATTRS.SenderId                #USER_MID|ROLE_MID that called SendMessage*()
                                  #Undefined if anonymous

                                  ┌─────────────────┐
                                  │   POLICY AUTH   │
                                  └─────────────────┘

CROSS-ACCOUNT REQUESTS ==>        #Allowed by using Pricipal with another ACCOUNT, in QUEUE_POLICY
                                  #Only for PACTIONs sqs:*Message* (not *MessageMoveTask) or sqs:PurgeQueue|GetQueue*|ListDeadLetterSourceQueues

ANONYMOUS REQUESTS ==>            #Allowed by using Principal '*', in QUEUE_POLICY
                                  #Not recommended

PACTION sqs:AddPermission
 |RemovePermission                #Do not require PACTION sqs:SetQueueAttributes, even though they set QUEUE_ATTRS.Policy

root-task/SQSUnlockQueuePolicy    #AWS managed POLICY. Allows sqs:Set|GetQueueAttributes and sqs:ListQueues|GetQueueUrl
                                  #Meant to fix QUEUE_POLICY that accidentally forbid all PRINCIPALs to sqs:SetQueueAttributes
                                  #See IAM doc for root-task/*

                                  ┌────────────────┐
                                  │   POLICY API   │
                                  └────────────────┘

AddPermission()                   #Req: PERMISSION
                                  #Res: empty
RemovePermission()                #Req: PERMISSION
                                  #  - only QueueUrl, Label
                                  #Res: empty

                                  ┌────────────────┐
                                  │   POLICY IAC   │
                                  └────────────────┘

AWS::SQS::QueueInlinePolicy       #RESPROPs: QueuePolicyDocument POLICY_DOC_OBJ, Queue 'QUEUE_URL'
                                  #Is QUEUE_ATTRS.Policy, i.e. resource-level
                                  #With Cloud Control, cannot list

AWS::SQS::QueuePolicy             #RESPROPs: QueuePolicyDocument POLICY_DOC_OBJ, Queues 'QUEUE_URL'_ARR
                                  #RESATTR: Id POLICY_MID
                                  #Is a MPOLICY, i.e. identity-level
                                  #With Cloud Control, cannot read|list

new QueuePolicy(...CARGS, OPTS)   #CQUEUE_MPOLICY. AWS::SQS::QueuePolicy
CQUEUE_MPOLICY.document           #CPOLICY_DOC, initially empty
OPTS.queues                       #ICQUEUE_ARR

CQUEUE                            #Is RGRANTABLE, using CQUEUE_MPOLICY
                                  #If ICQUEUE, is RGRANTABLE but noop
CQUEUE.grant*(...)                #Uses identity-based POLICY or (if fails) CQUEUE_MPOLICY
                                  #If cross-ACCOUNT, uses both
CQUEUE.grant
 (YGRANTABLE, 'PACTION',...)
 ->CGRANT                         #Allows PACTION on QUEUE

                                  ┌─────────────────┐
                                  │   POLICY LINT   │
                                  └─────────────────┘

AWSSamples::SQSNonPublic::Hook    #Avoid allowing anonymous requests

                                  ┌──────────┐
                                  │   TAGS   │
                                  └──────────┘

QUEUE_TAGS.QueueUrl               #'QUEUE_URL'
QUEUE.tags
QUEUE_TAGS.Tags                   #TAGS OBJ

                                  ┌──────────────┐
                                  │   TAGS API   │
                                  └──────────────┘

TagQueue()                        #Req: QUEUE_TAGS
                                  #Res: empty
ListQueueTags()                   #Req: QUEUE_TAGS
                                  #  - only QueueUrl
                                  #Res: QUEUE_TAGS
                                  #  - only Tags
UntagQueue()                      #Req: QUEUE_TAGS
                                  #  - Tags OBJ -> TagKeys STR_ARR
                                  #Res: empty

                                  ┌──────────────┐
                                  │   TAGS IAC   │
                                  └──────────────┘

AWS::SQS::Queue                   #Includes RESPROPs: Tags TAG_PAIRS

                                  ┌────────────┐
                                  │   LAMBDA   │
                                  └────────────┘

EVENT_SOURCE.EventSourceArn       #SQS QUEUE_ARN (FIFO or not)
                                  #Set Lambda FUNCTION as receiver, automatically:
                                  #  - passes MESSAGEs from ReceiveMessage() as REQ
                                  #  - calls DeleteMessage() on successful RES
                                  #  - noop on failed RES
                                  #     - i.e. let MESSAGE fail after VisibilityTimeout
                                  #QUEUE and FUNCTION:
                                  #  - must be in same REGION
                                  #  - but can be cross-ACCOUNTs
                                  #     - only if SSE-KMS or no encryption (not SSE-SQS)
EVENT_SOURCE.*                    #See Lambda doc

EVENT_SOURCE.BatchSize            #NUM. Like MESSAGES_RCV.MaxNumberOfMessages except:
                                  #  - exact: does not return fewer
                                  #  - actually does multiple ReceiveMessage()
                                  #     - i.e. VisibilityTimeout starts while polling, not processing
                                  #Def: 10
                                  #Max: 10 (if FIFO) or 1e4 (if non-FIFO)

EVENT_SOURCE                      #NUM (in secs). Maximum duration to gather records for each batch
 .MaximumBatchingWindowInSeconds  #Note: MESSAGES_RCV.WaitTimeSeconds uses default from QUEUE_ATTRS.ReceiveMessageWaitTimeSeconds
                                  #Def|min:
                                  #  - if BatchSize <= 10: 0, no long polling
                                  #  - else: 1
                                  #Max: 5m

EVENT_SOURCE                      #NUM. Max CONCURRENCY of the FUNCTION
 .ScalingConfig.MaximumConcurrency#On FUNCTION error|throttling, automatically decreases CONCURRENCY
                                  #Min 2, max|def 1e4

EVENT_SOURCE.FilterCriteria       #Filters against LMESSAGE
                                  #LMESSAGE.body is OBJ (not 'OBJ_JSON') if valid JSON, else STR

QUEUE_ATTRS.VisibilityTimeout     #Recommended value is sum of:
                                  #  - EVENT_SOURCE.MaximumBatchingWindowInSeconds
                                  #  - FUNC_VERSION.Timeout
                                  #  - potential time spent throttled by Lambda due to too many invocations
                                  #     - documentation recommends: FUNC_VERSION.Timeout * 5

sqs-consumer                      #Alternative for long-runner instances. See its doc

                                  ┌─────────────────┐
                                  │   LAMBDA AUTH   │
                                  └─────────────────┘

PACTION sqs:ReceiveMessage
 |ChangeMessageVisibility         #Must be allowed on FUNC_VERSION.Role
 |DeleteMessage|GetQueueAttributes#Also kms:Descrypt, if SSE-KMS

AWSLambdaSQSQueueExecutionRole    #AWS managed POLICY for FUNC_VERSION.Role allowing:
                                  #  - sqs:ReceiveMessage|DeleteMessage|GetQueueAttributes on any QUEUE
                                  #  - logs:CreateLogGroup|CreateLogStream|PutLogEvents on any LOG_GROUP

                                  ┌────────────────┐
                                  │   LAMBDA IAC   │
                                  └────────────────┘

AWS::Lambda::EventSourceMapping   #Also includes RESPROPs: ScalingConfig
                                  #See Lambda doc for the others

new EventSourceMapping
 (...CARGS, CEVENT_SOURCE_OPTS)   #See Lambda doc

CEVENT_SOURCE_OPTS.maxConcurrency #NUM. EVENT_SOURCE.scalingConfig.maximumConcurrency

new SqsEventSource(ICQUEUE[,OPTS])#CCEVENT_SOURCE (see Lambda doc)
OPTS.*                            #Like CEVENT_SOURCE_OPTS.* (see Lambda doc), except:
                                  #  - no target
                                  #  - eventSourceArn -> ICQUEUE

                                  ┌────────────────┐
                                  │   LAMBDA SAM   │
                                  └────────────────┘

AWS::Serverless::Function         #Includes RESPROPs: Events.EVENT: Properties: Queue 'QUEUE_ARN', ScalingConfig

AWS::Serverless::Connector        #Can be used with:
                                  #  - Source: QUEUE (RESOURCE_REF.Arn)
                                  #  - Destination: Lambda FUNCTION (RESOURCE_REF.RoleName)
                                  #  - Permissions 'Read' and|or 'Write'
                                  #Transformed to a MPOLICY on 'ROLE':
                                  #  - allowing:
                                  #     - Read: sqs:ReceiveMessage|GetQueueAttributes
                                  #     - Write: sqs:DeleteMessage
                                  #  - on QUEUE

                                  ┌─────────────────────┐
                                  │   LAMBDA COMPOSER   │
                                  └─────────────────────┘

QUEUE ENHANCED COMPONENT ==>      #Can connect QUEUE to FUNCTION to create an EVENT_SOURCE

                                  ┌────────────────────┐
                                  │   LAMBDA METRICS   │
                                  └────────────────────┘

AWS/Lambda/DeletedEventCount      #NUM of DeleteMessage()

AWS/Lambda/PolledEventCount
AWS/Lambda/InvokedEventCount
AWS/Lambda/FailedInvokeEventCount #See Lambda doc

                                  ┌─────────────────┐
                                  │   LAMBDA LINT   │
                                  └─────────────────┘

cfn-lint E3634                    #Do not set EVENT_SOURCE.StartingPosition when using SQS EVENT_SOURCE

                                  ┌────────────────────┐
                                  │   LAMBDA PAYLOAD   │
                                  └────────────────────┘

REQ.Records                       #LRECORD_ARR
LRECORD.body                      #'LMESSAGE_JSON'
                                  #@middy/event-normalizer (see its doc) does JSON parsing on it

QUERY SQS                         #JMESPath 'QUERY' (see its doc) that gets LMESSAGE_ARR, i.e. JSON.parse(REQ.Records[*])

LMESSAGE.*                        #MESSAGE_RES.* but camelCase'd
LMESSAGE.eventSource              #Always 'aws:sqs'
LMESSAGE.eventSourceArn           #'QUEUE_ARN'
LMESSAGE.awsRegion                #'REGION'

                                  ┌──────────────────────────┐
                                  │   LAMBDA PARTIAL BATCH   │
                                  └──────────────────────────┘

PARTIAL BATCHES ==>               #See Lambda doc for EVENT_SOURCE.FunctionResponseTypes
                                  #Does not call DeleteMessage() on the MESSAGEs failed with RES.batchItemFailures

@aws-lambda-powertools/batch      #Helper (see its doc)

FIFO ==>                          #If a MESSAGE fails, every MESSAGE after it within the same MESSAGE_GROUP must be marked as fail too

RES.batchItemFailures[*]
 .itemIdentifier                  #'MESSAGE_MID'

FULL ERROR ==>                    #If all MESSAGEs fail, can be due to:
                                  #  - MESSAGE-specific reasons: should return RES.batchItemFailures
                                  #  - operational error: should make FUNCTION throw, so that CONCURRENCY is automatically decreased

                                  ┌───────────┐
                                  │   LOCAL   │
                                  └───────────┘

goaws                             #See its doc

ElasticMQ                         #SQS-compatible system
                                  #Meant for both:
                                  #  - AWS local testing (e.g. using docker-SQS-local project)
                                  #  - production, with AWS or not
                                  #Not documented yet
