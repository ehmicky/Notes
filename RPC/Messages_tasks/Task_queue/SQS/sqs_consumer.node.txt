
                                  ┏━━━━━━━━━━━━━━━━━━┓
                                  ┃   SQS_CONSUMER   ┃
                                  ┗━━━━━━━━━━━━━━━━━━┛

VERSION ==>                       #1.2.0

Consumer.create(OPTS)->CONSUMER   #Is an EVENTEMITTER

CONSUMER.updateOption('VAR', VAL) #Sets OPTS.VAR = VAL
CONSUMER.on('option_updated',
 FUNC('VAR', VAL))                #

CONSUMER.start()                  #Repeatedly calls ReceiveMessage()
CONSUMER.on('started', FUNC())    #
OPTS.pollingWaitTimeMs            #NUM (in ms, def: 0). How long to wait after ReceiveMessage() ended to call it again
OPTS.authenticationErrorTimeout   #NUM (in ms, def: 10s). Same but when ReceiveMessage() failed due to
                                  #network error, auth error, throttling or QUEUE not existing yet

CONSUMER.stop()                   #
OPTS.pollingCompleteWaitTimeMs    #NUM. Unless 0 (def), wait for any ongoing ReceiveMessage()
                                  #Times out after NUMms
CONSUMER.on('aborted', FUNC())    #On CONSUMER.stop() start, only if OPTS.abort true
CONSUMER.on('stopped', FUNC())    #On CONSUMER.stop() end
CONSUMER.on('waiting_for_polling_
 to_complete_timeout_exceeded',
 FUNC())                          #On CONSUMER.stop() end due to OPTS.pollingCompleteWaitTimeMs timeout

CONSUMER.abortController          #ABORT_CONTROLLER automatically created
                                  #Passed to SOPTS.abortSignal for every API call
OPTS.abort                        #BOOL (def: false). ABORT_CONTROLLER.abort() on CONSUMER.stop()

CONSUMER.status()->OBJ            #
OBJ.isPolling                     #BOOL. Whether some ReceiveMessage() or OPTS.*Callback|handleMessage[Batch]() is ongoing
OBJ.isRunning                     #BOOL. Based on CONSUMER.start|stop()

OPTS.queueUrl                     #'QUEUE_URL'
OPTS.sqs                          #SQS CLIENT (def: created)
OPTS.*                            #COPTS. Only used with the automatically created|default CLIENT

OPTS.*                            #Passed to ReceiveMessage() except:
                                  #  - no ReceiveRequestAttemptId
                                  #  - MaxNumberOfMessages (def: 10) -> batchSize (def: 1)
                                  #  - WaitTimeSeconds (def: 0) -> waitTimeSeconds (def: 20)
                                  #  - camelcase'd
OPTS.preReceiveMessageCallback    #FUNC()[->>] called before each ReceiveMessage()
OPTS.postReceiveMessageCallback   #FUNC()[->>] called after each ReceiveMessage()
CONSUMER.on('empty', FUNC())      #Called after each each ReceiveMessage() with no MESSAGEs
CONSUMER.on('message_received',
 FUNC(MESSAGE_RCV))               #Called after each ReceiveMessage()
OPTS.handleMessageBatch           #FUNC(MESSAGE_RCV_RES_ARR)[->>] called after ReceiveMessage() with some MESSAGEs
OPTS.handleMessage                #Same but as FUNC(MESSAGE_RCV_RES)[->>MESSAGE_RCV_RES], run in parallel

OPTS.shouldDeleteMessages         #BOOL. If true (def), calls DeleteMessage() after every OPTS.handleMessage[Batch]()
OPTS.alwaysAcknowledge            #BOOL. If false (def), no DeleteMessage() if OPTS.handleMessage() returns empty OBJ

DEBUG=sqs-consumer                #Logs EVENTs, lifecycle (start|poll|stop), auth ERRORs, MESSAGEs deletes

OPTS.handleMessageTimeout         #
OPTS.terminateVisibilityTimeout   #BOOL (def: false)
OPTS.heartbeatInterval            #NUM
                                  #Must be < visibilityTimeout

CONSUMER.on
 ('error', FUNC(SQS_ERROR))       #On exception from API calls or OPTS.*Callback|handleMessage[Batch]()
SQS_ERROR                         #
SQS_ERROR.name                    #'SQSError'
SQS_ERROR.code                    #STR
SQS_ERROR.statusCode              #NUM
SQS_ERROR.service                 #STR
SQS_ERROR.time                    #DATE
SQS_ERROR.retryable               #BOOL
SQS_ERROR.fault                   #'client|server'
SQS_ERROR.response                #OBJ: statusCode NUM, headers OBJ, body STR
SQS_ERROR.metadata                #OBJ: httpStatusCode NUM, requestId 'REQ_ID', extendedRequestId 'EXTENDED_REQ_ID', cfId STR, attempts NUM, totalRetryDelay NUM
OPTS.extendedAWSErrors            #BOOL (def: false)
