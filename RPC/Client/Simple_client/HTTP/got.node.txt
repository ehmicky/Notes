
                                  ┏━━━━━━━━━┓
                                  ┃   GOT   ┃
                                  ┗━━━━━━━━━┛

ALTERNATIVES ==>                  #See HTTP client summary

VERSION ==>                       #14.6.6 (supports Node >=20 only)
                                  #Node.js only

                                  ┌──────────┐
                                  │   MAIN   │
                                  └──────────┘

GOT(['URL'|URL][, OPTS[, OPTSI]])
 ->GPROMISE|STREAM                #HTTP request

User-Agent: got (URL) [C]
Content-Type [C]
Content-Length [C]                #Added

GPROMISE                          #PROMISE that resolves to RES

                                  ┌─────────────┐
                                  │   OPTIONS   │
                                  └─────────────┘

new Options(OPTS)->OPTSI          #
OPTSI.PROP                        #Can be get|set
OPTSI.toJSON()->OPTS              #

OPTSI.extend(OPTS|OPTSI2)->OPTSI3 #Add to defaults OPTS
OPTSI.merge(OPTS2)->OPTSI3        #

OPTS.mutableDefaults              #BOOL (def: false). Allow mutating OPTS.

                                  ┌────────────┐
                                  │   STREAM   │
                                  └────────────┘

OPTS.isStream                     #BOOL (def: false). Return STREAM instead of GPROMISE
                                  #Must write request body and read response body
GOT[.stream][.METHOD](...)        #Same with OPTS.method|stream set

STREAM.on('error', FUNC)          #Emitted, i.e. should use Stream.pipeline()
STREAM.once('retry', FUNC(NUM))   #Called on 'error'.
                                  #NUM is STREAM.retryCount (def: 0) + 1
                                  #  - to check to see if stop retrying
                                  #STREAM will be restarted, i.e. can pipe|read it again

STREAM.isReadonly                 #BOOL. True, unless no request body

                                  ┌─────────────┐
                                  │   REQUEST   │
                                  └─────────────┘

OPTS.*                            #Same as HTTP.request(), i.e.:
                                  #  - protocol STR (def: 'http:')
                                  #  - host[name] STR (def: "localhost")
                                  #     - prefer hostname
                                  #     - will fire exception if non existing
                                  #  - family 4|6 (def: both)
                                  #  - port PORT_NUM (def: 80)
                                  #  - localAddress STR
                                  #  - method STR (def: "GET")
                                  #  - path STR (def: "/"): including hash and query string
                                  #  - headers OBJ
                                  #  - auth STR: e.g. "auth:password"
                                  #  - https.rejectUnauthorized|checkServerIdentity|certificateAuthority|certificate|key|passphrase|pfx|serverName|secureOptions
                                  #  - agent[.http|https|http2] AGENT|false (def: globalAgent)
                                  #  - keepAlive[Msecs]: see AGENT
                                  #  - createConnection FUNC(...): see AGENT
                                  #  - setHost BOOL (def: true)
                                  #  - maxHeaderSize NUM
                                  #Not:
                                  #  - OPTS.socketPath:
                                  #     - should use '[PROTO://]unix:/SOCKET_PATH:/URI_PATH' URL instead

OPTS.url                          #URL|'URL'
OPTS.prefixUrl                    #URL|'URL': prepended to OPTS.url
                                  #When used, input URL must not start with /
RES.requestUrl                    #URL before redirects
RES.url                           #URL after redirects
OPTS.searchParams                 #OBJ|SEARCHPARAMS|'SEARCH'
                                  #null are converted to ''. undefined are skipped.
OPTS.username|password            #STR. Basic HTTP auth

OPTS.body                         #STR|BUFFER|TYPED_ARR|ISTREAM|[ASYNC_]ITERABLE|FORM-DATA. Request body
                                  #FORMDATA (using FORM-DATA library, see its doc): multipart/form-data request body
OPTS.json                         #VAL. application/json request body
OPTS.form                         #OBJ. application/x-www-form-urlencoded request body

OPTS.allowGetBody                 #BOOL (def: false). Allow request body with GET

OPTS.request                      #FUNC (def: http.request or https.request)
OPTS.http2                        #BOOL (def: false)

OPTS.enableUnixSockets            #BOOL (def: false)

OPTSI.createNativeRequestOptions()
 ->OPTS                           #To use with CLIENTREQ (HTTP.request())
OPTSI.getRequestFunction()->FUNC  #Returns bound CLIENTREQ

OPTS.copyPipedHeaders             #BOOL (def: true). If CLIENTREQ.pipe(GOT_STREAM), copy CLIENTREQ.headers to GOT_STREAM

                                  ┌──────────────┐
                                  │   RESPONSE   │
                                  └──────────────┘

RES.*                             #Same as RES.* but with additional members.

OPTS.responseType                 #'json', 'buffer' or 'text' (def)
                                  #Parse RES.body as VAL|BUFFER|STR
RES.body                          #VAL|BUFFER|STR
OPTS.resolveBodyOnly              #BOOL (def: false)
                                  #Resolve with parsed response instead of RES
GPROMISE.json|buffer|text()
 ->GPROMISE                       #Same as setting OPTS.responseType|resolveBodyOnly
OPTS.parseJson                    #FUNC(STR)->VAL (def: JSON.parse)
                                  #On 'json' responseType
OPTS.stringifyJson                #FUNC(VAL)->STR (def: JSON.stringify)
                                  #On 'json' responseType
OPTS.decompress                   #BOOL (def: true)
                                  #Decompress response (using DECOMPRESS-RESPONSE, see its doc)
                                  #Sets Accept-Encoding: gzip, deflate, br, zstd [C]
OPTS.encoding                     #'ENCODING' (def: 'utf8')

RES.ip                            #'IP'|undefined

OPTS.strictContentLength          #BOOL (def: false). Throws ERROR with code 'ERR_HTTP_CONTENT_LENGTH_MISMATCH' if both:
                                  #  - Content-Length [S] set
                                  #  - but does not match response body size

                                  ┌───────────────┐
                                  │   REDIRECTS   │
                                  └───────────────┘

OPTS.followRedirect               #BOOL[(RES)] (def: true). Follow Redirect [S] if 3**
RES.redirectUrls                  #URL_ARR
GPROMISE|STREAM.on
 ('redirect', FUNC(OPTS, RES))    #On HTTP redirection

OPTS.maxRedirects                 #NUM (def: 10)

OPTS.methodRewriting              #BOOL (def: true). Change method to GET when receiving 302|303 (which is standard RFC behavior)

                                  ┌────────────┐
                                  │   ERRORS   │
                                  └────────────┘

OPTS.throwHttpErrors              #BOOL (def: true)
                                  #Throw HTTPError if not 2**|3**

ERROR.code                        #STR
ERROR.options                     #OPTSI
RequestError                      #Name 'RequestError'. Network error (REQ.on('error'))
UnsupportedProtocolError          #Name 'UnsupportedProtocolError'. When not HTTP[S]
ReadError                         #Name 'ReadError'. When reading response body fails
ParseError                        #Name 'ParseError', response RES. When parsing response body fails. Error message shows URL
HTTPError                         #Name 'HTTPError', response RES. When not 2**|3**. Error message shows status code.
TimeoutError                      #Name 'TimeoutError', timings RES.timings, event ERROR.event. On OPTS.timeout.
MaxRedirectsError                 #Name 'MaxRedirectsError', response RES. When redirecting more than OPTS.maxRedirects times
CacheError                        #Name 'CacheError'. Cache store error
CancelError                       #Name 'CancelError'. On cancel()

                                  ┌────────────────┐
                                  │   PAGINATION   │
                                  └────────────────┘

GOT.paginate.each                 #Paginates.
 (['URL'|URL][, OPTS])            #Call HTTP request (using GOT(OPTS)) repeatedly
 ->ASYNC_ITERATOR_VAL             #Iterates over each VAL (not each response)
GOT.paginate.all
 (['URL'|URL][, OPTS])
 ->ARR                            #Paginates until the end

OPTS.pagination                   #POPTS
POPTS.paginate(OBJ)->false|OPTS   #Pagination logic
                                  #OBJ:
                                  #  - response RES
                                  #  - allItems ARR: all previous VALs
                                  #  - currentItems ARR2: current VALs
                                  #Should return false to stop iteration
                                  #Otherwise should return new OPTS for next HTTP request (using GOT(OPTS))
                                  #By def, use Link: <URI>; rel="next" [S]
POPTS.transform(RES)->ARR         #Customize how response body is parsed.
                                  #Def: JSON.parse(RES.body)
POPTS.filter(OBJ)->BOOL           #Whether to include a specific VAL
                                  #ARR are previous VALs
                                  #Def: none
POPTS.shouldContinue(OBJ)->BOOL   #Same but to stop whole iteration
                                  #Def: none
POPTS.countLimit                  #NUM. Stop whole iteration at NUM items
                                  #Def: Infinity
POPTS.requestLimit                #NUM. Max amount of iterations
                                  #Def: 10000
POPTS.stackAllItems               #BOOL. If false (def), ARR in POPTS.paginate|filter|shouldContinue() is always empty
                                  #Useful to reduce memory consumption
POPTS.backoff                     #Wait NUMms (def: 0) between each request

                                  ┌───────────┐
                                  │   RETRY   │
                                  └───────────┘

OPTS.retry                        #OBJ
                                  #Retry-After [S]:
                                  #  - used if set
                                  #  - if 413, must use it
OPTS.retry.limit                  #NUM (def: 2)
OPTS.retry.calculateDelay         #FUNC(OBJ)->[>]NUM
                                  #Delay between retries
                                  #OBJ:
                                  #  - computedValue NUM: double each time, starting at 1 second
                                  #  - attemptCount NUM2
                                  #  - error ERROR
                                  #  - retryAfter NUM (in ms): Retry-After [S] if set
                                  #  - retryOptions OPTS.retry
                                  #Def: OBJ.computedValue
OPTS.retry.enforceRetryRules      #BOOL (def: false, recommended: true)
                                  #If true, skip calculateDelay() if OPTS.retry.limit|methods|*Codes does not match
                                  #If false, calculateDelay() must manually check if OPTS.retry.limit|methods|*Codes does not match, and return 0 then
OPTS.retry.methods                #'METHOD'_ARR (def: ['get', 'put', 'head', 'delete', 'options', 'trace'])
OPTS.retry.statusCodes            #NUM_ARR (def: [408, 413, 429, 500, 502, 503, 504, 521, 522, 524])
OPTS.retry.errorCodes             #STR_ARR (def: 'ETIMEDOUT|ECONNRESET|EADDRINUSE|ECONNREFUSED|EPIPE|ENOTFOUND|ENETUNREACH|EAI_AGAIN')
                                  #For ERROR.code
OPTS.retry.maxRetryAfter          #NUM. Max Retry-After [S]
OPTS.retry.backoffLimit           #NUM (def: Infinity)
OPTS.retry.noise                  #NUM (def: 100, which means 0-100). Amount of ms randomly added to backoff
RES.retryCount                    #NUM

                                  ┌─────────────┐
                                  │   TIMEOUT   │
                                  └─────────────┘

OPTS.timeout                      #Request timeout (in ms) (def: none)
                                  #OBJ:
                                  #  - lookup NUM: DNS lookup
                                  #  - connect NUM: TCP handshake
                                  #  - secureConnect NUM: TLS setup
                                  #  - socket NUM: like HTTP.setTimeout()
                                  #  - send NUM: time to send request
                                  #  - response NUM: time between request sent and response starting to be received
                                  #  - request NUM: time between request started and response ended
                                  #  - read NUM: time between response read start and response ended
GPROMISE.cancel()                 #Abort HTTP request
REQ.isCanceled                    #BOOL

OPTS.signal                       #ABORT_SIGNAL
                                  #Destroy request|streams on 'abort' event

                                  ┌─────────────┐
                                  │   COOKIES   │
                                  └─────────────┘

OPTS.cookieJar TOUGHCOOKIE|OBJ    #Store and sets Cookie [C]
                                  #Must use tough-cookie library (see its doc) or OBJ:
                                  #  - setCookie('COOKIE', 'URL')->>
                                  #  - getCookieString('URL')->>'COOKIE'
OPTS.ignoreInvalidCookies         #BOOL: if false (def), throw if cookie is invalid

                                  ┌───────────┐
                                  │   CACHE   │
                                  └───────────┘

OPTS.cache                        #'URI'|STORE|BOOL. Cache responses (HTTP caching)
                                  #Passed to cacheable-request (see its doc)
OPTS.cacheOptions                 #OBJ to http-cache-semantics

RES|STREAM.isFromCache            #BOOL. Whether cache was used.

OPTS.dnsCache                     #KEYV|BOOL (def: false). Cache DNS responses (see keyv doc)
OPTS.dnsLookupIpVersion           #undefined (def, auto), 4 or 6
OPTS.dnsLookup                    #Customize DNS lookup (def: dns.lookup())

                                  ┌──────────────┐
                                  │   PROGRESS   │
                                  └──────────────┘

GPROMISE|STREAM.on                #Request body upload progress event OBJ:
 ('uploadProgress', FUNC(OBJ))    #  - percent 0-1
                                  #     - 0 if unknown
                                  #  - transferred NUM
                                  #     - uses request body size
                                  #  - total NUM
                                  #     - use Content-Length [C] or body size (using Buffer.byteLength(), FS.stat(), etc.)
                                  #     - at the end, uses same NUM as transferred
                                  #     - 0 if unknown
                                  #Requires using chunk-data on OPTS.body:
                                  #  - STR|BUFFER|TYPED_ARR: chunk()
                                  #  - STREAM|[ASYNC_]ITERABLE: chunkFromAsync()
                                  #  - FORMDATA: cannot use
                                  #Sent once per chunk
GPROMISE|STREAM.on                #Response body download progress event OBJ:
 ('downloadProgress', FUNC(OBJ))  #  - percent 0-1
                                  #     - 0 if unknown
                                  #  - transferred NUM
                                  #     - uses response body size
                                  #     - reset on redirect
                                  #  - total NUM
                                  #     - use Content-Length [S]
                                  #     - at the end, uses same NUM as transferred
                                  #     - 0 if unknown (1 at the end)
STREAM
 .uploadProgress|downloadProgress #Same OBJ as above

                                  ┌────────────────────┐
                                  │   RESPONSE TIMES   │
                                  └────────────────────┘

RES.timings                       #TIMINGS_OBJ of how long request|response took:
                                  #  - start NUM: request start
                                  #  - socket NUM: TCP socket created
                                  #  - lookup NUM: DNS lookup done
                                  #  - connect NUM: TCP handshake done
                                  #  - upload NUM: request body sent
                                  #  - response NUM: response body received
                                  #  - end|error NUM: request end|error
                                  #  - phases:
                                  #     - wait NUM: start to socket
                                  #     - dns NUM: socket to lookup
                                  #     - tcp NUM: lookup to connect
                                  #     - request NUM: connect to upload
                                  #     - firstByte NUM: upload to response
                                  #     - download NUM: response to end
                                  #     - total NUM: start to end|error
                                  #Each NUM is a Unix timestamp (in ms)

                                  ┌────────────┐
                                  │   CUSTOM   │
                                  └────────────┘

OPTS.hooks                        #Events callbacks. OBJ:
                                  #  - init ARR of FUNC(OPTS, OPTSI):
                                  #     - before each request
                                  #     - only fired if OPTS|OPTSI was provided
                                  #  - beforeRequest ARR of FUNC(OPTS, OBJ)[->>]
                                  #     - OBJ: retryCount NUM
                                  #  - beforeRedirect ARR of FUNC(OPTS, RES)[->>]: before HTTP redirection
                                  #  - beforeRetry ARR of FUNC(ERROR, NUM)[->>]
                                  #  - beforeCache ARR of FUNC(RES)[->false]: before caching response
                                  #     - can return false to skip caching
                                  #     - can modify RES to change cache key, i.e. RES.headers
                                  #  - beforeError ARR of FUNC(ERROR)->[>]ERROR
                                  #  - afterResponse ARR of FUNC(RES, FUNC2(OPTS))->GPROMISE
                                  #     - FUNC2 retries with new OPTS
                                  #     - further afterResponse hooks discarded, unless OPTS.preserveHooks true
                                  #        - must guard against infinite loops then
OPTS.context                      #Stateful OBJ, meant for OPTS.hooks

OPTS.request                      #FUNC instead of HTTP[S].request()

GPROMISE|STREAM.on('error',
 FUNC(ERROR, RES.body, RES))      #
GPROMISE|STREAM.on
 ('request', FUNC(REQ))           #
GPROMISE|STREAM.on
 ('upload-complete', FUNC(REQ))   #
GPROMISE|STREAM.on
 ('response', FUNC(RES))          #

GPROMISE|STREAM.off('EVENT', FUNC)#

                                  ┌───────────┐
                                  │   DEBUG   │
                                  └───────────┘

DIAGNOSTICS_CHANNEL.subscribe
 ('got:request:request',          #Start
 FUNC(OBJ))                       #OBJ: requestId STR, url 'URL', method 'METHOD'
DIAGNOSTICS_CHANNEL.subscribe
 ('got:request:start',            #Start of underlying HTTP request
 FUNC(OBJ))                       #OBJ: requestId STR, url 'URL', method 'METHOD', headers OBJ
DIAGNOSTICS_CHANNEL.subscribe
 ('got:response:start',           #Response headers received
 FUNC(OBJ))                       #OBJ: requestId STR, url 'URL', method 'METHOD', headers OBJ, statusCode NUM, isFromCache BOOL
DIAGNOSTICS_CHANNEL.subscribe
 ('got:response:end',             #Response body received
 FUNC(OBJ))                       #OBJ: requestId STR, url 'URL', statusCode NUM, bodySize NUM|undefined, timings TIMINGS_OBJ|undefined
DIAGNOSTICS_CHANNEL.subscribe
 ('got:request:error',
 FUNC(OBJ))                       #OBJ: requestId STR, url 'URL', error ERROR, timings TIMINGS_OBJ|undefined
DIAGNOSTICS_CHANNEL.subscribe
 ('got:request:retry',
 FUNC(OBJ))                       #OBJ: requestId STR, retryCount NUM, delay NUM, error ERROR
DIAGNOSTICS_CHANNEL.subscribe
 ('got:response:redirect',
 FUNC(OBJ))                       #OBJ: requestId STR, fromUrl 'URL', toUrl 'URL2', statusCode NUM
