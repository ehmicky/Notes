
           
   GRAPHQL  
           



VERSION ==>                       #Spec from 18 May 2017.
                                  #Former releases:
                                 N#  - next release
                                21#  - October 2021
                                18#  - June 2018
                                 !#Not in spec, but in graphQL.js

GOAL ==>                          #  - IDL, resource-oriented like REST
                                  #  - client-oriented (attribute-oriented), good|declarative query language
                                  #  - read-oriented (as opposed to write)
                                  #  - good support for nested resources
                                  #  - semantics left to implementation, except for generic read|write (query|mutation)
                                  #  - geared towards HTTP and JSON
                                  #  - strongly typed: safer but less dynamic


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        GENERAL SYNTAX         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NAMING ==>                        #For most names
                                  #  - including OPNAME, $VAR|ARG, ALIAS|ATTR, TYPE, ENUM_VAL, FRAGMENT, DIRECTIVE, SUBSCRIPTION
                                  #Rules:
                                  #  - [[:alnum:]_]
                                  #  - cannot start with __
                                  #  - case sensitive
                                  #By convention camelCase except:
                                  #  - Capitalize: TYPE, SUBSCRIPTION
                                  #  - UPPER_CASE: ENUM_VAL

COMMAS ==>                        #Always optional, i.e.:
                                  #  - can be replaced by whitespace
                                  #  - trailing comma accepted
                                  #For $VAR|ARG, ARR, OBJ

WHITESPACES ==>                   #Are ignored, except inside STR

#COMMENT                          #

"DESCRIPTION"
"""
DESCRIPTION
...                               #Before a TYPE|ATTR|..., used as description for introspection queries
"""                               #Can contain Markdown


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TYPES             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE                              #Either:
                                  #  - scalar: String, Int, Float, Boolean, ID, ENUM
                                  #  - complex: Object, InputObject

MODIFIER ==>                      #As opposed to base types, modifies an underlying type
                                  #Includes: [TYPE] and TYPE!

String                            #"STR" (double quotes)
                                  #Must escape " \ newline, with \
                                  #Can contain \uXXXX \/ \b \f \n \r \t
                                  #UTF-8

Int                               #Signed 32 bits

Float                             #Double precision

Boolean                           #true|false

ID                                #Same as String, but with ID semantics

ENUM                              #Same as String, but with enum semantics
                                  #Defined by enum ENUM

InputObject                       #OBJ used as client input (e.g. as ARG)
                                  #Defined by input TYPE
{ ATTR: VAL, ... }                #INPUT_OBJ value

Object                            #OBJ used as server output
                                  #Includes OPTYPE
                                  #Defined by type TYPE

[TYPE]                            #List, i.e. array
                                  #Can be nested, e.g. [[TYPE]]
[VAL,...]                         #ARR value

null                              #Possible value with any TYPE, except non-nullable
                                  #Kept as is for both query|response

undefined                         #When a value is absent (there is no "undefined" keyword)
                                  #Possible value with any TYPE, except non-nullable
                                  #Kept as is for query (InputObject's fields, $VAR, ARG)
                                  #But coerced to null for queried response fields

= VAL                             #Default value for query (InputObject's fields, $VAR, ARG)
                                  #Assigned if value is undefined, but not if it is null
                                  #Not deep, i.e. only assigned on InputObject's fields if parent is defined

TYPE!                             #Not-nullable, i.e. required
                                  #Query|resolver error if query|response null|undefined
                                  #ARR:
                                  #  - [TYPE!]: TYPE required, TYPE_ARR optional
                                  #  - [TYPE]!: TYPE optional, TYPE_ARR required
                                  #  - TYPE_ARR required might still have length 0

TYPE COERCION ==>                 #"input coercion":
                                  #  - typecasing from client to graphQL
                                  #  - query error if cannot typecast
                                  #  - can be:
                                  #     - STR -> ID|ENUM
                                  #     - VAL -> [VAL]
                                  #"result coercion":
                                  #  - typecasting from server to graphQL
                                  #  - resolver error if cannot typecast
                                  #  - can be:
                                  #     - INT|FLOAT <-> 'INT|FLOAT'
                                  #     - BOOL -> 'BOOL'
                                  #     - INT -> FLOAT
                                  #     - INT|FLOAT <-> BOOL
                                  #     - STR -> ID|ENUM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          DEFINITION           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DEFINITIONS ==>                   #Types declarations, done server-side
                                  #Can be shared to client (e.g. for validation)

schema {
  OPTYPE: OBJ_TYPE
  ...                             #Top-level entrypoints ("operations")
}                                 #Def: { query: Query, mutation: Mutation, subscription: Subscription } (if any exists)

OPTYPE                            #Can be:
                                  #  - query:
                                  #     - same semantics as GET in REST
                                  #     - field resolvers (for a given OBJ) are executed in parallel
                                  #  - mutation:
                                  #     - same semantics as PUT|POST|DELETE|PATCH in REST
                                  #     - field resolvers (for a given OBJ) are executed serially
                                  #  - subscription (see below)

type OBJ_TYPE {
  ATTR[(ARG: TYPE [= VAL],...)]:
    TYPE
  ...
}                                 #Object type definition

VARIADIC ARGS ==>                 #Should be last, as ARR
                                  #Query needs to supply ARR, but VAL -> [VAL] typecasting possible (see above)

input INPUT_OBJ_TYPE {
  ATTR: TYPE [= VAL]
}                                 #InputObject type definition

enum ENUM {
  ENUM_VAL
  ...                             #ENUM type definition.
}                                 #ENUM_VAL are not surrounded by quote

interface INTERFACE { ... }       #Inheritance.
type OBJ_TYPE                     #OBJ_TYPE must reimplement INTERFACE, as a superset|covariant:
 implements INTERFACE [& ...]     #  - can add (but not remove):
 { ... }                          #     - ATTR
                                  #     - ARG
                                  #     - !-modifier (on ATTR, not ARG)
                                  #  - types must be exact same otherwise
                                  #When client queries an attribute of type:
                                  #  - INTERFACE: INTERFACE.* is available
                                  #  - OBJ_TYPE: all OBJ_TYPE.* is available
                                  #  - FRAGMENT "on OBJ_TYPE": all OBJ_TYPE.* is available

union OBJ_TYPE = OBJ_TYPE2 | ...  #Mixed type definition.
                                  #Same as using an empty interface OBJ_TYPE, implemented by OBJ_TYPE2, etc.
                                  #OBJ_TYPE2 cannot use modifiers
                                  #Can be use as a type aliasing, by picking only one OBJ_TYPE2
                                
scalar TYPE                       #New scalar type definition.
                                  #Must be:
                                  #  - implemented|defined by server
                                  #  - serializable as string

extend type ...                  !#Like type ..., but meant as a mixin to existing type
                                 !#Only parsed|executed by extendSchema()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             QUERY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[OPTYPE [OPNAME]                  #ATTR:
[($VAR: TYPE [= DEF_VAL],...)]] { #  - used to pick resolver
  [ALIAS:] ATTR[(ARG: VAL,...)] { #ALIAS:
    ...                           #  - used for return value output, i.e. response shape
  }]                              #  - def: same as ATTR
  ...                             #  - useful to differentiate to avoid collisions when using twice same ATTR but different arguments
}                                 #ARG:
                                  #  - passed to resolver
                                  #Sub { ... }:
                                  #  - necessary if OBJ_[ARR_]TYPE
                                  #     - if OBJ_ARR_TYPE, performed on each OBJ item
                                  #  - forbidden otherwise
                                  #  - same syntax as OBJ
                                  #  - recursive
                                  #$VAR:
                                  #  - can be used as const VAR inside query body
                                  #     - including fragments
                                  #  - if defined, has to be used
                                  #  - client specifies the $VAR's value separately, as part of the overall request
                                  #OPTYPE:
                                  #  - def: 'query'
                                  #OPNAME:
                                  #  - allows query to define several top-level operations
                                  #  - server performs only one of them, selected using an "operationName" parameter provided by client
                                  #  - there is still only one top-level operation performed
                                  #How clients communicate $VAR values and "operationName" is server implementation-specific
                                  #  - e.g. with URL query variables

DOCUMENT ==>                      #File containing 0-n operations|fragments
                                  #  - providing they do not have same names

QUERY ERROR ==>                   #Produces { errors ... } return value


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FRAGMENT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


fragment FRAGMENT on OBJ_TYPE     #Declare named fragment
 { ... }                          #Must be done in a query

{                                 #Expand|mix in named fragment
  [...]                           #Parent must be OBJ_TYPE (or subtype)
  ...FRAGMENT                     #  - if not, silently ignored
  [...]                           #  - parent can be polymorphic (e.g. using INTERFACE or union)
}                                 #Can be nested

... [on OBJ_TYPE] { ... }         #Inline fragment
                                  #Shortcut for ...FRAGMENT, followed by fragment FRAGMENT on OBJ_TYPE {...}
                                  #Only useful usage is coupled with polymorphism
                                  #"on OBJ_TYPE" is only optional if @DIRECTIVE is used


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           DIRECTIVE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


... @DIRECTIVE(ARG: VAL,...)...   #Possibly change return value shape.
 ...                              #Server implementation-defined.
                                  #Each directive has only specific locations where it can be used, either in queries or in server definitions

@include|skip(if: BOOL)           #Skips field if false|true
                                  #Possibly used in queries, after:
                                  #  - ATTR[(...)]
                                  #  - ... [on OBJ_TYPE]
                                  #  - ...FRAGMENT

@deprecated([reason: STR])        #STR:
                                  #  - can contain Markdown
                                  #  - def: 'No longer supported'
                                  #Shown in introspection: FIELD|INPUTVALUE|ENUMVALINFO.isDeprecated|deprecationReason
                                  #Possibly used in server definition, after:
                                  #  - ATTR[(...)]
                                  #  - ENUM_VAL
                                  #  - ARG

@specifiedBy(url: "URI")          #Documentation URI for custom TYPEs
                                  #Shown in introspection: TYPEINFO.specifiedByURL
                                  #Possibly used in server definition, after:
                                  #  - scalar TYPE

@defer(label: "LABEL"            N#Requests that a fragment be sent in a separate response.
 [, if: BOOL])                   N#Initial response lacks the fragment
                                 N#1-n next response with OBJ:
                                 N#  - label "LABEL"
                                 N#  - path "VAR"_ARR
                                 N#  - data OBJ2: with deferred fragment
                                 N#All responses have OBJ:
                                 N#  - hasNext BOOL: true for final response
                                 N#I.e. goal is streaming the response
                                 N#Def BOOL: true
                                 N#Possibly used after:
                                 N#  - ... [on OBJ_TYPE]
                                 N#  - ...FRAGMENT

@stream(label: "LABEL"           N#Similar to @defer except:
 [, initialCount: INT]           N#  - meant for ARR attributes, not FRAGMENTs
 [, if: BOOL])                   N#  - initial response returns INT items
                                 N#  - next responses have 1 item each
                                 N#Def INT: 0
                                 N#Def BOOL: true
                                 N#Possibly used after:
                                 N#  - ATTR[(...)]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           RESOLVER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RESOLVER ==>                      #GraphQL from|to backend layer.
                                  #Each GraphQL query ATTR:
                                  #  - has its own resolver function
                                  #  - when combined, it produces the query result
                                  #Shape of return value and query are the same.

{                                 #If ATTR has:
  TYPE: {                         #  - OBJ_TYPE:
    ATTR(RPARENT, ARGS, CONTEXT)  #     - RATTR is usually OBJ, but does not need to
     ->[PROMISE_]RATTR            #     - RATTR passed to child as RPARENT
    ...                           #  - OBJ_ARR_TYPE:
  }                               #     - RATTR must be ARR
}                                 #        - usually OBJ_ARR, but does not need to
                                  #     - each RATTR item is passed to child as RPARENT
                                  #  - otherwise: RATTR rendered as output
                                  #For top-level ATTR, implementation can allow client to provide "root value" (initial RPARENT)
                                  #ARGS: the ones passed by query, as OBJ
                                  #CONTEXT:
                                  #  - request-long object, i.e. holding request info
                                  #  - provided by server, implementation-specific
                                 !#Server implementation often provide default resolver
                                 !#  - e.g. returning RPARENT.ATTR

RESOLVER ERROR ==>                #Can arise on:
                                  #  - result coercion error
                                  #  - any general exception|error thrown (or returned, but prefer thrown) during ATTR()
                                  #Effect:
                                  #  - same as if resolver returned null
                                  #  - will be appended to return value "errors"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         RETURN VALUE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RETURN RESPONSE ==>               #  - data OBJ
                                  #     - absent if error before operation starts
                                  #     - null if error during operation
                                  #  - errors OBJ_ARR:
                                  #     - if queried data:
                                  #        - is not defined: always present (query error)
                                  #        - is defined: present if query|resolver error
                                  #     - always contain at least one element
                                  #     - contains:
                                  #        - message STR
                                  #        - locations OBJ_ARR (within GraphQL document):
                                  #           - line NUM
                                  #           - column NUM
                                  #        - path 'VAR'|NUM_ARR
                                  #        - any custom
                                 !#        - stack STR
                                 !#        - originalError ERROR
                                 !#        - positions NUM_ARR
                                 !#        - nodes AST_NODE_ARR
                                 !#        - source SOURCE
                                  #  - extensions OBJ (any custom)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         INTROSPECTION         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INTROSPECTION ==>                 #Special attributes that request metadata

__typename                        #'TYPE'
                                  #It is:
                                  #  - SCHEMA: '__Schema'
                                  #  - TYPEINFO: '__Type'
                                  #  - DIRECTIVEINFO: '__Directive'
                                  #  - FIELD: '__Field'
                                  #  - INPUTVALUE: '__InputValue'
                                  #  - ENUMVALINFO: '__EnumValue'
                                  #  - TYPEKIND: '__TypeKind'
                                  #  - DIRECTIVE: '__Directive'
                                  #  - DIRECTIVELOCATION: '__DirectiveLocation'

__type(name: 'TYPE')              #TYPEINFO

__schema                          #SCHEMA:
                                  #  - description STR
                                  #  - types TYPEINFO_ARR:
                                  #     - all supported types, including scalar and __TYPE
                                  #  - queryType|mutationType|subscriptionType TYPEINFO (top-level operations)
                                  #  - directives DIRECTIVEINFO_ARR

TYPEINFO                          #OBJ:
                                  #  - name 'TYPE'
                                  #  - description STR
                                  #  - kind TYPEKIND
                                  #  (only custom TYPEs)
                                  #  - specifiedByURL 'URL'
                                  #  (only NonNull|List modifiers)
                                  #  - ofType TYPEINFO
                                  #     - when kind is a modifier (NON_NULL|LIST), use "ofType" to get subtype
                                  #  (only Objects|Interface)
                                  #  - fields[(includeDeprecated = false)] FIELD_ARR
                                  #  (only InputObjects)
                                  #  - inputFields[(includeDeprecated = false)] INPUTVALUE_ARR
                                  #  (only Interface|Objects)
                                  #  - interfaces TYPEINFO_ARR
                                  #  (only Interface|Union)
                                  #  - possibleTypes TYPEINFO_ARR
                                  #  (only Enums)
                                  #  - enumValues[(includeDeprecated = false)] ENUMVALINFO_ARR

TYPEKIND                          #Enum among SCALAR|[INPUT_]OBJECT|INTERFACE|UNION|ENUM|NON_NULL|LIST

FIELD                             #OBJ:
                                  #  - name 'ATTR'
                                  #  - description STR
                                  #  - type TYPE_INFO
                                  #  - args[(includeDeprecated = false)] INPUTVALUE_ARR
                                  #  - isDeprecated BOOL
                                  #  - deprecationReason STR

INPUTVALUE                        #OBJ:
                                  #  - name 'VAR'
                                  #  - description STR
                                  #  - type TYPE_INFO
                                  #  - defaultValue STR
                                  #  - isDeprecated BOOL
                                  #  - deprecationReason STR

ENUMVALINFO                       #OBJ:
                                  #  - name 'ENUMVAL'
                                  #  - description STR
                                  #  - isDeprecated BOOL
                                  #  - deprecationReason STR

DIRECTIVEINFO                     #OBJ:
                                  #  - name 'DIRECTIVE'
                                  #  - description STR
                                  #  - args[(includeDeprecated = false)] INPUTVALUE_ARR
                                  #  - locations DIRECTIVELOCATION_ARR
                                  #  - isRepeatable BOOL

DIRECTIVELOCATION                 #Enum among:
                                  #  - (query) QUERY|MUTATION|SUBSCRIPTION|FIELD|FRAGMENT_DEFINITION|
                                  #    FRAGMENT_SPREAD|INLINE_FRAGMENT|VARIABLE_DEFINITION
                                  #  - (definition) SCHEMA|SCALAR|OBJECT|FIELD_DEFINITION|ARGUMENT_DEFINITION|INTERFACE|
                                  #    UNION|ENUM|ENUM_VALUE|INPUT_OBJECT|INPUT_FIELD_DEFINITION


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          VALIDATION           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


VALIDATION ==>                    #Since query has explicit typing, can validate against server definition compile-time
                                  #  - can be done by client and|or by server
                                  #List of possible errors is available in spec


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         SUBSCRIPTION          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SUBSCRIPTIONS ==>                 #Top-level operation similar to query, except:
                                  #  - receives results when server wants, i.e. on push, e.g. via WebSocket
                                  #  - i.e. initial query ("subscription") is only an "addListener",
                                  #    although can perform a query too

type subscription {
  CHANNEL(...) { ... }
}                                 #Schema definition, similar to type query

subscription SUBSCRIPTION {       #Client query, to subscribe to channel.
  CHANNEL(...) { ... }            #Arguments can be passed to server to customize event handling for that channel.
}                                 #When server wants to push to client:
                                  #  - it triggers an event
                                  #  - event PAYLOAD is used as root value of query, and query is performed
                                  #  - query return value is communicated to client, e.g. via WebSocket
                                  #The server may (or not) push right away a query as the response to subscription.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:    IMPLEMENTATION-SPECIFIC    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PROTOCOL ==>                      #Single endpoint, usually /graphql
                                  #Parameters:
                                  #  - query JSON
                                  #  - variables JSON
                                  #  - operationName 'OPNAME': if query contains several possible top-level operations
                                  #Usually over HTTP, either:
                                  #  - GET with parameters as query variables
                                  #     - only for OPTYPE 'query'
                                  #  - POST with parameters as request body JSON, Content-Type: application/json [C]
                                  #  - POST with QUERY as request body, Content-Type: application/graphql [C]
                                  #    and query variables for other parameters

VERSIONING ==>                    #Recommends no versioning (but I don't agree with that)

OTHER IMPLEMENTATION-SPECIFIC ==> #  - programming language
                                  #  - CONTEXT
