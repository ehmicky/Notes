
                  
   PATH-TO-REGEXP  
                  



ALTERNATIVES ==>                  #  - URLPattern (preferred if browser|Deno): standard DOM
                                  #  - path-to-regexp (preferred if Node): more features

VERSION ==>                       #6.2.2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PATTERN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


'PATH'                            #URI path without template variables

PATH_PATTERN                      #URI path with template variables.
                                  #Can contain:
                                  #  - :VAR
                                  #     - VAR name is \p{XID_Continue}+, i.e. roughly same as valid JavaScript identifiers
                                  #     - matches anything until DELIM
                                  #  - (REGEXP)
                                  #     - can be nested
                                  #     - not stopped by DELIM
                                  #  - *
                                  #     - same as {([^DELIM]*);DELIM}*
                                  #     - i.e. match anything, not stopped by DELIM
                                  #  - RAW: anything else
                                  #Cannot contain ! @ , (reserved chars)
                                  #Can \-escape any special char: () {} * ? + ; ! @ ,
                                  #Can wrap anything with {...}
                                  #  - can be {...} {...}? {...}* or {...}+
                                  #  - can include :VAR or (REGEXP) but only once
                                  #     - PREFIX|SUFFIX: any characters before|after
                                  #  - can end with ;SEPARATOR
                                  #     - separator between each match of :VAR or (REGEXP) inside {...}* or {...}+
                                  #     - def SEPARATOR: PREFIX + SUFFIX (if none: '')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            TOKENS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TOKENS                            #Several TTOKENs, i.e. PATH_PATTERN parsed
TOKENS.tokens                     #ARR of TOKEN|'RAW'

TOKEN                             #
TOKEN.name                        #'VAR' (if :VAR) or 'NUM' (if (REGEXP)) or '' (if {...} without :VAR|(REGEXP))
TOKEN.pattern                     #'REGEXP' (if (REGEXP))
TOKEN.modifier                    #'?', '*', '+' or '' (if {...})
TOKEN.prefix                      #'PREFIX' (if {...:VAR} or {...(REGEXP)})
TOKEN.suffix                      #'SUFFIX' (if {:VAR...} or {(REGEXP)...})
TOKEN.separator                   #'SEPARATOR' (if {...})

PATH_REGEXP                       #REGEXP where each parenthesis group matches a :VAR or (REGEXP)
PATH_REGEXP.keys                  #TOKEN_ARR of all :VAR and (REGEXP)

PARAMS                            #Template variables (:VAR and (REGEXP)) as OBJ
                                  #Keys are TOKEN.name
                                  #Values can be:
                                  #  - STR
                                  #  - ARR:
                                  #     - each match of :VAR or (REGEXP) inside {...}* or {...}+
                                  #     - excluding SEPARATORs
                                  #     - not if OPTS.decode false
                                  #  - NUM -> 'NUM' (serialization, not parsing)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OPTIONS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.sensitive                    #BOOL (def: false). Case-sensitive

OPTS|TOKENS.delimiter             #'DELIM' (def: '/').
OPTS.trailing                     #BOOL (def: true). End must be:
                                  #  - OPTS.trailing false + OPTS.end true: $
                                  #  - OPTS.trailing false + OPTS.end false: $, DELIM
                                  #  - OPTS.trailing true + OPTS.end true: $, DELIMs$
                                  #  - OPTS.trailing true + OPTS.end false: $, DELIMs, DELIMs$
                                  #DELIMs is multiple DELIMs if OPTS.loose true
OPTS.loose                        #BOOL (def: true). Allow multiple DELIMs in a row

OPTS.start                        #BOOL (def: true). Must match from beginning
OPTS.end                          #BOOL (def: true). Must match until end

OPTS.encodePath                   #FUNC(STR)->STR (def: identity)
                                  #Transform 'RAW', 'PREFIX' and 'SUFFIX'
                                  #Should use encodeURI() if PATH_PATTERN might contain non-URI-encoded characters
OPTS.encode                       #FUNC(VAL)->STR or false (same as identity function)
                                  #Def: encodeURIComponent()
OPTS.decode                       #FUNC(STR)->STR or false (same as identity function)
                                  #Transform PARAMS.*
                                  #Def: decodeURIComponent()

OPTS.validate                     #BOOL (def: true)
                                  #Throw TypeError if PARAMS VAL matches TOKEN.name but not TOKEN.pattern, e.g. contains delimiters
                                  #TypeError is always thrown when missing PARAMS (no TOKEN with correct TOKEN.name)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PARSE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


parse(PATH_PATTERN[, OPTS])       #PATH_PATTERN -> TOKENS
 ->TOKENS                         #OPTS: delimiter|encodePath

pathToRegexp                      #PATH_PATTERN|TOKENS -> PATH_REGEXP
 (PATH_PATTERN|TOKENS[, OPTS])    #If PATH_PATTERN_ARR: alternatives
 ->PATH_REGEXP                    #OPTS: sensitive|delimiter|trailing|loose|start|end|encodePath

match(PATH_PATTERN|TOKENS[, OPTS])#PATH_PATTERN|TOKENS + 'PATH' -> PARAMS
 ->FUNC('PATH')                   #OBJ:
 ->OBJ|false                      #  - params PARAMS
                                  #  - path STR: whole part of 'PATH' that matched
                                  #  - index NUM: first matching group in PATH_REGEXP, usually 0
                                  #OPTS: sensitive|delimiter|trailing|loose|start|end|encodePath|decode
                                  #For better matching, it is recommended to 'PATH'.normalize()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           SERIALIZE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


compile                           #PATH_PATTERN|TOKENS + PARAMS -> 'PATH'
 (PATH_PATTERN|TOKENS[, OPTS])    #Replaces:
 ->FUNC([PARAMS])                 #  - :VAR by PARAMS.VAR
 ->'PATH'                         #  - (...) by PARAMS[NUM]
                                  #OPTS: sensitive|delimiter|loose|encodePath|encode|validate
