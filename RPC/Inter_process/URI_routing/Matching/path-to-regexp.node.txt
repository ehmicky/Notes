
                  
   PATH-TO-REGEXP  
                  



ALTERNATIVES ==>                  #  - URLPattern (preferred if browser|Deno): standard DOM
                                  #  - path-to-regexp (preferred if Node): more features

VERSION ==>                       #6.2.2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONCEPT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


'PATH'                            #URI path without template variables

PATH_PATTERN                      #URI path with template variables.
                                  #Can contain:
                                  #  - :VAR
                                  #     - VAR name is \p{XID_Continue}+, i.e. roughly same as valid JavaScript identifiers
                                  #  - (REGEXP)
                                  #  - *
                                  #  - RAW: anything else
                                  #Cannot contain ! @ , (reserved chars)
                                  #Can \-escape any special char: () {} * ? + ; ! @ ,
                                  #Can contain {...}? or {...}+
                                  #  - ... can be any characters, :VAR or (REGEXP)
                                  #  - :VAR or (REGEXP) can be preceded|followed by any characters (PREFIX|SUFFIX)
                                  #  - can be ...;SEPARATOR
                                  #     - def SEPARATOR: PREFIX + SUFFIX

TOKENS                            #Several TTOKENs, i.e. PATH_PATTERN parsed
TOKENS.tokens                     #ARR of TOKEN|'RAW'

TOKEN                             #
TOKEN.name                        #'VAR' (if :VAR) or NUM (if (REGEXP)) or '' ({...}?+ without :VAR|(REGEXP))
TOKEN.pattern                     #'REGEXP':
                                  #  - (REGEXP): as is
                                  #  - '*': [^DELIM]*
TOKEN.modifier                    #'*', '?', '+' or ''
TOKEN.prefix                      #'PREFIX' (if {...:VAR}?+ or {...(REGEXP)}?+)
TOKEN.suffix                      #'SUFFIX' (if {:VAR...}?+ or {(REGEXP)...}?+)
TOKEN.separator                   #'SEPARATOR' (if {...}?+)
                                  #If '*': 'DELIM'

PATH_REGEXP                       #REGEXP where each parenthesis group matches a TOKEN
PATH_REGEXP.keys                  #TOKEN_ARR, filled by ???

PARAMS                            #Template variables as OBJ
                                  #Keys are TOKEN.name
                                  #Values can be:
                                  #  - STR
                                  #  - NUM -> 'NUM' (only serialization, not parsing)
                                  #  - ARR:
                                  #     - if modifier + *
                                  #     - is joined with 'PREFIX' and 'SUFFIX'

OPTS.sensitive                    #BOOL (def: false). Case-sensitive
OPTS|TOKENS.delimiter             #'DELIM' (def: '/')
                                  #Does not stop {...}+
OPTS.trailing                     #BOOL (def: true). DELIM character optional at the end
OPTS.loose                        #BOOL (def: true). Allow multiple DELIM characters in a row
OPTS.start                        #BOOL (def: true). Must match from beginning
OPTS.end                          #BOOL (def: true). Must match until end
OPTS.encodePath                   #FUNC(STR)->STR (def: identity)
                                  #Transform 'RAW', 'PREFIX' and 'SUFFIX'
                                  #Should use encodeURI() if PATH_PATTERN might contain non-URI-encoded characters
OPTS.encode                       #FUNC(VAL)->STR or false (def, same as identity function)
                                  #Should use encodeURIComponent()
OPTS.decode                       #FUNC(STR)->STR or false (def, same as identity function)
                                  #Should use decodeURIComponent()
OPTS.validate                     #BOOL (def: true)
                                  #Throw TypeError if PARAMS VAL matches TOKEN.name but not TOKEN.pattern, e.g. contains delimiters
                                  #TypeError is always thrown when missing PARAMS (no TOKEN with correct TOKEN.name)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PARSING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


parse(PATH_PATTERN[, OPTS])       #PATH_PATTERN -> TOKENS
 ->TOKENS                         #OPTS: delimiter|encodePath

pathToRegexp                      #PATH_PATTERN|TOKENS -> PATH_REGEXP
 (PATH_PATTERN|TOKENS[, OPTS])    #If PATH_PATTERN_ARR: alternatives
 ->PATH_REGEXP                    #OPTS: delimiter|encodePath|sensitive|trailing|loose|start|end

match(PATH_PATTERN|TOKENS[, OPTS])#PATH_PATTERN|TOKENS + 'PATH' -> PARAMS
 ->FUNC('PATH')                   #OBJ:
 ->OBJ|false                      #  - params PARAMS
                                  #  - path 'PATH'
                                  #  - index NUM: first matching group in PATH_REGEXP, usually 0
                                  #OPTS: delimiter|encodePath|decode|sensitive|trailing|loose|start|end
                                  #For better matching, it is recommended to normalize 'PATH':
                                  #  - Unicode: STR.normalize()
                                  #  - squash multiple delimiters: STR.replace(/\/+/g, '/')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          SERIALIZING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


compile                           #PATH_PATTERN|TOKENS + PARAMS -> 'PATH'
 (PATH_PATTERN|TOKENS[, OPTS])    #Replaces:
 ->FUNC([PARAMS])                 #  - :VAR by PARAMS.VAR
 ->'PATH'                         #  - (...) by PARAMS[NUM]
                                  #OPTS: delimiter|encodePath|encode|validate|sensitive
