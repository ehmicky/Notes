
                  
   PATH-TO-REGEXP  
                  



ALTERNATIVES ==>                  #  - URLPattern (preferred if browser|Deno): standard DOM
                                  #  - path-to-regexp (preferred if Node): more features

VERSION ==>                       #6.2.2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONCEPT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


'PATH'                            #URI path without template variables

PATH_PATTERN                      #URI path with template variables.
                                  #Can contain:
                                  #  - (REGEXP)
                                  #  - :VAR
                                  #     - VAR name is any Unicode identifier character (\p{XID_Continue})
                                  #  - *
                                  #Cannot contain ! @ , (reserved chars)
                                  #Can \-escape any special char: () {} * ? + ; ! @ ,
                                  #(REGEXP) and :VAR:
                                  #  - can be followed by modifier ? +
                                  #     - + does not stop at DELIM
                                  #  - must be wrapped in {[PREFIX]...[SUFFIX][;SEPARATOR]}:
                                  #     - def SEPARATOR: PREFIX + SUFFIX

OPTS|TTOKENS.delimiter            #'DELIM' (def: '/')

TTOKENS                           #Several TTOKENs, i.e. PATH_PATTERN parsed
TTOKENS.tokens                    #TTOKEN_ARR
TTOKEN                            #Path groups, either TOKEN or 'STR' (anything between TOKEN)

TOKEN                             #
TOKEN.name                        #'VAR' (if :VAR) or NUM (if (REGEXP)) or '' ({...} without :VAR|(REGEXP))
TOKEN.pattern                     #'REGEXP':
                                  #  - (REGEXP): as is
                                  #  - '*': [^DELIM]*
TOKEN.modifier                    #'*', '?', '+' or ''
TOKEN.prefix                      #'PREFIX'
TOKEN.suffix                      #'SUFFIX'
TOKEN.separator                   #'SEPARATOR' (if {...}? or {...}+)
                                  #If '*': 'DELIM'

PATH_REGEXP                       #REGEXP where each parenthesis group matches a TOKEN
                                  #OPTS:
                                  #  - sensitive BOOL (def: false): case-sensitive
                                  #  - trailing BOOL: if true (def), optional DELIM character (e.g. trailing slash)
                                  #  - loose BOOL (def: true): allow multiple DELIM characters in a row (e.g. two slashes)
                                  #  - start BOOL (def: true): must match from beginning
                                  #  - end BOOL (def: true): must match until end
                                  #  - encodePath FUNC(STR)->STR (def: identity):
                                  #     - serialize 'STR' TTOKENs and TOKEN.prefix|suffix
                                  #     - should use encodeURI() if PATH_PATTERN might contain non-URI-encoded characters
PATH_REGEXP.keys                  #TOKEN_ARR, filled by ???

PARAMS                            #Template variables as OBJ
                                  #Keys are TOKEN.name
                                  #Values can be:
                                  #  - STR
                                  #  - NUM -> 'NUM' (only serialization, not parsing)
                                  #  - ARR:
                                  #     - if modifier + *
                                  #     - is joined with 'PREFIX' and 'SUFFIX'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PARSING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


parse(PATH_PATTERN[, OPTS])       #PATH_PATTERN -> TTOKEN_ARR
 ->TTOKEN_ARR                     #OPTS: delimiter|encodePath

pathToRegexp                      #PATH_PATTERN|TTOKENS -> PATH_REGEXP
 (PATH_PATTERN|TTOKENS[, OPTS])   #If PATH_PATTERN_ARR: alternatives
 ->PATH_REGEXP                    #OPTS: delimiter|encodePath|sensitive|trailing|loose|start|end

match(PATH_PATTERN|TTOKENS[,OPTS])#PATH_PATTERN|TTOKENS + 'PATH' -> PARAMS
 ->FUNC('PATH')->OBJ|false        #OBJ:
                                  #  - params PARAMS
                                  #  - path 'PATH'
                                  #  - index NUM: first matching group in PATH_REGEXP, usually 0
                                  #OPTS:
                                  #  - delimiter|encodePath|sensitive|trailing|loose|start|end: see above
                                  #  - decode FUNC(STR)->STR (def: none)
                                  #     - should use decodeURIComponent()
                                  #     - can also be false (same as identify function)
                                  #For better matching, it is recommended to normalize 'PATH':
                                  #  - Unicode: STR.normalize()
                                  #  - squash multiple delimiters: STR.replace(/\/+/g, '/')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          SERIALIZING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


compile                           #PATH_PATTERN|TTOKENS + PARAMS -> 'PATH'
 (PATH_PATTERN|TTOKENS[, OPTS])   #Replaces:
 ->FUNC([PARAMS])                 #  - :VAR by PARAMS.VAR
 ->'PATH'                         #  - (...) by PARAMS[NUM]
                                  #OPTS:
                                  #  - delimiter|encodePath|sensitive: see above
                                  #  - validate BOOL (def: true):
                                  #     - throw TypeError if PARAMS VAL matches TOKEN.name but not TOKEN.pattern, e.g. contains delimiters
                                  #     - TypeError is always thrown when missing PARAMS (no TOKEN with correct TOKEN.name)
                                  #  - encode FUNC(VAL)->STR (def: none)
                                  #     - should use encodeURIComponent()
                                  #     - can also be false (same as identify function)
