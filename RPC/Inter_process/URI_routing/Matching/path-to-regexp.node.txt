
                  
   PATH-TO-REGEXP  
                  



ALTERNATIVES ==>                  #  - URLPattern (preferred if browser|Deno): standard DOM
                                  #  - path-to-regexp (preferred if Node): more features

VERSION ==>                       #7.1.0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PATTERN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


'PATH'                            #URI path without template variables

PATH_PATTERN                      #URI path with template variables
                                  #Can contain:
                                  #  - :VAR
                                  #     - VAR name is same as valid JavaScript identifiers
                                  #        - can use other chars with :"VAR" or \-escaping
                                  #     - matches anything until DELIM
                                  #  - *
                                  #     - same as {([^DELIM]*);DELIM}*
                                  #     - i.e. match anything (including nothing), not stopped by DELIM
                                  #  - RAW: anything else
                                  #Can \-escape any special char: {} * \
                                  #Reserved chars that must be \-escaped: () [] ? + ! @ ,
                                  #Can wrap anything with {...}
                                  #  - can include :VAR but only once
                                  #     - PREFIX|SUFFIX: any characters before|after
                                  #  - can end with ;SEPARATOR
                                  #     - def SEPARATOR: PREFIX + SUFFIX (if none: '')
                                  #  - with {...}* and {...}+
                                  #     - each match of :VAR is separated by SEPARATOR
                                  #     - but PREFIX|SUFFIX is before|after all matches (not each)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            TOKENS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new TokenData(TOKEN|'RAW'_ARR
 [, 'SEPARATOR'])                 #TOKENS
TOKENS.tokens                     #TOKEN|'RAW'_ARR

TOKEN                             #OBJ representation of PATH_PATTERN's part
TOKEN.type                        #Can be:
                                  #  - 'param' (if :VAR)
                                  #  - 'wildcard' (if *)
                                  #  - 'group' (if {...})
                                  #  - 'text' (if 'RAW')
TOKEN.name                        #Can be:
                                  #  - 'VAR' (if :VAR)
                                  #  - '*' (if *)
TOKEN.tokens                      #'...' (if {...})

PATH_REGEXP                       #REGEXP where each parenthesis group matches a :VAR
PATH_REGEXP.keys                  #TOKEN_ARR of all :VAR

PARAMS                            #Template variables (:VAR) as OBJ
                                  #Keys are TOKEN.name
                                  #Values can be:
                                  #  - STR
                                  #  - ARR
                                  #     - each match of :VAR inside {...}* or {...}+ (separated by SEPARATOR)
                                  #     - not if OPTS.decode|encode false


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OPTIONS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OPTS.sensitive                    #BOOL (def: false). Case-sensitive

OPTS|TOKENS.delimiter             #'DELIM' (def: '/')
                                  #Multiple DELIMs in a row are counted as separate
OPTS.trailing                     #BOOL (def: true). End must match:
                                  #  - OPTS.trailing false + OPTS.end true: $
                                  #  - OPTS.trailing false + OPTS.end false: $ or DELIM
                                  #  - OPTS.trailing true + OPTS.end true: $ or DELIM$
                                  #  - OPTS.trailing true + OPTS.end false: $ or DELIM or DELIM$
OPTS.end                          #BOOL (def: true). Must match until end
                                  #Always matches from beginning

OPTS.encodePath                   #FUNC('RAAW')->STR (def: identity)
                                  #Transform 'RAW' during parsing
                                  #Should use encodeURI() if PATH_PATTERN might contain non-URI-encoded characters
OPTS.encode                       #FUNC(VAL)->STR or false (same as identity function)
                                  #Transform PARAMS.* during serialization
                                  #Def: encodeURIComponent()
OPTS.decode                       #FUNC(STR)->STR or false (same as identity function)
                                  #Transform PARAMS.* during parsing
                                  #Def: decodeURIComponent()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PARSE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


parse(PATH_PATTERN[, OPTS])       #PATH_PATTERN -> TOKENS
 ->TOKENS                         #OPTS: encodePath

pathToRegexp                      #PATH_PATTERN|TOKENS -> PATH_REGEXP
 (PATH_PATTERN|TOKENS[_ARR]       #If ARR: alternatives
 [, OPTS])->PATH_REGEXP           #OPTS: sensitive|delimiter|trailing|end

match(PATH_PATTERN|TOKENS[, OPTS])#PATH_PATTERN|TOKENS + 'PATH' -> PARAMS
 ->FUNC('PATH')                   #OPTS: sensitive|delimiter|trailing|end|decode
 ->MATCH_RESULT|false             #For better matching, it is recommended to 'PATH'.normalize()
MATCH_RESULT.params               #PARAMS
MATCH_RESULT.path                 #STR. Whole part of 'PATH' that matched
MATCH_RESULT.index                #NUM. First matching group in PATH_REGEXP, usually 0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           SERIALIZE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


compile                           #PATH_PATTERN|TOKENS + PARAMS -> 'PATH'
 (PATH_PATTERN|TOKENS[, OPTS])    #Replaces:
 ->FUNC([PARAMS])                 #  - :VAR by PARAMS.VAR
 ->'PATH'                         #  - (...) by PARAMS[NUM]
                                  #OPTS: delimiter|encode
