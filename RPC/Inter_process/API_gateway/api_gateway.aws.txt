
                                  ┏━━━━━━━━━━━━━━━━━┓
                                  ┃   API GATEWAY   ┃
                                  ┗━━━━━━━━━━━━━━━━━┛

VERSION ==>                       #2024-02-15

NOTATION ==>                     =#: v1
                                 -#: v2 HTTP
                                 ~#: v2 WebSocket

SUMMARY ==>                       #API: v1|v2, HTTP|WebSocket, quick create
                                  #Payloads: compression, binary
                                  #Route: request|response, params|body validation|mapping, test, gateway responses
                                  #Integration: request|response, proxy, HTTP, AWS (Lambda, first-class), mock, timeout, VPC
                                  #AWS integrations: Lambda, first-class (SQS, EventBridge, Kinesis, StepFunctions, AppConfig)
                                  #Authorization: API.policy, none|IAM|Lambda|JWT|Cognito, cache, test, CORS, WAF
                                  #Stage: variables, deployment, auto-deploy, canary
                                  #Monitoring: metrics (detailed), execution logging (level, body), access logging (CloudWatch|Kinesis, format), X-Ray
                                  #Caching: size, TTL, encryption, key, invalidation
                                  #OpenAPI: import|export (merge|overwrite), extensions, DOCPART, SDK
                                  #Domain name: edge|regional|private, certificates, client TLS, server auth, mapping
                                  #Usage plan: throttle, quota, key (import), marketplace
                                  #WebSocket: connection, message

                                  ┌──────────────┐
                                  │   VERSIONS   │
                                  └──────────────┘

VERSION ==>                       #There are two versions of the API
                                 =#v1 (also called "REST")
                                  #  - more features, except for a few that v2-only
                                -~#v2 (also called "HTTP"/"WebSocket")
                                  #  - cheaper
                                  #  - slightly faster
                                  #  - simpler

MIXING ==>                        #Resources are version-specific, i.e. cannot use v1|v2 together
                                =-#But HTTP|REST APIs can be mixed under same domain name by using MAPPINGs

UNIQUE FEATURES PER VERSION ==>  =#Edge, caching, compression, canary, X-Ray, USAGEPLAN, private API
                                 =#OpenAPI 2.0, API.cloneFrom, ROUTE|AUTHORIZER testing, GRESP, Cognito, API.policy, WAF, Kinesis logging, merge IMPORT, DOCPART, SDK, CCERTIFICATE
                                 -#First-class INTEGRATION, JWT, CORS, API quick create
                                 ~#WebSocket

MISSING FEATURES PER VERSION ==> =#Auto-deploy
                                 -#Binary, request|response body mapping, request params|body validation, mock INTEGRATION, execution logging
                                 ~#HTTP, path variables, OpenAPI custom fields, VPCLINK, AUTHORIZER cache

CONCLUSION ==>                    #If needs WebSocket, use v2
                                  #Otherwise, if just needs routing and no v1-unique features, use v2 HTTP
                                  #Otherwise, use v1 REST

                                  ┌─────────┐
                                  │   API   │
                                  └─────────┘

SERVICE_DOMAIN                    #apigateway.amazonaws.com

FORMAT ==>                        #JSON REST

REQ_ID                            #x-amzn-requestid [S]
                                  #Extended REQ_ID: x-amz-apigw-id [S]

x-amzn-ErrorType: ERROR_TYPE [S]  #Automatically set on 4**|5**

PAGINATION ==>                    #Uses:
                                 =#  - REQ.limit NUM (def 25, max 500), REQ|RES.position STR
                                -~#  - REQ.maxResults NUM (def 25, max 500), REQ|RES.nextToken STR
                                  #No pagination:
                                  #  - GetTags()
                                 =#  - GetStages()
                                  #  - with SDK:
                                 =#     - GetAuthorizers(), GetDocumentation*(), GetGatewayResponses(), GetRequestValidators(), GetSdkTypes()
                                -~#     - all ACTIONs
                                -~#  - with CLI: GetApiMappings()

THROTTLING ==>                    #Per ACCOUNT:
                                  #  - 10/s: total for all ACTIONs (burst of 40) (for API ACTIONs, not client requests)
                                 =#  - 5/s: Create|DeleteApiKey, Create|DeleteResource
                                 =#  - 1/s: PutRestApi
                                 =#  - 5/2s: GetResources
                                 =#  - 1/5s: CreateDeployment
                                 =#  - 1/15s: CreateVpcLink
                                 =#  - 1/20s: CreateDocumentationVersion, UpdateAccount, UpdateUsagePlan
                                 =#  - 1/30s: Create|Update|DeleteDomainName, ImportDocumentationParts, DeleteRestApi, DeleteVpcLink
                                 =#  - 1/3s (ENDPOINT.types 'EDGE'), 1/30s (ENDPOINT.types 'REGIONAL|PRIVATE'): CreateRestApi, ImportRestApi

PRICING ==>                       #Requests:
                                 =#  - 3.5$/1e6 requests
                                  #     - 20% cheaper after 3e8 requests, 32% after 1e9, 57% after 2e10
                                  #     - also pay EC2 egress cost on responses (e.g. 1$/11GB)
                                  #     - free for first 12 months: 1e6 requests/month
                                 -#  - 1$/1e6 requests
                                  #     - 10% cheaper after 3e8 requests
                                  #     - no egress cost, but big responses count as multiple, using size % 512KB
                                  #     - free for first 12 months: 1e6 requests/month
                                 ~#  - 1$/1e6 requests or responses (push message)
                                  #     - 20% cheaper after 1e9 requests
                                  #     - no igress|egress cost, but big requests|responses count as multiple, using size % 32KB
                                  #     - free for first 12 months: 1e6 requests/month
                                 ~#Connections: 1$/1e6 connections
                                  #  - for 4 minutes connections, proportional to duration otherwise
                                  #  - free for first 12 months: 7.5e5 connections/month
                                 =#Caching:
                                  #  - depending on STAGE.cacheClusterSize:
                                  #     - 0.5 GB: 15$, 1.6GB: 27$, 6.1GB: 146$, 13.5GB: 182$, 28.4GB: 365$, 58.2GB: 730$, 118GB: 1400$, 237GB: 2800$
                                  #  - those are monthly prices, but this is charged hourly
                                =-#  - AUTHORIZER cache: free

                                  ┌──────────┐
                                  │   AUTH   │
                                  └──────────┘

AmazonAPIGatewayAdministrator     #AWS managed POLICY that allows PACTION apigateway:*

AWSServiceRoleForAPIGateway       #SERVER_LINKED_ROLE automatically created when using:
                                  #  - ROUTE_SETTINGS.loggingLevel
                                  #  - STAGE.accessLogSettings
                                  #  - STAGE.tracingEnabled
                                  #  - [D]DNAME.[ownershipVerification]certificateArn
                                  #  - VPC
                                  #Can only be assumed by SERVICE_DOMAIN 'ops.apigateway.amazonaws.com'
APIGatewayServiceRolePolicy       #POLICY of APIGatewayServiceRole allowing PACTIONs:
                                  #  - logs:*LogDelivery
                                  #  - firehose:PutRecord[Batch]|DescribeDeliveryStream on STREAM 'amazon-apigateway-*'
                                  #  - xray:PutTraceSegments|PutTelemetryRecords|GetSamplingTargets|GetSamplingRules
                                  #  - acm:Describe|GetCertificate
                                  #  - elasticloadbalancing:*Listener*|DescribeLoadBalancers
                                  #  - ec2:*NetworkInterface*|*PrivateIpAddresses|DescribeAvailabilityZones
                                  #    |DescribeVpcs|DescribeSubnets|DescribeRouteTables|DescribeSecurityGroups
                                  #  - servicediscovery:DiscoverInstances|GetNamespace|GetService

                                  ┌─────────────┐
                                  │   EXECUTE   │
                                  └─────────────┘

EXECUTE API ==>                   #Separate API, also called "data plane API"
                                  #Used only by INVOKE_URI and by *Connection()

SERVICE_DOMAIN                    #execute-api.amazonaws.com

INVOKE_URI                      =-#https://API_MID.execute-api.REGION.amazonaws.com
                                 ~#wss://API_MID.execute-api.REGION.amazonaws.com
                                  #URI for clients to call the API
                                  #Online documentation calls "app developer" the client, as opposed to "API developer".

                                  ┌─────────────────┐
                                  │   EXECUTE IAC   │
                                  └─────────────────┘

ICSTAGE.urlForPath(['/PATH'])    =#'https://API_MID.execute-api.REGION.amazonaws.com/STAGE/[PATH]'
 ->'URL'                          #Def 'PATH': '/'
ICAPI.url
ICAPI.urlForPath(...)->'URL'     =#Same as ICAPI.deploymentStage.urlForPath(...)
CAPI_OPTS.endpointExportName     =#STR. EXPORT.name of STACK OUTPUT with value ICAPI.url

CSTAGE.url                       -#'https://API_MID.execute-api.REGION.amazonaws.com/[STAGE]'
CAPI.url                         -#CAPI.defaultStage.url
CSTAGE.callbackUrl               ~#'https://API_MID.execute-api.REGION.amazonaws.com/STAGE'
CSTAGE.url                       ~#'wss://API_MID.execute-api.REGION.amazonaws.com/STAGE'

                                  ┌───────────────┐
                                  │   PATCH API   │
                                  └───────────────┘

PATCH METHODS ==>                =#All Update*() request payload is different from other SERVICEs
                                  #Instead, it is { patchOperations: PATCH_OP_ARR }

PATCH_OP                         =#See JSON patch doc. Has following differences
PATCH_OP.op 'add|remove'         =#For properties that are ARR, 'VAL,...', or dynamic OBJs (where keys are user-defined)
PATCH_OP.op 'copy'               =#Only with STAGE.deploymentId, with PATCH_OP.from '/canarySettings/deploymentId'
PATCH_OP.path                    =#Targets (unless documented otherwise):
                                  #  - dynamic OBJs: OBJ itself (but can use op 'add|remove')
                                  #  - non-dynamic OBJs: OBJ.*
                                  #  - OBJ_ARR: ARR.*, but using an OBJ id, not the ARR index
                                  #  - other ARR: ARR itself

                                  ┌──────────────┐
                                  │   REST API   │
                                  └──────────────┘

API                               #API gateway, i.e. sets of endpoints that perform validation and authorization then forward to a backend
                                  #Max 120 (if ENDPOINT.types 'EDGE') or 600 (if ENDPOINT.types 'REGIONAL|PRIVATE') per ACCOUNT
API_ARN                          =#arn:aws:apigateway:REGION::/restapis[/API_MID]
API_ARN                         -~#arn:aws:apigateway:REGION::/apis[/API_MID]
API.id                           =
API.apiId                       -~#API_MID
OINFO.title
API.name                          #'API'
OINFO.description
API.description                   #STR
API.createdDate                  =#DATE_NUM
                                -~#'DATE'

OSERVER2.schemes
OSERVER3.url
API.protocolType                -~#Protocol used, either 'HTTP' or 'WEBSOCKET'
API.tags                          #TAGS
                                 =#Inherited by children (ABAC-only): RESOURCE, ROUTE, ROUTESETTINGS, INTEGRATION, GRESP, MODEL,
                                  #AUTHORIZER, STAGE, DEPLOYMENT, DOCPART, DOCVERS

                                  ┌───────────────────┐
                                  │   REST API AUTH   │
                                  └───────────────────┘

COND_KEY ApiName                  #API.name, on Create|Update|Delete[Rest]Api()

                                  ┌──────────────────┐
                                  │   REST API API   │
                                  └──────────────────┘

POST /restapis                   =#Req: API
                                  #  - no id, rootResourceId, createdDate, warnings
                                  #  - only one with cloneFrom
CreateRestApi()                   #Res: API
PATCH /restapis/API_MID          =#Req: API
                                  #  - no id, rootResourceId, createdDate, version, warnings, tags
UpdateRestApi()                   #Res: API
GET /restapis                    =#Req: empty
GetRestApis()                     #Res: item API_ARR
GET /restapis/API_MID            =#Req: empty
GetRestApi()                      #Res: API
DELETE /restapis/API_MID         =#Req: empty
DeleteRestApi()                   #Res: empty

POST /v2/apis                   -~#Req: API
CreateApi()                       #  - no apiId, warnings, importInfo, apiEndpoint, apiGatewayManaged, createdDate
                                  #  - only ones with target|credentialsArn|routeKey
                                  #Res: API
PATCH /v2/apis/API_MID          -~#Req: API
UpdateApi()                       #  - no apiId, warnings, importInfo, apiEndpoint, apiGatewayManaged, createdDate
                                  #  - no protocolType, tags
                                  #  - only ones with target|credentialsArn|routeKey
                                  #Res: API
GET /v2/apis                    -~#Req: empty
GetApis()                         #Res: items API_ARR
GET /v2/apis/API_MID            -~#Req: empty
GetApi()                          #Res: API
DELETE /v2/apis/API_MID         -~#Req: empty
DeleteApi()                       #Res: empty

                                  ┌──────────────────┐
                                  │   REST API IAC   │
                                  └──────────────────┘

AWS::ApiGateway::RestApi         =#RESPROPs: Name, Description, Tags
                                  #RESATTRs: RestApiId
AWS::ApiGatewayV2::Api          -~#RESPROPs: Name, Description, ProtocolType, Tags
                                  #RESATTRs: ApiId

new RestApi
 (...CARGS[, CAPI_OPTS])         =#CAPI
new HttpApi
 (...CARGS[, CAPI_OPTS])         -#CAPI with API.protocolType 'HTTP'
new WebSocketApi
 (...CARGS[, CAPI_OPTS])         ~#CAPI with API.protocolType 'WEBSOCKET'
RestApi.fromRestApiId
 (...CARGS, 'API_MID')->ICAPI    =#
RestApi.fromRestApiAttributes
 (...CARGS, CAPI_OPTS)->ICAPI    =#CAPI_OPTS: restApiId, restApiName, rootResourceId
HttpApi.fromHttpApiAttributes
 (...CARGS, CAPI_OPTS)->ICAPI    -#CAPI_OPTS: httpApiId, apiEndpoint (API.apiEndpoint)
WebSocketApi
 .fromWebSocketApiAttributes
 (...CARGS, CAPI_OPTS)->ICAPI    ~#CAPI_OPTS: webSocketId, apiEndpoint (API.apiEndpoint)

ICAPI.restApiId                  =
CAPI.apiId                      -~#API.id
ICAPI[_OPTS].restApiName         =
CAPI_OPTS.apiName               -~
CAPI_OPTS.httpApiName            -
CAPI_OPTS.webSocketApiName       ~#'API' (def: NODE.id). API.name
ICAPI_OPTS.description            #API.*

                                  ┌───────────────────────┐
                                  │   REST API COMPOSER   │
                                  └───────────────────────┘

INFRASTRUCTURE COMPOSER ==>       #Has enhanced component for AWS::Serverless::Api

                                  ┌─────────────────────┐
                                  │   REST API PULUMI   │
                                  └─────────────────────┘

pulumi-aws-apigateway             #Package with an API REZ simplifying setting:
                                  #  - Lambda INTEGRATION|AUTHORIZER, with inline FUNC
                                  #  - S3 INTEGRATION, uploading local files then serving them
                                  #Does not allow using every API Gateway features
                                  #Version 2.1.0
                                  #Not fully documented yet

                                  ┌───────────────────┐
                                  │   REST API LINT   │
                                  └───────────────────┘

cfn-lint E3660                    #API.name must be set unless RAW_API_EXPORT used

                                  ┌──────────────────┐
                                  │   QUICK CREATE   │
                                  └──────────────────┘

API.cloneFrom                    =#API_MID to copy from

API.target                       -#STR. Automatically create:
                                  #  - '$default' STAGE
                                  #  - '$default' ROUTE
                                  #  - INTEGRATION, depending on STR:
                                  #     - 'URL': integrationType 'HTTP_PROXY'
                                  #     - Lambda FUNC_ARN: integrationType 'AWS_PROXY'
                                  #All readonly, except INTEGRATION can be updated, and API deleted
API.credentialsArn               -#INTEGRATION.credentialsArn, when using API.target FUNC_ARN
API.routeKey                     -#'ROUTE' (def: '$default') when using API.target FUNC_ARN

API|STAGE|ROUTE|INTEGRATION
 .apiGatewayManaged              -#BOOL. Whether created through API.target

                                  ┌──────────────────────┐
                                  │   QUICK CREATE IAC   │
                                  └──────────────────────┘

AWS::ApiGateway::RestApi         =#Includes RESPROPs: CloneFrom
AWS::ApiGatewayV2::Api           -#Includes RESPROPs: Target, CredentialsArn, RouteKey
AWS::ApiGatewayV2::              -#To use instead of AWS::ApiGatewayV2::Integration|Route|Stage
 ApiGatewayManagedOverrides       #RESPROPs: ApiId
                                  #RESATTRs: Id

CAPI_OPTS.cloneFrom              =#ICAPI. API.*

                                  ┌──────────────┐
                                  │   PAYLOADS   │
                                  └──────────────┘

API.minimumCompressionSize       =#NUM (def: disabled, max: 10MB). When set:
OSPEC.x-amazon-apigateway-        #  - allow compressed request body
 minimum-compression-size         #     - if Content-Encoding: ALGO [C] (only first ALGO)
                                  #  - produce compressed response body
                                  #     - if Accept-Encoding: ALGO [C] (only first ALGO) and no Content-Encoding [S]
                                  #Only for gzip|deflate
                                  #Only when body >=NUM bytes.

API.binaryMediaTypes
OSPEC.x-amazon-apigateway-       =#Binary 'MIME|*'_ARR allowed
 binary-media-types               #By default, only non-binary allowed, i.e. UTF8

INTEGRATION|IRESP.contentHandling=
INTEGRATION|IRESP                ~#STR. Whether request|response body should be:
 .contentHandlingStrategy         #  - default: keep as is
                                  #  - CONVERT_TO_BINARY: base64 decode
                                  #     - only if non-binary MIME request|response
                                  #  - CONVERT_TO_TEXT: base64 encode
                                  #     - only if binary MIME request|response
                                 ~#Backend request|response must be base64'd, if binary

MIME                              #Based on Content-Type [C] and Accept: MIME [S] (only first MIME)
                                  #Def: application/json
                                  #Can use wildcard *
                                  #Can be '$default' as a catch-all

                                  ┌──────────────────┐
                                  │   PAYLOADS SDK   │
                                  └──────────────────┘

@aws-sdk/
 middleware-sdk-api-gateway       #Used internally by SDK to force Accept: application/json [C]

                                  ┌──────────────────┐
                                  │   PAYLOADS IAC   │
                                  └──────────────────┘

AWS::ApiGateway::RestApi         =#Includes RESPROPs: MinimumCompressionSize, BinaryMediaTypes (JSON pointer encoded)
AWS::ApiGateway::Method          =#Includes RESPROPs: Integration:
                                  #  - ContentHandling
                                  #  - IntegrationResponses OBJ_ARR: ContentHandling
AWS::ApiGatewayV2::
 Integration[Response]           ~#Includes RESPROPs: ContentHandlingStrategy

CAPI_OPTS.minCompressionSize     =#SIZE. API.minimumCompressionSize
CAPI_OPTS.binaryMediaTypes       =#API.*

CINTEGRATION_OOPTS|CIRESP
 .contentHandling                =
CANY|AWS|LAMBDA_INTEGRATION_OPTS
 .contentHandling                ~#INTEGRATION.contentHandling[Strategy]

                                  ┌──────────────┐
                                  │   RESOURCE   │
                                  └──────────────┘

RESOURCE                         =#Endpoints sharing same /PATH (but different HTTP_METHODs)
                                  #Max 300 per API (soft)
RESOURCE_ARN                     =#arn:aws:apigateway:REGION::/restapis/API_MID/resources[/RESOURCE_MID]
RESOURCE.id                      =#RESOURCE_MID

OPATHS./PATH
RESOURCE.path                    =#'/PATH'
RESOURCE.pathPart                =#'PATHPART'. Last part of '/PATH'
                                  #Only [:alnum:]._-:$
                                  #Cannot include / nor start with /
                                  #Can be '{PATHVAR[+]}' (see below)
RESOURCE.parentId                =#PARENT_RESOURCE_MID, i.e. same '/PATH' without last part
API.rootResourceId               =#Root RESOURCE_MID

                                  ┌──────────────────┐
                                  │   RESOURCE API   │
                                  └──────────────────┘

POST /restapis/API_MID           =#Req: RESOURCE
 /resources/PARENT_RESOURCE_MID   #  - no id, path, resourceMethods
CreateResource()                  #  - parentId is in URL path
                                  #Res: RESOURCE
PATCH /restapis/API_MID          =#Req: RESOURCE
 /resources/RESOURCE_MID          #  - no id, path, resourceMethods
UpdateResource()                  #Res: RESOURCE
GET /restapis/API_MID/resources  =#Req:
GetResources()                    #  - only embed 'methods', to return RESOURCE.resourceMethods
                                  #Res: item RESOURCE_ARR
GET /restapis/API_MID
 /resources/RESOURCE_MID         =#Req: only embed 'methods'
GetResource()                     #Res: RESOURCE
DELETE /restapis/API_MID
 /resources/RESOURCE_MID         =#Req: empty
DeleteResource()                  #Res: empty

                                  ┌──────────────────┐
                                  │   RESOURCE IAC   │
                                  └──────────────────┘

AWS::ApiGateway::Resource        =#RESPROPs: RestApiId, PathPart, ParentId
                                  #RESATTRs: ResourceId
AWS::ApiGateway::RestApi         =#Includes RESATTRs: RootResourceId

new Resource
 (...CARGS, CRESOURCE_OPTS)      =#
Resource.fromResourceAttributes
 (...CARGS, CRESOURCE_OPTS)
 ->ICRESOURCE                    =#CRESOURCE_OPTS: restApi, resourceId, path
ICRESOURCE.api                   =#ICAPI
ICRESOURCE.resourceId            =#RESOURCE.id

ICRESOURCE.path                  =#RESOURCE.*
CRESOURCE_OPTS.pathPart          =#RESOURCE.*
CRESOURCE_OPTS.parent            =#ICRESOURCE. RESOURCE.parentId
CRESOURCE.parentResource         =#ICRESOURCE or undefined (if root)

ICRESOURCE.addResource
 ('PATHPART'[, CRESOURCE_OPTS])
 ->ICRESOURCE                    =#Automatically sets CRESOURCE_OPTS.pathPart|parent
ICRESOURCE.getResource
 ('PATHPART')->CRESOURCE2        =#Direct child CRESOURCE2
ICRESOURCE.resourceForPath       =#Any child CRESOURCE2
 ('PATH')->CRESOURCE2             #'PATH' should either be '/', or not start with /
                                  #Creates CRESOURCE2 if not existing

CAPI.restApiRootResourceId       =#RESOURCE_MID_CSATTR. API.rootResourceId
                                  #Throws if used RestApi.fromRestApiId()
CAPI.root                        =#CRESOURCE
                                  #Throws if used RestApi.fromRestApiId()

                                  ┌───────────────────┐
                                  │   ROUTE REQUEST   │
                                  └───────────────────┘

ROUTE                             #Endpoint, i.e. /PATH + HTTP_METHOD
                                  #Max 300 per API (soft)
ROUTE_ARN                        =#arn:aws:apigateway:REGION::/restapis/API_MID/integrations/resources/RESOURCE_MID/methods/HTTP_METHOD
ROUTE_ARN                       -~#arn:aws:apigateway:REGION::/apis/API_MID/routes[/ROUTE_MID]
ROUTE.routeId                   -~#ROUTE_MID

OPATHDEF.HTTP_METHOD
ROUTE.httpMethod                 =#'HTTP_METHOD'
RESOURCE
 .resourceMethods.HTTP_METHOD    =#ROUTE
ROUTE.routeKey                  -~#'ROUTE', as:
                                 -#  - 'HTTP_METHOD /PATH'
                                  #     - [[:alnum:]_-.,:{}]
                                  #     - cannot be /[s]ping
                                  #     - cannot end with /
                                 ~#  - any STR
                                  #Can be '$default' as a catch-all
                                 ~#  - including on non-JSON request bodies
                                  #  - def: returns { message: 'Not Found' }
API.routeSelectionExpression    -~#'ROUTE_$EXPR' used by each request
                                 -#Always '${request.method} ${request.path}'
OOPERATION.isDefaultRoute       =-#BOOL. ROUTE '$default'
                                  #Must be under OPATHDEF.x-amazon-apigateway-any-method

OPARAM.name|in|required|schema
ROUTE.requestParameters.EXPR    =~#BOOL (requiredness). Allowed request non-body parameters from client
                                  #EXPR: only non-body 'request.*'
                                  #Max size of URI: 8KB
                                  #Max size of URI + headers: 10KB
PARAM_ARN                        ~#arn:aws:apigateway:REGION::/apis/API_MID/routes/ROUTE_MID/requestparameters/PARAM

OPARAM2.name|in|required|schema
OOPERATION2.consumes
OREQ_BODY3.content|required
ROUTE.requestModels.MIME         =#'MODEL'. Allowed request body parameters from client
                                  #Max request body size: 10MB
ROUTE.requestModels.ROUTE_MODEL  ~#Same but using a name selected by MODEL_$EXPR
                                  #Max request body size: 128KB, with max frame size 32KB
                                  #ROUTE_MODEL can be '$default' as a catch-all
ROUTE.modelSelectionExpression   ~#'ROUTE_MODEL_$EXPR'

                                  ┌───────────────────────┐
                                  │   ROUTE REQUEST API   │
                                  └───────────────────────┘

PUT /restapis/API_MID
 /resources/RESOURCE_MID         =#Req: ROUTE
 /methods/HTTP_METHOD             #  - no httpMethod, methodIntegration, methodResponses
PutMethod()                       #Res: ROUTE
PATCH /restapis/API_MID          =#Req: ROUTE
 /resources/RESOURCE_MID          #  - no httpMethod, methodIntegration, methodResponses
 /methods/HTTP_METHOD             #  - op:add|remove, not op:replace: authorizationScopes
UpdateMethod()                    #Res: ROUTE
GET /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD            =#Req: empty
GetMethod()                       #Res: ROUTE
DELETE /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD            =#Req: empty
DeleteMethod()                    #Res: empty

POST /v2/apis/API_MID/routes    -~#Req: ROUTE
CreateRoute()                     #  - no routeId, apiGatewayManaged
                                  #Res: ROUTE
PATCH /v2/apis/API_MID          -~#Req: ROUTE
 /routes/ROUTE_MID                #  - no routeId, apiGatewayManaged
UpdateRoute()                     #Res: ROUTE
GET /v2/apis/API_MID/routes     -~#Req: empty
GetRoutes()                       #Res: items ROUTE_ARR
GET /v2/apis/API_MID
 /routes/ROUTE_MID              -~#Req: empty
GetRoute()                        #Res: ROUTE
DELETE /v2/apis/API_MID
 /routes/ROUTE_MID              -~#Req: empty
DeleteRoute()                     #Res: empty
DELETE /v2/apis/API_MID
 /routes/ROUTE_MID              -~#Req: empty
 /requestparameters/EXPR          #Res: empty
DeleteRouteRequestParameter()     #Delete ROUTE.requestParameters

                                  ┌───────────────────────┐
                                  │   ROUTE REQUEST IAC   │
                                  └───────────────────────┘

AWS::ApiGateway::Method          =#RESPROPs: RestApiId, ResourceId, HttpMethod, RequestParameters, RequestModels
                                  #Cannot list
AWS::ApiGatewayV2::Route          #RESPROPs:
                                ~-#  - ApiId, RouteKey, RouteResponseSelectionExpression
                                 ~#  - RequestParameters, RequestModels, ModelSelectionExpression
                                  #RESATTRs: RouteId
AWS::ApiGatewayV2::Api          ~-#Includes RESATTRs: RouteSelectionExpression

new Method
 (...CARGS, CROUTE_OPTS)         =#
new HttpRoute
 (...CARGS, CROUTE_OPTS)         -#
new WebSocketRoute
 (...CARGS, CROUTE_OPTS)         ~#
ICRESOURCE.addMethod('HTTP_METHOD'
 [, CINTEGRATION[, CROUTE_OOPTS]])
 ->CROUTE                        =#Automatically sets CROUTE_OPTS: resource, integration, options
CAPI.addRoutes(CROUTE_OPTS)      -#Creates multiple CROUTEs, with CROUTE_OPTS:
 ->CROUTE_ARR                     #  - routeKey -> methods 'HTTP_METHOD'_ARR (def: ['ANY']) + path '/PATH'
                                  #  - integration, authorizer, authorizationScopes
                                  #Automatically sets CROUTE_OPTS: httpApi
                                  #Takes into account CAPI_OPTS.defaultAuthorizer|defaultAuthorizationScopes
CAPI.addRoute
 ('ROUTE', CROUTE_OPTS)->CROUTE  ~#Automatically sets CROUTE_OPTS: webSocketApi, routeKey

CAPI_OPTS.defaultIntegration     -#CINTEGRATION. Creates a '$default' ROUTE
                                  #Automatically sets CROUTE_OPTS: httpApi, routeKey, integration
                                  #Takes into account CAPI_OPTS.defaultAuthorizer|defaultAuthorizationScopes
CAPI_OPTS.defaultRouteOptions
 |connectRouteOptions            ~#CROUTE_OPTS. Creates a '$default|$connect|$disconnect' ROUTE
 |disconnectRouteOptions          #Automatically sets CROUTE_OPTS: webSocketApi, routeKey

CROUTE_OPTS.options              =#CROUTE_OOPTS
CAPI_OPTS|CRESOURCE[_OPTS]       =#CROUTE_OOPTS
 .defaultMethodOptions            #No: requestModels, requestValidator*
                                  #Inherited by child RESOURCEs (can override specific members)

CROUTE.api                       =
CROUTE[_OPTS].httpApi            -
CROUTE[_OPTS].webSocketApi       ~#ICAPI
CROUTE.methodId                  =
CROUTE.routeId                  -~#ROUTE_MID

CROUTE[_OPTS].resource           =#ICRESOURCE
CROUTE[_OPTS].httpMethod         =#ROUTE.*. Normalized to uppercase
CROUTE[_OPTS].routeKey           ~#ROUTE.*
CROUTE_OPTS.routeKey             -#ROUTE.* among:
                                  #  - HttpRouteKey.DEFAULT: '$default'
                                  #  - HttpRouteKey.with('/PATH'[, 'HTTP_METHOD'])
                                  #     - def HTTP_METHOD: 'ANY'
CROUTE.method                    -#'HTTP_METHOD'
CROUTE.path                      -#'/PATH' or undefined (if '$default')

CAPI_OPTS                       -~#API.*
 .routeSelectionExpression       ~#Def: '$request.body.action'

CROUTE_OOPTS.requestParameters   =#ROUTE.*
CROUTE_OOPTS.requestModels.MIME  =#ICMODEL. ROUTE.*

CAPI.methods                      #CROUTE_ARR

                                  ┌──────────────────────┐
                                  │   ROUTE PARAMETERS   │
                                  └──────────────────────┘

HTTP_METHOD                       #'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' or 'ANY'
OPATHDEF.x-amazon-apigateway-
 any-method                     =-#OOPERATION but with HTTP_METHOD 'ANY'

X-HTTP-Method-Override: METHOD [C]#Handled.
                                  #Removed to INTEGRATION request, unless explicitely mapped with INTEGRATION.requestParameters

QUERY STRING ==>                  #Cannot use ; |

HEADERS FORWARDING ==>            #Request|response header names are capitalized
                                  #Cookies are sorted by name
                                  #Creates Content-Length [C] if missing
                                  #Sets Host [C] to match INTEGRATION
                                  #Removes:
                                  #  - Content-MD5 [C], Expect [C|S], Host [S], Max-Forwards [C], Server [C],
                                  #    TE [C|S], Transfer-Encoding [C|S], Trailer [C|S], Upgrade [C|S]
                                  #  - Proxy-Authenticate [C|S], WWW-Authenticate [C]
                                  #  - Authorization [C] if it contains AWS signature
                                  #  - only with integrationType:
                                  #     - 'HTTP': Accept [S]
                                  #     - 'HTTP_PROXY': Content-Encoding [C]
                                  #     - 'HTTP[_PROXY]': Via [C]
                                  #     - 'AWS_PROXY': Connection [C]
                                  #     - '*_PROXY': Via [S]
                                  #Renames HEADER to X-Amzn-Remapped-HEADER:
                                  #  - Authorization [S], Connection [S], Date [S], Max-Forwards [S],
                                  #    Server [S], User-Agent [S], WWW-Authenticate [S]

RESERVED HEADERS ==>              #Many well-known HTTP headers cannot be set in request|response
                                  #Nor x-amz[n]-* [C|S]
                                  #I.e. mostly meant for custom headers

                                  ┌───────────────────────────┐
                                  │   ROUTE PATH PARAMETERS   │
                                  └───────────────────────────┘

PATHVAR ==>                     =-#/PATH can include '{PATHVAR[+]}'
                                  #Can use /{PATHVAR} but not /...{PATHVAR}...
                                  #Can resolve to empty
                                  #If +:
                                  #  - does not stop at next /
                                  #  - called "proxy parameter"
                                  #  - PATHVAR often named `proxy`
                                  #Since it is part of URL, must be URL encoded

                                  ┌───────────────────────────────┐
                                  │   ROUTE PATH PARAMETERS IAC   │
                                  └───────────────────────────────┘

new ProxyResource                =#CRESOURCE with partPart '{proxy+}'
 (...CARGS, CRESOURCE_OPTS)       #No CRESOURCE_OPTS.defaultCorsPreflightOptions
                                  #The following is only with ProxyResource
ICRESOURCE.addProxy
 ([CRESOURCE_OPTS])->CRESOURCE   =#Automatically sets CRESOURCE_OPTS.pathPart|parent

CRESOURCE_OPTS.anyMethod         =#BOOL (def: true). Creates a CROUTE with HTTP_METHOD 'ANY'

CRESOURCE.addMethod(...)         =#Same but:
                                  #  - if this is a sub-RESOURCE and parent is root
                                  #  - then add CROUTE to both current RESOURCE and root RESOURCE
                                  #  - this ensures '{proxy+}' matches empty PATHs

                                  ┌────────────────────┐
                                  │   ROUTE RESPONSE   │
                                  └────────────────────┘

RRESP                           =~#ROUTE's response status|headers|body
                                 ~#Def: no response
                                  #Not with integrationType '*_PROXY'
RRESP_ARN                        =#arn:aws:apigateway:REGION::/restapis/API_MID/integrations/resources/RESOURCE_MID/methods/HTTP_METHOD/responses/STATUS_NUM
RRESP_ARN                        ~#arn:aws:apigateway:REGION::/apis/API_MID/routes/ROUTE_MID/routeresponses[/RRESP_MID]
RRESP.routeReponseId             ~#RRESP_MID
RRESP.routeReponseKey            ~#'RRESP'. Can only be '$default', i.e. only one RRESP per ROUTE

ROUTE.methodResponses.STATUS_NUM =#RRESP
ROUTE.routeResponse
 SelectionExpression             ~#Always '\$default'

ORESPONSES.STATUS_NUM
RRESP.statusCode                 =#'STATUS_NUM'
ORESP2.headers.HEADER
ORESP3.headers.HEADER.schema
RRESP.responseParameters.EXPR   =~#BOOL (requiredness). Response headers to send to client
                                  #EXPR: only 'response.header.*'
OOPERATION2.produces
ORESP2.schema
ORESP3.content.MIME.schema
RRESP.responseModels.MIME        =#'MODEL'. Response body to send to client
RRESP.responseModels.RRESP_MODEL ~#Same but using a name
RRESP.modelSelectionExpression   ~#'RRESP_MODEL_$EXPR'. Currently not supported

ACONTEXT.status                   #STATUS_NUM of RRESP
CONTEXT.error.message           =-#'ERROR' message of RRESP
CONTEXT.error.messageString       #Like CONTEXT.error.message but "-quoted

ACONTEXT.responseLatency        =-#Duration NUM (in ms) of RRESP

ACONTEXT.responseLength         =-#RRESP Content-Length [S]

CONTEXT.dataProcessed            -#NUM of bytes processed

                                  ┌────────────────────────┐
                                  │   ROUTE RESPONSE API   │
                                  └────────────────────────┘

PUT /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD            =#Req: RRESP
 /responses/STATUS_NUM            #  - no statusCode
PutMethodResponse()               #Res: RRESP
PATCH /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD            =#Req: RRESP
 /responses/STATUS_NUM            #  - no statusCode
UpdateMethodResponse()            #Res: RRESP
GET /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /responses/STATUS_NUM           =#Req: empty
GetMethodResponse()               #Res: RRESP
DELETE /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /responses/STATUS_NUM           =#Req: empty
DeleteMethodResponse()            #Res: empty

POST /v2/apis/API_MID
 /routes/ROUTE_MID               ~#Req: RRESP
 /routeresponses                  #  - no routeResponseId
CreateRouteResponse()             #Res: RRESP
PATCH /v2/apis/API_MID
 /routes/ROUTE_MID               ~#Req: RRESP
 /routeresponses/RRESP_MID        #  - no routeResponseId
UpdateRouteResponse()             #Res: RRESP
GET /v2/apis/API_MID
 /routes/ROUTE_MID
 /routeresponses                 ~#Req: empty
GetRouteResponses()               #Res: RRESP
GET /v2/apis/API_MID
 /routes/ROUTE_MID
 /routeresponses/RRESP_MID       ~#Req: empty
GetRouteResponse()                #Res: items RRESP_ARR
DELETE /v2/apis/API_MID
 /routes/ROUTE_MID
 /routeresponses/RRESP_MID       ~#Req: empty
DeleteRouteResponse()             #Res: empty

                                  ┌────────────────────────┐
                                  │   ROUTE RESPONSE IAC   │
                                  └────────────────────────┘

AWS::ApiGateway::Method          =#Includes RESPROPs: MethodResponses OBJ_ARR: StatusCode, ResponseParameters, ResponseModels
AWS::ApiGatewayV2::RouteResponse ~#RESPROPs:
                                  #  - ApiId, RouteId, RouteResponseKey, ResponseModels, ModelSelectionExpression
                                  #  - ResponseParameters.Required BOOL
                                  #RESATTRs: RouteResponseId

CROUTE_OOPTS.methodResponses     =#CRRESP_ARR (def: []). ROUTE.methodResponses
CROUTE.addMethodResponse(CRRESP) =#Same
CRRESP
 .statusCode|responseParameters  =#RRESP.*
CRRESP.responseModels.MIME       =#ICMODEL. RRESP.*

CROUTE_OPTS.returnResponse       ~#BOOL (def: false). Adds a RRESP

                                  ┌────────────────────────────┐
                                  │   ROUTE RESPONSE METRICS   │
                                  └────────────────────────────┘

AWS/ApiGateway/Latency          =-#Duration NUM (in ms) of RRESP
                                  #cdk-monitoring-constructs:
                                  #  - XSTAT: METRIC, summary WIDGET, MALARM LatencyXSTAT > CALARM_OPTS.maxLatency
                                  #     - XSTAT can be:
                                  #        - 'Average'
                                  #        - 'P50|70|90|95|99|999|9999|100'
                                  #        - 'TM50|70|90|95|99|999|9999'
                                  #        - 'TM(95|99|99.9|99.99%:100%)'
                                  #           - with MALARM, called 'TM95|99|999|9999Outlier' instead
                                  #     - WIDGETs: only for CXMONITORING_OPTS.latencyTypesToRender 'XSTAT'_ARR (def: ['P50', 'P90', 'P99'])
                                  #        - always include XSTATs added as MALARMs
ICAPI|ICSTAGE.metricLatency
 ([CMETRIC_OPTS])->CMETRIC      =-#
CROUTE.metricLatency
 (ICSTAGE[, CMETRIC_OPTS])
 ->CMETRIC                       =#

AWS/ApiGateway/DataProcessed     -#NUM of bytes processed
ICAPI|ICSTAGE.metricDataProcessed
 ([CMETRIC_OPTS])->CMETRIC       -#

                                  ┌────────────────┐
                                  │   ROUTE TEST   │
                                  └────────────────┘

INVOKE_ROUTE_REQ                 =#Like calling INVOKE_URI, but programmatically, for debugging
                                  #Uses STAGE 'test-invoke-stage'
                                  #Not logged by CloudTrail
INVOKE_ROUTE_REQ
 .pathWithQueryString            =#'/PATH?QUERY'. Request path
INVOKE_ROUTE_REQ.headers.HEADER  =#'VAL'. Request headers
INVOKE_ROUTE_REQ
 .multiValueHeaders.HEADER       =#Same as 'VAL'_ARR
INVOKE_ROUTE_REQ.body            =#STR. Request body. Must be JSON
INVOKE_ROUTE_REQ
 .stageVariables.STAGE_VAR       =#'VAL'

INVOKE_ROUTE_RES.status          =#STATUS_NUM of response
INVOKE_ROUTE_RES.headers.HEADER  =#'VAL'. Response headers
INVOKE_ROUTE_RES
 .multiValueHeaders.HEADER       =#Same as 'VAL'_ARR
INVOKE_ROUTE_RES.body            =#STR. Response body
INVOKE_ROUTE_RES.latency         =#NUM (in ms). Duration
INVOKE_ROUTE_RES.log             =#STR. From execution logging

                                  ┌────────────────────┐
                                  │   ROUTE TEST API   │
                                  └────────────────────┘

POST /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD            =#Req: INVOKE_ROUTE_REQ
TestInvokeMethod()                #Res: INVOKE_ROUTE_RES

                                  ┌────────────────────────┐
                                  │   ROUTE TEST TOOLKIT   │
                                  └────────────────────────┘

TEST ROUTE ==>                    #Can invoke a ROUTE from "Explorer"

                                  ┌─────────────────────────┐
                                  │   INTEGRATION REQUEST   │
                                  └─────────────────────────┘

INTEGRATION                       #"Backend", i.e. destination to forward client's request, and send back response from
                                  #Max 300 per API (soft)

OOPERATION.x-amazon-apigateway- =-#INTEGRATION.*, except:
 integration.*                    #  - no *Id, description, apiGatewayManaged
                                  #  - integrationResponses -> responses.REGEXP|default IRESP
                                  #  - responseParameters: use IRESP instead
                                  #When v1|v2 have different names, uses v1's
OCOMPONENTS
 .x-amazon-apigateway-integrations
 .NAME                          =-#OOPERATION.x-amazon-apigateway-integration, to use as JSON reference

INTEGRATION_ARN                  =#arn:aws:apigateway:REGION::/restapis/API_MID/integrations/resources/RESOURCE_MID/methods/HTTP_METHOD/integration
INTEGRATION_ARN                 -~#arn:aws:apigateway:REGION::/apis/API_MID/integrations[/INTEGRATION_MID]
INTEGRATION.integrationId       -~#INTEGRATION_MID
INTEGRATION.description         -~#STR

ROUTE.methodIntegration          =#INTEGRATION
ROUTE.target                    -~#'integrations/INTEGRATION_MID'

INTEGRATION.type                 =
INTEGRATION.integrationType     -~#STR. "Backend" to forward to:
                                  #  - HTTP[_PROXY]: a new HTTP request
                                  #     - initial port must be 80|443|1024-65535
                                  #  - AWS[_PROXY]: a call to an AWS SERVICE
                                =~#  - MOCK: nothing
                                  #Difference between:
                                  #  - HTTP_PROXY: pass initial request as is
                                  #  - AWS_PROXY:
                                  #     - Lambda: pass initial request as a REQ with its parameters|body|context
                                 -#     - "first-class": like integrationType AWS (including mapping parameters) except:
                                  #        - only specific SERVICEs|ACTIONs
                                  #        - INTEGRATION.requestParameters keys are PARAMs, i.e. simpler
                                =~#  - HTTP|AWS ("custom"):
                                  #     - must map parameters|body|context to a body OBJ
                                  #     - if no mapping specified, pass initial request body as is
                                  #     - AWS: any SERVICEs|ACTIONs

INTEGRATION.integrationSubtype   -#'SERVICE-ACTION' among:
                                  #  - SQS-SendMessage|ReceiveMessage|DeleteMessage|PurgeQueue
                                  #  - EventBridge-PutEvents (for a single EVENT)
                                  #  - Kinesis-PutRecord
                                  #  - StepFunctions-Start[Sync]Execution|StopExecution
                                  #  - AppConfig-GetConfiguration
                                  #Only with integrationType 'AWS_PROXY' ("first-class")
INTEGRATION.uri                  =
INTEGRATION.integrationUri      -~#Depending on type:
                                  #  - 'HTTP[_PROXY]': 'URI' to call
                                  #  - 'AWS[_PROXY]':
                                  #     - either:
                                  #        - 'SERVICE_ARN:action/ACTION[&QUERY]': any SERVICEs (including REST)
                                  #        - 'SERVICE_ARN:path/PATH[?QUERY]': REST SERVICEs only
                                  #     - where:
                                  #        - SERVICE_ARN: 'arn:aws:apigateway:REGION:SERVICE'
                                  #        - QUERY: PARAM=VAL&..., only for URL paths and query parameters
                                =~#  - 'MOCK': not allowed
INTEGRATION.httpMethod           =
INTEGRATION.integrationMethod   -~#'HTTP_METHOD' to call
                                  #Not with type 'MOCK'

INTEGRATION.requestParameters     #OBJ. Request parameters to send to backend.
                                  #Non-body parameters (except "first-class")
                                  #Key:
                                =~#  - 'EXPR': only 'integration.request.*'
                                 -#  - if "first-class": 'PARAM' among:
                                  #     - any parameter of the SERVICE ACTION (PATHVARs, query variables, headers, body)
                                  #     - Region
                                 -#  - otherwise: 'TEXPR' (PATHVARs, query variables, headers only)
                                  #Value:
                                =~#  - 'EXPR2'
                                 -#  - '$EXPR2'
                                  #  - [$]EXPR2 is only '[$]request|stagevar|context.*' or static STR
                                  #Not with integrationType '*_PROXY' (except "first-class")

INTEGRATION                     =~#'TEMPLATE'. Request body to send to backend.
 .requestTemplates.MIME           #Not with integrationType '*_PROXY'
INTEGRATION                      ~#Same but using a name selected by templateSelectionExpression
 .requestTemplates.INT_TEMPLATE   #INT_TEMPLATE can be '$default' as a catch-all
                                  #Not with integrationType '*_PROXY'
INTEGRATION
 .templateSelectionExpression    ~#'INT_TEMPLATE_$EXPR'. Can only be 'INT_TEMPLATE' or '$request.body.VARR'
INTEGRATION                     =~#STR. Default behavior when no requestTemplates matches. Can be:
 .passthroughBehavior             #  - NEVER: respond with 415
                                  #  - WHEN_NO_MATCH (def): forward request body as is
                                  #  - WHEN_NO_TEMPLATES: like NEVER if requestTemplates is defined, as WHEN_NO_MATCH otherwise

INTEGRATION.timeoutInMillis       #NUM (in ms, min: 50ms, def|max: 29s). Request+response timeout

                                  ┌──────────────────────────────┐
                                  │   INTEGRATION REQUEST AUTH   │
                                  └──────────────────────────────┘

INTEGRATION.credentials          =
INTEGRATION.credentialsArn      -~#STR. Authentication, among:
                                  #  - ROLE_ARN: must allow Principal.Service 'apigateway.amazonaws.com' assuming it
                                  #  - 'arn:aws:iam::*:user/*': keep current authenticated USER
                                  #  - null (def): none, but can use resource-based POLICY, e.g. Lambda FUNCTION PERMISSION
                                  #Only for integrationType 'AWS[_PROXY]'

                                  ┌─────────────────────────────┐
                                  │   INTEGRATION REQUEST API   │
                                  └─────────────────────────────┘

PUT /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD            =#Req: INTEGRATION
 /integration                     #  - no integrationResponses
PutIntegration()                  #Res: INTEGRATION
PATCH /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD            =#Req: INTEGRATION
 /integration                     #  - no credentials, integrationResponses
UpdateIntegration()               #Res: INTEGRATION
GET /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /integration                    =#Req: empty
GetIntegration()                  #Res: INTEGRATION
DELETE /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /integration                    =#Req: empty
DeleteIntegration()               #Res: empty

POST /v2/apis/API_MID           -~#Req: INTEGRATION
 /integrations                    #  - no integrationId, integrationResponseSelectionExpression, apiGatewayManaged
CreateIntegration()               #Res: INTEGRATION
PATCH /v2/apis/API_MID          -~#Req: INTEGRATION
 /integrations/INTEGRATION_MID    #  - no integrationId, integrationResponseSelectionExpression, apiGatewayManaged
UpdateIntegration()               #Res: INTEGRATION
GET /v2/apis/API_MID
 /integrations                  -~#Req: empty
GetIntegrations()                 #Res: items INTEGRATION_ARR
GET /v2/apis/API_MID
 /integrations/INTEGRATION_MID  -~#Req: empty
GetIntegration()                  #Res: INTEGRATION
DELETE /v2/apis/API_MID
 /integrations/INTEGRATION_MID  -~#Req: empty
DeleteIntegration()               #Res: empty

                                  ┌─────────────────────────────┐
                                  │   INTEGRATION REQUEST IAC   │
                                  └─────────────────────────────┘

AWS::ApiGateway::Method          =#Includes RESPROPs: Integration: IntegrationHttpMethod, Type, Uri, RequestParameters,
                                  #RequestTemplates, PassthroughBehavior, Credentials, TimeoutInMillis
AWS::ApiGatewayV2::Integration  -~#RESPROPs:
                                  #  - ApiId, IntegrationMethod, Description, IntegrationType, IntegrationUri,
                                  #    RequestParameters, CredentialsArn, TimeoutInMillis
                                 -#  - IntegrationSubtype
                                 ~#  - RequestTemplates, TemplateSelectionExpression, PassthroughBehavior
                                  #RESATTRs: IntegrationId
AWS::ApiGatewayV2::Route        -~#Includes RESPROPs: Target
AWS::ApiGatewayV2::              -#Includes RESPROPs:
 ApiGatewayManagedOverrides       #  - Integration: IntegrationMethod, Description, TimeoutInMillis
                                  #  - Route: Target

CROUTE_OPTS.integration          =#CINTEGRATION (def: new MockIntegration()). INTEGRATION + ROUTE.methodIntegration
CAPI_OPTS|CRESOURCE[_OPTS]       =#CINTEGRATION
 .defaultIntegration              #Same but lower priority, and inherited by child RESOURCEs (unless overridden)
CROUTE_OPTS.integration         -~#CINTEGRATION. INTEGRATION + ROUTE.target

new HttpRouteIntegration
 ('CONSTRUCT')                   -
new WebSocketRouteIntegration
 ('CONSTRUCT')                   ~#CANY_INTEGRATION. CINTEGRATION with any INTEGRATION.type
CANY_INTEGRATION.bind(OPTS)     -~#Must be redefined
 ->CANY_INTEGRATION_OPTS          #OPTS: route|scope ICROUTE
CANY_INTEGRATION_OPTS.type      -~#INTEGRATION.type
CANY_INTEGRATION_OPTS.subtype    -#INTEGRATION.integrationSubtype

new MockIntegration
 ([CMOCK_INTEGRATION_OPTS])      =
new WebSocketMockIntegration
 ('CONSTRUCT')                   ~#CINTEGRATION with INTEGRATION.type 'MOCK'
new HttpIntegration('URI'
 [, CHTTP_INTEGRATION_OPTS])     =#CINTEGRATION with INTEGRATION.type 'HTTP[_PROXY]' and INTEGRATION.uri 'URI'
new HttpUrlIntegration
 ('CONSTRUCT', 'URI'
 [, CHTTP_INTEGRATION_OPTS])     -#CINTEGRATION with INTEGRATION.type 'HTTP_PROXY' and INTEGRATION.uri 'URI'
new AwsIntegration
 (CAWS_INTEGRATION_OPTS)         =#CINTEGRATION with INTEGRATION.type 'AWS[_PROXY]'
new WebSocketAwsIntegration
 ('CONSTRUCT'
 [, CAWS_INTEGRATION_OPTS])      ~#CINTEGRATION with INTEGRATION.type 'AWS'
CHTTP|AWS|LAMDA_INTEGRATION_OPTS
 .proxy                          =#BOOL (def: true with HTTP|LAMBDA, false with AWS). INTEGRATION.type

CMOCK|LAMBDA_INTEGRATION_OPTS.*
CHTTP|AWS_INTEGRATION_OPTS
 .options                        =#CINTEGRATION_OOPTS

CANY_INTEGRATION_OPTS.uri       -~
CAWS_INTEGRATION_OPTS
 .integrationUri                 ~#INTEGRATION.integrationUri
CAWS_INTEGRATION_OPTS.region     =#'REGION' of INTEGRATION.uri
CAWS_INTEGRATION_OPTS.service    =#'SERVICE' of INTEGRATION.uri
CAWS_INTEGRATION_OPTS.subdomain  =#STR. Subdomain: STR.SERVICE of INTEGRATION.uri
CAWS_INTEGRATION_OPTS.path       =#'/PATH[?QUERY]' of INTEGRATION.uri
CAWS_INTEGRATION_OPTS.action     =#'ACTION' of INTEGRATION.uri
CAWS_INTEGRATION_OPTS            =#QUERY_OBJ of INTEGRATION.uri
 .actionParameters                #Only with CAWS_INTEGRATION_OPTS.action
                                  #Automatically URI encodes keys|values

CHTTP_INTEGRATION_OPTS.httpMethod=#'HTTP_METHOD' (def: 'GET'). INTEGRATION.httpMethod
CHTTP|VPC_INTEGRATION_OPTS.method-#'HTTP_METHOD' (def: 'ANY'). INTEGRATION.integrationMethod
CAWS_INTEGRATION_OPTS
 .integrationHttpMethod          =#'HTTP_METHOD' (def: 'POST'). INTEGRATION.httpMethod
CANY_INTEGRATION_OPTS.method    -~
CAWS_INTEGRATION_OPTS
 .integrationMethod              ~#'HTTP_METHOD' (no def). INTEGRATION.integrationMethod

CINTEGRATION_OOPTS
 .requestParameters
 |requestTemplates
 |passthroughBehavior            =
CANY|AWS_INTEGRATION_OOPTS
 .requestParameters
 |requestTemplates
 |passthroughBehavior            ~#INTEGRATION.*
CANY|HTTP|LAMBDA|VPC
 _INTEGRATION_OPTS
 .parameterMapping               -#CREQ_PARAMS. INTEGRATION.requestParameters

CANY|AWS_INTEGRATION_OPTS
 .templateSelectionExpression    ~#INTEGRATION.*

CINTEGRATION_OOPTS
 .credentialsRole                =
CANY|AWS_INTEGRATION_OPTS
 .credentialsRole                ~#ICROLE. INTEGRATION.credentials[Arn]
CINTEGRATION_OOPTS
 .credentialsPassthrough         =#BOOL (def: false). INTEGRATION.credentials 'arn:aws:iam::*:user/*'
CANY_INTEGRATION_OPTS.credentials-#INTEGRATION.credentialsArn among:
                                  #  - IntegrationCredentials.fromRole(ICROLE)
                                  #  - IntegrationCredentials.useCallerIdentity(): 'arn:aws:iam::*:user/*'

CINTEGRATION_OOPTS.timeout       =
CANY|HTTP|AWS|LAMBDA|VPC
 _INTEGRATION_OPTS.timeout      -~#DURATION. INTEGRATION.timeoutInMillis

                                  ┌──────────────────────────┐
                                  │   INTEGRATION RESPONSE   │
                                  └──────────────────────────┘

IRESP                             #Response from backend, sent to RRESP (not client)
                                  #Not with integrationType '*_PROXY'
IRESP_ARN                        =#arn:aws:apigateway:REGION::/restapis/API_MID/integrations/resources/RESOURCE_MID/methods/HTTP_METHOD/integration/responses/STATUS_NUM
IRESP_ARN                       -~#arn:aws:apigateway:REGION::/apis/API_MID/integrations[/IRESP_MID]
IRESP.integrationResponseId     -~#IRESP_MID
IRESP.selectionPattern           =#'REGEXP' whether to use IRESP, matched against STATUS_NUM
                                  #Can be '' (def) as a catch-all
IRESP.integrationResponseKey    -~#'/REGEXP/' whether to use IRESP, matched against STATUS_NUM
                                 ~#Can be '$default' as a catch-all

INTEGRATION
 .integrationResponses.REGEXP    =#IRESP
INTEGRATION.integrationResponse  ~#'$EXPR' evaluated to IRESP.integrationResponseKey
 SelectionExpression              #Can only be '$integration.response.statuscode'

IRESP.statusCode                 =#'STATUS_NUM'
IRESP.responseParameters.EXPR   =~#'EXPR2'. Response headers to send to RRESP (not client)
                                  #EXPR: only 'response.header.*'
                                  #EXPR2: only 'integration.response|stageVariables|context.*' or static STR
INTEGRATION                      -#'$EXPR'. Response headers to send to RRESP (not client)
 .responseParameters.TEXPR        #TEXPR: only headers or status code
                                  #'$EXPR': only '$integration.response|stageVariables|context.*' or static STR

IRESP.responseTemplates.MIME     =#'TEMPLATE'. Response body to send to RRESP (not client)
IRESP.responseTemplate           ~#Same but as a name selected by templateSelectionExpression
 .IRESP_TEMPLATE                  #Can be '$default' as a catch-all
IRESP                            ~#'IRESP_TEMPLATE_$EXPR'. Can be:
 .templateSelectionExpression     #  - 'IRESP_TEMPLATE'
                                  #  - '$request.body.VARR'
                                  #  - '$integration.response.statuscode'
                                  #  - '$integration.response.[multivalue]header.HEADER'

ACONTEXT.integration.status     =-
CONTEXT.integrationErrorMessage  -
ACONTEXT.integration.error      =-
ACONTEXT.integrationLatency     =-
ACONTEXT.integration.latency    =-#Same as ACONTEXT.authorize.* but for backend response
ACONTEXT[.integration]          =-#Like ACONTEXT.integration.status except with Lambda:
 .integrationStatus               #STATUS_NUM of Invoke() call itself, not MAIN_RES.statusCode

                                  ┌──────────────────────────────┐
                                  │   INTEGRATION RESPONSE API   │
                                  └──────────────────────────────┘

PUT /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /integration                    =#Req: IRESP
 /responses/STATUS_NUM            #  - no statusCode
PutIntegrationResponse()          #Res: IRESP
PATCH /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /integration                    =#Req: IRESP
 /responses/STATUS_NUM            #  - no statusCode
UpdateIntegrationResponse()       #Res: IRESP
GET /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /integration
 /responses/STATUS_NUM           =#Req: empty
GetIntegrationResponse()          #Res: IRESP
DELETE /restapis/API_MID
 /resources/RESOURCE_MID
 /methods/HTTP_METHOD
 /integration
 /responses/STATUS_NUM           =#Req: empty
DeleteIntegrationResponse()       #Res: empty

POST /v2/apis/API_MID
 /integrations/INTEGRATION_MID  -~#Req: IRESP
 /integrationresponses            #  - no integrationResponseId
CreateIntegrationResponse()       #Res: IRESP
PATCH /v2/apis/API_MID
 /integrations/INTEGRATION_MID  -~#Req: IRESP
 /integrationresponses/IRESP_MID  #  - no integrationResponseId
UpdateIntegrationResponse()       #Res: IRESP
GET /v2/apis/API_MID
 /integrations/INTEGRATION_MID
 /integrationresponses          -~#Req: empty
GetIntegrationResponses()         #Res: items IRESP_ARR
GET /v2/apis/API_MID
 /integrations/INTEGRATION_MID
 /integrationresponses
 /IRESP_MID                     -~#Req: empty
GetIntegrationResponse()          #Res: IRESP
DELETE /v2/apis/API_MID
 /integrations/INTEGRATION_MID
 /integrationresponses
 /IRESP_MID                     -~#Req: empty
DeleteIntegrationResponse()       #Res: empty

                                  ┌──────────────────────────────┐
                                  │   INTEGRATION RESPONSE IAC   │
                                  └──────────────────────────────┘

AWS::ApiGateway::Method          =#Includes RESPROPs: Integration: IntegrationResponses OBJ_ARR:
                                  #SelectionPattern, StatusCode, ResponseParameters, ResponseTemplates
AWS::ApiGatewayV2::             -~#RESPROPs:
 IntegrationResponse              #  - ApiId, IntegrationId, IntegrationResponseKey, ResponseParameters
                                 ~#  - ResponseTemplates, TemplateSelectionExpression
                                  #RESATTRs: IntegrationResponseId

CINTEGRATION_OOPTS
 .integrationResponses           =#CIRESP_ARR. INTEGRATION.integrationResponses
CIRESP.selectionPattern          =#'REGEXP' from INTEGRATION.integrationResponses.REGEXP
CIRESP.statusCode
 |responseParameters
 |responseTemplates              =#IRESP.*

                                  ┌──────────────────────────────────┐
                                  │   INTEGRATION RESPONSE METRICS   │
                                  └──────────────────────────────────┘

AWS/ApiGateway/IntegrationLatency #CloudWatch METRIC with duration NUM (in ms) of INTEGRATION
                                  #cdk-monitoring-constructs:
                                -~#  - XSTAT: METRIC, summary WIDGET, MALARM IntegrationLatencyXSTAT > CALARM_OPTS.maxLatency
                                  #     - XSTAT can be:
                                  #        - 'Average'
                                  #        - 'P50|70|90|95|99|999|9999|100'
                                  #        - 'TM50|70|90|95|99|999|9999'
                                  #        - 'TM(95|99|99.9|99.99%:100%)'
                                  #           - with MALARM, called 'TM95|99|999|9999Outlier' instead
                                  #     - WIDGETs: only for CXMONITORING_OPTS.latencyTypesToRender 'XSTAT'_ARR (def: ['P50', 'P90', 'P99'])
                                  #        - always include XSTATs added as MALARMs
ICAPI|ICSTAGE
 .metricIntegrationLatency
 ([CMETRIC_OPTS])->CMETRIC      =-#
CROUTE.metricIntegrationLatency
 (ICSTAGE[, CMETRIC_OPTS])
 ->CMETRIC                       =#

                                  ┌────────────────────────┐
                                  │   INTEGRATION LAMBDA   │
                                  └────────────────────────┘

INTEGRATION.httpMethod           =
INTEGRATION.integrationMethod   -~#'POST'
INTEGRATION.uri                  =#'arn:aws:apigateway:REGION:lambda:path/YYYY-MM-DD/functions/SHORT_FUNC_ARN/invocations[?Qualifier=QUALIFIER]
INTEGRATION.integrationUri      -~#Lambda FUNC_ARN
INTEGRATION.requestParameters     #Can be used to set X-Amz-InvocationType|ClientContext|LogType [C]
LAMBDA INVOCATIONTYPE ==>         #'RequestResponse', but can be changed with X-Amz-InvocationType [C]

ERRORS ==>                        #Invocation|function errors (but not RES with 4**|5** status codes) are returned as 502
                                  #with response body { message: 'Internal server error' }

INTEGRATION                     -~#'X.Y' of the request sent to backend.
 .payloadFormatVersion            #With Lambda + integrationType 'AWS_PROXY':
                                 -#  - either '1.0' or '2.0', documented as REQ*[1|2]
                                 ~#  - always '1.0', documented as REQ*[0]
                                  #Otherwise, always '1.0'
REQ.version                       #undefined ('1.0') or '2.0'

REQ                               #If integrationType 'AWS', request body as is
                                  #If integrationType 'AWS_PROXY', following properties
REQ.requestContext                #REQ_CONTEXT
REQ_CONTEXT2.http                 #REQ_HTTP2

CONTEXT.protocol                =-
REQ_CONTEXT1|REQ_HTTP2.protocol   #Like FUNC_URL_REQ_CONTEXT_HTTP.protocol
CONTEXT.httpMethod              =-
REQ[_CONTEXT]1.httpMethod
REQ_HTTP2.method                  #Like FUNC_URL_REQ_CONTEXT_HTTP.method
CONTEXT.domainPrefix            =-
CONTEXT.apiId
REQ_CONTEXT.domainPrefix|apiId    #'API_MID'
[REQ_]CONTEXT.domainName          #STR
CONTEXT.path                    =-
REQ[_CONTEXT]1|REQ_HTTP2.path
REQ2.rawPath                      #'/PATH'
CONTEXT.resourcePath             =
REQ1.resource
REQ_CONTEXT1.resourcePath         #Last '/PATH' part
CONTEXT.resourceId               =
REQ_CONTEXT1.resourceId           #RESOURCE_MID
CONTEXT.routeKey                -~
REQ_CONTEXT0|2.routeKey
REQ2.routeKey                     #'ROUTE'

REQ1|2.pathParameters             #OBJ|null of PATHVARs
                                  #Not URL decoded
REQ2.rawQueryString
REQ1.queryStringParameters
REQ.headers                       #Like FUNC_URL_REQ.*
REQ2.cookies                      #ARR. Like FUNC_URL_REQ.*
                                  #REQ0|1 can use REQ.headers.Cookie STR instead
REQ0|1
 .multiValueQueryStringParameters
 |multiValueHeaders               #Same but, with ARR values (instead of comma-separated) if duplicate name
REQ0|1.body                       #Like FUNC_URL_REQ.*
QUERY API_GATEWAY_REST           =
QUERY API_GATEWAY_HTTP          -~#JMESPath 'QUERY' (see its doc) for REQ0|1.body, that JSON parses it
REQ.isBase64Encoded               #Like FUNC_URL_REQ.*

[REQ_]CONTEXT.stage               #'STAGE'
REQ.stageVariables                #OBJ|null of STAGEVARs

[REQ_]CONTEXT.requestId           #REQ_ID of client request
CONTEXT|REQ_CONTEXT0|1
 .extendedRequestId               #x-amz-id-2 [S] of client request
CONTEXT.awsEndpointRequestId
ACONTEXT.integration.requestId  =-#REQ_ID of backend request
CONTEXT.awsEndpointRequestId2    -#x-amz-id-2 [S] of backend request
CONTEXT|REQ_CONTEXT0|1
 .requestTime[Epoch]
REQ_CONTEXT2.time[Epoch]          #Like FUNC_URL_REQ_CONTEXT.time[Epoch]
REQ_IDENTITY0|1|REQ_HTTP2.sourceIp#Like FUNC_URL_REQ_CONTEXT_HTTP.*
REQ_IDENTITY1|REQ_HTTP2.userAgent #Like FUNC_URL_REQ_CONTEXT_HTTP.*

CONTEXT.accountId               =-
REQ_CONTEXT.accountId             #ACCOUNT_ID of API
CONTEXT.identity                  #CONTEXT_IDENTITY
REQ_CONTEXT0|1.identity           #REQ_IDENTITY0|1
CONTEXT_IDENTITY.principalOrgId =-
REQ_IDENTITY0|1.principalOrgId
CONTEXT_IDENTITY|REQ_IDENTITY0|1
 .accountId
CONTEXT_IDENTITY|REQ_IDENTITY0|1
 .userArn
CONTEXT_IDENTITY|REQ_IDENTITY0|1
 .user
CONTEXT_IDENTITY|REQ_IDENTITY0|1
 .caller                          #Like FUNC_URL_REQ_IAM.*
REQ_IDENTITY0|1.accessKey         #Only when IAM authenticated

RES                               #One of: MAIN_RES, ERROR_RES, CUSTOM_ERROR_RES
MAIN_RES.statusCode|headers|body  #Like FUNC_URL_RES.*
 |isBase64Encoded                 #Must base64 if binary MIME
MAIN_RES.multiValueHeaders        #OBJ

ERROR_RES.errorType|errorMessage
 |stackTrace|cause                #Like Lambda
IRESP.selectionPattern
IRESP.integrationResponseKey      #When using ERROR_RES, matches ERROR_RES.errorMessage, not STATUS_NUM
INTEGRATION.integrationResponse
 SelectionExpression             ~#When using ERROR_RES, must be '$integration.response.body.errorMessage' instead

CUSTOM_ERROR_RES                  #Is 'OBJ_JSON', not OBJ
CUSTOM_ERROR_RES.errorType        #STR. ERROR.name
CUSTOM_ERROR_RES.trace            #CUSTOM_ERROR_TRACE
CUSTOM_ERROR_TRACE.file           #'FILENAME'
CUSTOM_ERROR_TRACE.function       #'FUNC()'
CUSTOM_ERROR_TRACE.line           #LINE_NUM
CUSTOM_ERROR_RES.httpStatus       #STATUS_NUM
CUSTOM_ERROR_RES.requestId        #REQ_ID. Should forward REQ_CONTEXT.requestId

                                  ┌─────────────────────────────┐
                                  │   INTEGRATION LAMBDA AUTH   │
                                  └─────────────────────────────┘

PERMISSIONS ==>                   #Must use FUNCTION PERMISSION or INTEGRATION.credentials[Arn] to allow:
                                  #  - PACTION lambda:InvokeFunction
                                  #  - Principal.Service 'apigateway.amazonaws.com'
                                  #  - COND_KEY aws:SourceArn CALL_ROUTE_ARN
                                  #  - COND_KEY aws:SourceAccount|SourceOrg*

                                  ┌────────────────────────────┐
                                  │   INTEGRATION LAMBDA IAC   │
                                  └────────────────────────────┘

AWS::ApiGatewayV2::Integration  -~#Includes RESPROPs: PayloadFormatVersion
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Integration: PayloadFormatVersion

new LambdaIntegration(ICANYFUNC  =#CINTEGRATION with:
 [, CLAMBDA_INTEGRATION_OPTS])    #  - INTEGRATION.type 'AWS[_PROXY]'
                                  #  - INTEGRATION.uri for Lambda, without any QUALIFIER
                                  #Automatically add right PERMISSION, with COND_KEY SourceArn (not SourceAccount|SourceOrg*)
new HttpLambdaIntegration        -
 ('CONSTRUCT', ICANYFUNC
 [, CLAMBDA_INTEGRATION_OPTS])
new WebSocketLambdaIntegration   ~#Same with:
 ('CONSTRUCT', ICANYFUNC          #  - INTEGRATION.type 'AWS_PROXY'
 [, CLAMBDA_INTEGRATION_OPTS])    #  - INTEGRATION.integrationUri

CLAMBDA_INTEGRATION_OPTS
 .allowTestInvoke                =#BOOL (def: true). Add PERMISSION to allow running TestInvoke*()

CANY|LAMBDA_INTEGRATION_OPTS     -#INTEGRATION.* among:
 .payloadFormatVersion            #  - PayloadFormatVersion.VERSION_1_0
                                  #  - PayloadFormatVersion.VERSION_2_0 (def)
                                  #  - PayloadFormatVersion.custom(STR)

new LambdaRestApi
 (...CARGS, CLAMBDA_API_OPTS)    =#Like new RestApi(...) but with CAPI_OPTS.defaultIntegration LambdaIntegration
CLAMBDA_API_OPTS.*               =#CAPI_OPTS.*
CLAMBDA_API_OPTS.handler         =#ICANYFUNC
CLAMBDA_API_OPTS
 .integrationOptions             =#CLAMBDA_INTEGRATION_OPTS
CLAMBDA_API_OPTS.proxy           =#BOOL (def: true). Creates a {proxy+} PATHVAR on root path
                                  #Also forces a single RESOURCE|ROUTE (root path)

new ApiEventSource               =#CCEVENT_SOURCE, i.e. passed to Lambda CFUNCTION_OPTS.events
 ('HTTP_METHOD', '/PATH'          #Like new RestApi(...) but with CAPI_OPTS.defaultIntegration LambdaIntegration
 [, CROUTE_OPTS])                 #Also creates a ROUTE

                                  ┌─────────┐
                                  │   VPC   │
                                  └─────────┘

VPCLINK                         =-#Access backend that uses a private VPC
                                  #All resoures must be in same ACCOUNT
                                 =#Max 20 per ACCOUNT + REGION (soft)
                                 -#Max 10 per ACCOUNT + REGION (soft)
VPCLINK_ARN                       #arn:aws:apigateway:REGION::/vpclinks[/VPCLINK_MID]
VPCLINK.id                       =
VPCLINK.vpcLinkId                -#VPCLINK_MID
VPCLINK.name                    =-#'VPCLINK'
VPCLINK.description              =#STR
VPCLINK.createdDate              -#'DATE'
VPCLINK.vpcLinkVersion           -#Always 'V2'

INTEGRATION.connectionType      =-#Either:
                                  #  - 'INTERNET' (def)
                                  #  - 'VPC_LINK': use connectionId
INTEGRATION.connectionId        =-#VPCLINK_MID. Called "private INTEGRATION"
                                  #Only with integrationType 'HTTP[_PROXY]'
                                 =#Can be an $EXPR (only with STAGEVAR)

VPCLINK.subnetIds                -#VPC SUBNET_MID_ARR
                                  #Max 10 (soft)
VPCLINK.securityGroupIds         -#VPC SECURITY_GROUP_MID_ARR

VPCLINK.targetArns               =#ELB_ARN_ARR
INTEGRATION.uri                   #Not used for routing, but used to set Host [C] and for SSL verification
                                  #Must be of:
                                 =#  - ELB network LISTENER DOMAIN
                                 -#  - ELB network LISTENER_ARN
                                 -#  - ELB application LISTENER_ARN
                                 -#  - Cloud Map service ARN

VPCLINK.status                   =
VPCLINK.vpcLinkStatus            -#STR, among:
                                  #  - PENDING: provisioning ENIs
                                  #  - AVAILABLE
                                  #  - INACTIVE: after 60 days of inactivity, deleting ENIs, but not VPCLINK
                                  #  - DELETING
                                  #  - FAILED
VPCLINK.statusMessage            =
VPCLINK.vpcLinkStatusMessage     -#STR

INTEGRATION.tlsConfig           =-#TLSCONFIG. Use HTTPS
                                  #Only with VPCLINK
TLSCONFIG.serverNameToVerify     -#'HOSTNAME' to verify with TLS handshake
TLSCONFIG                        =#BOOL. If false (def), verify TLS certificate against known CAs
 .insecureSkipVerification        #Only with integrationType 'HTTP[_PROXY]'

VPCLINK.tags                    =-#TAGS

                                  ┌─────────────┐
                                  │   VPC API   │
                                  └─────────────┘

POST /vpclinks                   =#Req: VPCLINK
CreateVpcLink()                   #  - no id, status*
                                  #Res: VPCLINK
PATCH /vpclinks/VPCLINKS_MID     =#Req: VPCLINK
UpdateVpcLink()                   #  - no id, status*, targetArns, tags
                                  #Res: VPCLINK
GET /vpclinks                    =#Req: empty
GetVpcLinks()                     #Res: item VPCLINK_ARR
GET /vpclinks/VPCLINKS_MID       =#Req: empty
GetVpcLink()                      #Res: VPCLINK
DELETE /vpclinks/VPCLINKS_MID    =#Req: empty
DeleteVpcLink()                   #Res: empty

POST /v2/vpclinks                -#Req: VPCLINK
CreateVpcLink()                   #  - no vpcLinkId, createdDate, vpcLinkVersion, vpcLinkStatus*
                                  #Res: VPCLINK
PATCH /v2/vpclinks/VPCLINK_MID   -#Req: VPCLINK
UpdateVpcLink()                   #  - no vpcLinkId, createdDate, vpcLinkVersion, vpcLinkStatus*
                                  #  - no subnetIds, securityGroupIds, tags
                                  #Res: VPCLINK
GET /v2/vpclinks                 -#Req: empty
GetVpcLinks()                     #Res: items VPCLINK_ARR
GET /v2/vpclinks/VPCLINK_MID     -#Req: empty
GetVpcLink()                      #Res: VPCLINK
DELETE
 /v2/vpclinks/VPCLINK_MID        -#Req: empty
DeleteVpcLink()                   #Res: empty

                                  ┌─────────────┐
                                  │   VPC IAC   │
                                  └─────────────┘

AWS::ApiGateway::VpcLink         =#RESPROPs: Name, Description, TargetArns, Tags
                                  #RESATTRs: VpcLinkId
AWS::ApiGatewayV2::VpcLink       -#RESPROPs: Name, SubnetIds, SecurityGroupIds, Tags
                                  #RESATTRs: VpcLinkId
AWS::ApiGateway::Method          =#Includes RESPROPs: Integration: ConnectionType, ConnectionId
AWS::ApiGatewayV2::Integration   -#Includes RESPROPs:
                                  #  - ConnectionType, ConnectionId
                                  #  - TlsConfig: no InsecureSkipVerification

new VpcLink
 (...CARGS[, CVPCLINK_OPTS])    =-#
ICAPI.addVpcLink(CVPCLINK_OPTS)
 ->VPCLINK                       -#
VpcLink.fromVpcLinkId
 (...CARGS, 'VPCLINK_MID')
 ->ICVPCLINK                     =#
VpcLink.fromVpcLinkAttributes
 (...CARGS, CVPCLINK_OPTS)
 ->ICVPCLINK                     -#CVPCLINK_OPTS: vpcLinkId, vpc
CVPCLINK.vpcLinkId              =-#VPCLINK.id
CVPCLINK_OPTS.vpcLinkName       =-#'VPCLINK' (def: auto 'CID')

CVPCLINK_OPTS.description        =#VPCLINK.*
CVPCLINK_OPTS.targets            =#ICELB_ARN_ARR. VPCLINK.targetArns
CVPCLINK_OPTS.addTarget
 (ICELB_ARN,...)                 =#Same

ICVPCLINK[_OPTS].vpc             -#ICVPC, used with SUBNET_SELECTION
CVPCLINK_OPTS.subnets            -#SUBNET_SELECTION. VPCLINK.subnetIds
                                  #Def: {subnetType: 'Private'}
CVPCLINK_OPTS
 .addSubnets(ISUBNET,...)        -#Same
CVPCLINK_OPTS.securityGroups     -#ISECURITY_GROUP_ARR. VPCLINK.securityGroupIds
CVPCLINK_OPTS.addSecurityGroups
 (ISECURITY_GROUP,...)           -#Same

CINTEGRATION_OOPTS.vpcLink       =#ICVPCLINK. INTEGRATION.connectionId
                                  #Add default value for INTEGRATION.uri:
                                  #  - 'http://FIRST_ELB_DOMAIN_NAME'
                                  #  - only if all of:
                                  #     - using new HttpIntegration(undefined, ...)
                                  #     - passing CVPCLINK (not ICVPCLINK)
                                  #     - setting CINTEGRATION_OOPTS.connectionType 'VPC_LINK' explicitely (not using default value)
CINTEGRATION_OOPTS.connectionType=#INTEGRATION.connectionType
                                  #Def: 'VPC_LINK' if CINTEGRATION_OOPTS.vpcLink set, 'INTERNET' else
CANY_INTEGRATION_OPTS
 .connectionId|connectionType    -#INTEGRATION.*
new HttpNlbIntegration
 ('CONSTRT', IELB_NETWORK_LISTENER
 [, CVPC_INTEGRATION_OPTS])      -
new HttpAlbIntegration
 ('CONSTRUCT', IELB_APP_LISTENER
 [, CVPC_INTEGRATION_OPTS])      -
new
 HttpServiceDiscoveryIntegration -#CINTEGRATION with
 ('CONSTRUCT', ICLOUD_MAP_SERVICE #  - integrationType 'HTTP_PROXY'
 [, CVPC_INTEGRATION_OPTS])       #  - VPCLINK (INTEGRATION.connectionType)
CVPC_INTEGRATION_OPTS.vpcLink    -#ICVPCLINK. INTEGRATION.connectionId
                                  #Def: use IELB_*_LISTENER.vpc

CANY|VPC_INTEGRATION_OPTS
 .secureServerName               -#TLSCONFIG.serverNameToVerify

                                  ┌──────────────────────┐
                                  │   GATEWAY RESPONSE   │
                                  └──────────────────────┘

GRESP                            =#Used by invalid requests and system errors, instead of RRESP|IRESPs
                                  #Can be customized

OSPEC.x-amazon-apigateway-
 gateway-responses               =#OBJ with GRESP.responseType as key, GRESP (except responseType, defaultResponse) as value

GRESP_ARN                        =#arn:aws:apigateway:REGION::/restapis/API_MID/gatewayresponses[/RESP_TYPE]
GRESP.statusCode
GRESP.responseParameters         =#Same as IRESP.*, except EXPR key is 'gatewayresponse.header.*'
GRESP.responseTemplates          =#Same as IRESP.* except TEMPLATE can only use simple $EXPR in OBJ|ARR values
GRESP.defaultResponse            =#BOOL (def: true). Whether has been customized

GRESP.responseType               =#'RESP_TYPE' among:
CONTEXT.error.responseType       =#  - BAD_REQUEST_PARAMETERS: 400, validation against non-body parameters
                                  #  - BAD_REQUEST_BODY: 400, validation against body
                                  #  - MISSING_AUTHENTICATION_TOKEN: 403, no authentication
                                  #  - INVALID_SIGNATURE: 403, AWS ACCESS_TOKEN invalid
                                  #  - EXPIRED_TOKEN: 403, AWS ACCESS_TOKEN expired
                                  #  - INVALID_API_KEY: 403, invalid APIKEY
                                  #  - ACCESS_DENIED: 403, authorization error
                                  #  - UNAUTHORIZED: 403, AUHTORIZER error
                                  #  - RESOURCE_NOT_FOUND: 404
                                  #  - REQUEST_TOO_LARGE: 413, request body too large
                                  #     - cannot be customized
                                  #  - UNSUPPORTED_MEDIA_TYPE: 415, invalid MIME
                                  #  - QUOTA_EXCEEDED: 429, USAGEPLAN QUOTA
                                  #  - THROTTLED: 429, AWS quota
                                  #  - API_CONFIGURATION_ERROR: 500, API Gateway was misconfigured
                                  #  - AUTHORIZER_CONFIGURATION_ERROR: 500, AUTHORIZER was misconfigured
                                  #  - AUTHORIZER_FAILURE: 500, AUTHORIZER exception
                                  #  - INTEGRATION_FAILURE: 504, INTEGRATION exception
                                  #  - INTEGRATION_TIMEOUT: 504, INTEGRATION timed out
                                  #  - DEFAULT_4XX|5XX: used instead of the above if not defined

                                  ┌──────────────────────────┐
                                  │   GATEWAY RESPONSE API   │
                                  └──────────────────────────┘

POST /restapis/API_MID           =#Req: GRESP
 /gatewayresponses/RESP_TYPE      #  - no defaultResponse
PutGatewayResponse()              #  - responseType is in URL path
                                  #Res: GRESP
PUT /restapis/API_MID            =#Req: GRESP
 /gatewayresponses/RESP_TYPE      #  - no defaultResponse
UpdateGatewayResponse()           #  - responseType is in URL path
                                  #Res: GRESP
GET /restapis/API_MID
 /gatewayresponses               =#Req: empty
GetGatewayResponses()             #Res: item GRESP_ARR
GET /restapis/API_MID
 /gatewayresponses/RESP_TYPE     =#Req: empty
GetGatewayResponse()              #Res: GRESP
DELETE /restapis/API_MID
 /gatewayresponses/RESP_TYPE     =#Req: empty
DeleteGatewayResponse()           #Res: empty

                                  ┌──────────────────────────┐
                                  │   GATEWAY RESPONSE IAC   │
                                  └──────────────────────────┘

AWS::ApiGateway::GatewayResponse =#RESPROPs: RestApiId, StatusCode, ResponseParameters, ResponseTemplates, ResponseType
                                  #RESATTRs: Id

new GatewayResponse
 (...CARGS, CGRESP_OPTS)         =#
ICAPI.addGatewayResponse
 ('CONSTRUCT', CGRESP_OPTS)
 ->CGRESP                        =#Automatically sets CGRESP_OPTS.restApi

CGRESP_OPTS.restApi              =#ICAPI
CGRESP_OPTS.statusCode           =#GRESP.*
CGRESP_OPTS.responseHeaders      =#GRESP.responseParameters, but as OBJ with keys being only header name
CGRESP_OPTS.templates            =#GRESP.responseTemplates
CGRESP_OPTS.type                 =#ResponseType.RESP_TYPE of ResponseType.of('RESP_TYPE'). GRESP.responseType

                                  ┌────────────────┐
                                  │   MODEL MAIN   │
                                  └────────────────┘

MODEL                           =~#Request|response body, from client perspective (not backend)
MODEL_ARN                        =#arn:aws:apigateway:REGION::/restapis/API_MID/models[/MODEL]
MODEL_ARN                        ~#arn:aws:apigateway:REGION::/apis/API_MID/models[/MODEL_MID]
MODEL.id                         =
MODEL.modelId                    ~#MODEL_MID
MODEL.name                      =~#'MODEL'. Only [:alnum:]
MODEL.description               =~#STR

OCOMPONENTS2.definitions.MODEL
OCOMPONENTS3.schemas.MODEL
MODEL.contentType               =~#'MIME'
                                  #With OpenAPI, must be 'application/json'

                                  ┌────────────────────┐
                                  │   MODEL MAIN API   │
                                  └────────────────────┘

POST /restapis/API_MID/models    =#Req: MODEL
CreateModel()                     #  - no id
                                  #Res: MODEL
PATCH /restapis/API_MID          =#Req: MODEL
 /models/MODEL                    #  - no id, name, contentType
UpdateModel()                     #Res: MODEL
GET /restapis/API_MID/models     =#Req: empty
GetModels()                       #Res: item MODEL_ARR
GET /restapis/API_MID            =#Req: MODEL
 /models/MODEL                    #  - only one with flatten
GetModel()                        #Res: MODEL
DELETE /restapis/API_MID
 /models/MODEL                   =#Req: empty
DeleteModel()                     #Res: empty

POST /v2/apis/API_MID/models    -~#Req: MODEL
CreateModel()                     #  - no modelId
                                  #Res: MODEL
PATCH /v2/apis/API_MID          -~#Req: MODEL
 /models/MODEL_MID                #  - no modelId
UpdateModel()                     #Res: MODEL
GET /v2/apis/API_MID/models     -~#Req: empty
GetModels()                       #Res: items MODEL_ARR
GET /v2/apis/API_MID
 /models/MODEL_MID              -~#Req: empty
GetModel()                        #Res: MODEL
DELETE /v2/apis/API_MID
 /models/MODEL_MID              -~#Req: empty
DeleteModel()                     #Res: empty

                                  ┌────────────────────┐
                                  │   MODEL MAIN IAC   │
                                  └────────────────────┘

AWS::ApiGateway::Model           =#RESPROPs: RestApiId, Name, Description, ContentType
AWS::ApiGatewayV2::Model         ~#RESPROPs: ApiId, Name, Description, ContentType
                                  #RESATTRs: ModelId

new Model(...CARGS, CMODEL_OPTS) =#
Model.fromModelName
 (...CARGS, 'MODEL')->ICMODEL    =#
CAPI.addModel
 ('CONSTRUCT', CMODEL_OPTS)
 ->CMODEL                        =#Automatically sets CMODEL_OPTS.restApi

ICMODEL.modelId
CMODEL_OPTS.modelName            =#MODEL.name
CMODEL_OPTS.description          =#MODEL.*
CMODEL_OPTS.contentType          =#MODEL.contentType (def: 'application/json')

Model.EMPTY_MODEL                =#MODEL with a JSON schema with only $schema, title, type 'object'
Model.ERROR_MODEL                =#Same but also a single 'message: STR' property

                                  ┌────────────────────┐
                                  │   MODEL TEMPLATE   │
                                  └────────────────────┘

MODEL_TEMPLATE_ARN               =#arn:aws:apigateway:REGION::/restapis/models/MODEL/template
MODEL_TEMPLATE_ARN               ~#arn:aws:apigateway:REGION::/apis/API_MID/models/MODEL_MID/template
MODEL_TEMPLATE.value            =~#'TEMPLATE'

TEMPLATE                        =~#Transforms request|response body between ROUTE and backend
                                  #Velocity template
                                  #  - not documented yet
                                  #  - when documenting, should also check:
                                  #     - https://docs.aws.amazon.com/apigateway/latest/developerguide/models-mappings.html
                                  #     - https://docs.aws.amazon.com/apigateway/latest/developerguide/rest-api-develop-models-mapping-examples.html
                                  #Max 400KB
                                  #Max 1e3 iterations in #foreach loops
                                  #Can use $EXPR

$input                          =~#Used instead of $request in TEMPLATEs
$input.body                     =~#STR
$input.json('JSONPATH')         =~#STR, from body request parameter
$input.path('JSONPATH')         =~#Same but JSON parsed
$input.params(['PARAM'])        =~#VAL, from non-body parameter (def: all)

CONTEXT.requestOverride
 |responseOverride.*             =#Can be set (but not twice). Only for TEMPLATEs
CONTEXT.requestOverride
 .path.PATHVAR                   =#'VAL'
CONTEXT.requestOverride
 .querystring.PARAM              =#'VAL'[_ARR]
CONTEXT.requestOverride
 .header.PARAM                   =#'VAL'[_ARR]
CONTEXT
 .responseOverride.header.PARAM  =#'VAL'
CONTEXT.responseOverride.status  =#STATUS_NUM

$util.parseJson('JSON')         =~#VAL
$util.urlEncode|Decode(STR)     =~#STR. For application/x-www-form-urlencoded
$util.base64Encode|Decode(STR)  =~#STR
$util.escapeJavaScript(STR)     =~#STR. Actually meant for JSON escaping

                                  ┌────────────────────────┐
                                  │   MODEL TEMPLATE API   │
                                  └────────────────────────┘

GET /restapis/API_MID
 /models/MODEL/default_template  =#Req: empty
GetModelTemplate()                #Res: MODEL_TEMPLATE

GET /v2/apis/API_MID
 /models/MODEL_MID/template      ~#Req: empty
GetModelTemplate()                #Res: MODEL_TEMPLATE

                                  ┌────────────────┐
                                  │   EXPRESSION   │
                                  └────────────────┘

TEXPR                            -#STR. Any of the following VARs
overwrite:path                    #Like $request.path
overwrite:querystring.PARAM       #Like $request.querystring.PARAM
overwrite:header.PARAM            #Like $request|response.header.PARAM
overwrite:statuscode              #Like $response.statuscode
remove:querystring|header.PARAM   #Same as overwrite:* but unsets instead
                                  #Value can be anything, often "''"
append:querystring|header.PARAM   #Same as overwrite:* but if value already exists, appends as ,-separated list

$EXPR                             #STR. Can include:
                                  #  - value as is ("static")
                                  #  - ${...}... for concatenation
                                  #  - any of the following $VAR
                                  #Can \-escape $
EXPR                            =~#STR. Can include:
                                  #  - value '-quoted ("static")
                                  #  - no concatenation
                                  #  - any $VAR, but as VAR instead
                                  #     - $request|response (but not $integration.request|response) is instead:
                                 =#        - method.request|response
                                 ~#        - route.request|response

$request                          #Request from client
$integration.request              #Request sent to backend. Same syntax as $request.*
$integration.response             #Response received from backend. Same syntax as $response.*
$response                         #Response to client

$request.path                     #STR (without STAGE)
$request.path.PARAM             =-#'VAL'
$request.querystring.PARAM        #'VAL,...'
$request
 .multivaluequerystring.PARAM   =~#'VAL'_ARR
$request|response.header.PARAM    #'VAL,...'
$request|response
 .multivalueheader.PARAM        =~#'VAL'_ARR
$request|response.body            #STR
$request|response.body.VARR       #VAL
$response.statuscode              #STATUS_NUM

PARAM                             #Name must be only [[:alnum:]._$-]
VARR                              #JSON path (see its doc)
                                  #Since $EXPR:
                                  #  - is stringified and usually evaluates to a name
                                  #     - e.g. 'MODEL_$EXPR' evaluates to 'MODEL' name
                                  #  - it is usually more useful to resolve to a STR (not ARR|OBJ)
                                  #I.e. in practice, mostly only .VAR, ['VAR'] and [NUM] are useful
                                  #If not found, resolves to empty string

$stageVariables.STAGEVAR
$stageVariables['STAGEVAR']       #'VAL'

$context                          #CONTEXT
                                 =#Or ACONTEXT: when can only be used in ACCESS_LOG.format

                                  ┌────────────────────┐
                                  │   EXPRESSION IAC   │
                                  └────────────────────┘

new ParameterMapping()           -#CREQ_PARAMS. INTEGRATION.requestParameters

ParameterMapping.fromObject(OBJ)
 ->CREQ_PARAMS                   -#

CREQ_PARAMS.custom
 ('KEY', CREQ_VAL)->CREQ_PARAMS  -#Key 'KEY'
CREQ_PARAMS.overwritePath
 (CREQ_VAL)->CREQ_PARAMS         -#Key 'overwrite:path'
CREQ_PARAMS
 .overwriteQueryString|Header
 ('PARAM', CREQ_VAL)
 ->CREQ_PARAMS                   -#Key 'overwrite:querystring|header.PARAM'
CREQ_PARAMS
 .removeQueryString|Header
 ('PARAM')->CREQ_PARAMS          -#Key 'remove:querystring|header.PARAM'
CREQ_PARAMS
 .appendQueryString|Header
 ('PARAM', CREQ_VAL)
 ->CREQ_PARAMS                   -#Key 'append:querystring|header.PARAM'

MappingValue.custom('VAL')
 ->CREQ_VAL                      -#Value 'VAL'
MappingValue.NONE                -#CREQ_VAL. Value ''
MappingValue.requestPath()
 ->CREQ_VAL                      -#Value '$request.path'
MappingValue.requestPathParam
 |QueryString|Header('PARAM')
 ->CREQ_VAL                      -#Value '$request.path|querystring|header.PARAM'
MappingValue.requestBody('VARR')
 ->CREQ_VAL                      -#Value '$request.body.PARAM'
MappingValue.stageVariable
 ('STAGEVAR')->CREQ_VAL          -#Value '$stageVariables.STAGEVAR'
MappingValue.contextVariable
 ('VARR')->CREQ_VAL              -#Value '$context.VARR'

                                  ┌────────────────┐
                                  │   VALIDATION   │
                                  └────────────────┘

REQVALID                         =#Request [non-]body parameters validation

OSPEC.x-amazon-apigateway-
 request-validators
 .REQVALID.requestValidator.*    =#REQVALID.*, except id|name

REQVALID_ARN                     =#arn:aws:apigateway:REGION::/restapis/API_MID/requestvalidators[/REQVALID_MID]
REQVALID.id                      =#REQVALID_MID
REQVALID.name
OSPEC|OOPERATION.x-amazon-
 apigateway-request-validator    =#'REQVALID'

ROUTE.requestValidatorId         =#VALIDATOR_MID

REQVALID                         =#BOOL (def: false). Validate request parameters against ROUTE.requestParameters BOOL (requiredness only)
 .validateRequestParameters      ~#Always true
                                  #If fails, returns 400

REQVALID.validateRequestBody     =#BOOL (def: false). Validate request body against ROUTE.requestModels's MODEL.schema
                                 ~#Always true
                                  #If fails, returns:
                                 =#  - 400
                                 ~#  - OBJ: message 'Bad request body', connectionId CONNECTION_ID, messageId STR
OCOMPONENTS2.definitions.MODEL
OCOMPONENTS3.schemas.MODEL
MODEL.schema                    =~#STR. JSON schema v4. Only with MODEL.contentType 'application/json'
                                  #Must specify RSCHEMA.$schema": 'http://json-schema.org/draft-04/schema#'
                                  #Can use $ref and SCHEMA.definitions
                                  #With OpenAPI:
                                  #  - must be defined
                                  #  - uses JSON schema v4, not OpenAPI SCHEMA
                                  #     - e.g. no SCHEMA.discriminator, readOnly, format 'int32|64'
                                  #  - not used: default, exclusiveMinimum, oneOf
                                  #  - not used in validation: minItems|maxItems
                                  #  - $ref:
                                  #     - must target current file
                                  #     - cannot be used as ORESP
                                  #     - must be used for OSCHEMA unless OSCHEMA.type 'object'

MODEL.flatten                    =#BOOL (def: false). Resolve all JSON references

CONTEXT
 .error.validationErrorString   =~#'MESSAGE' on validation error

API.disableSchemaValidation      ~#BOOL. If false (def), validate MODELs during DEPLOYMENT

                                  ┌────────────────────┐
                                  │   VALIDATION API   │
                                  └────────────────────┘

POST /restapis/API_MID           =#Req: REQVALID
 /requestvalidators               #  - no id
CreateRequestValidator()          #Res: REQVALID
PATCH /restapis/API_MID          =#Req: REQVALID
 /requestvalidators/REQVALID_MID  #  - no id
UpdateRequestValidator()          #Res: REQVALID
GET /restapis/API_MID
 /requestvalidators              =#Req: empty
GetRequestValidators()            #Res: item REQVALID_ARR
GET /restapis/API_MID
 /requestvalidators/REQVALID_MID =#Req: empty
GetRequestValidator()             #Res: REQVALID
DELETE /restapis/API_MID
 /requestvalidators/REQVALID_MID =#Req: empty
DeleteRequestValidator()          #Res: empty

                                  ┌────────────────────┐
                                  │   VALIDATION IAC   │
                                  └────────────────────┘

AWS::ApiGateway::RequestValidator=#RESPROPs: RestApiId, Name, ValidateRequestParameters, ValidateRequestBody
                                  #RESATTRs: RequestValidatorId
AWS::ApiGateway::Method          =#Includes RESPROPs: RequestValidatorId
AWS::ApiGateway::Model           =#Includes RESPROPs: Schema
AWS::ApiGatewayV2::Model         ~#Includes RESPROPs: Schema
AWS::ApiGatewayV2::Api           ~#Includes RESATTRs: DisableSchemaValidation

new RequestValidator
 (...CARGS, CREQVALID_OPTS)      =#
RequestValidator
 .fromRequestValidatorId
 (...CARGS, 'REQVALID_MID')
 ->ICREQVALID                    =#
CAPI.addRequestValidator
 ('CONSTRUCT', CREQVALID_OPTS)
 ->CREQVALID                     =#Automatically sets CREQVALID_OPTS.restApi
CREQVALID_OPTS.restApi           =#ICAPI
ICREQVALID.requestValidatorId    =#REQVALID.id
CREQVALID_OPTS
 .requestValidatorName           =#REQVALID.name
CREQVALID_OPTS
 .validateRequestParameters
 |validateRequestBody            =#REQVALID.*

CROUTE_OOPTS.requestValidator    =#ICREQVALID. ROUTE.requestValidatorId
CROUTE_OOPTS                     =#Same but as CREQVALID_OPTS
 .requestValidatorOptions         #No need to specific CREQVALID_OPTS.restApi
FFLAG @aws-cdk/aws-apigateway:   =#BOOL (recommended, def: false)
 requestValidatorUniqueId         #Make NODE.id be a SID, when using CROUTE_OOPTS.requestValidatorOptions
                                  #This allows multiple REQVALIDs per API

CMODEL_OPTS.schema               =#JSON_SCHEMA_OBJ. MODEL.*

                                  ┌─────────────────────┐
                                  │   VALIDATION LINT   │
                                  └─────────────────────┘

cdk-nag APIGWRequestValidation   =#Validate every API has a REQVALID
                                  #Must set REQVALID.validateRequestParameters|validateRequestBody true

                                  ┌───────────────────┐
                                  │   AUTHORIZATION   │
                                  └───────────────────┘

OOPERATION
 .x-amazon-apigateway-auth.type
ROUTE_SUMMARY.authorizationType  =
ROUTE.authorizationType           #STR. How to authorize requests to API, among:
                                  #  - 'NONE' (def): always allow
                                  #  - 'AWS_IAM': requires authenticated USER
                                  #  - 'CUSTOM': AUTHORIZER with type 'REQUEST|TOKEN'
                                 -#  - 'JWT': AUTHORIZER with type 'JWT'
                                 =#  - 'COGNITO_USER_POOLS': AUTHORIZER with type 'COGNITO_USER_POOLS'
OSECURITY_DEF.*                   #With authorizationType 'AWS_IAM':
                                  #  - type 'apiKey'
                                  #  - name 'Authorization'
                                  #  - in 'header'
                                  #  - x-amazon-apigateway-authtype 'awsSigv4'
COND_KEY RouteAuthorizationType   #STR, on Create|Put|DeleteMethod(), on ROUTE
                                  #Also STR_ARR on [Re]Import[Rest]Api(), on API

API.policy                       =#IAM 'POLICY_DOC'
                                  #Resource-based policy for API, with resource-level permissions
                                  #Max 8KB (soft)
OSPEC.x-amazon-apigateway-policy =#API.policy, as OBJ
PACTION
 apigateway:UpdateRestApiPolicy  =#Required for API.policy

PACTION execute-api:*             #Required if either:
                                  #  - authorizationType 'AWS_IAM|CUSTOM'
                                  #  - API.policy set
PACTION execute-api:Invoke        #Required to call INVOKE_URI
AmazonAPIGatewayInvokeFullAccess  #AWS managed POLICY that allows PACTION execute-api:Invoke|ManageConnections

CALL_ROUTE_PREFIX                 #'arn:aws:execute-api:REGION:ACCOUNT_ID:API_MID'
                                  #When setting API.policy, can also be shortened as 'execute-api:'
CALL_ROUTE_ARN                    #ARN of the act of executing a ROUTE (not of the ROUTE itself)
                                  #Used as Resource when allowing PACTION execute-api:*
                                  #Is:
                                =-#  - CALL_ROUTE_PREFIX/STAGE/HTTP_METHOD/PATH
                                 ~#  - WS_MESSAGE: CALL_ROUTE_PREFIX/STAGE/ROUTE
                                 ~#  - CONNECTION: CALL_ROUTE_PREFIX/STAGE/HTTP_METHOD/@connections
                                  #Can use * in STAGE|HTTP_METHOD|PATH|ROUTE
                                  #Max 1600 bytes (512 when used as Resource in a POLICY_DOC)

PACTION apigateway:HTTP_METHOD    #Unlike other SERVICEs, PACTIONs are not named apigateway:ACTION,
                                  #except for a few ones documented in this doc
                                  #Instead, one must specify:
                                  #  - HTTP_METHOD: GET|POST|PUT|PATCH|DELETE|*
                                  #  - Resource ARN|*

COND_KEY apigateway:Request/NAME  #COND_KEYs targetting the request payload
COND_KEY apigateway:Response/NAME #COND_KEYs targetting the current state of the response
                                  #Not available for Create*() since resource not created yet
COND_KEY NAME                     #Short notation in this doc for COND_KEY apigateway:Request|Response/NAME

ACONTEXT.authenticate.status     =#STATUS_NUM of underlying authentication request
ACONTEXT.authenticate.error      =#'MESSAGE' of underlying authentication request, if errored
ACONTEXT.authenticate.latency    =#NUM (in ms) duration of underlying authentication request
ACONTEXT.authorize
 .status|error|latency           =#Same but for underlying authorization request
ACONTEXT.authorizer.error       =-#'MESSAGE' on AUTHORIZER exception or if could not be executed
ACONTEXT.authorizer
 .status|latency                 =#Same as ACONTEXT.authorize.* but only when using AUTHORIZER
ACONTEXT.authorizer
 .integrationStatus|Latency      =#Same as ACONTEXT.authorize.* but only when using Lambda AUTHORIZER

                                  ┌───────────────────────┐
                                  │   AUTHORIZATION IAC   │
                                  └───────────────────────┘

AWS::ApiGateway::Method          =#Includes RESPROPs: AuthorizationType
AWS::ApiGatewayV2::Route        -~#Includes RESPROPs: AuthorizationType
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Route: AuthorizationType
AWS::ApiGateway::RestApi         =#Includes RESPROPs: Policy

CROUTE_OOPTS|C*AUTHORIZER
 .authorizationType              =
CCAUTHORIZER_SUMMARY
 .authorizationType             -~#ROUTE.* (def: 'NONE')

CAPI_OPTS.policy                 =#API.*

ICAPI.arnForExecuteApi
 (['HTTP_METHOD'[, '/PATH'
 [, 'STAGE']]])->'CALL_ROUTE_ARN' #Def 'HTTP_METHOD'|'STAGE': '*', def '/PATH': '/*'
CROUTE.methodArn                 =#'CALL_ROUTE_ARN' for this ROUTE (HTTP_METHOD + PATH) and ICAPI.deploymentStage (if any)
                                  #Any '{PATHVAR[+]}' is replaced by *
CROUTE.testMethodArn             =#Same but with STAGE 'test-invoke-stage' (see below)
CROUTE.routeArn                  -#'CALL_ROUTE_ARN' for this ROUTE (HTTP_METHOD + PATH) and any STAGE (*)
                                  #Uses * for HTTP_METHOD|PATH if '$default' ROUTE
                                  #Any '{PATHVAR[+]}' is replaced by *

CROUTE.grantExecute(YGRANTABLE)
 ->CGRANT                        =
CROUTE.grantInvoke
 (YGRANTABLE[, OPTS])->CGRANT    -#Allow execute-api:Invoke on CALL_ROUTE_ARN
OPTS.httpMethods                 -#'HTTP_METHOD'_ARR (def: CROUTE.method)

CAPI|CSTAGE
 .grantManagementApiAccess
 (YGRANTABLE)->CGRANT            ~#Allows execute-api:ManageConnections on CALL_ROUTE_ARN

                                  ┌──────────────────────────┐
                                  │   AUTHORIZATION PULUMI   │
                                  └──────────────────────────┘

RestApiPolicy                    =#REZ for API.policy

                                  ┌────────────────────────┐
                                  │   AUTHORIZATION LINT   │
                                  └────────────────────────┘

cdk-nag APIGWAuthorization        #Validate ROUTE.authorizationType is not 'NONE'

                                  ┌─────────────────────┐
                                  │   AUTHORIZER MAIN   │
                                  └─────────────────────┘

AUTHORIZER                        #Authorize requests to API
                                  #Max 10 per API (soft)
OSECURITY_DEF.x-amazon-apigateway-
 authorizer.*                   =-#AUTHORIZER.*, except id|authorizerId, name, authType
OSECURITY_DEF                     #Is only used if OSECURITY_USES is

AUTHORIZER_ARN                   =#arn:aws:apigateway:REGION::/restapis/API_MID/authorizers[/AUTHORIZER_MID]
AUTHORIZER_ARN                  -~#arn:aws:apigateway:REGION::/apis/API_MID/authorizers[/AUTHORIZER_MID]
AUTHORIZER.id                    =
AUTHORIZER.authorizerId         -~#AUTHORIZER_MID
AUTHORIZER.name                   #'AUTHORIZER'

ROUTE.authorizerId                #AUTHORIZER_MID (if any)

AUTHORIZER.type                  =
AUTHORIZER.authorizerType       -~#'AUTH_TYPE', among:
                                  #  - 'REQUEST'
                                 =#  - 'TOKEN'
                                 -#  - 'JWT'
                                 =#  - 'COGNITO_USER_POOLS'

AUTHORIZER.authType              =#Like authorizerType except only for documentation purpose, e.g. for authorization subtype
OSECURITY_DEF
 .x-amazon-apigateway-authtype    #Can be any STR. E.g. 'oauth2'

AUTHORIZER.identitySource        =#'EXPR,...'. Locates request authentication info (which is authorizerType-specific).
                                  #Returns 401 right away if missing request authentication info
                                  #EXPR: only 'request|stageVariables|context.*' or static STR
AUTHORIZER.identitySource       -~#Same but use '$EXPR'_ARR instead of 'EXPR,...'

AUTHORIZER                        #'REGEXP' matched on value returned by AUTHORIZER.identifySource
 .identityValidationExpression    #Returns 401 right away if no match

                                  ┌──────────────────────────┐
                                  │   AUTHORIZER MAIN AUTH   │
                                  └──────────────────────────┘

COND_KEY AuthorizerType           #AUTHORIZER.type|authorizerType. STR, on Create|Update|DeleteAuthorizer(), on AUTHORIZER
                                  #Also STR_ARR, on [Re]Import[Rest]Api(), on API

                                  ┌─────────────────────────┐
                                  │   AUTHORIZER MAIN API   │
                                  └─────────────────────────┘

POST /restapis/API_MID           =#Req: AUTHORIZER
 /authorizers                     #  - no id
CreateAuthorizer()                #Res: AUTHORIZER
PATCH /restapis/API_MID          =#Req: AUTHORIZER
 /authorizers/AUTHORIZER_MID      #  - no id
UpdateAuthorizer()                #  - op:add|remove, not op:replace: providerARNs
                                  #Res: AUTHORIZER
GET /restapis/API_MID
 /authorizers                    =#Req: empty
GetAuthorizers()                  #Res: item AUTHORIZER_ARR
GET /restapis/API_MID
 /authorizers/AUTHORIZER_MID     =#Req: empty
GetAuthorizer()                   #Res: AUTHORIZER
DELETE /restapis/API_MID
 /authorizers/AUTHORIZER_MID     =#Req: empty
DeleteAuthorizer()                #Res: empty

POST /v2/apis/API_MID           -~#Req: AUTHORIZER
 /authorizers                     #  - no authorizerId
CreateAuthorizer()                #Res: AUTHORIZER
PATCH /v2/apis/API_MID          -~#Req: AUTHORIZER
 /authorizers/AUTHORIZER_MID      #  - no authorizerId
UpdateAuthorizer()                #Res: AUTHORIZER
GET /v2/apis/API_MID
 /authorizers                   -~#Req: empty
GetAuthorizers()                  #Res: items AUTHORIZER_ARR
GET /v2/apis/API_MID
 /authorizers/AUTHORIZER_MID    -~#Req: empty
GetAuthorizer()                   #Res: AUTHORIZER
DELETE /v2/apis/API_MID
 /authorizers/AUTHORIZER_MID    -~#Req: empty
DeleteAuthorizer()                #Res: empty

                                  ┌─────────────────────────┐
                                  │   AUTHORIZER MAIN IAC   │
                                  └─────────────────────────┘

AWS::ApiGateway::Authorizer      =#RESPROPs: RestApiId, Name, Type, AuthType, IdentitySource, IdentityValidationExpression
                                  #RESATTRs: AuthorizerId
AWS::ApiGatewayV2::Authorizer   -~#RESPROPs: ApiId, Name, AuthorizerType, IdentitySource, IdentityValidationExpression
                                  #RESATTRs: AuthorizerId
AWS::ApiGateway::Method          =#Includes RESPROPs: AuthorizerId
AWS::ApiGatewayV2::Route        -~#Includes RESPROPs: AuthorizerId
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Route: AuthorizerId

new HttpAuthorizer
 (...CARGS, CCAUTHORIZER_OPTS)   -
new WebSocketAuthorizer
 (...CARGS, CCAUTHORIZER_OPTS)   ~#CCAUTHORIZER. AUTHORIZER with any authorizationType

CAUTHORIZER                       #Higher-level, authorizationType-specific API over CCAUTHORIZER
HttpAuthorizer
 .fromHttpAuthorizerAttributes
 (...CARGS, CAUTHORIZER_OPTS)
 ->ICAUTHORIZER                  -
WebSocketAuthorizer
.fromWebSocketAuthorizerAttributes
 (...CARGS, CAUTHORIZER_OPTS)
 ->ICAUTHORIZER                  ~#CAUTHORIZER_OPTS: authorizerId, authorizerType (actually AUTHORIZER.authorizationType)
ICAUTHORIZER.bind(OPTS)         -~#Creates a CCAUTHORIZER
 ->CCAUTHORIZER_SUMMARY           #OPTS: route ICROUTE, scope CONSTRUCT (usually ICAPI)

new HttpNoneAuthorizer()         -
new WebSocketNoneAuthorizer()    ~#CAUTHORIZER with authorizationType 'NONE'
new HttpIamAuthorizer()          -
new WebSocketIamAuthorizer()     ~#CAUTHORIZER with authorizationType 'AWS_IAM'

CROUTE_OOPTS.authorizer          =
CROUTE_OPTS.authorizer          -~
CAPI[_OPTS].defaultAuthorizer    -#CAUTHORIZER. ROUTE.authorizationType|authorizerId

CCAUTHORIZER_OPTS.httpApi        -
CCAUTHORIZER_OPTS.webSocketApi   ~#ICAPI
C*AUTHORIZER.authorizerArn       =#'AUTHORIZER_ARN'
C*AUTHORIZER.authorizerId        =
CCAUTHORIZER[_SUMMARY]
 .authorizerId                  -~#AUTHORIZER.authorizerId
C*AUTHORIZER_OPTS.authorizerName =#AUTHORIZER.name (def: auto 'CID')
C[C]*AUTHORIZER_OPTS
 .authorizerName                -~#AUTHORIZER.name (def: 'CONSTRUCT')

CCAUTHORIZER_OPTS.type          -~#AUTHORIZER.authorizerType

CCAUTHORIZER_OPTS.identitySource-~#'$EXPR'_ARR. AUTHORIZER.identitySource
C*AUTHORIZER_OPTS.identitySource-~#Same but def:
                                 -#  - ['$request.header.Authorization']
                                 ~#  - ['route.request.header.Authorization']
C*AUTHORIZER_OPTS.identitySources=#CIDENTITY_SOURCE_ARR. AUTHORIZER.identitySource, for authorizerType 'REQUEST'
C*AUTHORIZER_OPTS.identitySource =#CIDENTITY_SOURCE. AUTHORIZER.identitySource, for other authorizerTypes
                                  #Def: 'method.request.header.Authorization'
IdentitySource.toString
 (STR, STR2)->STR                =#'STR.STR2'
IdentitySource.context(STR)->STR =#'context.STR'
IdentitySource.header
 ('HEADER')->STR                 =#'method.request.header.HEADER'
IdentitySource.queryString
 ('VAR')->STR                    =#'method.request.querystring.VAR'
IdentitySource.stageVariable
 ('STAGEVAR')->STR               =#'stageVariables.STAGEVAR'

                                  ┌──────────────────────────┐
                                  │   AUTHORIZER MAIN LINT   │
                                  └──────────────────────────┘

AWSSamples::APIGWEnforceAuthorizer
 ::Hook                           #Require AUTHORIZERs

                                  ┌────────────────────┐
                                  │   AUTHORIZER JWT   │
                                  └────────────────────┘

AUTH_TYPE 'JWT'                  -#Authorize with JWT
                                  #AUTHORIZER.identitySource locates the JWT value
                                  #  - either 'JWT' or 'Bearer JWT'
                                  #  - only in headers or query variables

AUTHORIZER.jwtConfiguration      -#JWT
JWT.issuer                       -#STR, matched against PAYLOAD.iss
JWT.audience                     -#STR_ARR, matched against PAYLOAD.aud
                                  #Must be used instead of AUTHORIZER.identityValidationExpression
                                  #Max 50 per AUTHORIZER
ROUTE.authorizationScopes        -#'SCOPE'_ARR', matched against PAYLOAD.scope|scp
                                  #Max 10 per ROUTE
PAYLOAD.iat|nbf|exp              -#Must not be expired

ISSUER/.well-known/jwks.json     -#Used and cached for 2h
                                  #Timeout: 1.5s. Max response: 150KB
JWK.alg                          -#Only RSA algorithms
JWK.kid                          -#Must match ENVLOP.kid

REQ_CONTEXT0|1.authorizer
REQ_CONTEXT2.authorizer.jwt      -#REQ_JWT
CONTEXT.authorizer.claims
REQ_JWT.claims                   -#OBJ|null of custom PAYLOAD.* on JWT token
REQ_JWT.scopes                   -#'SCOPE'_ARR|null

                                  ┌────────────────────────┐
                                  │   AUTHORIZER JWT IAC   │
                                  └────────────────────────┘

AWS::ApiGatewayV2::Authorizer   -~#Includes RESPROPs: JwtConfiguration
AWS::ApiGateway::Method          =#Includes RESPROPs: AuthorizationScopes
AWS::ApiGatewayV2::Route         -#Includes RESPROPs: AuthorizationScopes
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Route: AuthorizationScopes

new HttpJwtAuthorizer
 ('CONSTRUCT', JWT.issuer
 [, CJWT_AUTHORIZER_OPTS])       -#CAUTHORIZER with authorizationType 'JWT'

CCAUTHORIZER_OPTS.jwtIssuer      -#JWT.issuer
C[C]JWT_AUTHORIZER_OPTS
 .jwtAudience                    -#JWT.audience
CROUTE_OPTS.authorizationScopes
CAPI[_OPTS]
 .defaultAuthorizationScopes     -#ROUTE.*

                                  ┌────────────────────────┐
                                  │   AUTHORIZER COGNITO   │
                                  └────────────────────────┘

AUTH_TYPE 'COGNITO_USER_POOLS'   =#Authorize with Cognito USER_POOL
                                 -#Could also use type 'JWT' instead, since Cognito uses JWT
                                  #  - JWT.issuer: https://cognito-idp.REGION.amazonaws.com/USER_POOL_MID
                                  #  - JWT.audience: USER_POOL_CLIENT_MID_ARR
                                  #AUTHORIZER.identitySource locates the token (only in headers)

AUTHORIZER.providerARNs          =#Cognito USER_POOL_ARN_ARR

AUTHORIZER
 .identityValidationExpression
ROUTE.authorizationScopes
REQ_CONTEXT0|1.authorizer        =#Same as JWT but using Cognito's JWT

CONTEXT.authorizer.claims.VAR    =
INVOKE_AUTHORIZER_REQ.claims     =#Same as REQ_JWT but using Cognito's JWT

CONTEXT.identity
 .cognitoIdentityId              =
REQ_IDENTITY1.cognitoIdentityId  =#STR
CONTEXT.identity
 .cognitoIdentityPoolId          =
REQ_IDENTITY1
 .cognitoIdentityPoolId          =#USER_POOL_MID
CONTEXT.identity
 .cognitoAuthenticationType      =
REQ_IDENTITY1
 .cognitoAuthenticationType      =#'[un]authenticated'
CONTEXT.identity
 .cognitoAuthenticationProvider  =
REQ_IDENTITY1
 .cognitoAuthenticationProvider  =#'PROVIDER,...'

                                  ┌─────────────────────────────┐
                                  │   AUTHORIZER COGNITO AUTH   │
                                  └─────────────────────────────┘

COND_KEY apigateway:
 CognitoUserPoolProviderArn      =#AUTHORIZER.providerARNs. USER_POOL_ARN_ARR, on Create|Update|DeleteAuthorizer()

                                  ┌────────────────────────────┐
                                  │   AUTHORIZER COGNITO IAC   │
                                  └────────────────────────────┘

AWS::ApiGateway::Authorizer      =#Includes RESPROPs: ProviderARNs, AuthorizationScopes

new CognitoUserPoolsAuthorizer
 (...CARGS,
 CCOGNITO_AUTHORIZER_OPTS)       =#CAUTHORIZER with authorizerType 'COGNITO_USER_POOLS'
new HttpUserPoolAuthorizer
 ('CONSTRUCT', ICUSER_POOL
 [, CCOGNITO_AUTHORIZER_OPTS])   -#CAUTHORIZER for Cognito, but using 'JWT' instead

CCOGNITO_AUTHORIZER_OPTS
 .cognitoUserPools               =#ICUSER_POOL_ARR. AUTHORIZER.providerARNs
CCOGNITO_AUTHORIZER_OPTS
 .userPoolRegion                 -#'REGION' of USER_POOL (def: current)
CCOGNITO_AUTHORIZER_OPTS
 .userPoolClients                -#ICUSER_POOL_CLIENT_ARR (def: create a single new one)

CROUTE_OOPTS.authorizationScopes =
CAPI[_OPTS]
 .defaultAuthorizationScopes     -#ROUTE.*

                                  ┌───────────────────────┐
                                  │   AUTHORIZER LAMBDA   │
                                  └───────────────────────┘

AUTH_TYPE 'REQUEST|TOKEN'         #Pass a 'TOKEN' to a Lambda FUNCTION, which performs authorization
AUTH_TYPE 'REQUEST'               #AUTHORIZER.identitySource can use request headers, query variables, PATHVARs, STAGEVARs, context
AUTH_TYPE 'TOKEN'                =#AUTHORIZER.identitySource can use request headers only

AUTHORIZER                       =#'REGEXP' matched against 'TOKEN'
 .identityValidationExpression   =#Only with AUTH_TYPE 'TOKEN'

AUTHORIZER.authorizerUri          #Lambda FUNCTION to invoke
                                  #Is 'arn:aws:apigateway:REGION:lambda:path/API_VERSION/functions/FUNC_ARN/invocations'

AUTHORIZER                       -#'1.0' or '2.0'. Format of Lambda FUNCTION request body, i.e. AREQ1|2
 .authorizerPayloadFormatVersion ~#Always '1.0'
AUTHORIZER.enableSimpleResponses -#BOOL (def: false). Whether Lambda FUNCTION uses the simple response format, i.e. SARES
                                  #Only with AUTHORIZER.authorizerPayloadFormatVersion '2.0'

AREQ                              #AUTHORIZER Lambda REQ
AREQ.type                         #'AUTH_TYPE'
AREQ1.methodArn
AREQ2.routeArn                    #CALL_ROUTE_ARN
AREQ1.identitySource            =-#'TOKEN,...'
AREQ2.identitySource             -#'TOKEN'_ARR
AREQ.authorizationToken           #'TOKEN,...'
                                  #Only with AUTH_TYPE 'TOKEN'
AREQ1.*                           #Like REQ1.*, except some not documented (i.e. maybe not present):
                                  #  - body, isBase64Encoded
                                  #  - REQ_CONTEXT.authorizer|domain*|extendedRequestId|protocol|requestTime[Epoch]
                                  #  - REQ_IDENTITY: only sourceIp, clientCert
                                  #Only with AUTH_TYPE 'REQUEST'
AREQ2.*                           #Like REQ2.*, except some not documented (i.e. maybe not present):
                                  #  - body, isBase64Encoded
ACONTEXT.authorizer.requestId    =#REQ_ID of Lambda invocation

[S]ARES                           #AUTHORIZER Lambda RES
                                  #Can be null to send 401
                                  #Max 8KB
                                  #Timeout: 10s

ARES.principalId                  #PRINCIPAL ID. Authenticate request with it
CONTEXT.authorizer.principalId
INVOKE_AUTHORIZER_RES
 .principalId                    =#ARES.principalId

ARES.policyDocument               #POLICY_DOC, as OBJ, to attach to requester
                                  #This is in additional to other POLICYs that might impact ARES.principalId
                                  #Usually allows|denies PACTION execute-api:* on CALL_ROUTE_ARN
                                  #Send 403 if POLICY_DOC denies
INVOKE_AUTHORIZER_RES.policy     =#'POLICY_DOC' from ARES.policyDocument

SARES.isAuthorized                #BOOL. Simpler alternative to ARES.policyDocument.

[S]ARES.context                   #Custom OBJ. Values cannot be OBJ|ARR
[REQ_]CONTEXT.authorizer          #OBJ from ARES.context

                                  ┌────────────────────────────┐
                                  │   AUTHORIZER LAMBDA AUTH   │
                                  └────────────────────────────┘

AUTHORIZER.authorizerCredentials =
AUTHORIZER                      -~#ROLE_ARN to assume when calling Lambda FUNCTION
 .authorizerCredentialsArn        #ROLE is assumed by Principal.Service 'apigateway.amazonaws.com'
                                  #Optional, e.g. can use Lambda FUNCTION PERMISSION instead
                                  #In either case, must:
                                  #  - be allowed PACTION lambda:InvokeFunction
                                  #  - use COND_KEY aws:SourceArn 'arn:aws:execute-api:REGION:ACCOUNT_ID:API_MID/authorizers/AUTHORIZER_MID'

COND_KEY AuthorizerUri            #AUTHORIZER.authorizerUri. STR, on Create|Update|DeleteAuthorizer(), on AUTHORIZER
                                  #Also STR_ARR, on [Re]Import[Rest]Api(), on API

                                  ┌───────────────────────────┐
                                  │   AUTHORIZER LAMBDA IAC   │
                                  └───────────────────────────┘

AWS::ApiGateway::Authorizer      =#Includes RESPROPs: AuthorizerUri, AuthorizerCredentials
AWS::ApiGatewayV2::Authorizer   -~#Includes RESPROPs: AuthorizerUri, AuthorizerCredentialsArn, AuthorizerPayloadFormatVersion, EnableSimpleResponses

new RequestAuthorizer(...CARGS,
 CRLAMBDA_AUTHORIZER_OPTS)       =
new HttpLambdaAuthorizer
 (...CARGS, ICANYFUNC
 [, CRLAMBDA_AUTHORIZER_OPTS])   -
new WebSocketLambdaAuthorizer
 (...CARGS, ICANYFUNC
 [, CRLAMBDA_AUTHORIZER_OPTS])   ~#CAUTHORIZER with authorizerType 'REQUEST'

new TokenAuthorizer(...CARGS,
 CTLAMBDA_AUTHORIZER_OPTS)       =#CAUTHORIZER with authorizerType 'TOKEN'
CTLAMBDA_AUTHORIZER_OPTS
 .validationRegex                =#'REGEXP'. AUTHORIZER.identityValidationExpression

C*LAMBDA_AUTHORIZER_OPTS.handler =#ICANYFUNC. AUTHORIZER.authorizerUri
CCAUTHORIZER_OPTS.authorizerUri -~#STR. AUTHORIZER.authorizerUri
C*LAMBDA_AUTHORIZER_OPTS         =#ICROLE. AUTHORIZER.authorizerCredentials
 .assumeRole                      #Automatically grants Lambda permissions:
                                  #  - if ICROLE, use an IPOLICY (no COND_KEY SourceArn)
                                  #  - else, use a PERMISSION (with COND_KEY SourceArn)
PERMISSION ==>                  -~#Automatically add a Lambda PERMISSION (with COND_KEY SourceArn)
                                  #Does not use a ROLE

C*LAMBDA_AUTHORIZER_OPTS         -#Either [HttpLambdaResponseType.IAM] (def) or [HttpLambdaResponseType.SIMPLE]
 .responseTypes                   #AUTHORIZER.enableSimpleResponses
                                  #Also decides AUTHORIZER.authorizerPayloadFormatVersion '1.0'|'2.0'
CCAUTHORIZER_OPTS
 .payloadFormatVersion           -#STR (def: '2.0' if Lambda). AUTHORIZER.authorizerPayloadFormatVersion
CCAUTHORIZER_OPTS
 .enableSimpleResponses          -#AUTHORIZER.*

                                  ┌──────────────────────┐
                                  │   AUTHORIZER CACHE   │
                                  └──────────────────────┘

AUTHORIZER                      =-#NUM of secs to cache AUTHORIZER's Lambda FUNCTION successful responses
 .authorizerResultTtlInSeconds    #'TOKEN' is used as cache key
                                  #Def: 5m, min: 0, max: 1h
                                  #Can be invalidated with API

                                  ┌──────────────────────────┐
                                  │   AUTHORIZER CACHE API   │
                                  └──────────────────────────┘

DELETE /restapis/API_MID
 /stages/STAGE/cache/authorizers =#Req: empty
FlushStageAuthorizersCache()      #Res: empty
DELETE /v2/apis/API_MID
 /stages/STAGE
 /cache/authorizers              -#Req: empty
ResetAuthorizersCache()           #Res: empty

                                  ┌──────────────────────────┐
                                  │   AUTHORIZER CACHE IAC   │
                                  └──────────────────────────┘

AWS::ApiGateway::Authorizer      =#Includes RESPROPs: AuthorizerResultTtlInSeconds
AWS::ApiGatewayV2::Authorizer    -#Includes RESPROPs: AuthorizerResultTtlInSeconds

C*AUTHORIZER_OPTS
 .resultsCacheTtl                 =
C[C]LAMBDA_AUTHORIZER_OPTS
 .resultsCacheTtl                 -#DURATION. AUTHORIZER.authorizerResultTtlInSeconds

                                  ┌─────────────────────┐
                                  │   AUTHORIZER TEST   │
                                  └─────────────────────┘

INVOKE_AUTHORIZER_REQ            =#Not logged by CloudTrail
                                  #Uses STAGE 'test-invoke-stage'
INVOKE_AUTHORIZER_REQ
 .pathWithQueryString|headers
 |multiValueHeaders|body
 |stageVariables                 =#Like INVOKE_ROUTE_REQ.*
INVOKE_AUTHORIZER_REQ
 .additionalContext.VAR          =#STR. Sets CONTEXT.VAR

INVOKE_AUTHORIZER_RES
 .latency|log                    =#Like INVOKE_ROUTE_REQ.*
INVOKE_AUTHORIZER_RES
 .clientStatus                   =#STATUS_NUM. 0 if AUTHORIZER passed
INVOKE_AUTHORIZER_RES
 .authorization.STR              =#STR_ARR

                                  ┌─────────────────────────┐
                                  │   AUTHORIZER TEST API   │
                                  └─────────────────────────┘

POST /restapis/API_MID
 /authorizers/AUTHORIZER_MID     =#Req: INVOKE_AUTHORIZER_REQ
TestInvokeAuthorizer()            #Res: INVOKE_AUTHORIZER_RES

                                  ┌──────────┐
                                  │   CORS   │
                                  └──────────┘

CORS ==>                        =-#Must set Access-Control-Allow-Origin [S]
                                  #If preflight requests are needed, must also configure OPTIONS ROUTE
                                  #  - Access-Control-Allow-Headers [S] must contain at least
                                  #    Content-Type [C], Authorization [C], X-Amz-Date [C], X-Api-Key [C], X-Amz-Security-Token [C]
                                  #The $default ROUTE has lower priority than an OPTIONS ROUTE
                                  #  - this allows setting authorization on all requests except preflight ones

OSPEC.x-amazon-apigateway-cors
API.corsConfiguration            -#CORS
                                  #Alternative to just setting those response headers manually

CORS_ARN                         -#arn:aws:apigateway:REGION::/apis/API_MID/cors

CORS.allowOrigins                -#'ORIGIN'_ARR. Access-Control-Allow-Origin [S]
CORS.allowMethods                -#'HTTP_METHOD'_ARR. Access-Control-Allow-Methods [S]
CORS.allowHeaders                -#'HEADER'_ARR. Access-Control-Allow-Headers [S]
CORS.allowCredentials            -#BOOL. Access-Control-Allow-Credentials [S]
CORS.maxAge                      -#NUM. Access-Control-Max-Age [S]
CORS.exposeHeaders               -#'HEADER'_ARR. Access-Control-Expose-Headers [S]

                                  ┌──────────────┐
                                  │   CORS API   │
                                  └──────────────┘

DELETE /v2/apis/API_MID/cors     -#Req: empty
DeleteCorsConfiguration()         #Res: empty

                                  ┌──────────────┐
                                  │   CORS IAC   │
                                  └──────────────┘

AWS::ApiGatewayV2::Api           -#Includes RESPROPs: CorsConfiguration CORS

ICRESOURCE.addCorsPreflight      =#Emulates CORS.* but for v1
 (CCORS_OPTS)                     #Uses a ROUTE for OPTIONS
                                  #  - with a MOCK INTEGRATION
                                  #  - adds Vary: Origin [S]
CAPI_OPTS|CRESOURCE[_OPTS]       =#CCORS_OPTS. Same
 .defaultCorsPreflightOptions     #Inherited by child RESOURCEs (unless overridden)
CAPI_OPTS.corsPreflight          -#CCORS_OPTS

CCORS_OPTS.statusCode            =#STATUS_NUM (def: 204)

CCORS_OPTS.allowOrigins         =-#'ORIGIN'_ARR. Access-Control-Allow-Origin [S]
                                 =#Can be Cors.ALL_ORIGIN, i.e. ['*']
                                 =#Uses a Velocity template with IRESP.responseTemplates so that the header value is:
                                  #  - first matching 'ORIGIN' using Origin [C]
                                  #  - if none, first 'ORIGIN' in ARR
CCORS_OPTS.allowMethods         =-#'HTTP_METHOD'_ARR. Access-Control-Allow-Methods [S]
                                 =#Can be Cors.ALL_METHODS (def), i.e. ['OPTIONS', 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD']
CCORS_OPTS.allowHeaders         =-#'HEADER'_ARR. Access-Control-Allow-Headers [S]
                                 =#Can be Cors.DEFAULT_HEADERS (def), i.e.:
                                  #  - Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token
                                  #  - X-Amz-User-Agent
CCORS_OPTS.allowCredentials     =-#BOOL (def: false). Access-Control-Allow-Credentials [S]
CCORS_OPTS.maxAge               =-#DURATION. Access-Control-Max-Age [S]
CCORS_OPTS.disableCache          =#BOOL (def: false). Access-Control-Max-Age: -1 [S]
CCORS_OPTS.exposeHeaders        =-#'HEADER'_ARR. Access-Control-Expose-Headers [S]

                                  ┌──────────────┐
                                  │   FIREWALL   │
                                  └──────────────┘

STAGE|CONTEXT.webAclArn          =#WEB_ACL_ARN. Enable WAF
                                  #Must be regional WEB_ACL
                                  #Must be done with WAF AssociateWebAcl()

CONTEXT.wafResponseCode          =#'WAF_ALLOW|WAF_BLOCK'

ACONTEXT.waf.status|error|latency=#Same as ACONTEXT.authorize.* but for WAF response

                                  ┌───────────────────┐
                                  │   FIREWALL AUTH   │
                                  └───────────────────┘

PACTION apigateway:SetWebACL     =#Required for STAGE|CONTEXT.webAclArn

                                  ┌───────────┐
                                  │   STAGE   │
                                  └───────────┘

STAGE                             #Like a git branch, for a API
                                  #Included in requester's path, i.e. API_MID.execute-api.amazonaws.com[/STAGE]
                                -~#'$default' can be used as default (only for ROUTE '/')
                                  #Max 10 per API (soft)
STAGE_ARN                        =#arn:aws:apigateway:REGION::/restapis/API_MID/stages[/STAGE]
STAGE_ARN                       -~#arn:aws:apigateway:REGION::/apis/API_MID/stages[/STAGE]
STAGE.stageName                   #'STAGE'. Max 128 chars, [[:alnum:]-_]
STAGE.description                 #STR
STAGE.createdDate                =#DATE_NUM
                                -~#'DATE'
STAGE.lastUpdatedDate            =#DATE_NUM
                                -~#'DATE'

STAGE.variables.STAGE_VAR        =
STAGE.stageVariables.STAGE_VAR  -~#'VAL', max 512 chars
                                  #'STAGE_VAR': max 64 chars, [[:alnum:]-._~:/?#&=,]
                                  #Similar goal as an environment-specific ENVVAR
                                  #Should not include confidential information
                                  #Max 100 per STAGE

STAGE.methodSettings             =#ROUTE_SETTINGS
 ./PATH/HTTP_METHOD               #PATH|HTTP_METHOD can be *
STAGE.routeSettings.ROUTE       -~#ROUTE_SETTINGS
STAGE.defaultRouteSettings      -~#ROUTE_SETTINGS applied to any ROUTE
ROUTE_SETTINGS_ARN              -~#arn:aws:apigateway:REGION::/apis/API_MID/stages/STAGE/routesettings

STAGE.tags                        #TAGS

                                  ┌────────────────┐
                                  │   STAGE AUTH   │
                                  └────────────────┘

COND_KEY StageName                #STATE.stageName. STR_ARR, on CreateDeployment()

                                  ┌───────────────┐
                                  │   STAGE API   │
                                  └───────────────┘

POST /restapis/API_MID/stages    =#Req: STAGE
CreateStage()                     #  - no accessLogSettings, cacheClusterStatus, clientCertificateId, createdDate,
                                  #    lastUpdatedDate, methodSettings, webAclArn
                                  #Res: STAGE
PATCH /restapis/API_MID          =#Req: STAGE
 /stages/STAGE                    #  - no stageName, createdDate, lastUpdatedDate, tags, webAclArn
UpdateStage()                     #  - whole OBJ (not only OBJ.*): methodSettings|variables
                                  #  - can use op:remove: accessLogSettings|canarySettings
                                  #  - no op:add|remove: variables|stageVariableOverrides
                                  #  - methodSettings.* PATCH_OP.path:
                                  #     - throttling|cache|logging|metrics* -> throttling|cache|logging|metrics/*
                                  #     - dataTraceEnabled -> logging/dataTrace
                                  #     - *CacheControl* -> caching/*CacheControl*
                                  #Res: STAGE
GET /restapis/API_MID/stages     =#Req: STAGE
GetStages()                       #  - only deploymentId
                                  #Res: item STAGE_ARR
GET /restapis/API_MID
 /stages/STAGE                   =#Req: empty
GetStage()                        #Res: STAGE
DELETE /restapis/API_MID
 /stages/STAGE                   =#Req: empty
DeleteStage()                     #Res: empty

POST /v2/apis/API_MID/stages    -~#Req: STAGE
CreateStage()                     #  - no createdDate, lastUpdatedDate, lastDeploymentStatusMessage, apiGatewayManaged, webAclArn
                                  #Res: STAGE
PATCH /v2/apis/API_MID          -~#Req: STAGE
 /stages/STAGE                    #  - no createdDate, lastUpdatedDate, lastDeploymentStatusMessage, apiGatewayManaged, webAclArn
UpdateStage()                     #  - no stageName, tags
                                  #Res: STAGE
GET /v2/apis/API_MID/stages     -~#Req: empty
GetStages()                       #Res: items STAGE_ARR
GET /v2/apis/API_MID
 /stages/STAGE                  -~#Req: empty
GetStage()                        #Res: STAGE
DELETE /v2/apis/API_MID
 /stages/STAGE                  -~#Req: empty
DeleteStage()                     #Res: empty
DELETE /v2/apis/API_MID
 /stages/STAGE                  -~#Req: empty
 /routesettings/ROUTE             #Res: empty
DeleteRouteSettings()             #Delete STAGE.routeSettings
DELETE /v2/apis/API_MID
 /stages/STAGE                  -~#Req: empty
 /accesslogsettings               #Res: empty
DeleteAccessLogSettings()         #Delete STAGE.accessLogSettings

                                  ┌───────────────┐
                                  │   STAGE IAC   │
                                  └───────────────┘

AWS::ApiGateway::Stage           =#RESPROPs:
                                  #  - RestApiId, StageName, Description, Variables, Tags
                                  #  - MethodSettings OBJ_ARR
                                  #     - ResourcePath 'PATH' (JSON pointer encoded)
                                  #     - HttpMethod 'HTTP_METHOD'
                                  #     - ROUTE_SETTINGS.*
                                  #        - no ROUTE_SETTINGS.*CacheControl*
AWS::ApiGatewayV2::Stage        -~#RESPROPs: ApiId, StageName, Description, StageVariables, [Default]RouteSettings, Tags
                                  #RESATTRs: Id
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Stage: Description, StageVariables, [Default]RouteSettings

new Stage(...CARGS, CSTAGE_OPTS) =
new HttpStage
 (...CARGS, CSTAGE_OPTS)         -
new WebSocketStage
 (...CARGS, CSTAGE_OPTS)         ~#
HttpApi.addStage
 ('CONSTRUCT', CSTAGE_OPTS)
 ->CSTAGE                        -#Automatically sets CSTAGE_OPTS: httpApi
Stage.fromStageAttributes
 (...CARGS, CSTAGE_OPTS)->ICSTAGE=#Only CSTAGE_OPTS: restApi, stageName
HttpStage.fromStageAttributes
 (...CARGS, CSTAGE_OPTS)->ICSTAGE-
WebSocketStage
 .fromStageAttributes
 (...CARGS, CSTAGE_OPTS)->ICSTAGE~#Only CSTAGE_OPTS: api, stageName

CAPI_OPTS.createDefaultStage     -#BOOL (def: false). Creates a default CSTAGE
                                  #Automatically sets: httpApi, autoDeploy true
CAPI.defaultStage                -#CSTAGE created by CAPI_OPTS.createDefaultStage

ICSTAGE.stageArn                 =#'STAGE_ARN'
ICSTAGE.restApi                  =
ICSTAGE.api                     -~#CAPI
CSTAGE_OPTS.httpApi              -
CSTAGE_OPTS.webSocketApi         ~#ICAPI
ICSTAGE[_OPTS].stageName          #STAGE.stageName. Def:
                                 =#  - 'prod'
                                 -#  - '$default'
                                 ~#  - none
CSTAGE_OPTS.description           #STAGE.*

CSTAGE_OPTS.variables            =#STAGE.*

CSTAGE_OPTS.OPT                  =#STAGE.methodSettings./*/*.OPT
CSTAGE_OPTS.methodOptions
 ./PATH/HTTP_METHOD.OPT          =#STAGE.methodSettings./PATH/HTTP_METHOD.OPT

                                  ┌────────────────┐
                                  │   DEPLOYMENT   │
                                  └────────────────┘

DEPLOYMENT                        #Make latest changes on an API (including subresources) available in production, for a given STAGE[s]
DEPLOYMENT_ARN                   =#arn:aws:apigateway:REGION::/restapis/API_MID/deployments[/DEPLOYMENT_MID]
DEPLOYMENT_ARN                  -~#arn:aws:apigateway:REGION::/apis/API_MID/deployments[/DEPLOYMENT_MID]
DEPLOYMENT.id                    =
DEPLOYMENT.deploymentId         -~#DEPLOYMENT_MID
DEPLOYMENT.description            #STR
DEPLOYMENT.createdDate           =#DATE_NUM
DEPLOYMENT.createdDate          -~#'DATE'

STAGE.deploymentId                #DEPLOYMENT_MID

STAGE.canarySettings             =#CANARY. Make STAGE use a different DEPLOYMENT than STAGE.deploymentId for a given percentage of requests.
CANARY.deploymentId              =#DEPLOYMENT_MID
                                  #Def: new one, when using CreateDeployment()
CANARY.percentTraffic            =#0-100 percentage of traffic to send to canary DEPLOYMENT
CANARY.stageVariableOverrides
 .STAGE_VAR                      =#'VAL'
CANARY.useStageCache             =#BOOL (def: false). Whether to use STAGE.cacheCluster*

DEPLOYMENT
 .apiSummary./PATH.HTTP_METHOD   =#ROUTE_SUMMARY

DEPLOYMENT.deploymentStatus     -~#STR among:
                                  #  - PENDING
                                  #  - SUCCEEDED, FAILED
DEPLOYMENT
 .deploymentStatusMessage       -~#STR, when deploymentStatus FAILED

STAGE.autoDeploy                -~#BOOL (def: false). Create a DEPLOYMENT when API is updated
DEPLOYMENT.autoDeployed         -~#BOOL
STAGE
 .lastDeploymentStatusMessage   -~#STR. Last DEPLOYMENT.deploymentStatusMessage when using STAGE.autoDeploy true

                                  ┌────────────────────┐
                                  │   DEPLOYMENT API   │
                                  └────────────────────┘

POST /restapis/API_MID           =#Req: DEPLOYMENT + STAGE
 /deployments                     #  - DEPLOYMENT: no id, createdDate, apiSummary
CreateDeployment()                #  - STAGE:
                                  #     - no accessLogSettings, cacheClusterStatus, clientCertificateId, createdDate,
                                  #       lastUpdatedDate, methodSettings, webAclArn
                                  #     - no [canarySettings.]deploymentId, documentationVersion, tags
                                  #     - description -> stageDescription
                                  #Res: DEPLOYMENT
PATCH /restapis/API_MID          =#Req: DEPLOYMENT
 /deployments/DEPLOYMENT_MID      #  - only description
UpdateDeployment()                #Res: DEPLOYMENT
GET /restapis/API_MID
 /deployments                    =#Req: empty
GetDeployments()                  #Res: item DEPLOYMENT_ARR
GET /restapis/API_MID            =#Req:
 /deployments/DEPLOYMENT_MID      #  - embed 'apisummary': to return apiSummary
GetDeployment()                   #Res: DEPLOYMENT
DELETE /restapis/API_MID
 /deployments/DEPLOYMENT_MID     =#Req: empty
DeleteDeployment()                #Res: empty

POST /v2/apis/API_MID           -~#Req: DEPLOYMENT
 /deployments                     #  - no deploymentId, deploymentStatus*, autoDeployed
CreateDeployment()                #Res: DEPLOYMENT
PATCH /v2/apis/API_MID          -~#Req: DEPLOYMENT
 /deployments/DEPLOYMENT_MID      #  - no deploymentId, deploymentStatus*, autoDeployed
UpdateDeployment()                #  - no stageName
                                  #Res: DEPLOYMENT
GET /v2/apis/API_MID
 /deployments                   -~#Req: empty
GetDeployments()                  #Res: items DEPLOYMENT_ARR
GET /v2/apis/API_MID
 /deployments/DEPLOYMENT_MID    -~#Req: empty
GetDeployment()                   #Res: DEPLOYMENT
DELETE /v2/apis/API_MID
 /deployments/DEPLOYMENT_MID    -~#Req: empty
DeleteDeployment()                #Res: empty

                                  ┌────────────────────┐
                                  │   DEPLOYMENT IAC   │
                                  └────────────────────┘

AWS::ApiGateway::Deployment      =#RESPROPs:
                                  #  - RestApiId, Description
                                  #  - DeploymentCanarySettings CANARY
                                  #     - no deploymentId
                                  #  - StageName 'STAGE': creates a STAGE
                                  #     - alternative to using AWS::ApiGateway::Stage RESPROP DeploymentId
                                  #  - StageDescription: AWS::ApiGateway::Stage + AWS::ApiGateway::Stage.MethodSettings[*]
                                  #     - no RestApiId, StageName, CanarySetting.DeploymentId, MethodSettings[*].HttpMethod|ResourcePath
                                  #RESATTRs: DeploymentId
                                  #If APIs|RESOURCEs|ROUTEs|MODELs|GRESPs|REQVALIDs|AUTHORIZERs or Lambda FUNCTION INTEGRATION are declared in same TEMPLATE,
                                  #DEPLOYMENT must DependsOn each of them
AWS::ApiGatewayV2::Deployment   -~#RESPROPs: ApiId, Description, StageName
                                  #RESATTRs: DeploymentId
AWS::ApiGateway::Stage           =#Includes RESPROPs: DeploymentId, CanarySetting CANARY
AWS::ApiGatewayV2::Stage        -~#Includes RESPROPs: DeploymentId, AutoDeploy
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Stage: AutoDeploy

new Deployment
 (...CARGS, CDEPLOYMENT_OPTS)    =#

CDEPLOYMENT.deploymentId         =#DEPLOYMENT_MID_STR_TK
CDEPLOYMENT[_OPTS].api           =#ICAPI
CAPI.deployments                  #CDEPLOYMENT_ARR
CDEPLOYMENT[_OPTS].stageName     =#'STAGE'
CDEPLOYMENT_OPTS.description     =#DEPLOYMENT.*

CSTAGE_OPTS.autoDeploy          -~#STAGE.*

CDEPLOYMENT_OPTS                 =#BOOL (def: false). Use DeletionPolicy|UpdateReplacePolicy RETAIN (instead of DESTROY)
 .retainDeployments               #This allows reverting

CDEPLOYMENT.addToLogicalId       =#Append MD5 hash of JSON_VAL to 'LID'
 (JSON_VAL)                       #I.e. create a new DEPLOYMENT when JSON_VAL changes
                                  #Regardless, if CDEPLOYMENT_OPTS.api is CAPI (not ICAPI), a new DEPLOYMENT is created when following changes:
                                  #  - CAPI.**
                                  #  - CRESOURCE|CROUTE|CMODEL|CGRESP|CREQVALID.*
                                  #  - CAUTHORIZER.*
                                  #     - if FFLAG @aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId true (recommended, def: false)
                                  #  - LambdaIntegration ICANYFUNC.functionName

CSTAGE_OPTS.deployment           =#CDEPLOYMENT. STAGE.deploymentId + CSTAGE.restApi

CAPI_OPTS.deploy                 =#BOOL (def: true). Create a DEPLOYMENT + STAGE
ICAPI.latestDeployment           =#CDEPLOYMENT created by CAPI_OPTS.deploy
CAPI_OPTS.description            =#CDEPLOYMENT_OPTS.* (def: 'Automatically created by the RestApi construct')
                                  #Overridden by CAPI_OPTS.deployOptions.description
CAPI_OPTS.retainDeployments      =#CDEPLOYMENT_OPTS.*
ICAPI.deploymentStage            =#CSTAGE created by CAPI_OPTS.deploy
CAPI_OPTS.deployOptions          =#CSTAGE_OPTS

                                  ┌───────────────────────┐
                                  │   DEPLOYMENT PULUMI   │
                                  └───────────────────────┘

DEPLOYMENT_RPROPS.triggers        #TRIGGER_OBJ

                                  ┌─────────────┐
                                  │   METRICS   │
                                  └─────────────┘

SYSTEM ERRORS ==>                 #Some 5** might not create logs nor METRICS.
                                  #Also some 429 (throttle) and 413 (request body too large)

ROUTE_SETTINGS.metricsEnabled    =
ROUTE_SETTINGS                  -~#BOOL. If false (def), send each METRIC with:
 .detailedMetricsEnabled          #  - DVAR ApiName|ApiId
                                  #  - DVAR ApiName|ApiId + Stage
                                  #If true, also with:
                                  #  - DVAR ApiName|ApiId + Stage + Method|Resource
                                  #1m PERIOD

DVAR ApiName                     =#'API'
DVAR ApiId                      -~#API_MID
DVAR Stage                        #'STAGE'
DVAR Method                       #'HTTP_METHOD'
DVAR Resource                     #'/PATH'

AWS/ApiGateway/Count            =-#CloudWatch METRIC with NUM of requests|responses
                                  #cdk-monitoring-constructs:
                                  #  - rate/s: METRIC, summary WIDGET, MALARM Low|HighTps < > CXALARM_OPTS.min|maxTps
AWS/ApiGateway/ConnectCount      ~#CloudWatch METRIC with NUM of CONNECTIONs
AWS/ApiGateway/MessageCount      ~#CloudWatch METRIC with NUM of messages (requests or push messages)

AWS/ApiGateway/4XXError          =
AWS/ApiGateway/4xx               -#CloudWatch METRIC with NUM of 4** responses
AWS/ApiGateway/ClientError       ~#CloudWatch METRIC with NUM of 4** responses in ROUTE (not INTEGRATION)
                                  #cdk-monitoring-constructs:
                                  #  - sum:
                                  #     - METRIC, WIDGET
                                 =#     - MALARM 4XXErrorCount >= CXALARM_OPTS.maxErrorCount
                                -~#     - MALARM 4xxCount >= CXALARM_OPTS.maxErrorCount
                                  #  - rate:
                                  #     - METRIC, summary WIDGET
                                 =#     - MALARM 4XXErrorRate >= CXALARM_OPTS.maxErrorRate
                                -~#     - MALARM 4xxRate >= CXALARM_OPTS.maxErrorRate
AWS/ApiGateway/5XXError          =
AWS/ApiGateway/5xx               -#CloudWatch METRIC with NUM of 5** responses
AWS/ApiGateway/ExecutionError    ~#CloudWatch METRIC with NUM of 4**|5** responses in INTEGRATION
                                  #cdk-monitoring-constructs:
                                  #  - sum:
                                  #     - METRIC, WIDGET
                                 =#     - MALARM 5XXErrorCount >= CXALARM_OPTS.maxErrorCount
                                -~#     - MALARM 5xxCount >= CXALARM_OPTS.maxErrorCount
                                  #  - rate
                                  #     - METRIC, summary WIDGET
                                 =#     - MALARM 5XXErrorRate >= CXALARM_OPTS.maxErrorRate
                                -~#     - MALARM 5xxRate >= CXALARM_OPTS.maxErrorRate

                                  ┌─────────────────┐
                                  │   METRICS IAC   │
                                  └─────────────────┘

AWS::ApiGateway::Stage           =#Includes RESPROPs: MethodsSettings OBJ_ARR: MetricsEnabled
AWS::ApiGatewayV2::Stage        -~#Includes RESPROPs: DefaultRouteSettings|RouteSettings.ROUTE: DetailedMetricsEnabled

CSTAGE_OPTS
 [.methodOptions./PATH/HTTP_METOD]
 .metricsEnabled                 =#STAGE.methodSettings./PATH/HTTP_METHOD.*

ICAPI|ICSTAGE.metric
 ('METRIC'[, CMETRIC_OPTS])
 ->CMETRIC                        #
CROUTE.metric('METRIC', ICSTAGE
 [, CMETRIC_OPTS])->CMETRIC      =#
ICAPI|ICSTAGE.metricCount
 ([CMETRIC_OPTS])->CMETRIC      =-#
CROUTE.metricCount
 (ICSTAGE[, CMETRIC_OPTS])
 ->CMETRIC                       =#
ICAPI|ICSTAGE.metricClientError
 ([CMETRIC_OPTS])->CMETRIC      =-#
CROUTE.metricClientError
 (ICSTAGE[, CMETRIC_OPTS])
 ->CMETRIC                       =#
ICAPI|ICSTAGE.metricServerError
 ([CMETRIC_OPTS])->CMETRIC      =-#
CROUTE.metricServerError
 (ICSTAGE[, CMETRIC_OPTS])
 ->CMETRIC                       =#

CFACADE.monitorApiGateway
 (CXMONITORING_OPTS)            =
CFACADE
 .monitorApiGatewayV2HttpApi
 (CXMONITORING_OPTS)            -~#See cdk-monitoring-constructs doc
CXMONITORING_OPTS.api             #ICAPI
CXMONITORING_OPTS.apiStage        #'STAGE'. Def:
                                 =#  - 'prod'
                                -~#  - '$default'
CXMONITORING_OPTS.apiMethod       #'HTTP_METHOD'
CXMONITORING_OPTS.apiResource     #'/PATH'

                                  ┌─────────────┐
                                  │   LOGGING   │
                                  └─────────────┘

ROUTE_SETTINGS.loggingLevel     =~#STR. Send requests info|CONTEXT to CloudWatch logs ("execution logging")
                                  #STR can be:
                                  #  - 'OFF' (def): none
                                  #  - 'ERROR': 4**|5** requests
                                  #  - 'INFO': any request
                                  #Sent to LOG_GROUP API-Gateway-Execution-Logs/API_MID/STAGE[/canary]
                                  #  - contains multiple LOG_STREAMs ordered by time
ROUTE_SETTINGS.dataTraceEnabled =~#BOOL (def: false). Whether to log request|response [non-]body parameters
                                  #Not recommended in production, to avoid logging confidential information

STAGE.accessLogSettings           #ACCESS_LOG. Send request logs ("access logging")
                                  #Unlike execution logging, can choose LOG_EVENT format
ACCESS_LOG_ARN                  -~#arn:aws:apigateway:REGION::/apis/API_MID/stages/STAGE/accesslogsettings
ACCESS_LOG.destinationArn         #Either:
                                  #  - CloudWatch LOG_GROUP_ARN
                                 =#  - Kinesis Firehose DELIVERY_STREAM_ARN
                                  #     - name must start with 'amazon-apigateway-'
ACCESS_LOG.format                 #'$EXPR' of the log line to print
                                  #Must include '$context.requestId' or '$context.extendedRequestId'
                                  #Max 3KB
                                  #Max 1KB after resolution

STAGE.tracingEnabled             =#BOOL (def: false). Enable X-Ray
ACONTEXT.xrayTraceId             =#X-Ray TRACE_MID

                                  ┌──────────────────┐
                                  │   LOGGING AUTH   │
                                  └──────────────────┘

ACCOUNT.cloudwatchRoleArn        =#ROLE_ARN used to send to CloudWatch logs (both execution|access logging)
                                  #Assumed by Principal.Service 'apigateway.amazonaws.com'
                                -~#Performed using current PRINCIPAL instead with PACTIONs logs:*:
                                  #  - DescribeLogGroups|DescribeLogStreams|GetLogEvents|FilterLogEvents on LOG_GROUP
                                  #  - CreateLogDelivery|UpdateLogDelivery|GetLogDelivery|ListLogDeliveries|DeleteLogDelivery
                                  #  - PutResourcePolicy|DescribeResourcePolicies
                                  #  - CreateLogGroup
AmazonAPIGateway                  #AWS managed POLICY that allows PACTIONs:
 PushToCloudWatchLogs             #  - logs:Create|DescribeLogGroup|Stream
                                  #  - logs:Put|Filter|GetLogEvent
                                  #Meant for ACCOUNT.cloudwatchRoleArn

COND_KEY AccessLoggingDestination
COND_KEY AccessLoggingFormat      #ACCESS_LOG.destinationArn|format. On Create|Update|DeleteStage()

                                  ┌─────────────────┐
                                  │   LOGGING IAC   │
                                  └─────────────────┘

AWS::ApiGateway::Stage           =#Includes RESPROPs:
                                  #  - MethodsSettings OBJ_ARR: LoggingLevel, DataTraceEnabled
                                  #  - AccessLogSettings, TracingEnabled
AWS::ApiGatewayV2::Stage        -~#Includes RESPROPs:
                                  #  - DefaultRouteSettings|RouteSettings.ROUTE: LoggingLevel, DataTraceEnabled
                                  #  - AccessLogSettings
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Stage: AccessLogSettings
AWS::ApiGateway::Account         =#Includes RESPROPs: CloudWatchRoleArn

CSTAGE_OPTS
 [.methodOptions./PATH/HTTP_METOD]
 .loggingLevel|dataTraceEnabled  =#STAGE.methodSettings./PATH/HTTP_METHOD.*

CSTAGE_OPTS.accessLogDestination =#ACCESS_LOG.destinationArn. One of:
                                  #  - new LogGroupLogDestination(ICLOG_GROUP)
                                  #  - new FirehoseLogDestination(CFIREHOSE_DELIVERY_STREAM)

CSTAGE_OPTS.accessLogFormat      =#CACCESS_LOG_FORMAT. ACCESS_LOG.format
                                  #Def if CSTAGE_OPTS.accessLogDestination set: AccessLogFormat.clf()
AccessLogFormat.custom('$EXPR')
 ->CACCESS_LOG_FORMAT            =#
AccessLogField.context*([...])   =#To use inside $EXPR
 ->'$context....'                 #See CDK code for full list of methods
AccessLogFormat.clf()            =#Common Log format. Space-delimited list of:
 ->CACCESS_LOG_FORMAT             #  - $context.identity.sourceIp
                                  #  - $context.identity.caller
                                  #  - $context.identity.user
                                  #  - [$context.requestTime]
                                  #  - "$context.httpMethod $context.resourcePath $context.protocol"
                                  #  - $context.status
                                  #  - $context.responseLength
                                  #  - $context.requestId
AccessLogFormat                  =#Same but as OBJ_JSON:
 .jsonWithStandardFields(OPTS)    #  - requestId: '$context.requestId'
 ->CACCESS_LOG_FORMAT             #  - ip: '$context.identity.sourceIp'
                                  #  - user: '$context.identity.user'
                                  #  - caller: '$context.identity.caller'
                                  #  - requestTime: '$context.requestTime'
                                  #  - httpMethod: '$context.httpMethod'
                                  #  - resourcePath: '$context.resourcePath'
                                  #  - status: '$context.status'
                                  #  - protocol: '$context.protocol'
                                  #  - responseLength: '$context.responseLength'
                                  #Each field can be turned out using OPTS.PROP false

CAPI_OPTS.cloudWatchRole         =#BOOL. Automatically creates ROLE for ACCOUNT.cloudwatchRoleArn
                                  #Def: opposite of FFLAG @aws-cdk/aws-apigateway:disableCloudWatchRole (recommended, def: false)
                                  #Should be false if multiple APIs per ACCOUNT + REGION
CAPI_OPTS
 .cloudWatchRoleRemovalPolicy    =#STR (def: 'RETAIN'). DeletionPolicy|UpdateReplacePolicy of ROLE created by CAPI_OPTS.cloudWatchRole

CSTAGE_OPTS.tracingEnabled       =#STAGE.*

                                  ┌──────────────────┐
                                  │   LOGGING LINT   │
                                  └──────────────────┘

cfn-lint-serverless
 aws_apigateway[v2]
 _stage_logging_rule
 (ES2000)                         #STAGE.accessLogSettings must be set
cfn-lint-serverless
 aws_api_gateway[v2]
 _stage_structured_logging
 (WS2001)                         #ACCESS_LOG.format must be 'OBJ_JSON'
cfn-lint-serverless
 aws_apigateway_stage_tracing_rule
 (WS2002)                        =#STAGE.tracingEnabled must be true

cdk-nag APIGWAccessLogging        #STAGE.accessLogSettings must be set
cdk-nag
 APIGWExecutionLoggingEnabled   =~#Validate ROUTE_SETTINGS.loggingLevel is not 'OFF' on HTTP_METHOD * and PATH /*
cdk-nag APIGWXrayEnabled         =#STAGE.tracingEnabled must be true

                                  ┌─────────────┐
                                  │   CACHING   │
                                  └─────────────┘

STAGE.cacheClusterEnabled        =#BOOL (def: false). Cache RRESP successful responses
                                  #Can be flushed with API
STAGE.cacheClusterSize           =#'NUM' (in GB). Max cache size
                                  #Can be 0.5, 1.6, 6.1, 13.5, 28.4, 58.2, 118, 237
                                  #Also impacts the instance type, i.e. its CPU, RAM and network bandwidth, i.e. overall performance
                                  #Updating it flushes cache
                                  #Individual responses >1GB are never cached
STAGE.cacheClusterStatus         =#STR among:
                                  #  - CREATE_IN_PROGRESS
                                  #  - AVAILABLE
                                  #  - FLUSH_IN_PROGRESS
                                  #  - DELETE_IN_PROGRESS
                                  #  - NOT_AVAILABLE

ROUTE_SETTINGS.cachingEnabled    =#BOOL. Enable caching for that ROUTE
                                  #Requires STAGE.cacheClusterEnabled true
                                  #Def: true, but only if GET method + STAGE.cacheClusterEnabled true
ROUTE_SETTINGS.cacheTtlInSeconds =#NUM (in secs). How long to cache
                                  #Def: 5m, min: 0, max: 1h
ROUTE_SETTINGS
 .cacheDataEncrypted             =#BOOL. Encrypt cached responses

INTEGRATION.cacheKeyParameters   =#'EXPR'_ARR (def: []) to use as cache key
                                  #Must be present in ROUTE.requestParameters.*
INTEGRATION.cacheNamespace       =#STR (def: RESOURCE_MID) prefixing cache key

Cache-Control: max-age=0 [C]     =#Invalidate cache

                                  ┌──────────────────┐
                                  │   CACHING AUTH   │
                                  └──────────────────┘

PACTION
 execute-api:InvalidateCache     =#Allow invalidation requests
ROUTE_SETTINGS.require           =#BOOL. Require PACTION execute-api:InvalidateCache for invalidation requests
 AuthorizationForCacheControl     #Also must be authenticated, and within same ACCOUNT
                                  #Def: true if PACTION execute-api:InvalidateCache specified, false otherwise
ROUTE_SETTINGS.unauthorized      =#How to handle unauthorized invalidation requests, among:
 CacheControlHeaderStrategy       #  - 'FAIL_WITH_403'
                                  #  - 'SUCCEED_WITHOUT_RESPONSE_HEADER'
                                  #  - 'SUCCEED_WITH_RESPONSE_HEADER': set a warning in a response header

                                  ┌─────────────────┐
                                  │   CACHING API   │
                                  └─────────────────┘

DELETE /restapis/API_MID
 /stages/STAGE/cache/data        =#Req: empty
FlushStageCache()                 #Res: empty

                                  ┌─────────────────┐
                                  │   CACHING IAC   │
                                  └─────────────────┘

AWS::ApiGateway::Stage           =#Includes RESPROPs:
                                  #  - CacheClusterEnabled, CacheClusterSize
                                  #  - MethodsSettings OBJ_ARR: CachingEnabled, CacheTtlInSeconds, CacheDataEncrypted
AWS::ApiGateway::Method          =#Includes RESPROPs: Integration: CacheKeyParameters, CacheNamespace

CSTAGE_OPTS.cacheClusterEnabled  =#BOOL (def: true if CSTAGE_OPTS.cacheClusterSize set). STAGE.*
CSTAGE_OPTS.cacheClusterSize     =#'NUM' (def: '0.5' if CSTAGE_OPTS.cacheClusterEnabled|cachingEnabled). STAGE.*
CSTAGE_OPTS
 [.methodOptions./PATH/HTTP_METOD]
 .cachingEnabled
 |cacheDataEncrypted             =#STAGE.methodSettings./PATH/HTTP_METHOD.*
CSTAGE_OPTS
 [.methodOptions./PATH/HTTP_METOD]
 .cacheTtl                       =#DURATION. STAGE.methodSettings./PATH/HTTP_METHOD.*

CINTEGRATION_OOPTS
 .cacheKeyParameters
 |cacheNamespace                 =#INTEGRATION.*

                                  ┌────────────────────┐
                                  │   CACHING PULUMI   │
                                  └────────────────────┘

apiGatewayStageCached            =#Pulumi POLICY validating STAGE.cacheClusterEnabled is true
apiGatewayMethod
 CachedAndEncrypted              =#Pulumi POLICY validating ROUTE_SETTINGS.cacheDataEncrypted is true

                                  ┌─────────────────────┐
                                  │   CACHING METRICS   │
                                  └─────────────────────┘

AWS/ApiGateway/CacheHitCount     =#CloudWatch METRIC with NUM of cached responses
ICAPI|ICSTAGE.metricCacheHitCount
 ([CMETRIC_OPTS])->CMETRIC
CROUTE.metricCacheHitCount
 (ICSTAGE[, CMETRIC_OPTS])
 ->CMETRIC                       =#

AWS/ApiGateway/CacheMissCount    =#CloudWatch METRIC with NUM of non-cached responses
ICAPI|ICSTAGE
 .metricCacheMissCount
 ([CMETRIC_OPTS])->CMETRIC
CROUTE.metricCacheMissCount
 (ICSTAGE[, CMETRIC_OPTS])
 ->CMETRIC                       =#

                                  ┌──────────────────┐
                                  │   CACHING LINT   │
                                  └──────────────────┘

cdk-nag                          =#Validate ROUTE_SETTINGS.cacheDataEncrypted and ROUTE_SETTINGS.cachingEnabled are true,
 APIGWCacheEnabledAndEncrypted    #on HTTP_METHOD * and PATH /*

                                  ┌───────────────────┐
                                  │   IMPORT/EXPORT   │
                                  └───────────────────┘

RAW_API_EXPORT                    #'JSON|YAML' OpenAPI OSPEC
                                  #Max 6MB
                                  #In CLI: FILE, in SDK: INPUT_BLOB|OUTPUT_BLOB
                                  #Exporting API Gateway RESOURCEs to OpenAPI OSPEC:
                                  #  - misses some fields
                                  #  - pro: simpler|automated
                                  #  - con: not as high-quality as hand-written

OSPEC2.swagger
OSPEC3.openapi                    #OpenAPI version, either 'oas30' (3.0)
API_EXPORT_TYPE                  =#or 'swagger' (2.0)
Accepts: MIME [C]                =#'application/json' or 'application/yaml'
API_EXPORT.outputType           -~#'JSON' or 'YAML'

API_EXPORT_ARN                  -~#arn:aws:apigateway:REGION::/apis/API_MID/exports/API_EXPORT_TYPE
API_EXPORT.exportVersion        -~#Always '1.0'

API_EXPORT.stageName              #'STAGE' to export

IMPORT.mode                      =#How to handle previous API, either:
                                  #  - 'import': fail, i.e. only create a new API
                                  #  - 'merge': deep merge, with priority to RAW_API_EXPORT
                                  #  - 'overwrite'
                                  #Importing OpenAPI OSPEC to API Gateway RESOURCEs:
                                  #  - useful to avoid duplication between OSPEC and some API Gateway RESOURCEs
                                  #  - especially: OINFO.title|description|version, OSERVER, OOPERATION,
                                  #    OPARAM, OREQ_BODY, ORESP, OCOMPONENTS.definitions|schemas
                                  #  - it is often recommend to specify all x-amazon-apigateway-*
                                  #     - however, I prefer not to specify, and use API Gateway RESOURCEs instead
                                  #     - pros:
                                  #        - less clutter in OSPEC, keeping it agnostic to API Gateway
                                  #        - allows using CloudFormation tooling (linting, CDK, etc.) for Gateway RESOURCEs
                                  #     - must use IMPORT.mode 'merge' for ROUTE|INTEGRATION|IRESP

API.importInfo                   -#'MESSAGE'_ARR. Import low-severity issues
API.warnings                      #'MESSAGE'_ARR. Import medium-severity issues
IMPORT.failOnWarnings             #BOOL (def: false). Fail on API.warnings

API_IMPORT
 .endpointConfigurationTypes     =#ENDPOINT.types[0] (def: 'REGIONAL')

                                  ┌───────────────────────┐
                                  │   IMPORT/EXPORT API   │
                                  └───────────────────────┘

GET /restapis/API_MID
 /stages/STAGE                   =#Req: parameters API_EXPORT
 /exports/API_EXPORT_TYPE         #  - stageName is in URL path
GetExport()                       #Res: RAW_API_EXPORT
POST /restapis                   =#Req: RAW_API_EXPORT + IMPORT (query variables) + parameters API_IMPORT (query variables)
ImportRestApi()                   #  - mode must be 'import'
                                  #Res: API
PUT /restapis/API_MID            =#Req: RAW_API_EXPORT + IMPORT (query variables) + parameters API_IMPORT (query variables)
PutRestApi()                      #  - mode must be 'merge' (def) or 'overwrite'
                                  #Res: API

GET /v2/apis/API_MID
 /exports/API_EXPORT_TYPE       -~#Req: API_EXPORT
ExportApi()                       #Res: RAW_API_EXPORT
PUT /v2/apis                    -~#Req: RAW_API_EXPORT + [API]_IMPORT (query variables)
ImportApi()                       #Res: API
PUT /v2/apis/API_MID            -~#Req: RAW_API_EXPORT + [API]_IMPORT (query variables)
ReimportApi()                     #Res: API

                                  ┌───────────────────────┐
                                  │   IMPORT/EXPORT IAC   │
                                  └───────────────────────┘

AWS::ApiGateway::RestApi         =#Includes RESPROPs:
                                  #  - Body RAW_API_EXPORT_OBJ
                                  #  - BodyS3Location OBJ: Bucket 'BUCKET', Key 'OBJECT', Version VERSION_MID, ETag STR
                                  #     - can use `aws cloudformation package` (defaults to undefined) or `sam package`
                                  #  - Parameters API_IMPORT
                                  #  - Mode
                                  #  - FailOnWarnings
AWS::ApiGatewayV2::Api          -~#Includes RESPROPs: Body[S3Location], FailOnWarnings
                                  #  - BodyS3Location can use `sam package` (not `aws cloudformation package`)

CAPI_OPTS.apiDefinition          =#CAPI_EXPORT_BODY. RAW_API_EXPORT
ApiDefinition.fromInline
 (RAW_API_EXPORT_OBJ)
 ->CAPI_EXPORT_BODY              =#
ApiDefinition.fromBucket
 (ICBUCKET, 'OBJECT'
 [, 'VERSION'_MID])
 ->CAPI_EXPORT_BODY              =#
ApiDefinition.fromAsset          =#Uses aws-s3-assets (see its doc)
 ('SOURCE_PATH'[, HFOPTS])        #Must be regular FILE, not DIR nor *.tar[.gz]|tgz|zip|jar
 ->CAPI_EXPORT_BODY               #Adds the following TEMPLATE.Resources.RESOURCE.Metadata:
                                  #  - 'aws:asset:property': 'BodyS3Location'
                                  #  - 'aws:asset:path': 'TARGET_PATH'

CAPI_OPTS.parameters             =#API_IMPORT.*
CAPI_OPTS.failOnWarnings         =#IMPORT.*

new SpecRestApi(...)             =#Same as new RestApi(...)
                                  #Required when usig CAPI_OPTS.apiDefinition
                                  #Lacks:
                                  #  - CAPI.methods|deployments
                                  #  - CAPI.addModel|addRequestValidator()
                                  #  - CAPI_OPTS.description|binaryMediaTypes|apiKeySourceType|cloneFrom
                                  #  - CAPI_OPTS.defaultIntegration|defaultMethodOptions|defaultCorsPreflightOptions
RestApi.isRestApi(CAPI)->BOOL    =#Whether created with RestApi, not SpecRestApi

                                  ┌────────────────────────────┐
                                  │   IMPORT/EXPORT COMPOSER   │
                                  └────────────────────────────┘

INFRASTUCTURE COMPOSER ==>        #Can use external file for AWS::Serverless::Api RESPROP DefinitionUri

                                  ┌──────────────────────────┐
                                  │   IMPORT/EXPORT PULUMI   │
                                  └──────────────────────────┘

API_RPROPS.body                   #'JSON|YAML', for RAW_API_EXPORT

API_RPROPS.putRestApiMode        =#IMPORT.mode

                                  ┌─────────────┐
                                  │   OPENAPI   │
                                  └─────────────┘

O*                              =-#OpenAPI specification fields

O*.x-amazon-apigateway-*        =-#OpenAPI custom fields used when import|exporting to API
API_EXPORT.extensions            =#'STR' to use among:
                                  #  - 'apigateway': all x-amazon-apigateway-*
                                  #  - 'documentation' (def): only DOCPARTs
                                  #  - 'integrations': only x-amazon-apigateway-integration
                                  #  - 'authorizers': only x-amazon-apigateway-authorizer
                                  #  - 'postman': Postman extensions
API_EXPORT.includeExtensions     -#BOOL (def: true). Include all x-amazon-apigateway-*

${AWS::...}                       #Substituted during OpenAPI imports
${AWS::Partition}                 #PARTITION
${AWS::Region}                    #REGION
${AWS::AccountId}                 #ACCOUNT_ID

OSPEC.x-amazon-apigateway-
 importexport-version           =-#Always '1.0'

API.version                       #'API_VERSION', used only as OINFO.version
                                  #Def: DEPLOYMENT.createdDate

OSERVER2.basePath                 #'/STAGE'
OSERVER3.variables.basePath
 .default                         #'STAGE'
API_IMPORT.basepath             =-#STR. How to use OSERVER.url|[variables.]basePath, among:
                                  #  - 'ignore' (def): do not use
                                  #  - 'prepend': prepend to each ROUTE
                                 =#  - 'split': take first '/PATH' part as RESOURCE, prepend rest to each ROUTE

OSERVER2.host                     #'API_MID.execute-api.REGION.amazonaws.com'
OSERVER3.url                      #'https|ws://API_MID.execute-api.REGION.amazonaws.com/{basePath}'

ROUTE.operationName               #'OPERATION', used only as OOPERATION.operationId

OOPERATION|OPARAM.deprecated      #Removed on export
OPARAM.allowEmptyValue
OPARAM|ORESP|OCONTENT.example[s]  #Not used

                                  ┌─────────────────┐
                                  │   OPENAPI IAC   │
                                  └─────────────────┘

AWS::ApiGatewayV2::Api           -#Includes RESPROPs: Version, BasePath
AWS::ApiGateway::Method          =#Includes RESPROPs: OperationName
AWS::ApiGatewayV2::Route         -#Includes RESPROPs: OperationName
AWS::ApiGatewayV2::
 ApiGatewayManagedOverrides      -#Includes RESPROPs: Route: OperationName

CROUTE_OOPTS.operationName       =#ROUTE.*

                                  ┌──────────────┐
                                  │   DOC PART   │
                                  └──────────────┘

DOCPART                          =#OpenAPI field. Kept during imports|exports
                                  #Goal: getting|setting it via API
                                  #  - e.g. controlling permissions on who can update which field
                                  #  - as opposed to editing on OpenAPI spec directly
                                  #Max 2e3 per API (soft)

OSPEC.x-amazon-apigateway-
 documentation
 .documentationParts             =#DOCPART_ARR, except id
API_IMPORT.ignore                =#If 'documentation', do not import DOCPARTs

DOCPART_ARN                      =#arn:aws:apigateway:REGION::/restapis/API_MID/documentation/parts[/DOCPART_MID]
DOCPART.id                       =#DOCPART_MID

DOCPART.properties               =#OpenAPI 'OBJ_JSON'
                                  #Properties that are not OpenAPI-defined nor x-* are not merged
                                  #  - but they are still kept under OSPEC.x-amazon-apigateway-documentation, like the others
DOCPART.locationStatus           =#'[UN]DOCUMENTED'. Whether DOCPART.properties is empty

DOCPART.location                 =#DOCPART_LOCATION. OpenAPI field to target.
DOCPART_LOCATION.type            =#STR among:
                                  #  - API: OSPEC
                                  #  - MODEL: OCOMPONENTS.definitions|schemas.NAME
                                  #  - RESOURCE: OPATHDEF
                                  #  - METHOD: OOPERATION
                                  #  - PATH_PARAMETER, QUERY_PARAMETER, REQUEST_HEADER: OPARAM
                                  #  - REQUEST_BODY: OPARAM|OREQ_BODY
                                  #  - RESPONSE: ORESP
                                  #  - RESPONSE_HEADER: ORESP.headers.HEADER
                                  #  - RESPONSE_BODY: ORESP.schema|contents
                                  #  - AUTHORIZER: OSECURITY_DEF
DOCPART_LOCATION.path            =#'/PATH' (def: '/')
                                  #Not with type API|AUTHORIZER|MODEL
DOCPART_LOCATION.method          =#'HTTP_METHOD' (def: '*')
                                  #Not with type API|AUTHORIZER|MODEL|RESOURCE
DOCPART_LOCATION.name            =#'NAME'
                                  #Not with type API|RESOURCE|METHOD|RESPONSE[_BODY]
DOCPART_LOCATION.statusCode      =#'STATUS_NUM' (def: '*')
                                  #Only with type RESPONSE*

                                  ┌──────────────────┐
                                  │   DOC PART API   │
                                  └──────────────────┘

POST /restapis/API_MID           =#Req: DOCPART
 /documentation/parts             #  - no id
CreateDocumentationPart()         #Res: DOCPART
PATCH /restapis/API_MID          =#Req: DOCPART
 /documentation/parts/DOCPART_MID #  - only properties
UpdateDocumentationPart()         #Res: DOCPART
GET /restapis/API_MID            =#Req: DOCPART
 /documentation/parts             #  - only DOCPART_LOCATION.type|path|name -> type|path|nameQuery
GetDocumentationParts()           #  - only one with locationStatus
                                  #Res: item DOCPART_ARR
GET /restapis/API_MID
 /documentation
 /parts/DOCPART_MID              =#Req: empty
GetDocumentationPart()            #Res: DOCPART
DELETE /restapis/API_MID
 /documentation
 /parts/DOCPART_MID              =#Req: empty
DeleteDocumentationPart()         #Res: empty

                                  ┌──────────────────┐
                                  │   DOC PART IAC   │
                                  └──────────────────┘

AWS::ApiGateway::                =#RESPROPs: RestApiId, Properties, Location DOCPART_LOCATION
 DocumentationPart                #RESATTRs: DocumentationPartId

                                  ┌────────────────┐
                                  │   DOC IMPORT   │
                                  └────────────────┘

RAW_DOCPART_IMPORT               =#DOCPART.properties as is
                                  #In CLI: FILE, in SDK: INPUT_BLOB

DOCPART_IMPORT.ids               =#DOCPART_MID_ARR
DOCPART_IMPORT.warnings          =#Like API.*

                                  ┌────────────────────┐
                                  │   DOC IMPORT API   │
                                  └────────────────────┘

PUT /restapis/API_MID
 /documentation/parts            =#Req: RAW_DOCPART_IMPORT + IMPORT (query variables)
ImportDocumentationParts()        #Res: DOCPART_IMPORT

                                  ┌─────────────────┐
                                  │   DOC VERSION   │
                                  └─────────────────┘

DOCVERS                          =#Publish current DOCPARTs to a STAGE
                                  #Required to use DOCPARTs when importing|exporting to OpenAPI
DOCVERS_ARN                      =#arn:aws:apigateway:REGION::/restapis/API_MID/documentation/versions[/DOCVERS]
DOCVERS.version
OSPEC.x-amazon-apigateway-
 documentation.version           =#'DOCVERS'. Should be OINFO.version 'API_VERSION'
DOCVERS.description              =#STR
DOCVERS.createdDate
OSPEC.x-amazon-apigateway-
 documentation.createdDate       =#DATE_NUM

DOCVERS.stageName                =#'STAGE'. To match API_EXPORT.stageName
STAGE.documentationVersion       =#'DOCVERS'

                                  ┌─────────────────────┐
                                  │   DOC VERSION API   │
                                  └─────────────────────┘

POST /restapis/API_MID           =#Req: DOCVERS
 /documentation/versions          #  - no createdDate
CreateDocumentationVersion()      #  - version -> documentationVersion
                                  #  - only one with stageName
                                  #Res: DOCVERS
PATCH /restapis/API_MID
 /documentation/versions         =#Req: DOCVERS
 /DOCVERS_MID                     #  - only description
UpdateDocumentationVersion()      #Res: DOCVERS
GET /restapis/API_MID
 /documentation/versions         =#Req: empty
GetDocumentationVersions()        #Res: item DOCVERS_ARR
GET /restapis/API_MID
 /documentation/versions
 /DOCVERS_MID                    =#Req: empty
GetDocumentationVersion()         #Res: DOCVERS
DELETE /restapis/API_MID
 /documentation/versions
 /DOCVERS_MID                    =#Req: empty
DeleteDocumentationVersion()      #Res: empty

                                  ┌─────────────────────┐
                                  │   DOC VERSION IAC   │
                                  └─────────────────────┘

AWS::ApiGateway::
 DocumentationVersion            =#RESPROPs: RestApiId, Description, DocumentationVersion
AWS::ApiGateway::Stage           =#Includes RESPROPs: DocumentationVersion

CSTAGE_OPTS.documentationVersion =#STAGE.*

                                  ┌─────────┐
                                  │   SDK   │
                                  └─────────┘

RAW_SDK                          =#Auto-generated client library, as a .zip file
                                  #Based on ROUTE|RRESP.*
                                  #In CLI: FILE, in SDK: OUTPUT_BLOB

SDKTYPE.id                       =#SDKTYPE_MID
SDKTYPE.friendlyName             =#'SDKTYPE', among 'javascript', 'java', 'ruby', 'android' (Java), 'swift' (iOS), 'objectivec' (iOS)
SDKTYPE.description              =#STR

SDKTYPE_CONFVARS.SDKTYPE_CONFVAR =#'VAL'. SDKTYPE-specific configuration properties
SDKTYPE.configurationProperties  =#SDKTYPE_CONFVAR_ARR
SDKTYPE_CONFVAR.name             =#SDKTYPE_CONFVAR_MID
SDKTYPE_CONFVAR.friendlyName     =#'SDKTYPE_CONFVAR'
SDKTYPE_CONFVAR.description      =#STR
SDKTYPE_CONFVAR.required         =#BOOL
SDKTYPE_CONFVAR.defaultValue     =#'VAL'

JAVASCRIPT SDKTYPE_CONFVARs ==>  =#None
SDKTYPE_CONFVAR 'serviceName'    =#With java
SDKTYPE_CONFVAR 'javaPackageName'=#With java
SDKTYPE_CONFVAR 'buildSystem'    =#'maven|gradle'
                                  #With java
SDKTYPE_CONFVAR 'licenseText'    =#'LICENSE'
                                  #With java
SDKTYPE_CONFVAR 'groupId'        =#With java|android
SDKTYPE_CONFVAR 'artifactId'     =#With java|android
SDKTYPE_CONFVAR 'artifactVersion'=#With java|android
SDKTYPE_CONFVAR 'invokerPackage' =#With android
SDKTYPE_CONFVAR 'service.name'   =#With ruby
SDKTYPE_CONFVAR 'ruby.gem-name'  =#With ruby
SDKTYPE_CONFVAR
 'ruby.gem-version'              =#With ruby
SDKTYPE_CONFVAR 'classPrefix'    =#With swift|objectivec

new Client([OPTS])               =#JavaScript CLIENT
                                  #Other CLIENTs have similar capabilities
OPTS.accessKey                   =#ACCESS_KEY_ID
OPTS.secretKey                   =#SECRET_ACCESS_KEY
OPTS.apiKey                      =#X-Api-Key [C]

CLIENT.OPERATION_ID              =#PARAMS are for API-defined query variables, request headers, PATHVARs
 (PARAMS[, BODY[, OBJ]])->>RES   =#OBJ is { headers OBJ2, queryParams OBJ3 } for non-API-defined parameters

                                  ┌─────────────┐
                                  │   SDK API   │
                                  └─────────────┘

GET /sdktypes                    =#Req: empty
GetSdkTypes()                     #Res: item SDKTYPE_ARR
GET /sdktypes/SDKTYPE_MID        =#Req: empty
GetSdkType()                      #Res: SDKTYPE
GET /restapis/API_MID
 /stages/STAGE/sdks/SDKTYPE      =#Req: parameters SDKTYPE_CONFVARS
GetSdk()                          #Res: RAW_SDK

                                  ┌─────────────────┐
                                  │   DOMAIN NAME   │
                                  └─────────────────┘

DNAME                             #Custom domain name
                                  #Cannot be used with ENDPOINT.types 'PRIVATE'
                                  #Max 120 per REGION (soft)
DNAME_ARN                         #arn:aws:apigateway:REGION::/domainnames/DNAME
DNAME.domainName                  #'DNAME'

DNAME.domainNameConfigurations  -~#DDNAME_ARR

API.apiEndpoint                 -~#'API_MID.execute-api.amazonaws.com'
API.disableExecuteApiEndpoint
OSPEC2|OSERVER3
 .x-amazon-apigateway-
 endpoint-configuration
 .disableExecuteApiEndpoint       #BOOL (def: false). Do not allow API_MID.execute-api.amazonaws.com, i.e. must use DNAME instead

DNAME.domainName                 =
DDNAME.apiGatewayDomainName     -~#Custom domain name, e.g. 'example.com'
                                  #Must point to either DNAME.distributionDomainName or DNAME.regionalDomainName
DNAME.distributionDomainName     =#CloudFront domain name, e.g. 'DISTRIBUTION_MID.cloudfront.net'
                                  #Only with ENDPOINT.types 'EDGE'
DNAME.regionalDomainName         =#Regional domain name, e.g. 'API_MID.execute-api.REGION.amazonaws.com'
                                  #Only with ENDPOINT.types 'REGIONAL'
DDNAME.hostedZoneId             -~
DNAME.distributionHostedZoneId   =
DNAME.regionalHostedZoneId       =#Like *DomainName, but as Route53 ZONE_MID

DNAME|API.endpointConfiguration  =#ENDPOINT
ENDPOINT.types                   =#STR_ARR among:
                                  #  - 'EDGE' ("edge-optimized")
                                  #     - use edge location
                                  #     - has underlying CloudFront DISTRIBUTION
                                  #     - def if DNAME.certificateArn
                                  #  - 'REGIONAL':
                                  #     - use current REGION
                                  #     - no underlying CloudFront
                                  #     - goals:
                                  #        - faster when client is in same REGION
                                  #        - use own CloudFront instead of default one
                                  #     - def if DNAME.regionalCertificateArn
                                  #  - 'PRIVATE': use VPC
                                  #To set from 'PRIVATE' to 'EDGE', must set to 'REGIONAL' first
                                  #To set from|to 'EDGE' from|to 'REGIONAL', must set to ['EDGE', 'REGIONAL'] first
DDNAME.endpointType             -~#STR, like ENDPOINT.types, but always 'REGIONAL'

DNAME.domainNameStatus           =
DDNAME.domainNameStatus         -~#STR, among:
                                  #  - PENDING_CERTIFICATE_REIMPORT
                                  #  - PENDING_OWNERSHIP_VERIFICATION
                                  #  - UPDATING
                                  #  - AVAILABLE
DNAME.domainNameStatusMessage    =
DDNAME.domainNameStatusMessage  -~#STR

DNAME.tags                        #TAGS
                                 =#Inherited by children (ABAC-only): MAPPING

                                  ┌──────────────────────┐
                                  │   DOMAIN NAME AUTH   │
                                  └──────────────────────┘

COND_KEY DisableExecuteApiEndpoint#API.disableExecuteApiEndpoint. On Create|Update|Delete[Rest]Api()

COND_KEY EndpointType             #ENDPOINT.types. On Create|Update|Delete[Rest]Api|DomainName()

                                  ┌─────────────────────┐
                                  │   DOMAIN NAME API   │
                                  └─────────────────────┘

POST /domainnames                =#Req: DNAME
CreateDomainName()                #  - no regionalHostedZoneId, regionalDomainName, certificateUploadDate, domainNameStatus*, truststoreWarnings
                                  #Res: DNAME
PATCH /domainnames/DNAME         =#Req: DNAME
UpdateDomainName()                #  - no regionalHostedZoneId, regionalDomainName, certificateUploadDate, domainNameStatus*, truststoreWarnings
                                  #  - no domainName, distribution*, vpcEndpointIds, tags
                                  #  - op:add|remove, not op:replace: ENDPOINT.types
                                  #Res: DNAME
GET /domainnames                 =#Req: empty
GetDomainNames()                  #Res: item DNAME_ARR
GET /domainnames/DNAME           =#Req: empty
GetDomainName()                   #Res: DNAME
DELETE /domainnames/DNAME        =#Req: empty
DeleteDomainName()                #Res: empty

POST /v2/domainnames            -~#Req: DNAME
CreateDomainName()                #  - no apiMappingSelectionExpression, truststoreWarnings
                                  #Res: DNAME
PATCH /v2/domainnames/DNAME     -~#Req: DNAME
UpdateDomainName()                #  - no apiMappingSelectionExpression, truststoreWarnings
                                  #  - no domainName, tags
                                  #Res: DNAME
GET /v2/domainnames             -~#Req: empty
GetDomainNames()                  #Res: items DNAME_ARR
GET /v2/domainnames/DNAME       -~#Req: empty
GetDomainName()                   #Res: DNAME
DELETE /v2/domainnames/DNAME    -~#Req: empty
DeleteDomainName()                #Res: empty

                                  ┌─────────────────────┐
                                  │   DOMAIN NAME IAC   │
                                  └─────────────────────┘

AWS::ApiGateway::DomainName      =#RESPROPs: DomainName, EndpointConfiguration, Tags
                                  #RESATTRs: DistributionDomainName, RegionalDomainName, DistributionHostedZoneId, RegionalHostedZoneId
AWS::ApiGatewayV2::DomainName   -~#RESPROPs:
                                  #  - DomainName, Tags
                                  #  - DomainNameConfigurations OBJ_ARR: EndpointType
                                  #RESATTRs: RegionalDomainName, RegionalHostedZoneId
AWS::ApiGateway::RestApi         =#Includes RESPROPs: DisableExecuteApiEndpoint, EndpointConfiguration
AWS::ApiGatewayV2::Api          -~#Includes RESATTRs: ApiEndpoint, DisableExecuteApiEndpoint

new DomainName
 (...CARGS, CDNAME_OPTS)          #
DomainName
 .fromDomainNameAttributes
 (...CARGS, CDNAME_OPTS)
 ->ICDNAME                       =#CDNAME_OPTS: only domainName, domainNameAliasTarget, domainNameAliasHostedZoneId
DomainName
 .fromDomainNameAttributes
 (...CARGS, CDNAME_OPTS)
 ->ICDNAME                      -~#CDNAME_OPTS: only name, regionalDomainName, regionalHostedZoneId

ICDNAME[_OPTS].domainName        =
CDNAME_OPTS.domainName
ICDNAME.name                    -~#DNAME.domainName
ICDNAME.domainNameAliasDomainName=#STR[_CSATTR]. DNAME.distributionDomainName|regionalDomainName
ICDNAME.regionalDomainName      -~#DNAME.regionalDomainName
ICDNAME
 .domainNameAliasHostedZoneId    =#STR[_CSATTR]. DNAME.distributionHostedZoneId|regionalHostedZoneId
ICDNAME.regionalHostedZoneId    -~#DNAME.regionalHostedZoneId

CDNAME_OPTS.endpointType          #ENDPOINT.types[0] or DDNAME.endpointType (def: 'REGIONAL')
CDNAME.addEndpoint(CDNAME_OPTS) -~#Add new endpoint with different CDNAME_OPTS.endpointType
                                  #Only allow CDNAME_OPTS: endpointType, certificate, certificateName, securityPolicy, ownershipCertificate

ICAPI.apiEndpoint               -~#API.*

CAPI_OPTS
 .disableExecuteApiEndpoint      =
CAPI[_OPTS]
 .disableExecuteApiEndpoint      -#API.*

CAPI_OPTS.endpointConfiguration  =#CENDPOINT. API.endpointConfiguration
CAPI_OPTS|CENDPOINT.types        =#ENDPOINT.*

AWSSamples::ApiGateway
 ::CustomDomain::MODULE           #MODULE with a DNAME + MAPPING + Route53 RECORD_SET (IPv4|6, public|private)

                                  ┌────────────────────────┐
                                  │   DOMAIN NAME PULUMI   │
                                  └────────────────────────┘

apiGatewayEndpointType            #Pulumi POLICY enforcing ENDPOINT.types
                                  #Uses PPCONF.allowEdge|Regional|Private BOOL (def: false)

                                  ┌─────────────────┐
                                  │   PRIVATE API   │
                                  └─────────────────┘

ENDPOINT.types 'PRIVATE'         =#Access API through VPC
                                  #Min TLS 1.2

ENDPOINT.vpcEndpointIds
OSPEC2|OSERVER3
 .x-amazon-apigateway-
 endpoint-configuration
 .vpcEndpointIds                 =#VPC ENDPOINT_MID_ARR. Only if ENDPOINT.types 'PRIVATE'

INVOKE_URI                       =#Used by backend: https://VPC_MID.execute-api.REGION.vpce.amazonaws.com
                                  #Used by clients: https://API_MID-VPC_MID.execute-api.REGION.amazonaws.com

                                  ┌─────────────────────┐
                                  │   PRIVATE API IAC   │
                                  └─────────────────────┘

AWS::ApiGateway::RestApi         =#Includes RESPROPs: EndpointConfiguration: VpcEndpointIds

CENDPOINT.vpcEndpoints           =#ICVPC_ENDPOINT_ARR. ENDPOINT.vpcEndpointIds

                                  ┌─────────┐
                                  │   TLS   │
                                  └─────────┘

DNAME.certificateArn             =
DDNAME.certificateArn           -~#ACM certificate ARN, used for TLS
                                 =#Only with ENDPOINT.types 'EDGE'
                                  #  - certificate's REGION must be us-east-1
DNAME.certificateName            =
DDNAME.certificateName          -~#Same but as 'ACM_CERTIFICATE' name
DNAME.certificateUploadDate      =#DATE_NUM
DDNAME.certificateUploadDate    -~#'DATE'
DNAME.regionalCertificateArn|Name=#Same as certificateArn|Name but only with ENDPOINT.types 'REGIONAL'
                                  #Certificate's REGION must be the same REGION

DNAME.securityPolicy             =#'TLS_1_0|1_2' (def: none)
DDNAME.securityPolicy           -~#'TLS_1_2' (def: none)

DNAME.mutualTlsAuthentication     #DNAME_TLS. Require client TLS authentication
                                  #Only when accessed through DNAME, i.e. should consider using API.disableExecuteApiEndpoint true
                                  #Only with ENDPOINT.types 'REGIONAL'
DNAME_TLS.truststoreUri           #'s3://BUCKET/OBJECT' to truststore, that contains CAs
                                  #Must be *.pem file. Newline-separated list of X.509 certificates in PEM format
                                  #For whole CAs chain (max size for chain: 4)
                                  #Can be self-signed
                                  #Hash algorithms: at least SHA-256, RSA-2048 or ECDSA-256
DNAME_TLS.truststoreVersion       #VERSION_ID of S3 OBJECT
DNAME_TLS.truststoreWarnings      #'MESSAGE'_ARR. Warnings related to truststore

DNAME.ownership
 VerificationCertificateArn      =
DDNAME.ownership                -~#ACM certificate ARN, used for ownership verification
 VerificationCertificateArn       #Only needed when both:
                                  #  - using DNAME_TLS
                                  #  - DNAME.regionalCertificateArn's CA is either private, or using ACM

                                  ┌──────────────┐
                                  │   TLS AUTH   │
                                  └──────────────┘

PACTION apigateway:
 AddCertificateToDomain
 |RemoveCertificateFromDomain     #Required for D[D]NAME.certificateArn

COND_KEY SecurityPolicy           #D[D]NAME.securityPolicy. STR_ARR, on Create|Put|DeleteDomainName()

COND_KEY MtlsTrustStoreUri|Version#DNAME_TLS.*. STR, on Create|Update|DeleteDomainName()

                                  ┌─────────────┐
                                  │   TLS IAC   │
                                  └─────────────┘

AWS::ApiGateway::DomainName      =#Includes RESPROPs:
                                  #  - [Regional]CertificateArn, SecurityPolicy, OwnershipVerificationCertificateArn
                                  #  - MutualTlsAuthentication
                                  #     - no TruststoreWarnings
AWS::ApiGatewayV2::DomainName   -~#Includes RESPROPs: DomainNameConfigurations OBJ_ARR:
                                  #  - CertificateArn, CertificateName, SecurityPolicy, OwnershipVerificationCertificateArn
                                  #  - MutualTlsAuthentication
                                  #     - no TruststoreWarnings

CDNAME_OPTS.certificate           #ACM ICERTIFICATE. [D]DNAME.[regional]certificateArn
CDNAME_OPTS.certificateName     -~#DDNAME.*
CDNAME_OPTS.securityPolicy        #[D]DNAME.*

CDNAME_OPTS.mtls                  #CDNAME_TLS. DNAME.mutualTlsAuthentication
CDNAME_TLS.bucket                 #ICBUCKET. DNAME_TLS.truststoreUri
CDNAME_TLS.key                    #'OBJECT'. DNAME_TLS.truststoreUri
CDNAME_TLS.version                #DNAME_TLS.truststoreVersion

CDNAME_OPTS.ownershipCertificate-~#ACM ICERTIFICATE. DDNAME.*

                                  ┌────────────────────────┐
                                  │   CLIENT CERTIFICATE   │
                                  └────────────────────────┘

CCERTIFICATE                     =#TLS self-signed certificate used by HTTP requests sent by ROUTEs to backend
                                  #Allows backend to authenticate requests it receives from ROUTEs
                                  #Only useful when backend is public
                                  #Max 60 per ACCOUNT + REGION (soft)
CCERTIFICATE_ARN                 =#arn:aws:apigateway:REGION::/clientcertificates[/CCERTIFICATE_MID]
CCERTIFICATE.clientCertificateId =#CCERTIFICATE_MID
CCERTIFICATE.description         =#STR
CCERTIFICATE.createdDate         =#DATE_NUM
CCERTIFICATE.expirationDate      =#DATE_NUM
                                  #Valid for 1 year

CCERTIFICATE
 .pemEncodedCertificate          =#'PEM' of client certificate
                                  #Automatically created

STAGE.clientCertificateId       =~#CCERTIFICATE_MID. Use CCERTIFICATE in this STAGE

INVOKE_ROUTE_REQ
 .clientCertificateId            =#CCERTIFICATE_MID. For debugging

CCERTIFICATE.tags                =#TAGS

REQ_CONTEXT
 .authentication.clientCert
CONTEXT_IDENTITY.clientCert      =
REQ_IDENTITY0|1.clientCert        #REQ_CCERTIFICATE. CCERTIFICATE received in backend
REQ_CCERTIFICATE.clientCertPem    #CCERTIFICATE.pemEncodedCertificate
REQ_CCERTIFICATE.validity
 .notBefore|notAfter              #'DATE' of expiration
REQ_CCERTIFICATE.subjectDN        #'DOMAIN' of user
REQ_CCERTIFICATE.issuerDN         #'DOMAIN' of issuer
REQ_CCERTIFICATE.serialNumber     #'XX:...:XX'

                                  ┌────────────────────────────┐
                                  │   CLIENT CERTIFICATE API   │
                                  └────────────────────────────┘

POST /clientcertificates         =#Req: CCERTIFICATE
GenerateClientCertificate()       #  - no clientCertificateId, createdDate, expirationDate, pemEncodedCertificate
                                  #Res: CCERTIFICATE
PATCH /clientcertificates        =#Req: CCERTIFICATE
 /CCERTIFICATE_MID                #  - no clientCertificateId, createdDate, expirationDate, pemEncodedCertificate, tags
UpdateClientCertificate()         #Res: CCERTIFICATE
GET /clientcertificates          =#Req: empty
GetClientCertificates()           #Res: item CCERTIFICATE_ARR
GET /clientcertificates
 /CCERTIFICATE_MID               =#Req: empty
GetClientCertificate()            #Res: CCERTIFICATE
DELETE /clientcertificates
 /CCERTIFICATE_MID               =#Req: empty
DeleteClientCertificate()         #Res: empty

                                  ┌────────────────────────────┐
                                  │   CLIENT CERTIFICATE IAC   │
                                  └────────────────────────────┘

AWS::ApiGateway::                =#RESPROPs: Description, Tags
 ClientCertificate                #RESATTRs: ClientCertificateId
AWS::ApiGateway::Stage           =#Includes RESPROPs: ClientCertificateId
AWS::ApiGatewayV2::Stage         ~#Includes RESPROPs: ClientCertificateId

CSTAGE_OPTS.clientCertificateId  =#STAGE.*

                                  ┌─────────────────────────────┐
                                  │   CLIENT CERTIFICATE LINT   │
                                  └─────────────────────────────┘

cdk-nag APIGWSSLEnabled         =~#Validate STAGE.clientCertificateId is set

                                  ┌─────────────┐
                                  │   MAPPING   │
                                  └─────────────┘

MAPPING                           #Make a given DNAME/BASEPATH use a specific API + STAGE
                                  #Can map same DNAME to multiple APIs (with different BASEPATHs),
                                =-#  - including from different versions (v1|v2, but not WebSocket)
                                  #Must all be in same ACCOUNT
                                  #If API uses ENDPOINT.types 'REGIONAL', securityPolicy must be 'TLS_1_2'
                                  #Max 200 per DNAME
MAPPING_ARN                      =#arn:aws:apigateway:REGION::/domainnames/DNAME/basepathmappings[/BASEPATH]
MAPPING_ARN                     -~#arn:aws:apigateway:REGION::/domainnames/DNAME/apimappings[/MAPPING_MID]
MAPPING.apiMappingId            -~#MAPPING_MID

MAPPING.basePath                 =
MAPPING.apiMappingKey           -~#'BASEPATH'. Can be '(none)'
                                  #Max 300 chars, [[:alnum:]$-_.+!*'()/]
                                  #Cannot start|end with / nor contain consecutive //
                                -~#Can use subdirectories
                                  #  - only if using ENDPOINT.types 'REGIONAL'
                                -~#Can use multiple MAPPINGs with BASEPATHs with common parent directories
                                  #  - e.g. 'a/b' and 'a/c', or 'a' and 'a/b', or '(none)' and 'a'
                                  #Can be a prefix (as opposed to exact match) for the last path part
                                  #  - but only if some MAPPINGs use subdirectories
                                  #  - e.g. 'a' matches 'ab', but only if annother MAPPING uses subdirectories
DNAME
 .apiMappingSelectionExpression -~#Always '$request.basepath'
ACONTEXT
 .customDomain.basePathMatched  =-#'/BASEPATH'

MAPPING.restApiId                =
MAPPING.apiId                   -~#API_MID
MAPPING.stage                     #'STAGE'

                                  ┌─────────────────┐
                                  │   MAPPING API   │
                                  └─────────────────┘

POST /domainnames/DNAME
 /basepathmappings               =#Req: MAPPING
CreateBasePathMapping()           #Res: MAPPING
PATCH /domainnames/DNAME
 /basepathmappings/BASEPATH      =#Req: MAPPING
UpdateBasePathMapping()           #Res: MAPPING
GET /domainnames/DNAME
 /basepathmappings               =#Req: empty
GetBasePathMappings()             #Res: item MAPPING_ARR
GET /domainnames/DNAME
 /basepathmappings/BASEPATH      =#Req: empty
GetBasePathMapping()              #Res: MAPPING
DELETE /domainnames/DNAME
 /basepathmappings/BASEPATH      =#Req: empty
DeleteBasePathMapping()           #Res: empty

POST /v2/domainnames/DNAME      -~#Req: MAPPING
 /apimappings                     #  - no apiMappingId
CreateApiMapping()                #Res: MAPPING
PATCH /v2/domainnames/DNAME     -~#Req: MAPPING
 /apimappings/MAPPING_MID         #  - no apiMappingId
UpdateApiMapping()                #Res: MAPPING
GET /v2/domainnames/DNAME
 /apimappings                   -~#Req: empty
GetApiMappings()                  #Res: item MAPPING_ARR
GET /v2/domainnames/DNAME
 /apimappings/MAPPING_MID       -~#Req: empty
GetApiMapping()                   #Res: MAPPING
DELETE /v2/domainnames/DNAME
 /apimappings/MAPPING_MID       -~#Req: empty
DeleteApiMapping()                #Res: empty

                                  ┌─────────────────┐
                                  │   MAPPING IAC   │
                                  └─────────────────┘

AWS::ApiGateway::BasePathMapping =#RESPROPs: DomainName, BasePath, RestApiId, Stage
AWS::ApiGatewayV2::ApiMapping   -~#RESPROPs: DomainName, ApiMappingKey, ApiId, Stage
                                  #RESATTRs: ApiMappingId
                                  #Should DependsOn Stage

new BasePathMapping
 (...CARGS, CMAPPING_OPTS)       =#
new ApiMapping
 (...CARGS, CMAPPING_OPTS)      -~#
ApiMapping
 .fromApiMappingAttributes
 (...CARGS, CMAPPING_OPTS)      -~#CMAPPING_OPTS: apiMappingId

CMAPPING_OPTS.domainName          #ICDNAME
CMAPPING.domainName             -~#ICDNAME

ICMAPPING.apiMappingId          -~#MAPPING.*

CMAPPING_OPTS.basePath           =
CMAPPING_OPTS.apiMappingKey
CMAPPING.mappingKey             -~#MAPPING.*

CMAPPING_OPTS.restApi            =#ICAPI. MAPPING.restApiId
CMAPPING_OPTS.api               -~#ICAPI. MAPPING.apiId

CMAPPING_OPTS.stage              =#CSTAGE. MAPPING.*
CMAPPING_OPTS.attachToStage      =#BOOL (def: true). Make CMAPPING_OPTS.stage default to ICAPI.deploymentStage
CMAPPING_OPTS.stage             -~#ICSTAGE (def: ICAPI.defaultStage). MAPPING.*

CDNAME.addBasePathMapping
 (ICAPI[, CMAPPING_OPTS])
 ->CMAPPING                      =#Creates a MAPPING with this DNAME
CDNAME.addApiMapping
 (ICSTAGE[, CMAPPING_OPTS])      =#Same but using ApiMapping (v2) instead
 ->CMAPPING                       #CMAPPING_OPTS: only basePath
CDNAME_OPTS.mapping              =#ICAPI. Calls CDNAME.addBasePathMapping()
                                  #If contains subdirectories, calls CDNAME.addApiMapping() instead
CDNAME_OPTS.basePath             =#MAPPING.basePath when using CDNAME_OPTS.mapping

CSTAGE_OPTS.domainMapping       -~#CMAPPING_OPTS: domainName, mappingKey
                                  #Like new ApiMapping() but automatically sets CMAPPING_OPTS.api|stage
CAPI_OPTS.defaultDomainMapping   -#Same but for CAPI.defaultStage
CSTAGE.domainUrl                 -#'https://DNAME[/BASEPATH]'
                                  #Requires CSTAGE_OPTS.domainMapping

ICAPI[_OPTS].domainName          =#CDNAME_OPTS. Creates new CDNAME + MAPPING (through CDNAME_OPTS.mapping)
ICAPI.addDomainName
 ('CONSTRUCT', CDNAME_OPTS)
 ->CDNAME                        =#Same

                                  ┌─────────────────────┐
                                  │   USAGE PLAN MAIN   │
                                  └─────────────────────┘

USAGEPLAN                        =#Limit number of requests made to a given API[s] + STAGE[s] by a given client
                                  #Max 300 per ACCOUNT + REGION (soft)
USAGEPLAN_ARN                    =#arn:aws:apigateway:REGION::/usageplans[/USAGEPLAN_MID]
USAGEPLAN.id                     =#USAGEPLAN_MID
USAGEPLAN.name                   =#'USAGEPLAN'
USAGEPLAN.description            =#STR

USAGEPLAN.apiStages              =#API_STAGE_ARR
API_STAGE.apiId                  =#API_MID
API_STAGE.stage                  =#'STAGE'

ACCOUNT.features                 =#STR_ARR. Must include 'UsagePlans' to enable USAGEPLAN, but only for APIs created before 2016

USAGEPLAN.tags                   =#TAGS
                                  #Inherited by children (ABAC-only): USAGEKEY

                                  ┌─────────────────────────┐
                                  │   USAGE PLAN MAIN API   │
                                  └─────────────────────────┘

POST /usageplans                 =#Req: USAGEPLAN
CreateUsagePlan()                 #  - no id, productCode
                                  #Res: USAGEPLAN
PATCH /usageplans/USAGEPLAN_MID  =#Req: USAGEPLAN
UpdateUsagePlan()                 #  - no id, tags
                                  #  - can use op:remove: quota, throttle, API_STAGE.throttle.HTTP_METHOD
                                  #  - apiStages.NUM -> /apiStages/STAGE
                                  #Res: USAGEPLAN
GET /usageplans                  =#Req: USAGEPLAN
GetUsagePlans()                   #  - only keyId, only one with it
                                  #Res: item USAGEPLAN_ARR
GET /usageplans/USAGEPLAN_MID    =#Req: empty
GetUsagePlan()                    #Res: USAGEPLAN
DELETE /usageplans/USAGEPLAN_MID =#Req: empty
DeleteUsagePlan()                 #Res: empty

                                  ┌─────────────────────────┐
                                  │   USAGE PLAN MAIN IAC   │
                                  └─────────────────────────┘

AWS::ApiGateway::UsagePlan       =#RESPROPs: UsagePlanName, Description, ApiStages, Tags
                                  #RESATTRs: Id

new UsagePlan
 (...CARGS, CUSAGEPLAN_OPTS)     =#CUSAGEPLAN
UsagePlan.fromUsagePlanId
 (...CARGS, 'USAGEPLAN_MID')
 ->ICUSAGEPLAN                   =#
ICAPI.addUsagePlan
 ('CONSTRUCT'[, CUSAGEPLAN_OPTS])
 ->CUSAGEPLAN                    =#

ICUSAGEPLAN.usagePlanId          =#CFNREF_STR_TK. USAGEPLAN.id
CUSAGEPLAN_OPTS.name|description =#USAGEPLAN.*

CUSAGEPLAN_OPTS.apiStages        =#CAPI_STAGE_ARR. USAGEPLAN.apiStages
CAPI_STAGE.api                   =#ICAPI. API_STAGE.apiId
CAPI_STAGE.stage                 =#CSTAGE. API_STAGE.stage

                                  ┌──────────────┐
                                  │   THROTTLE   │
                                  └──────────────┘

ACCOUNT.throttleSettings         =#THROTTLE. 429 if throttled
                                  #For that ACCOUNT + REGION. For all APIs and clients
                                  #Uses token bucket algorithm:
                                  #  - NUM2-- on each request
                                  #     - except if 0: throttled
                                  #  - NUM2++ every 1/NUM second
                                  #     - except if full
THROTTLE.rateLimit                #Max average rate of NUM requests per second
                                  #1e4 (soft)
THROTTLE.burstLimit               #Max NUM2 of requests > rateLimit, accumulated over time, decreased when < rateLimit
                                  #I.e. allowed burst over average rate
                                  #5e3 (soft)

ROUTE_SETTINGS                    #Like THROTTLE.*, but only for that API + STAGE + ROUTE. For all APIs and clients
 .throttlingRate|BurstLimit       #Def: only limited by ACCOUNT.throttleSettings

USAGEPLAN.throttle                #THROTTLE, for this client + API + STAGE
API_STAGE.throttle               =#THROTTLE, for this client + API + STAGE + HTTP_METHOD + /PATH
 ./PATH/HTTP_METHOD               #Max 20 per ACCOUNT + REGION (soft)

USAGEPLAN.quota                  =#QUOTA. 429 if quota exceeded
                                  #Unlike THROTTLE:
                                  #  - longer period
                                  #  - normal rate limiting, not token bucket algorithm
                                  #  - meant for pricing purpose, not for performance|resilience
QUOTA.limit                      =#Max NUM of requests per QUOTA.period
QUOTA.period                     =#'DAY|WEEK|MONTH'
QUOTA.offset                     =#NUM (def: 0) of requests to substract in the first QUOTA.period

                                  ┌──────────────────┐
                                  │   THROTTLE IAC   │
                                  └──────────────────┘

AWS::ApiGateway::Stage           =#Includes RESPROPs: MethodsSettings OBJ_ARR: ThrottlingRate, ThrottlingBurstLimit
AWS::ApiGatewayV2::Stage        -~#Includes RESPROPs: DefaultRouteSettings|RouteSettings.ROUTE: ThrottlingRate, ThrottlingBurstLimit
AWS::ApiGateway::UsagePlan       =#Includes RESPROPs: Throttle, Quota, ApiStages OBJ_ARR: Throttle

CSTAGE_OPTS
 [.methodOptions./PATH/HTTP_METOD]
 .throttlingRateLimit|BurstLimit  =#STAGE.methodSettings./PATH/HTTP_METHOD.*
CSTAGE_OPTS.throttle
 .rateLimit|burstLimit           -~#STAGE.defaultRouteSettings.throttling*

CUSAGEPLAN_OPTS.throttle|quota   =#USAGEPLAN.*
CAPI_STAGE.throttle              =#OBJ_ARR: method CROUTE, throttle THROTTLE
                                  #API_STAGE.throttle./PATH/HTTP_METHOD

                                  ┌───────────────────┐
                                  │   THROTTLE LINT   │
                                  └───────────────────┘

cfn-lint-serverless
 aws_apigateway[v2]
 _stage_throttling_rule
 (ES2003)                         #ROUTE_SETTINGS.throttlingRate|BurstLimit must be set

                                  ┌────────────────────┐
                                  │   USAGE PLAN KEY   │
                                  └────────────────────┘

USAGEKEY                         =#APIKEY used to enable a USAGEPLAN
                                  #Max 10 USAGEPLAN per APIKEY (soft)
USAGEKEY_ARN                     =#arn:aws:apigateway:REGION::/usageplans/USAGEPLAN_MID/keys[/USAGEKEY_MID]
USAGEKEY.id                      =#USAGEKEY_MID
USAGEKEY.name                    =#'USAGEKEY'

USAGEPLAN.keyId                  =#USAGEKEY_MID
USAGEKEY.usagePlanId             =#USAGEPLAN_MID

USAGEKEY.type                    =#Always 'API_KEY'
USAGEKEY.value                   =#'APIKEY_VAL'

                                  ┌────────────────────────┐
                                  │   USAGE PLAN KEY API   │
                                  └────────────────────────┘

POST /usageplans/USAGEPLAN_MID   =#Req: USAGEKEY
 /keys                            #  - only id|type -> keyId|keyType
CreateUsagePlanKey()              #Res: USAGEKEY
GET /usageplans/USAGEPLAN_MID    =#Req: USAGEKEY
 /keys                            #  - only name -> nameQuery
                                  #  - only one with usagePlanId
GetUsagePlanKeys()                #Res: item USAGEKEY_ARR
GET /usageplans/USAGEPLAN_MID
 /keys/USAGEKEY_MID              =#Req: empty
GetUsagePlanKey()                 #Res: USAGEKEY
DELETE /usageplans/USAGEPLAN_MID
 /keys/USAGEKEY_MID              =#Req: empty
DeleteUsagePlanKey()              #Res: empty

                                  ┌────────────────────────┐
                                  │   USAGE PLAN KEY IAC   │
                                  └────────────────────────┘

AWS::ApiGateway::UsagePlanKey    =#RESPROPs: UsagePlanId, KeyId, KeyType
                                  #RESATTRs: Id
                                  #Cannot update (replace only)

ICUSAGEPLAN.addApiKey
 (ICAPIKEY[, OPTS])              =#Add a USAGEKEY
FFLAG @aws-cdk/aws-apigateway:   =#BOOL (def|recommended: true)
 usagePlanKeyOrderInsensitiveId   #Appends ICAPIKEY_CID to USAGEKEY's NODE.id
                                  #This fixes a previous bug
OPTS.overrideLogicalId           =#USAGEKEY_'LID' (def: auto)

new RateLimitedApiKey
 (...CARGS, CFULL_USAGEKEY_OPTS) =#ICAPIKEY + CUSAGEPLAN + USAGEKEY
CFULL_USAGEKEY_OPTS.*            =#CAPIKEY_OPTS.*
CFULL_USAGEKEY.*                 =#ICAPIKEY.*
CFULL_USAGEKEY_OPTS
 .apiStages|throttle|quota       =#CUSAGEPLAN_OPTS.*

                                  ┌──────────────────────┐
                                  │   USAGE PLAN COUNT   │
                                  └──────────────────────┘

USAGECOUNT.usagePlanId           =#USAGEPLAN_MID
USAGECOUNT.keyId                 =#USAGEKEY_MID
USAGECOUNT.startDate|endDate     =#'DATE'
USAGECOUNT.values.APIKEY         =#[NUM, NUM2]_ARR, with NUM being used quota, NUM2 remaining quota

                                  ┌──────────────────────────┐
                                  │   USAGE PLAN COUNT API   │
                                  └──────────────────────────┘

PATCH /usageplans/USAGEPLAN_MID  =#Req: USAGEPLAN
 /keys/USAGEKEY_MID/usage         #  - only values.USAGE_KEY_VAL[0][1] -> remaining
UpdateUsage()                     #Res: USAGEPLAN
GET /usageplans/USAGEPLAN_MID    =#Req: USAGEPLAN
 /usage                           #  - only one with keyId
GetUsage()                        #Res: USAGEPLAN

                                  ┌──────────────────┐
                                  │   API KEY MAIN   │
                                  └──────────────────┘

APIKEY                           =#API key used for request authentication
                                  #Intended for USAGEPLANs only, documentation discourages using it for general authentication of the API
                                  #1 APIKEY can be used in several USAGEPLANs, unless they target the same API + STAGE
                                  #Max 1e4 per ACCOUNT + REGION
APIKEY_ARN                       =#arn:aws:apigateway:REGION::/apikeys[/APIKEY_MID]
APIKEY.id                        =#APIKEY_MID
APIKEY.name                      =#'APIKEY' (def: random). Max 1KB
APIKEY.description               =#STR
APIKEY.enabled                   =#BOOL (def: true)
APIKEY.createdDate               =#DATE_NUM
APIKEY.lastUpdatedDate           =#DATE_NUM

APIKEY.value                     =#'APIKEY_VAL'. Min 30 chars, max 128, [:alnum:], must be unique
                                  #Def: random

APIKEY.stageKeys                 =#'API_MID/STAGE'_ARR. Only enables for those API|STAGEs
                                  #Prefer USAGEPLAN.apiStages instead

OSPEC.x-amazon-apigateway-
 api-key-source
API.apiKeySource                 =#STR. Where APIKEY is located among:
                                  #  - 'HEADER': X-Api-Key [C] (def)
                                  #  - 'AUTHORIZER': ARES.usageIdentifierKey
API.apiKeySelectionExpression    ~#Same but named either:
                                  #  - '$request.header.x-api-key' (def)
                                  #  - '$context.authorizer.usageIdentifierKey'
ROUTE_SUMMARY.apiKeyRequired     =
ROUTE.apiKeyRequired            =~#BOOL (def: false). Requires requests to have an APIKEY

ACCOUNT.apiKeyVersion            =#STR

APIKEY.tags                      =#TAGS

AREQ                              #'APIKEY_VAL', when using apiKeySource 'HEADER'
 .requestContext.identity.apiKey  #Only with AUTH_TYPE 'REQUEST'
CONTEXT_IDENTITY.apiKey         =~#'APIKEY_VAL'
ARES.usageIdentifierKey           #'APIKEY_MID', when using apiKeySource 'AUTHORIZER'
CONTEXT_IDENTITY.apiKeyId       =~#'APIKEY_MID'

                                  ┌───────────────────────┐
                                  │   API KEY MAIN AUTH   │
                                  └───────────────────────┘

COND_KEY ApiKeyRequired           #ROUTE.apiKeyRequired. BOOL, on Create|Put|DeleteMethod(), on ROUTE
                                  #Also BOOL_ARR on [Re]Import[Rest]Api(), on API

                                  ┌──────────────────────┐
                                  │   API KEY MAIN API   │
                                  └──────────────────────┘

POST /apikeys                    =#Req: APIKEY
CreateApiKey()                    #  - no id, createdDate, lastUpdatedDate
                                  #  - stageKeys 'API_MID/STAGE'_ARR -> ARR of { restApiId API_MID, stageName 'STAGE' }
                                  #Res: APIKEY
PATCH /apikeys/APIKEY_MID        =#Req: APIKEY
UpdateApiKey()                    #  - no id, createdDate, lastUpdatedDate, value
                                  #  - tags -> labels
                                  #Res: APIKEY
GET /apikeys                     =#Req: APIKEY
GetApiKeys()                      #  - only name -> nameQuery, value STR -> includeValues BOOL, customerId
                                  #Res: item APIKEY_ARR
GET /apikeys/APIKEY_MID          =#Req: APIKEY
GetApiKey()                       #  - only value STR -> includeValue BOOL
                                  #Res: APIKEY
DELETE /apikeys/APIKEY_MID       =#Req: empty
DeleteApiKey()                    #Res: empty

                                  ┌──────────────────────┐
                                  │   API KEY MAIN IAC   │
                                  └──────────────────────┘

AWS::ApiGateway::ApiKey          =#RESPROPs:
                                  #  - Name, Description, Enabled, Value, Tags
                                  #  - StageKeys OBJ_ARR: RestApiId 'API_MID', StageName 'STAGE'
                                  #RESATTRs: ApiKeyId
AWS::ApiGateway::RestApi         =#Includes RESPROPs: ApiKeySourceType
AWS::ApiGatewayV2::Api           ~#Includes RESPROPs: ApiKeySelectionExpression
AWS::ApiGateway::Method          =#Includes RESPROPs: ApiKeyRequired
AWS::ApiGatewayV2::Route         ~#Includes RESPROPs: ApiKeyRequired

new ApiKey
 (...CARGS, CAPIKEY_OPTS)        =#CAPIKEY
ApiKey.fromApiKeyId
 (...CARGS, APIKEY_MID)->ICAPIKEY=#
ICAPI|ICSTAGE.addApiKey
 ('CONSTRUCT'[, CAPIKEY_OPTS])
 ->CAPIKEY                       =#Automatically sets CAPIKEY_OPTS.stages

ICAPIKEY.keyArn                  =#'APIKEY_ARN'
ICAPIKEY.keyId                   =#CFNREF_STR_TK. APIKEY.id
CAPIKEY_OPTS.apiKeyName          =#APIKEY.name
CAPIKEY_OPTS.description|enabled
 |value                          =#APIKEY.*

CAPIKEY_OPTS.stages              =#ICSTAGE_ARR. APIKEY.stageKeys
CAPIKEY_OPTS.resources           =#ICAPI_ARR. Alternative for APIKEY.stageKeys

CAPIKEY.grantRead
 (YGRANTABLE)->CGRANT            =#Allows 'apigateway:GET'
CAPIKEY.grantWrite
 (YGRANTABLE)->CGRANT            =#Allows 'apigateway:POST|PUT|PATCH|DELETE'
CAPIKEY.grantReadWrite
 (YGRANTABLE)->CGRANT            =#grantRead() + grantWrite()

CAPI_OPTS.apiKeySourceType       =#API.apiKeySource

CAPI_OPTS                        ~#API.apiKeySelectionExpression among:
 .apiKeySelectionExpression       #  - WebSocketApiKeySelectionExpression.HEADER_X_API_KEY: '$request.header.x-api-key'
                                  #  - WebSocketApiKeySelectionExpression.AUTHORIZER_USAGE_IDENTIFIER_KEY: '$context.authorizer.usageIdentifierKey'
                                  #  - new WebSocketApiKeySelectionExpression(STR)

CROUTE_OOPTS.apiKeyRequired      =
CROUTE_OPTS.apiKeyRequired       ~#ROUTE.*

                                  ┌────────────────────┐
                                  │   API KEY IMPORT   │
                                  └────────────────────┘

RAW_APIKEY_IMPORT                =#APIKEY in CSV format
                                  #Must have header, case-insensitive, any order
                                  #Columns: name 'API_KEY', key APIKEY_MID, enabled BOOL, usagePlanIds 'USAGEPLAN_MID,...'
                                  #In CLI: FILE, in SDK: INPUT_BLOB

APIKEY_IMPORT.format             =#Always 'csv'

APIKEY_IMPORT.ids                =#APIKEY_MID_ARR
APIKEY_IMPORT.warnings           =#Like API.*

                                  ┌────────────────────────┐
                                  │   API KEY IMPORT API   │
                                  └────────────────────────┘

POST /apikeys?mode=import        =#Req: RAW_APIKEY_IMPORT + [APIKEY_]IMPORT (query variables)
ImportApiKeys()                   #  - no mode
                                  #Res: APIKEY_IMPORT

                                  ┌─────────────────┐
                                  │   MARKETPLACE   │
                                  └─────────────────┘

USAGEPLAN.productCode            =#PRODUCT_MID. When distributing USAGEPLAN on AWS Marketplace

METRICS ==>                      =#Must send usage metrics to AWS Marketplace with type 'requests' and dimension 'apigateway'

POST SUBSCRIPTION_URL            =#Webhook called on new subscription from AWS Marketplace
                                  #SUBSCRIPTION_URL is set when registering on AWS Marketplace
                                  #Contains x-amzn-marketplace-token [C]

SNS_TOPIC subscribe-success      =#Called on subscription success
                                  #Should create an APIKEY (with customerId) and USAGEKEY
APIKEY.customerId                =#CUSTOMER_MID, from AWS Marketplace

SNS_TOPIC unsubscribe-success    =#Called on subscription deletion

                                  ┌──────────────────────┐
                                  │   MARKETPLACE AUTH   │
                                  └──────────────────────┘

PERMISSIONS ==>                  =#Must create a ROLE ApiGatewayMarketplaceMeteringRole:
                                  #  - allowing aws-marketplace:BatchMeterUsage|ResolveCustomer
                                  #  - assumed by Service.Principal 'apigateway.amazonaws.com'

                                  ┌─────────────────────┐
                                  │   MARKETPLACE IAC   │
                                  └─────────────────────┘

AWS::ApiGateway::ApiKey          =#Includes RESPROPs: CustomerId

CAPIKEY_OPTS.customerId          =#APIKEY.*

                                  ┌──────────────────────────┐
                                  │   WEBSOCKET CONNECTION   │
                                  └──────────────────────────┘

CONNECTION                       ~#WebSocket connection
                                  #Max 500 new connections per second per ACCOUNT + REGION (for all APIs) (soft) (burst of 500)
                                  #Timeout: 10m if idle, 2h if not

REQ_CONTEXT0|CONTEXT.connectionId~#CONNECTION_MID
                                  #Only passed in '$connect' ROUTE
CONNECTION.ConnectedAt
CONTEXT.connectedAt              ~#'DATE'
REQ_CONTEXT0.connectedAt         ~#DATE_NUM
CONNECTION.LastActiveAt          ~#'DATE'

CONNECTION.Identity.SourceIp     ~#'IP'
CONNECTION.Identity.UserAgent    ~#STR

ROUTE '$connect'                 ~#Special ROUTE called on WebSocket successful connection by client
                                  #Only ROUTE which can use authentication|authorization features
ROUTE '$disconnect'              ~#Special ROUTE called on WebSocket disconnection by client|server
                                  #Since connection might already closed, response might not be received
CONTEXT|REQ_CONTEXT0.eventType   ~#'CONNECT|DISCONNECT|MESSAGE'

                                  ┌───────────────────────────────┐
                                  │   WEBSOCKET CONNECTION AUTH   │
                                  └───────────────────────────────┘

PACTION
 execute-api:ManageConnections   ~#Required to use CONNECTION

                                  ┌──────────────────────────────┐
                                  │   WEBSOCKET CONNECTION API   │
                                  └──────────────────────────────┘

GET /@connections/CONNECTION_MID ~#Req: empty
GetConnection()                   #Res: CONNECTION
DELETE
 /@connections/CONNECTION_MID    ~#Req: empty
DeleteConnection()                #Res: empty
                                  #Disconnect

                                  ┌───────────────────────┐
                                  │   WEBSOCKET MESSAGE   │
                                  └───────────────────────┘

WS_MESSAGE                       ~#Push message from server to client
                                  #In CLI: FILE, in SDK: INPUT_BLOB

CONTEXT.messageId                ~#Unique ID for a given request or push message
REQ_CONTEXT0.messageDirection    ~#'IN|OUT'

                                  ┌───────────────────────────┐
                                  │   WEBSOCKET MESSAGE API   │
                                  └───────────────────────────┘

POST
 /@connections/CONNECTION_MID    ~#Req: WS_MESSAGE
PostToConnection()                #Res: empty

                                  ┌──────────────────────────────────┐
                                  │   WEBSOCKET MESSAGE MIDDLEWARE   │
                                  └──────────────────────────────────┘

@middy/ws-response                #Version: part of Middy (see its doc)

WS-RESPONSE([OPTS])->MIDDY_MDWR   #Calls PostToConnection()
                                  #Calls it once, then sends empty 200
                                  #Done in 'after' STEP

RES[.Data]                        #WS_MESSAGE
RES.ConnectionId                  #'CONNECTION_MID'
                                  #Def: REQ.requestContext.connectionId (if none, noop)

OPTS.awsClient*|disablePrefetch   #See Middy doc
OPTS.awsClientOptions.endpoint    #Def: 'https://DNAME/STAGE' using REQ.requestContext.domainName|stage

                                  ┌─────────────┐
                                  │   ACCOUNT   │
                                  └─────────────┘

ACCOUNT                          =#One per REGION + ACCOUNT
ACCOUNT_ARN                      =#arn:aws:apigateway:REGION::/account

                                  ┌─────────────────┐
                                  │   ACCOUNT API   │
                                  └─────────────────┘

PATCH /account                   =#Req: ACCOUNT
UpdateAccount()                   #  - no apiKeyVersion, throttleSettings
                                  #Res: ACCOUNT
GET /account                     =#Req: empty
GetAccount()                      #Res: ACCOUNT

                                  ┌─────────────────┐
                                  │   ACCOUNT IAC   │
                                  └─────────────────┘

AWS::ApiGateway::Account         =#RESATTRs: Id ACCOUNT_ID
                                  #Cannot list

                                  ┌──────────┐
                                  │   TAGS   │
                                  └──────────┘

RESOURCE                          #Any resource of API Gateway that has a `tags` property
RESOURCE.tags                     #TAGS
OTAG
 .x-amazon-apigateway-tag-value =-#'TAG' (def: '')

TAGS_ARN                          #arn:aws:apigateway:REGION::/tags/RESOURCE_ARN
                                  #RESOURCE_ARN must be URL-encoded

                                  ┌──────────────┐
                                  │   TAGS API   │
                                  └──────────────┘

PUT /tags/ARN                    =#Req: RESOURCE
TagResource()                     #Res: empty
GET /tags/ARN                    =#Req: empty
GetTags()                         #Res: RESOURCE
DELETE /tags/ARN                 =#Req: RESOURCE
UntagResource()                   #  - tags TAGS -> tagKeys 'TAG'_ARR
                                  #Res: empty

POST /v2/tags/ARN               -~#Req: RESOURCE
TagResource()                     #Res: empty
GET /v2/tags/ARN                -~#Req: empty
GetTags()                         #Res: RESOURCE
DELETE /v2/tags/ARN             -~#Req: RESOURCE
UntagResource()                   #  - tags TAGS -> tagKeys 'TAG'_ARR
                                  #Res: empty
