
                                  ┏━━━━━━━━━━━━┓
                                  ┃   OPENGL   ┃
                                  ┗━━━━━━━━━━━━┛

GENERAL :
OpenGL n'est pas une bibliothèque mais une spécification, qui a plusieurs implémentations. La principale implémentation open-source est mesa3d
OpenGL ne traite pas des intéractions souris/clavier, des windows, etc.

GLU est une library utilisant des fonctions OpenGL permettant un degré d'abstraction supérieur, tout aussi libre et cross-platform.

Il faut donc un niveau supérieur pour cela, parmi lesquels on peut utiliser des solutions propres à chaque plateforme :
 - GLX (X11)
 - WGL (W$)
 - CGL (OSX)
ou cross-plateforme :
 - glut (proprio et plus maintenu)
 - SDL
 - freeglut
 - SFML

paquets / Headers / Librairies :
 - OpenGL (mesa) : libgl1-mesa, libgl1-mesa-dev et libgl1-mesa-dri (accélération hardware) / <GL/gl.h> / libGL.so (pointe vers mesa/libGL.so pour moi), et xorg/modules/extensions/libdri.so et xorg/modules/extensions/libdri2.so pour l'accélération hardware
 - GLU (mesa) : libglu1-mesa et libglu1-mesa-dev / <GL/glu.h> / libGLU.so
 - GLUT : glutg3-dev et libglut3-dev / <GL/glut.h> / libglut.so
 - freeGLUT : freeglut3 et freeglut3-dev / <GL/freeglut.h>
 - GLX : libgl1-mesa-glx / <GL/glx.h> / xorg/modules/extensions/libglx.so

Savoir si accélération hardware activée : glxinfo | grep rendering
Voir si OpenGL marche : glxgears

Ma version : doit supporter OpenGL 2.1 (on en est déjà à 4.0...), mais m'affiche 1.4 car qq fonctions 2.1 peuvent manquer

METATEXTURES ==>        #Plusieurs textures concaténées dans une seule image. Comme ça, l'image n'est chargée qu'une fois par glBindTexture(), ensuite chaque texture est sélectionnée indépendamment dans cette métatexture
CONTOUR ==>         #Laisser un contour de 2 pixels sur les bords des textures
SCINTILLEMENT DES TEXTURES ==>      #Lors d'un dézoom. Utiliser des mipmaps

Il semble qu'avec OpenGL et SFML, notamment après un glFlush(), si un WINDOW.Clear() n'a pas lieu avant WINDOW.Close(), il y ait un message d'erreur : rajouter donc un WINDOW.Clear() avant WINDOW.Close()

Il semble qu'il faille mettre le code OpenGL au même endroit que les WINDOW.Draw() dans la boucle principale de SFML (avant WINDOW.Display(), et après WINDOW.Clear()).
En fait, cela dessine directement dans la WINDOW active : c'est pour cela qu'il faut mettre un WINDOW.SetActive() avant WINDOW.Clear()

OpenGL garde en mémoire deux couleurs courantes :
  - la couleur index courante (en mode couleur indexées (il faut que la fenêtre s'ouvre en mode couleur indexées, ce qui est impossible avec SFML)) ?
  - une RGBA couleur (par défaut blanc opaque)

Des commandes existent en doublons, avec des lettres ou ds chiffres qui changent à la fin : les chiffres indiquent le nombre de dimensions et/ou d'arguments, un "v" indique que les arguments sont des ADR (l'absence de v indique le contraire), un "u" indique que les arguments sont unsigned, un "b", "f", "s", "i", "d" indique un type d'argument
HEADER ==>              #<GL/gl.h>

GLshort                 #
GLbyte                  #
GLushort                #
GLubyte                 #
GLint                   #
GLuint                  #Semblent être des typedefs simples. Je préférerai 
GLfloat                 #utiliser leur version déréférencée directement dans ma 
GLdouble                #documentation
GLvoid                  #
GLboolean               #
GLsizei                 #Même que int
GLenum                  #Même que unsigned int
GLbitfield              #Même que unsigned int
GLclampf                #Même que float
GLclampd                #Même que double

STATE MACHINE 
OpenGL est caractérisé par des states : qui sont des états courants pour un paramètre particulier, affectant les prochaines opérations : par exemple couleur courante, perspective courante, matériau courant, texture courantes, lumière globale courante, etc.
Attention : lorsque l'un de ces states est modifié pour la première fois, il peut affecter les opérations précédentes prenant compte de ce state. Il faut donc le modifier avant ces dernières opérations. Par exemple : 1) dessiner un rectangle ; 2) modifier couleur courante ; 3) dessiner un triangle ; modifie la couleur des deux polygones. Il faut donc modifier la couleur courante du rectangle aussi.
On peut avoir un aperçu de la plupart de ces states via glGetBooleanv(), glGetDoublev(), glGetFloatv() et glGetIntegerv(). La plupart peuvent être activées/désactivées par glEnable() et glDisable()
On peut aussi enregistrer/charger l'état de certains de ces states via glPushAttrib() et glPopAttrib()

  == EN DEHORS DE LA BOUCLE ==

glPointSize(FLOAT_VAL)  #Définit l'épaisseur des points (en pixels) avec le 
                        #POLY_FLAG GL_POINTS
glLineWidth(FLOAT_VAL)  #Définit l'épaisseur des lignes (en pixels) avec les
                        #POLY_FLAG GL_LINES*
glLineStipple(SHORT_VAL,#Définit la manière avec laquel des lignes pointillées
INT_VAL)                #sont affichées : INT_VAL est un pattern de 16 bits où
                        #les 1 et 0 définissent le pointillé. Par exemple :
                        #  - 0xaaaa définit - - - - - - - - 
                        #  - 0xffff définit ---------------
                        #  - 0xeeaa définit --- --- - - - -
                        #Le nombre d'instance de chaque "-" et " " est ensuite 
                        #multiplié par SHORT_VAL. Par exemple avec 2 et 0xaaaa,
                        #cela donne --  --  --  --  --  --  --  --  
                        #Les lignes doivent être dessinées avec
                        #glBegin(GL_LINE*) et, à chaque boucle, 
                        #glEnable(GL_LINE_STIPPLE) doit être activé

glCullFace(FLAG)        #Désormais, les faces avant/arrière (en fonction du
                        #FLAG, soit GL_BACK, GL_FRONT ou GL_FRONT_AND_BACK) ne
                        #seront plus affichées. glEnable(GL_CULL_FACE) doit être
                        #activé. Permet un gain de performance.
glFrontFace(FLAG)       #Désigne la manière de déterminer si une face est avant
                        #ou arrière (FLAG peut être GL_CW ou GL_CCW). GL_CW est
                        #le mode normal. GL_CCW retourne cela, n'affichant en
                        #fait que les faces arrières. Pour retourner une face
                        #sinon, il suffit d'inverser l'ordre de toutes ses
                        #glVertex() dans la séquence glBegin().
glPolygonMode(FLAG1,    #Désigne la manière d'afficher les faces avant et/ou
FLAG2)                  #arrière (en fonction de FLAG1 : GL_BACK, GL_FRONT ou
                        #GL_FRONT_AND_BACK). FLAG2 peut être GL_POINT, GL_LINE
                        #ou GL_FILL (défaut).
 == DANS LA BOUCLE
glEdgeFlag[v](BOOL_VAL) #Avec un glPolygonMode() sur GL_LINE, si BOOL_VAL est
                        #false, les prochains points ne dessineront pas de
                        #lignes. Si BOOL_VAL est true, réactive le mode par
                        #défaut (dessin des lignes). Utilité : avec un maillage
                        #de polygones, ne dessiner que les contours de 
                        #l'ensemble, et non celui de chaque polygone. Doit être
                        #fait dans le glBegin() d'un GL_QUADS, GL_TRIANGLES ou
                        #GL_POLYGON.
 == PAS DANS LA BOUCLE
                        
gluOrtho2D(DOUBLE_VAL1, #En gros, change la matrice courante pour que ses quatre
DOUBLE_VAL2, DOBLE_VAL3,#bords correspondent à ces quatre valeurs (top, left,
DOUBLE_VAL4)            #bottom, right). Au départ, les 4 bords sont -1, 1, -1,
                        #1. Il semble qu'il soit mieux de le faire sur 
                        #GL_PROJECTION

  == DANS LA BOUCLE ==

glBegin(POLY_FLAGS)     #Commence une session glBegin, qui dessinera le
                        #polygone désigné par POLY_FLAGS. Cette session :
                        #  - ne peut contenir (sinon erreur fatale) que des 
                        #    appels à :
                        #    - glVertex()
                        #    - glColor()
                        #    - glIndex()
                        #    - glNormal()
                        #    - glTexCoord()
                        #    - glEvalCoord()
                        #    - glEvalPoint()
                        #    - glArrayElement()
                        #    - glMaterial()
                        #    - glEdgeFlag()
                        #    - glCallList() et glCallLists(), si elles exécutent
                        #      des appels aux précédentes fonctions.
                        #  - doit être terminée par glEnd()
                        #Pendant la session glBegin(), on ajoute une suite de
                        #sommets avec des propriétés pour chacun (couleur, etc.)
                        #En fonction du POLY_FLAGS choisit, leur nombre peut
                        #être requis d'un minimum ou du fait d'être le multiple
                        #d'un nombre, sinon les derniers sommets ne seront pas
                        #dessinés.
                        #Les POLY_FLAGS possibles sont :
+------------------+----+-----+------------------------------------------------+
|                  | Min| Mult| Définition                                    |
+------------------+----+-----+------------------------------------------------+
|GL_POINTS         # 1  |     | Points isolés                                   |
|GL_LINES          # 2  | 2   | Lignes isolées                                  |
|GL_LINE_STRIP     # 2  |     | Tracé non fermé                                |
|GL_LINE_LOOP      # 2  |     | Tracé fermé (sans remplissage)                 |
|GL_TRIANGLES      # 3  | 3   | Triangles isolés                               |
|GL_TRIANGLE_STRIP # 3  |     | Couvre une surface définie par la superposition|
|                  |    |     | de tous les triangles composés de trois sommets|
|                  |    |     | qui se suivent (sans retour au début) possibles|
|GL_TRIANGLE_FAN   # 3  |     | Couvre une surface définie par la superposition|
|                  |    |     | de tous les triangles composés de deux sommets |
|                  |    |     | qui se suivent liés au tout premier sommet,    |
|                  |    |     | possibles                                      |
|GL_QUADS          # 4  | 4   | Rectangle isolés (attention aux rectangles avec|
|                  |    |     | des angles concaves)                           |
|GL_QUAD_STRIP     # 4  | 2   | Couvre une surface définie par la superposition|
|                  |    |     | de tous les rectangles composés de quatre      |
|                  |    |     | sommets qui se suivent (sans retour au début)  |
|                  |    |     | possibles                                      |
|GL_POLYGON        # 3  |     | Tracé fermé (avec remplissage) (doit être      |
|                  |    |     | convexe, et sans intersection)                 |
+------------------+----+-----+------------------------------------------------+

    GL_QUAD_STRIP    GL_TRIANGLE_STRIP  GL_TRIANGLE_FAN
    ___ ____ ____      _________         ___                               
   |   |    |    |    |\   |\   |       |  /\_                         
   |   |    |    |    | \  | \  |       | /   \_                               
   |   |    |    |    |  \ |  \ |       |/_______\                              
   |___|____|____|    |___\|___\|       |      __/                        
                                        |   __/                             
                                        |__/                               
                                                                                

glEnd()                 #A exécuter à la fin d'une session glBegin().
glRect[dfis][v](ARG1,   #Affiche un rectangle dont le premier coin a les
ARG2, ARG3, ARG4)       #coordonnées ARG1,ARG2, et le coin opposé ARG3,ARG4.
                        #Ne doit pas être dans un glBegin()-glEnd(). Les 
                        #coordonnées z de chaque point sont 0.

glVertex[234][u][sifd]  #Le chiffre indique le nombre de dimensions (jusqu'à 4)
[v](...)                #Toute dimension non indiquée est supposée être == 0.
                        #Dessine un nouveau sommet, en fonction de :
                        #  - les coordonnées passés en arguments
                        #  - la couleur courante
                        #  - la texture courante et le mapping courant 
                        #    (multiplied par la couleur)
                        #  - A completer...

glColor[34][u][bsifd][v]#Le chiffre indique le nombre d'arguments
(...)                   #Cette fonction change la couleur courante :
                        #  - les 4 arguments sont RGBA (s'il y en a que 3,
                        #    l'alpha est opaque)
                        #  - pour SHORT_VAL et INT_VAL, la valeur minimale du 
                        #    type signifie rien, et la valeur maximale signifie
                        #    plein
                        #  - pour FLOAT_VAL et DOUBLE_VAL, c'est 0 et 1
                        #Les plus simples à utiliser sont donc glColor3ub() et
                        #glColor3d(), avec leur variantes "4" (pour l'alpha) et 
                        #"v" (pour réutiliser une même couleur)
glShadeModel(FLAG)      #Si FLAG == GL_SMOOTH (défaut), la couleur des pixels
                        #à l'intérieur d'une ligne, triangle, quad ou polygon
                        #est interpolée en fonction des sommets de cette ligne,
                        #triangle, etc.
                        #Si FLAG == GL_FLAT, la couleur des sommets n'affecte 
                        #que les sommets et pas l'intérieur de la ligne, 
                        #triangle, etc.
glNormal3[bdfis][v]     #Indique la normale des prochains sommets (par défaut
(ARG1, ARG2, ARG3)      #le vecteur (0, 0, 1)).

glFlush()               #A faire à la fin de chaque boucle, avant l'affichage,
                        #pour des raisons que je n'ai pas tout à fait saisi.
glFinish()              #Attend que toutes les frames aient fini d'être 
                        #affichées.

glNewList(FLAG1, FLAG2) #Commence une nouvelle glList dont le nom est FLAG1.
                        #FLAG1 est un #define vers une UINT_VAL, et devrait
                        #être généré par glGenLists()
                        #Si FLAG2 est GL_COMPILE, la liste n'est pas exécutée,
                        #s'il est GL_COMPILE_AND_EXECUTE, elle l'est.
                        #Une commande non-lancée par une glList est dîte en
                        #"mode immédiat".
                        #Une glList est tout ensemble de commande OpenGL
                        #(uniquement), qui pourra ensuite être lancée plusieurs
                        #fois (comme une fonction). Comme une glList est 
                        #calculée lors du compile-time :
                        #  - elle accroît les performances, notamment s'il y a
                        #    des opérations :
                        #     - sur les matrices
                        #     - sur les raster images
                        #     - sur les lumières
                        #     - sur une définition de texture
                        #     - sur des GL_TRIANGLE_STRIP, GL_QUAD_STRIP et
                        #       GL_TRIANGLE_FAN.
                        #     - lorsqu'OpenGL est utilisé en réseau
                        #  - elle est read-only. Si elle cible un array, une
                        #    copie de cet array, read-only, est utilisée
                        #  - certaines commandes peuvent être utilisées mais
                        #    seront lancées en mode immédiat :
                        #      - glColorPointer(), glDeleteLists(), 
                        #        glDisableClientState(), glEdgeFlagPointer(),  
                        #        glEnableClientState(), glFeedbackBuffer(), 
                        #        glFinish(), glFlush(), glGenLists(), 
                        #        glIndexPointer(), glInterleavedArrays(), 
                        #        glIsEnabled(), glIsList(), glNormalPointer(),  
                        #        glPopClientAttrib(), glPixelStore(), 
                        #        glPushClientAttrib(), glReadPixels(), 
                        #        glRenderMode(), glSelectBuffer(), 
                        #        glTexCoordPointer(),  glVertexPointer(),
                        #        glTexImage2D(), glTexImage1D()
                        #Il peut être utile d'entourer une glList de 
                        #glPushMatrix() et glPopMatrix(), ou glPushAttrib() et 
                        #glPopAttrib()
                        #Doit être terminé par glEndList()
glEndList()             #Termine une séquence glList.
glCallList(FLAG)        #Exécute la glList FLAG (peut être nested dans une autre
                        #glList)
glCallLists(SIZE_T_VAL, #Exécute toutes les glList contenues dans l'array 
FLAG, FLAGS2_ADR)       #FLAGS2_ADR contenant SIZE_T_VAL glLists. FLAG désigne
                        #le type de ces listes, mais en général c'est 
                        #GL_UNSIGNED_INT
glGenLists(SIZE_T_VAL)  #Crée SIZE_T_VAL noms de glList. Renvoie le premier nom
                        #sous forme de UINT_VAL. Les autres sont égales à cet
                        #UINT_VAL + 1, + 2, etc. Doit ensuite être supprimé
                        #avec glDeleteLists().
glIsList(FLAG)          #Renvoie true si FLAG est une glList actuellement
                        #sauvegardée.
glDeleteLists(FLAG,     #Supprime les SIZE_T_VAL noms de glLists suivant, et
SIZE_T_VAL)             #comprenant, FLAG.

LES MATRICES...
En gros, les matrices modifient la manière avec laquelle les prochains dessins seront faits. Les coordonnées de chaque objet sont en qq sorte "multipliés" par cette matrice avant d'être dessinés. La matrice peut donc par exemple produire des rotations, des agrandissements, etc. sur les objets en fonction des valeurs qu'elle a. Au départ il s'agit de la matrice identité, qui ne modifie rien. Ainsi, ce que j'appelerai par exemple "agrandir la matrice" signifie que la matrice obtiens des valeurs de telle sorte que les prochains éléments dessinés sont agrandis, etc.
Point de vue technique :
OpenGL utilise des matrices 4 x 4 (attention, les éléments font de haut en bas, puis de gauche à droite, et non l'inverse). Tout point a trois coordonnée, plus une "dummy" utilisée juste pour la multiplication et égale à 1. Tout point est multiplié avec cette matrice pour avoir sa position finale affichée.
Explication des nombres de cette matrice :
S R R G    G : utilisé pour les translations (x, y, z respectivement)
R S R G    S : utilisé pour les changements d'échelle (x, y, z respectivement)
R R S G    S et R : utilisé pour les rotations (un peu compliqué)
O O O O    O : utilisé pour les projections (?)
multiplication avec la matrice identité :
1 0 0 0     x     x
0 1 0 0  x  y  =  y   rien ne change.
0 0 1 0     z     z    
0 0 0 1     1     1
multiplication avec la matrice ayant opéré une translation (2, 1, 0) :
1 0 0 2     x     x + 2
0 1 0 1  x  y  =  y + 1  
0 0 1 0     z     z    
0 0 0 1     1     1
multiplication avec la matrice ayant opéré un changement d'échelle (2, 1, 3) :
2 0 0 0     x     2x
0 1 0 0  x  y  =  y   
0 0 3 0     z     3z    
0 0 0 1     1     1
multiplication avec la matrice ayant opéré une rotation de 90 degré autour de l'axe z
0 -1 0 0     x     -y
1  0 0 0  x  y  =  x  
0  0 1 0     z     z    
0  0 0 1     1     1
Il y a en fait 3 matrices, et une seule est courante (c'est-à-dire utilisée par les opérations sur les matrices, ou également par les dessins). Je ne comprends pas trop pour l'instant, il y a :
GL_PROJECTION : semble faire référence à la vue caméra
GL_MODELVIEW (défaut) : semble être la vue normale, sans penser à la caméra (glRotate, glScale, glTranslate, etc.)
GL_TEXTURE : les coordonnées texture : permet de déplacer, faire tourner, etc. une texture.
De plus, il y a un stack pour chacunes des trois, où l'on peut les sauvegarder/charger. Leur taille est respectivement de minimum 2 ; 32 ; 2 matrices (en comptant la courante). Cela permet de sauvegarder des états de la matrice courante. Ainsi, si l'on veut qu'un ensemble de transformations d'une matrice s'appliquent seulement sur un dessin, entourer ce dessin d'un glPushMatrix() puis d'un glPopMatrix()
Modifier une matrice au fur et à mesure, revient à déplacer, faire tourner et agrandir/rétrécir le point référence 0,0,0 à partir duquel les objets sont dessinés (comme une centre de curseur que l'on manipule)

glMatrixMode(MATRICE)   #MATRICE devient la matrice courante
glLoadIdentity()        #La matrice courante devient égale à la matrice identité
                        #Elle est donc remise à zéro (à faire à chaque itération
                        #de la boucle).
glLoadMatrix[fd]        #La matrice courante devient égale à la matrice désignée
(ARG_ADR)               #par ARG_ADR, qui pointe vers un array de 16 éléments.
glMultMatrix[fd]        #La matrice courante est multipliée par la matrice 
(ARG_ADR)               #désignée par ARG_ADR, qui pointe vers un array de 16 
                        #éléments.
glPushMatrix()          #Sauvegarge la matrice courante en la plaçant en haut du
                        #stack.
glPopMatrix()           #Charge la matrice du haut du stack et la retire du
                        #stack.
glTranslate[df](ARG1,   #
ARG2, ARG3)             #Déplace la matrice d'autant.
glScale[df](ARG1, ARG2, #Même chose, mais pour un changement d'échelle. Un 
ARG3)                   #argument négatif produit une symétrie.
glRotate [df](ARG1,     #Même chose, mais pour une rotation.
ARG2, ARG3, ARG4)       #Cependant deux différences :
                        #  - le premier ARG indique le nombre d'angles de la
                        #    rotation (countercockwise)
                        #  - les trois autres indiques la direction de la
                        #    rotation (utiliser des valeurs entre -1 et 1 par
                        #    exemple)

PLACEMENT DE LA CAMERA ET DE LA PERSPECTIVE : utiliser la matrice GL_PROJECTION. Doit venir avant les modifications de GL_MODELVIEW.
Schéma caméra :

  clipping     Scène   
   plane     ____|   Le clipping plane est l'écran 2D imprimant la scène par
     |  ____/    |   rapport au cône de projection de la caméra. Plus il est
   __v_/         |   petit, plus l'angle de prise de vue est grand, plus ça
<o<__|_          |   fait "fish-eye". Angle de prise de vue normale : 70°
 |     \____     |   Le clipping plane doit avoir un ratio largeur/hauteur ==
Camera      \____|   celui de la fenêtre pour éviter une déformation.
                 |

 == DANS LA BOUCLE
glFrustum(DOUBLE_VAL1,  #Désigne la perspective (non-orthogonale) courante :
DOUBLE_VAL2, DOUBLE_VL3,#  - DOUBLE_VAL1, 2, 4 et 5 désignent les coordonnées du
DOUBLE_VAL4, DOUBLE_VL5,#    clipping plane
DOUBLE_VAL6)            #  - DOUBLE_VAL3 et DOUBLE_VAL6 sont les minimum et
                        #    maximum distances pour qu'un objet soit visible.
gluPerspective          #Désigne la perspective (non-orthogonale) courante :
(DOUBLE_VAL1,           #  - DOUBLE_VAL1 est l'angle de prise de vue
DOUBLE_VAL2, DOBLE_VAL3,#  - DOUBLE_VAL2 est le ratio largeur / hauteur de la
DOUBLE_VAL4)            #    fenêtre
                        #  - DOUBLE_VAL3 et DOUBLE_VAL4 sont les minimum et
                        #    maximum distances pour qu'un objet soit visible.
                        #Modifie en fait la matrice GL_PROJECTION pour obtenir
                        #un tel effet.
glOrtho(DOUBLE_VAL1,    #Désigne la perspective (orthogonale) courante :
DOUBLE_VAL2, DOUBLE_VL3,#  - la caméra est placée au-dessus, regardant vers le
DOUBLE_VAL4, DOUBLE_VL5,#    bas.
DOUBLE_VAL6)            #  - les quatres premiers arguments désigne les limites
                        #    du rectangle qu'elle regarde. Le rectangle devrait
                        #    toujours être au même ratio que la fenêtre.
                        #    Le centre du rectangle désigne le point 0, 0, 0
                        #  - DOUBLE_VAL3 et DOUBLE_VAL6 sont les minimum et
                        #    maximum distances pour qu'un objet soit visible.
                        #Couplé avec un gluLookAt() :
                        #  - Déplacer le rectangle déplace la vue.
                        #  - Agrandir le rectangle renvoie une scène plus grande
                        #    (comme un éloignement orthogonale)
gluOrtho2D(DOUBLE_VAL1, #Equivaut à glOrtho(), avec les deux derniers arguments
DOUBLE_VAL2, DOUBLE_VL3,#étant -1 et 1. Utile lorsque la scène est en 2D.
DOUBLE_VAL4)            #(glVertex2D*() plaçant les vertex avec des coordonnées
                        #z de 0, ils sont toujours visibles).
glDepthRange(DOUBLE_VL1,#Les minimum et maximum distances pour qu'un objet soit
DOUBLE_VAL2)            #visible deviennent DOUBLE_VAL1 et DOUBLE_VAL2. Ces
                        #valeurs sont comprises entre 0 (caméra) et 1 (point de
                        #la scène le plus éloigné)
gluLookAt(3 triplets de #Place la caméra. Le premier triplet désigne ses
DOUBLE_VAL)             #coordonnées. Le deuxième le point qu'elle regarde.
                        #Le troisième, le point vers lequel pointe son axe
                        #vertical (en général 0,1,0 ou 0,0,1).
                        #Il est bon que la caméra soit à 0,0,0 (pour déplacer
                        #la caméra virtuellement, déplacer donc le lieu qu'elle
                        #regarde de x,y,z, puis faire un glTranslated(x,y,z)
                        #au début des modifications sur la matrice GL_MODELVIEW.
                        #Modifie en fait la matrice GL_PROJECTION pour obtenir
                        #un tel effet (avec des glScale*() et des
                        #glTranslate*()). 
                        #Est cumulatif par rapport à la dernière position :
                        #déplace en fait la caméra, plus le point où elle 
                        #regarde, puis le point de son axe vertical. Pour le
                        #faire de manière absolu, le faire donc après un 
                        #glLoadIdentity()
                        #Doit être fait couplé avec gluPerspective() il semble.

 == EN DEHORS DE LA BOUCLE
VIEWPORT ==>            #Le viewport ne modifie en fait pas la projection de la 
                        #scène. Il intervient à la fin, une fois que la scène
                        #est rendue, comme si l'on modifiait la scène comme une
                        #image 2D. Il permet de projeter la scène 3D rendue sur
                        #un support 2D sans, je le répète, changer la 
                        #projection. Le viewport doit être de la taille de 
                        #l'écran, et donc être réajuster en cas de 
                        #redimensionnement. Doit venir avant les modifications
                        #tel que glScale, etc.
                        #Pour que le ratio diffère de celui de l'écran, il faut
                        #compenser en spécifiant un différent ratio avec 
                        #gluPerspective()
                        #Par défaut, le VIEWPORT est égal à la taille de l'écran
glViewport(INT_VAL1,    #Définie la largeur SIZE_T_VAL1 et la hauteur 
INT_VAL2, SIZE_T_VAL1,  #SIZE_T_VAL2 du Viewport. Le viewport subit également
SIZE_T_VAL2)            #un décalage d'INT_VAL1 pixels en abscisse et INT_VAL2
                        #en ordonnée (ce qui revient à déplacer l'image finale 
                        #en 2D)
                        #Doit être fait sur la matrice GL_MODELVIEW.
                        

ZBuffer : nombre associé à chaque pixel de l'écran. Au départ infini, puis si un pixel est dessiné dessus, la profondeur de ce pixel par rapport à la caméra. Ensuite, si un nouveau pixel doit être dessiné dessus ce même pixel, il doit avoir une profondeur plus petite, sinon c'est refusé. Cela permet aux faces d'éviter de se chevaucher.
glClear(FLAGS)          #Réinitialise les données des pixels (à faire à chaque boucle), en fonction des flags :
  - GL_COLOR_BUFFER_BIT, réinitialise la couleur des pixels, en la remplissant par la ClearColor, telle que définie par glClearColor(FLOAT_VAL1, FLOAT_VAL2, FLOAT_VAL3, FLOAT_VAL4) (par défaut noir opaque)
  - GL_DEPTH_BUFFER_BIT, réinitialise le zbuffer de chaque pixel, pour chaque pixel ait une profondeur initiale de ClearDepth, tel que défini par glClearDepth(DOUBLE_VAL) (par défaut 1, soit une sorte d'infini (je crois qu'il s'agit du point de la scène le plus éloigné), car DOUBLE_VAL doit aller de 0 à 1). Utiliser d'autres valeurs pour glClearDepth() permet de ne pas afficher les objets les plus éloignés.
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)  #Réinitialise la couleur + zbuffer de tous les pixels (à faire à chaque boucle)
glEnable(GL_DEPTH_TEST)     #Active le ZBuffer (par défaut désactivé)
glDepthMask(BOOL_VAL)       #S'il est enabled, et que BOOL_VAL est false,
                            #désactive le Zbuffer.

ALPHA BLENDING
Utiliser des plans alphas (billboarding) permet d'avoir une impressions 3D en utilisant peu de ressources.
== EN DEHORS DE LA BOUCLE
glEnable(GL_BLEND)      #Active l'alpha blending.
glBlendFunc(FLAG1,      #Dès qu'un objet (opaque ou non) est dessiné devant ou
FLAG2)                  #derrière un autre, la valeur finale du mélange est 
                        #calculée en fonction de l'addition de FLAG1 et FLAG2.
                        #FLAG1 et FLAG2 désigne une transparence lors du mélange
                        #pour l'objet du dessus (FLAG1) et du dessous (FLAG2)
                        #Cela a en fait lieu non pas pour l'objet entier, mais
                        #pour chaque pixel se chevauchant.
                        #FLAG1 peut être :
                        #  - GL_ZERO : complètement opaque
                        #  - GL_ONE : complètement invisible
                        #  - GL_SRC_ALPHA : alpha de l'objet de dessus
                        #  - GL_ONE_MINUS_SRC_ALPHA : inverse de l'alpha de
                        #    l'objet de dessus
                        #  - GL_DST_ALPHA : alpha de l'objet de dessous
                        #  - GL_ONE_MINUS_DST_ALPHA : inverse de l'alpha de
                        #    l'objet de dessous
                        #  - GL_SRC_ALPHA_SATURATE : ??
                        #  - GL_DST_COLOR : ??
                        #  - GL_ONE_MINUS_DST_COLOR : ??
                        #FLAG2 peut avoir les même valeurs, sauf que 
                        #GL_DST_COLOR et GL_ONE_MINUS_DST_COLOR sont 
                        #GL_SRC_COLOR et GL_ONE_MINUS_SRC_COLOR
                        #Par défaut, les flags sont GL_ONE et GL_ZERO, ce qui
                        #signifie pas de blending.
                        #Pour un blending normale, utiliser GL_SRC_ALPHA et
                        #GL_ONE_MINUS_SRC_ALPHA.
                        #Si un objet est dessiné derrière un objet transparent
                        #qui a déjà été dessiné, la transparence n'a pas lieu :
                        #comment faire ??

ANTIALIASING ???

FOG
Permet d'assombrir les objets éloignés (et non les faire transparents), ce qui donne du réalisme et de la profondeur.
glEnable(GL_FOG)        #Active le fog
glFog[fi][v](FLAG1,     #Si FLAG1 est G_FOG_MODE, alors FLAG2 doit être
FLAG2)                  #GL_LINEAR, GL_EXP (brouillard exponentiel) ou GL_EXP2 
                        #(comme exponentiel, mais préserve un léger seuil pour
                        #les objets proches) pour désigner l'algorithme du fog.
                        #Par défaut GL_EXP.
                        #FLAG1 peut aussi être GL_FOG_START et GL_FOG_END pour 
                        #indiquer le début et la fin du brouillard (par défaut 
                        #0 et 1).
                        #Il peut enfin être GL_FOG_DENSITY pour indiquer la
                        #puissance du brouillard (par défaut 1).

== DANS LA BOUCLE
glClipPlane(FLAG,       #FLAG désigne l'un des six clip planes : GL_CLIP_PLANE0,
DOUBLE_ADR)             #GL_CLIP_PLANE1, etc. Définie la géométrie de ce clip,
                        #où DOUBLE_ADR pointe vers un array de quatre DOUBLE_VAL
                        #désignant l'équation ax + by + cz + d du plane. Ainsi
                        #un 1 en deuxième position avec des 0 à côtés donnera
                        #un plane vertical, un 1 en 1ère et 2ème position un
                        #plane diagonal, etc. Le plane passera par 0,0,0, sauf
                        #si un décalage est signalé avec le quatrième argument.
                        #Pour que clipping plane fonctionne, il faut activer
                        #(en dehors de la boucle) glEnable(GL_CLIP_PLANE*).

OBJET OPENGL : on doit les générer via un glGen... (... est le nom de l'objet), ce qui produit des nombres qui les désignent ("nom", comme le fd d'une fichier), bien qu'au départ ils soient vides. Ensuite, un appel glBind... prenant en argument ce nombre permet de faire de cet objet l'objet courant, et parfois de commencer à préciser ses paramètres. Ensuite, on utilise d'autres fonctions pour préciser les paramètres de l'objet ; puis on l'utilise, ou on le garde de côté. A la fin, un appel glDelete... doit être fait pour détruire l'objet.

LIGHTING
Comme dans Blender, un objet est composé d'un matériau avec une couleur spéculaire, diffuse, ambiante ; et une lumière aussi (elle diffuse donc aussi de la lumière ambiante). La couleur finale est une composition des couleurs du matériau + des couleurs des lumières.
Les lumières par défaut, traversent les objets.
EN DEHORS DE LA BOUCLE :
glEnable(GL_LIGHTING)   #Active le lighting. Les glColor() deviennent inutiles.
                        #Cependant, après un glEnable(GL_COLOR_MATERIAL), les
                        #glColor() permettent de modifier le matériau sans
                        #passer par glMaterial(), et donc de modifier les
                        #matériaux dans une séquence glBegin() (c'est aussi plus
                        #performant).
                        #Par contre, les matériaux et lumières deviennent 
                        #effectives. Le lighting est désactivé par défaut. 
glEnable(GL_LIGHT*)     #Active la lumière numéro * (commence à 0, il y en a
                        #minimum 8). Par défaut, toutes les lumières sont 
                        #désactivées, mais ont des paramètres (dont position).
                        #Les lumières prennent beaucoup de calcul.
glLight[fi][v](FLAG1,   #Spécifie les paramètres de la lumière FLAG1 (sur le
FLAG2, ARG)             #modèle GL_LIGHT*). Les paramètres sont désignés par
                        #FLAG2, et leur valeur dans ARG. Certains FLAGS ne sont
                        #disponibles qu'avec le "v", prenant alors comme ARG un
                        #ADR pointant vers un array de 3 ou 4 valeurs,
                        #désignant :
                        # - la couleur RGBA (j'ignore la signification de 
                        #   l'élément alpha ici)
                        # - la position (si la dernier élément est 0, la lumière
                        #   est directionnelle, si c'est 1, elle est 
                        #   positionnelle).
                        # - la direction (pour GL_SPOT_DIRECTION).
                        #La différence est que :
                        # - une lumière directionnelle (comme le Sun et non
                        #   comme la lumière directionnelle de Blender) est :
                        #     - considérée comme étant placée à l'infini.
                        #     - elle envoie de la lumière dans toutes les
                        #       directions sans atténuation.
                        # - une lumière positionnelle a :
                        #     - une position précise :
                        #     - son intensité diminue en fonction de la 
                        #       distance. Soit d la distance, et ca, la et qa
                        #       les trois sortes d'atténuations, à chaque unité
                        #       parcourue par la lumière elle perd :
                        #         - ca + d * la + d^2 * qa.
                        #       Donc ca est perdue à chaque unité (l'augmenter
                        #       ou non est un bon moyen d'augmenter la puissance
                        #       de la lumière)
                        #       la est de moins en perdue (linéaire), ce qui
                        #       permet d'éclairer mieux les parties obscures.
                        #       qa est la même chose, mais accentué.
                        #     - elle peut être limitée à un cône (spot). A la
                        #       fois GL_SPOT_CUTOFF et GL_SPOT_DIRECTION doivent
                        #       alors être précisés. Pour éviter que les bords
                        #       du spot soient nets, on peut utiliser 
                        #       GL_SPOT_EXPONENT
                        #Les FLAGS2 pour une lumière directionnelle ou
                        #positionnelle sont ("v" nécessaire) :
                        #  - GL_AMBIENT : couleur ambiante
                        #  - GL_DIFFUSE : couleur diffuse
                        #  - GL_SPECULAR : couleur spéculaire
                        #  - GL_POSITION : position dans l'espace
                        #Les FLAGS2 pour une lumière positionnelle seulement
                        #sont :
                        #  - GL_CONSTANT_ATTENUATION : atténuation constante
                        #    (cf plus bas) (défaut : 1)
                        #  - GL_LINEAR_ATTENUATION : atténuation linéaire
                        #    (défaut : 0)
                        #  - GL_QUADRATIC_ATTENUATION : atténuation quadratique
                        #    (défaut : 0)
                        #  - GL_SPOT_CUTOFF : rayon (degrés) du spot. Valeurs
                        #    possibles : 0 à 90, mais la valeur spéciale 180 
                        #    (aucun spot, défaut) aussi.
                        #  - GL_SPOT_DIRECTION ("v" nécessaire) : vecteur
                        #    indiquant la direction du spot.
                        #  - GL_SPOT_EXPONENT : facteur exponentiel concentrant
                        #    la lumière vers le centre et adoucissant les bords
                        #    (défaut 0, maximum 128).
glLightModel[fi][v]     #Spécifie les paramètres lumineux de la scène globale.
(FLAG1, ARGS)           #FLAG1 peut être :
                        #  - GL_LIGHT_MODEL_AMBIENT (seulement avec "v") : 
                        #    désigne la lumière ambiante générale 
                        #    (indépendamment des lumières ambiantes émises par 
                        #    les GL_LIGHT*). ARGS est un pointeur vers un
                        #    array RGBA. Par défaut, la lumière ambiante globale
                        #    est un gris à 20%.
                        #  - GL_LIGHT_MODEL_LOCAL_VIEWER : si ARG est égal à
                        #    true, la spécularité se fait en fonction du point
                        #    0,0,0 (qui est sensé être la caméra), ce qui permet
                        #    à la spécularité de dépendre du point de vue, mais
                        #    prend du calcul. Sinon (défaut), elle est calculée
                        #    en fonction d'un point lointain infini, toujours le
                        #    même quel que soit le point de vue.
                        #  - GL_LIGHT_MODEL_TWO_SIDE : Si ARG == 0, les faces
                        #    arrières sont illuminées comme les faces avant, et
                        #    elles utilisent les matériaux de GL_FRONT. Sinon,
                        #    elles utilisent le matériaux de GL_BACK et leurs
                        #    normales sont inversées (utile sur un polygone dont
                        #    on voit les deux faces, inutile et moins rapide 
                        #    sinon). Semble parfois nécessaire sur un plane.
== DANS LA BOUCLE
glMaterial[fi][v](FLAG1,#Spécifie les paramètres du matériau courant, pour ce
FLAG2, ARGS)            #qui est de FLAG1 (GL_FRONT, GL_BACK ou 
                        #GL_FRONT_AND_BACK). Les paramètres sont désignés par
                        #FLAG2, et leur valeur dans ARGS.
                        #Le matériau courant est appliqué à tous les prochains
                        #sommets.
                        #Si glLight() n'a pas de "v", les FLAGS2 peuvent être :
                        #  - GL_SHININESS : facteur exponentiel définissant le
                        #    degré de concentration de la spécularité (par
                        #    défaut 0)
                        #Il n'y a qu'un seul ARG désignant la valeur.
                        #Avec un "v", ces FLAGS2 sont disponibles, ARG désignant
                        #alors un ADR pointant vers un array de 4 valeurs
                        #(désignant la couleur ou la position). J'ignore la
                        #signification de l'élément alpha pour la couleur ici :
                        #  - GL_AMBIENT : couleur ambiante
                        #  - GL_DIFFUSE : couleur diffuse
                        #  - GL_AMBIENT_AND_DIFFUSE : couleur ambiante et 
                        #    diffuse
                        #  - GL_SPECULAR : couleur spéculaire
                        #  - GL_EMISSION : couleur d'émission. N'affecte pas les
                        #    objets environnants, mais donne l'impression 
                        #    (seulement sur l'objet émetteur) qu'il émet de la 
                        #    lumière
                        #  - GL_COLOR_INDEXES : ?
== POTENTIELLEMENT DANS LA BOUCLE
glColorMaterial(FLAG1,  #Après un glEnable(GL_COLOR_MATERIAL), désigne la 
FLAG2)                  #couleur de matériau qui est modifié par un glColor() : 
                        #FLAG1 peut être GL_FRONT, GL_BACK ou GL_FRONT_AND_BACK,
                        #et FLAG2 peut être GL_AMBIENT, GL_DIFFUSE,
                        #GL_AMBIENT_AND_DIFFUSE, GL_SPECULAR ou GL_EMISSION.
                        #Par défaut, glColor() affecte GL_FRONT_AND_BACK et
                        #GL_AMBIENT_AND_DIFFUSE après un 
                        #glEnable(GL_COLOR_MATERIAL)

TEXTURES
Elles multiplient la couleur ou matériau courant.
EN DEHORS DE LA BOUCLE :
1) glGenTextures(SIZE_T_VAL, UINT_ADR)  #Crée SIZE_T_VAL noms de textures, enregistrés dans l'array UINT_ADR. (je crois que s'il y a plusieurs textures, elles ne peuvent pas être accédées une à une (via []), mais comme un seul bloc)
2) glBindTexture(FLAG, UINT_VAL)        #La texture courante devient le nom de texture UINT_VAL. Il s'agit de la texture 2D courante si FLAG == GL_TEXTURE_2D, et de la texture 1D courante si FLAG == GL_TEXTURE_1D. Il existe à la fois une texture 1D et 2D courantes. Utilités : a) en dehors de la boucle, pour pouvoir paramétrer la texture UINT_VAL (notamment la lier à une image) en faisant d'elle la texture courante ; b) dans la boucle, pour qu'elle soit la texture appliquée aux sommets.
3) glTexImage2D(FLAG1, INT_VAL1, INT_VAL2, SIZE_T_VAL1, SIZE_T_VAL2, INT_VAL3, FLAG2, FLAG3, VOID_ADR)      #Lie la texture courante à l'image dont les pixels se trouvent à partir de VOID_ADR (on peut utiliser IMAGE.GetPixelPtr() avec SFML).
  - FLAG1 peut être GL_PROXY_TEXTURE_2D ou GL_TEXTURE_2D, mais je ne comprends pas le premier
  - INT_VAL1 désigne le niveau de mipmap (0 pour l'image entière). (mettre 0 si pas de mipmap)
  - INT_VAL2 désigne le nombre de channels : 1 à 4 (il existe aussi des constantes du style GL_RGBA). Il semble pour moi qu'il faille toujours mettre 4, même pour du .jpg ?
  - SIZE_T_VAL1 et SIZE_T_VAL2 sont la largeur et la hauteur de l'image
  - INT_VAL3 est l'épaisseur du border (1 ou 0) : marche mal, mettre toujours 0
  - FLAG2 désigne le style de l'image : GL_RGB, GL_RGBA (même chose pour l'histoire du .jpg), GL_GREEN, GL_ALPHA, GL_COLOR_INDEX, etc.
  - FLAG3 désigne le type des pixels de couleur de l'image : GL_UNSIGNED_BYTE en général, mais il y a aussi GL_UNSIGNED_BYTE, etc.
4) Plusieurs autres fonctions de paramètres sur la texture courante... dont :
glTexParameter[fi][v](FLAG1, FLAG2, ARG)    #Ajoute des options à la texture 1D ou 2D courante (en fonction du FLAG1 GL_TEXTURE_1D ou GL_TEXTURE_2D), concernant le paramètre désigné par FLAG2, avec la valeur ARG :
  - GL_TEXTURE_MAG_FILTER désigne l'interpolation (pour éviter les aliased artefacts) faite lorsque la texture est plus grande à l'écran que sa taille réelle. Choix possibles pour ARG : GL_NEAREST (pas d'interpolation), GL_LINEAR (interpolation linéaire, défaut).
  - GL_TEXTURE_MIN_FILTER : même chose, mais lorsque la texture est plus petite. De plus il y a des choix relatifs aux mipmaps.
  - GL_TEXTURE_WRAP_S : Active ou non le loop horizontal de la texture. ARG possibles : GL_CLAMP ou GL_REPEAT (défaut)
  - GL_TEXTURE_WRAP_T : même chose, mais vertical.
Il semble que paramétrer GL_TEXTURE_MIN_FILTER avec glTexParameter() soit obligatoire...
5) glDeleteTextures(SIZE_T_VAL, UINT_ADR)   #Supprime les SIZE_T_VAL noms de textures enregistrés dans UINT_ADR

DANS LA BOUCLE
glEnable(GL_TEXTURE_2D)     #A faire dans la boucle avant de commencer à texturer.
glDisable(GL_TEXTURE_2D)    #A faire dans la boucle avant de commencer avant de commencer un mode non texturage
glBindTexture(), à nouveau.
glTexCoord2f(FLOAT_VAL1, FLOAT_VAL2)    #Comme pour glColor(), mais définie non pas la couleur mais le mapping du sommet par rapport à la texture ([0, 0] à [1,1] pour l'image entière, ensuite la texture se répète (ce qui peut être utile)).

GL_BOOL_VAL     #OpenGL a ses propres BOOL_VAL : GL_TRUE et GL_FALSE

PRIMITIVES 3D
EN DEHORS DE LA BOUCLE
GLUquadric          #Désigne des paramètres et style pour toute primitive 3D.
                    #Peut être appliqué à plusieurs primitives différentes en
                    #même temps.
gluNewQuadric()     #Renvoie un nouveau GLUQUADRIC_ADR (à nettoyer à la fin avec gluDeleteQuadric())
gluDeleteQuadric()  #Supprime un GLUQUADRIC_ADR
gluQuadricTexture(GLUQUADRIC_ADR, GL_BOOL_VAL)      #Si GL_BOOL_VAL est vrai, active le texturing pour GLUQUADRIC_ADR (le mapping semble automatique et dépend de la forme de la primitive 3D), sinon non (défaut).
gluQuadricDrawStyle(GLUQUADRIC_ADR, FLAG)       #Désigne le mode de rendu de GLUQUADRIC_ADR en fonction de FLAG :
  - GLU_POINT : n'affiche que les points des sommets
  - GLU_LINE et GLU_SILHOUETTE : mode filiaire (ne voit pas la différence)
  - GLU_FILL : mode normal (défaut)

DANS LA BOUCLE :
gluSphere(GLUQUADRIC_ADR, DOUBLE_VAL, INT_VAL1, INT_VAL2)   #Affiche une UV sphère, selon les paramètres GLUQUADRIC_ADR, avec un rayon DOUBLE_VAL, un nombre de INT_VAL1 "latitudes" et de INT_VAL2 "longitudes"
gluCylinder(GLUQUADRIC_ADR, DOUBLE_VAL1, DOUBLE_VAL2, DOUBLE_VAL3, INT_VAL1, INT_VAL2)  #Affiche un cylindre, selon les paramètres GLUQUADRIC_ADR, avec un rayon DOUBLE_VAL1 à sa base, un rayon DOUBLE_VAL2 en son sommet (0 pour un cône), une hauteur DOUBLE_VAL3, un nombre de INT_VAL1 "latitudes" et de INT_VAL2 "longitudes"
gluDisk(GLUQUADRIC_ADR, DOUBLE_VAL1, DOUBLE_VAL2, INT_VAL1, INT_VAL2)   #Affiche un disque (plane circle) avec un trou au milieu (sauf si DOUBLE_VAL1 est 0) : DOUBLE_VAL1 est le rayon du trou, DOUBLE_VAL2 le rayon total, INT_VAL1 le nombre de division radiales, et INT_VAL2 permet de dupliquer ces divisions (inutile)
gluPartialDisk(GLUQUADRIC_ADR, DOUBLE_VAL1, DOUBLE_VAL2, INT_VAL1, INT_VAL2, DOUBLE_VAL3, DOUBLE_VAL4)      #Comme gluDisk(), sauf que le disque ne fait pas 360 degrés : DOUBLE_VAL3 est l'angle où il commence, DOUBLE_VAL4 le nombre de degrés qu'il traverse.
