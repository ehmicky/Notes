
                                  ┏━━━━━━━━━━━━━━━┓
                                  ┃   TINYCOLOR   ┃
                                  ┗━━━━━━━━━━━━━━━┛


VERSION ==>                       #1.6.0

COLOR_INPUT                       #Any of the following
                                  #If any 'FUNC(VAL,...)', ( ) and , are optional
                                  #0-1 and 0-255 can be written 0%-100% too
'COLOR_NAME'                      #CSS color name, e.g. 'aquamarine'
                                  #Case insensitive
'[#]XXX[XXX]'                     #Hex color, no alpha
'[#]XXXX[XXXX]'                   #Hex color, alpha
'rgb(0-255, 0-255, 0-255)'        #
'rgba(0-255, 0-255, 0-255, 0-1)'  #
RGB[A]_OBJ                        #OBJ: r: 0-255, g: 0-255, b: 0-255 [, a: 0-1]
'hsl(0-360, 0-1, 0-1)'            #
'hsla(0-360, 0-1, 0-1, 0-1)'      #
HSL[A]_OBJ                        #OBJ: h: 0-360, s: 0-1, l: 0-1 [, a: 0-1]
'hsv(0-360, 0-1, 0-1)'            #
'hsva(0-360, 0-1, 0-1, 0-1)'      #
HSV[A]_OBJ                        #OBJ: h: 0-360, s: 0-1, v: 0-1 [, a: 0-1]

new TINYCOLOR(...)                #TC
TINYCOLOR.fromRatio(...)          #Same as new TINYCOLOR(...) except 0-255 -> 0-1

TC.getOriginalInput()->COLOR_INPUT#
TC.isValid()->BOOL                #If wrong COLOR_INPUT, does not throw
                                  #Instead, use #000000, and isValid() is false

TC.getFormat()->STR               #Among 'name', 'hex', 'rgb', 'hsl', 'hsv'
TC.toString([FORMAT])->STR        #Def FORMAT: same as input

TC.getAlpha()->0-1                #
TC.setAlpha(0-1)->TC              #

TINYCOLOR.names.COLOR_NAME        #'XXX' or 'XXXXXX'
TINYCOLOR.hexNames.XXX[XXX]       #'COLOR_NAME'

TC.toName()->'COLOR_NAME'         #
TC.toHex()->'XXXXXX'              #
TC.toHexString()->'#XXXXXX'       #
TC.toHex8()->'XXXXXXXX'           #
TC.toHex8String()->'#XXXXXXXX'    #
TC.toRgb()->RGBA_OBJ              #
TC.toRgbString()->'rgb[a](...)'   #
TC.toPercentageRgb()->RGBA_OBJ
TC.toPercentageRgbString()
 ->'rgba(...)'                    #r|g|b values are '0%-100%' instead
TC.toHsv()->HSVA_OBJ              #
TC.toHsvString()->'hsv[a](...)'   #
TC.toHsl()->HSLA_OBJ              #
TC.toHslString()->'hsl[a](...)'   #

TC.getBrightness()->0-255         #Perceived brightness (WACG 1.0)
                                  #Uses WACG 1.0, i.e. weighted 0-255 average of:
                                  #  - R (30% weight)
                                  #  - G (59% weight)
                                  #  - B (11% weight)
TC.isDark()->BOOL                 #Whether getBrightness() < 128
TC.isLight()->BOOL                #Opposite

TC.getLuminance()->0-1            #Perceived luminance (WACG 1.0)
                                  #Uses WACG 1.0, i.e. weighted average of:
                                  #  - R (21% weight)
                                  #  - G (72% weight)
                                  #  - B (7% weight)
                                  #After each value has been:
                                  #  - mapped to 0-1
                                  #  - ((value + 0.055) / 1.055) ** 2.4
                                  #     - if <4%, only: value / 12.92

TC.spin([NUM])->TC                #Def NUM: 0
                                  #Add NUM (0-360) to "h" (from hsl)
TC.saturate([NUM])->TC            #Def NUM: 10
                                  #Add NUM% to "s" (from hsl)
TC.desaturate([NUM])->TC          #Opposite
TC.greyscale()->TC                #Same as .desaturate(100)
TC.lighten([NUM])->TC             #Def NUM: 10
                                  #Add NUM% to "l" (from hsl)
TC.darken([NUM])->TC              #Opposite
TC.brighten([NUM])->TC            #Def NUM: 10
                                  #Add NUM% to "r", "g", "b" (from rgb)

TC.analogous(...)
TC.monochromatic(...)
TC.splitcomplement(...)
TC.triad(...)
TC.tetrad(...)
TC.complement(...)

TINYCOLOR.equals(...)
TINYCOLOR.mix(...)
TINYCOLOR.random(...)

TINYCOLOR.readability(...)
TINYCOLOR.isReadable(...)
TINYCOLOR.mostReadable(...)

TC.clone(...)
