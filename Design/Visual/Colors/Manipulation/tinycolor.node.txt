
                                  ┏━━━━━━━━━━━━━━━┓
                                  ┃   TINYCOLOR   ┃
                                  ┗━━━━━━━━━━━━━━━┛

VERSION ==>                       #1.6.0

                                  ┌───────────┐
                                  │   INPUT   │
                                  └───────────┘

COLOR                             #Any of the following
                                  #If any 'FUNC(VAL,...)', ( ) and , are optional
                                  #0-1 and 0-255 can be written 0%-100% too

TC                                #

'COLOR_NAME'                      #CSS color name, e.g. 'aquamarine'
                                  #Case insensitive

'[#]XXX[XXX]'                     #Hex color, no alpha
'[#]XXXX[XXXX]'                   #Hex color, alpha

'rgb(0-255, 0-255, 0-255)'        #
'rgba(0-255, 0-255, 0-255, 0-1)'  #
RGB[A]_OBJ                        #OBJ: r: 0-255, g: 0-255, b: 0-255 [, a: 0-1]

'hsl(0-360, 0-1, 0-1)'            #
'hsla(0-360, 0-1, 0-1, 0-1)'      #
HSL[A]_OBJ                        #OBJ: h: 0-360, s: 0-1, l: 0-1 [, a: 0-1]

'hsv(0-360, 0-1, 0-1)'            #
'hsva(0-360, 0-1, 0-1, 0-1)'      #
HSV[A]_OBJ                        #OBJ: h: 0-360, s: 0-1, v: 0-1 [, a: 0-1]

                                  ┌──────────┐
                                  │   INIT   │
                                  └──────────┘

new TINYCOLOR(COLOR)              #TC
TINYCOLOR.fromRatio(COLOR)        #Same as new TINYCOLOR() except 0-255 -> 0-1

new TINYCOLOR(TC)                 #Returns reference
TC.clone()->TC2                   #Returns copy

TC.getOriginalInput()->COLOR      #
TC.isValid()->BOOL                #If wrong COLOR, does not throw
                                  #Instead, use #000000, and isValid() is false

TC.getAlpha()->0-1                #
TC.setAlpha(0-1)->TC              #

TINYCOLOR.equals(COLOR, COLOR2)
 ->BOOL                           #Using rgba

TINYCOLOR.random()->TC            #Using rgb, no alpha

                                  ┌─────────────┐
                                  │   CONVERT   │
                                  └─────────────┘

TC.getFormat()->STR               #Among 'name', 'hex', 'rgb', 'hsl', 'hsv'
TC.toString([FORMAT])->STR        #Def FORMAT: same as input

TINYCOLOR.names.COLOR_NAME        #'XXX' or 'XXXXXX'
TINYCOLOR.hexNames.XXX[XXX]       #'COLOR_NAME'

TC.toName()->'COLOR_NAME'         #
TC.toHex()->'XXXXXX'              #
TC.toHexString()->'#XXXXXX'       #
TC.toHex8()->'XXXXXXXX'           #
TC.toHex8String()->'#XXXXXXXX'    #
TC.toRgb()->RGBA_OBJ              #
TC.toRgbString()->'rgb[a](...)'   #
TC.toPercentageRgb()->RGBA_OBJ
TC.toPercentageRgbString()
 ->'rgba(...)'                    #r|g|b values are '0%-100%' instead
TC.toHsv()->HSVA_OBJ              #
TC.toHsvString()->'hsv[a](...)'   #
TC.toHsl()->HSLA_OBJ              #
TC.toHslString()->'hsl[a](...)'   #

                                  ┌──────────────────┐
                                  │   MANIPULATION   │
                                  └──────────────────┘

TINYCOLOR.mix                     #Def: 50
 (COLOR, COLOR2[, 0-100])->TC     #Mix NUM% of COLOR2 into COLOR, using a mean on each rgba channel

TC.spin([NUM])->TC                #Def NUM: 0
                                  #Add NUM (0-360) to "h" (from hsl)
TC.complement()->TC               #Same as .spin(180)

TC.saturate([NUM])->TC            #Def NUM: 10
                                  #Add NUM% to "s" (from hsl)
TC.desaturate([NUM])->TC          #Opposite
TC.greyscale()->TC                #Same as .desaturate(100)

TC.lighten([NUM])->TC             #Def NUM: 10
                                  #Add NUM% to "l" (from hsl)
TC.darken([NUM])->TC              #Opposite
TC.brighten([NUM])->TC            #Def NUM: 10
                                  #Add NUM% to "r", "g", "b" (from rgb)

TC.splitcomplement()->TC_ARR      #Returns ARR of 3 TCs:
                                  #  - initial TC
                                  #  - initial + 72 "h" (from hsl)
                                  #  - initial - 144 "h" (from hsl)
TC.analogous([NUM[, NUM2]])       #Def NUM2: 30
 ->TC_ARR                         #Returns ARR of NUM TCs (def: 6), starting with TC,
                                  #where each TC uses .spin(360 / NUM2)
TC.triad|tetrad()->TC_ARR         #Same with 3|4 TCs with even modulo rotation
TC.monochromatic([NUM])->TC_ARR   #Returns ARR of NUM TCs (def: 6), starting with TC,
                                  #where each TC uses a modulo rotation of "v" (from hsv)

                                  ┌────────────────┐
                                  │   BRIGHTNESS   │
                                  └────────────────┘

TC.getBrightness()->0-255         #Perceived brightness (WACG 1.0)
                                  #Uses WACG 1.0, i.e. weighted 0-255 average of:
                                  #  - R (30% weight)
                                  #  - G (59% weight)
                                  #  - B (11% weight)
TC.isDark()->BOOL                 #Whether getBrightness() < 128
TC.isLight()->BOOL                #Opposite

TC.getLuminance()->0-1            #Perceived luminance (WACG 1.0)
                                  #Uses WACG 1.0, i.e. weighted average of:
                                  #  - R (21% weight)
                                  #  - G (72% weight)
                                  #  - B (7% weight)
                                  #After each value has been:
                                  #  - mapped to 0-1
                                  #  - ((value + 0.055) / 1.055) ** 2.4
                                  #     - if <4%, only: value / 12.92

                                  ┌─────────────────┐
                                  │   READABILITY   │
                                  └─────────────────┘

TINYCOLOR.readability             #Readability of both colors used together (WACG 2.0)
 (COLOR, COLOR2)->NUM             #Computes luminance of both, then: (higherLuminance + 0.05) / (lowerLuminance + 0.05)

TINYCOLOR.isReadable              #Whether readability is >=:
 (COLOR, COLOR2[, OPTS])->BOOL    #  - 'AA' + 'large': 3
                                  #  - 'AAA' + 'large' or 'AA' + 'small': 4.5
                                  #  - 'AAA' + 'small': 7.5
OPTS.level                        #'AA' (def) or 'AAA'
OPTS.size                         #'small' (def) or 'large'

TINYCOLOR.mostReadable
 (COLOR, COLOR2_ARR[, OPTS])->TC  #Returns COLOR2 with highest readability(COLOR, COLOR2)
OPTS.includeFallbackColors        #BOOL (def: false)
                                  #If true (def) and !isReadable(), use either white|black, whichever is more redable
                                  #Note: if true, OPTS.includeFallbackColors mutated to false, i.e. should pass shallow copy
OPTS.level|size                   #As above
