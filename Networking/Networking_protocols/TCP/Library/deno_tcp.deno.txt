
            
   DENO_TCP  
            



VERSION ==>                       #See deno doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             OPEN              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Deno.connect(TCP_OPTS)->>CONN    !#Connect to TCP socket
Deno.listen(STCP_OPTS)->>LISTENER!#Open TCP socket

[S]TCP_OPTS|ADDR.transport        #Either:
                                 N#  - 'tcp': normal TCP socket
                              [W]R#  - 'unix': Unix TCP socket
[S]TCP_OPTS|ADDR.hostname         #'HOSTNAME'. Not with Unix socket
                                  #Def: '127.0.0.1' (Deno.connect()) or '0.0.0.0' (Deno.listen())
[S]TCP_OPTS|ADDR.port             #NUM. Not with Unix socket
[S]TCP_OPTS|ADDR.path             #'PATH'. Only with Unix socket
STCP_OPTS.reusePort               #BOOL (def: false). If true, allows multiple processes to listen on same port,
                                  #distributing new connections among them.
                                  #Uses SO_REUSEPORT, Linux only.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            LISTEN             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


LISTENER                          #CONN_ASYNC_ITERABLE. Inherits CLOSER
LISTENER.rid                      #RID
LISTENER.[un]ref()                #Set whether ref'd by the current process
LISTENER.addr                     #ADDR of source
LISTENER.accept()->>CONN          #Like LISTENER.next()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SEND              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONN                              #Inherits CLOSER|READER|WRITER
CONN.rid                          #RID
CONN.[un]ref()                    #Set whether ref'd by the current process
CONN.localAddr|remoteAddr         #ADDR of source|destination
CONN.readable                     #RSTREAM
CONN.writable                     #WSTREAM
Deno.shutdown(CONN.rid)
CONN.closeWrite()                 #Stops sending, but not receiving.
CONN.setNoDelay([BOOL])           #BOOL. If true (def), disable Nagle's algorithm
                                  #Only with tranport 'tcp'
CONN.setKeepAlive([BOOL])         #BOOL. If true (def), enable TCP keepalive
                                  #Only with tranport 'tcp'
