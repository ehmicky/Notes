
             
   CFN-GUARD  
             



TODO:
  - https://github.com/aws-cloudformation/cloudformation-guard/
  - install and check flags and behavior
  - lambda:
     - https://docs.aws.amazon.com/cfn-guard/latest/ug/setting-up-lambda.html
     - https://github.com/aws-cloudformation/cloudformation-guard/tree/main/guard-lambda
  - https://github.com/aws-cloudformation/aws-guard-rules-registry
  - https://github.com/aws-cloudformation/resource-schema-guard-rail

VERSION ==>                       #3.0.1
                                  #Installed through homebrew, cargo
                                  #Or install script, which downloads GitHub release binary and install to ~/.guard/bin/cfn-guard

cfn-guard                         #Declarative JSON|YAML validation
                                  #Meant as Policy-as-Code for CloudFormation, but can be used for anything
                                  #Similar to JSONPath, but more advanced DSL, and uses assertions (with OPs)

cfn-guard validate                #Validate RULEs against IDATA
                                  #Non-0 exit code on failure
--rules|-r                        #'RULE_FILE'
                                  #Can be either a file, or a DIR (it then uses DIR/*)
--data|-d                         #'IDATA_FILE'
                                  #Can be either a file, or a DIR (it then uses DIR/*)
--payload|-P                      #Alternative to using --rules|--data
                                  #Provides both as an OBJ: rules 'RULE'_ARR, data 'IDATA'_ARR
                                  #Can be passed as stdin too
--output-format|-o                #One of:
                                  #  - 'single-line-summary' (def)
                                  #  - 'json'
                                  #  - 'yaml'
--print-json|-p                   #Same as --output-format json. Or for evaluation summary instead???
--show-summary                    #Specifies the verbosity of the Guard rule evaluation summary.
                                  #One of:
                                  #  - 'all' (def): displays the full summary
                                  #  - 'pass,fail': only displays summary information for rules that passed or failed
                                  #  - 'none': does not display summary information
--type|-t                         #Input data format. Either:
                                  #  - default: displays property paths and values, such as `Property [/Resources/vol2/Properties/Encrypted`
                                  #  - 'CFNTemplate': Guard displays the logical names of CloudFormation template resources in the output
--verbose|-v                      #Increases the output verbosity. Can be specified multiple times.
                                  #The verbose output follows the structure of the Guard rules file.
                                  #Every block in the rules file is a block in the verbose output.
                                  #The top-most block is each rule.
                                  #If there are when conditions against the rule, they appear as a sibling condition block.
--show-clause-failures|-s         #Shows clause failure including a summary.
--last-modified|-m                #Run --rules|--data DIR/* in mtime order
--alphabetical|-a                 #Run --rules|--data DIR/* in alphabetical order

cfn-guard test                    #Validate RULEs against TDATA
                                  #Meant to unit test RULEs
                                  #Non-0 exit code on failure
--rules-file|-r                   #Like cfn-guard validate --rules
--test-data|-t                    #Like cfn-guard validate --data, but as 'TDATA_FILE'
--last-modified|-m
--alphabetical|-a
--verbose|-v                      #Like cfn-guard validate

cfn-guard rulegen                 #Scaffold rules from a TEMPLATE
                                  #Create one rule per RESPROP, requiring it to be equal
--output|-o                       #'PATH' (def: stdout)
--template|-t                     #'PATH' to TEMPLATE

cfn-guard parse-tree              #Parse rules
--rules|-r                        #'PATH'
--output|-o                       #'PATH' (def: stdout)
--print-json|-j
--print-yaml|-y                   #JSON (def) or YAML

IDATA                             #Input data to `cfn-guard validate`
                                  #Any JSON|YAML OBJ, although originally meant for CloudFormation TEMPLATEs

TDATA                             #Input datas to `cfn-guard test`
                                  #JSON|YAML ARR of TDATUM
                                  #Often filename ends with _tests.json|yaml
TDATUM.name                       #'TEST_NAME'
TDATUM.input                      #IDATA
TDATUM.expectations.rules.RULE_SET#Asserts that RULE_SET:
                                  #  - 'PASS'
                                  #  - 'FAIL'
                                  #  - 'SKIP', due to:
                                  #     - `when CLAUSE`
                                  #     - [...] filter resolving to empty

RULE                              #Newline-separated CLAUSEs
                                  #Often use file extension .guard

#COMMENT                          #

QUERY OP [QUERY|VAL]              #CLAUSE
                                  #Assertion on IDATA

CLAUSE <<MESSAGE>>                #Error message displayed with cfn-guard validate|test --verbose
                                  #Can include newlines or trailing whitespaces, ignored

CLAUSE [or]                       #Relation between CLAUSEs is either:
CLAUSE2                           #  - and (default)
                                  #  - `or`
                                  #`or` has higher priority than `and`

{ ... }                           #Block with CLAUSEs

QUERY { ... }                     #Sets `this` as QUERY inside { ... }
this                              #Implicitely prepended to each QUERY
                                  #Initially set to IDATA
                                  #Joined with . unless QUERY starts with [
                                  #Can also be used explicitly
                                  #To keep track of current `this` in children { ... }, can use `let MVAR = this`

when CLAUSE { ... }               #Ignore { ... } if CLAUSE is false

rule RULE_SET { ... }             #CLAUSE composed on the product of all the CLAUSEs in the block
                                  #Also called "named-rule block"
                                  #RULE_SET can be used as a CLAUSE inside another RULE_SET's `when` or block
rule RULE_SET when CLAUSE { ... } #Combine `rule` and `when`

QUERY                             #Performed on input data OBJ
                                  #All of the following are QUERYs, are can be chained
VAR                               #Input data OBJ.VAR
QUERY.VAR
QUERY.'VAR'                       #
QUERY[NUM]                        #
QUERY.*                           #All OBJ values
QUERY[*]                          #All ARR values
                                  #If not an ARR, noop
                                  #  - but does not fail
                                  #  - this allows traversing values that are optionally ARRs
QUERY[...]
QUERY[
  ...                             #Filter only elements with CLAUSEs true, where [...] is a block of CLAUSEs
]                                 #Each ARR item is `this` inside [...]

EMPTY QUERY ==>                   #Resolves to false:
                                  #  - QUERY.VAR or QUERY[NUM] that is unknown
                                  #     - except with `exists|empty`
                                  #  - QUERY.* or QUERY[*] on empty OBJ|ARR
                                  #     - except with `empty`, or when followed by [...] filter
                                  #Resolves to true:
                                  #  - QUERY[...] resulting to empty OBJ|ARR
let MVAR = QUERY
when %MVAR !empty {
  %MVAR.QUERY2 ...
}                                 #Common pattern to allow possibly empty queries

let MVAR = VAL                    #Define MVAR as a VAL
                                  #Lexical scope: if inside { ... }, can only be used inside it
                                  #Actual variable, not macro
let MVAR = [some] QUERY           #Define MVAR
                                  #If QUERY returns ARR:
                                  #  - if `some`: only first item
                                  #  - if only 1 item: can be used as VAL
%MVAR                             #Reference MVAR
                                  #Can be inside a QUERY, e.g. %MVAR.VAR or VAR.%MVAR
                                  #Cannot be inside <<MESSAGE>> nor REGEXP

[some] ARR OP ...                 #Performs OP on each ARR item
                                  #Result is and'd (def) or or'd (`some`)
QUERY.*
QUERY[*]                          #Resolve to ARR. The rest of the QUERY operates on each item
[some] QUERY { ... }              #Each ARR item evaluates its own { ... }
                                  #Result is and'd (def) or or'd (`some`)

OP                                #One of the following
not OP
!OP                               #

VAL == != VAL2                    #
VAL IN [VAL2,...]                 #
VAL exists                        #Is undefined
VAL empty                         #Is undefined, or empty STR|ARR|OBJ

NUM < <= > >= NUM2                #
NUM IN r[NUM2, NUM3]              #NUM2 <= NUM <= NUM3
                                  #Can also use r[...) r(...] r(...) to use < instead

"CHAR" IN r[...]                  #Same as IN r[NUM, NUM] but with CHARs
STR == /REGEXP/                   #
STR IN [/REGEXP/,...]             #

VAL is_null                       #Is null
VAL is_bool                       #Is BOOL
VAL is_int                        #Is INT
VAL is_float                      #Is FLOAT
VAL is_string                     #Is STR
VAL is_struct                     #Is OBJ
VAL is_list                       #Is ARR

null                              #
true|false                        #BOOL
INT                               #8 bytes
FLOAT                             #8 bytes
"..."                             #STR
/.../                             #REGEXP
{ "VAR": VAL, ... }               #OBJ
[VAL,...]                         #ARR
