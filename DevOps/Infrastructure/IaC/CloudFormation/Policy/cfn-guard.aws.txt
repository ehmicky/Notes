
             
   CFN-GUARD  
             



TODO:
  - check flags and behavior
  - lambda:
     - https://docs.aws.amazon.com/cfn-guard/latest/ug/setting-up-lambda.html
     - https://github.com/aws-cloudformation/cloudformation-guard/tree/main/guard-lambda
  - https://github.com/aws-cloudformation/aws-guard-rules-registry
  - https://github.com/aws-cloudformation/resource-schema-guard-rail

VERSION ==>                       #3.0.1
                                  #Installed through homebrew, cargo
                                  #Or install script, which downloads GitHub release binary and install to ~/.guard/bin/cfn-guard

cfn-guard                         #Declarative JSON|YAML validation
                                  #Meant as Policy-as-Code for CloudFormation, but can be used for anything
                                  #Similar to JSONPath, but more advanced DSL, and uses assertions (with OPs)

cfn-guard completions             #Shell autocompletion
--shell|-s                        #bash|zsh|fish

cfn-guard validate                #Validate RULES against IDATA
                                  #Non-0 exit code on failure
--rules|-r                        #'RULES_FILE|DIR'
                                  #If DIR, uses DIR/*.guard|ruleset
                                  #Can be specified multiple times
--data|-d                         #'IDATA_FILE|DIR'
                                  #If DIR, uses DIR/*.y[a]ml|js[o]n|template
                                  #Can be specified multiple times
--input-parameters|-i             #Like --data, but merged to it
--payload|-P                      #Alternative to using --rules|--data
                                  #Provides both as an OBJ: rules 'RULES'_ARR, data 'IDATA'_ARR
                                  #Can be passed as stdin too
--output-format|-o                #One of:
                                  #  - 'single-line-summary' (def)
                                  #  - 'json'
                                  #  - 'yaml'
--print-json|-p                   #Same as --output-format json. Or for evaluation summary instead??? Print parse tree???
--show-summary                    #Whether to print RULEs that are:
                                  #  - 'all': FAIL|PASS|SKIP
                                  #  - 'skip': SKIP
                                  #  - 'pass': PASS
                                  #  - 'fail' (def): FAIL
                                  #  - 'STR,...': combination
                                  #  - 'none': none
--type|-t                         #Input data format. Either:
                                  #  - default: displays property paths and values, such as `Property [/Resources/vol2/Properties/Encrypted`
                                  #  - 'CFNTemplate': Guard displays the logical names of CloudFormation template resources in the output
--verbose|-v                      #Increases the output verbosity. Can be specified multiple times.
                                  #The verbose output follows the structure of the Guard rules file.
                                  #Every block in the rules file is a block in the verbose output.
                                  #The top-most block is each rule.
                                  #If there are when conditions against the rule, they appear as a sibling condition block.
--show-clause-failures|-s         #Shows clause failure including a summary.
--last-modified|-m                #Run --rules|--data DIR/* in mtime order
--alphabetical|-a                 #Run --rules|--data DIR/* in alphabetical order
--structured|-z                   #Print out a list of structured and valid JSON/YAML???

cfn-guard test                    #Validate RULES against TDATA
                                  #Meant to unit test RULES
                                  #Non-0 exit code on failure
--rules-file|-r                   #Like cfn-guard validate --rules
--test-data|-t                    #Like cfn-guard validate --data, but as 'TDATA_FILE'
--last-modified|-m
--alphabetical|-a
--verbose|-v                      #Like cfn-guard validate
--dir|-d                          #'DIR' (def: '.'). Cwd for --rules-dir|test-data file paths

cfn-guard rulegen                 #Scaffold rules from a CloudFormation TEMPLATE
                                  #Create one CLAUSE per RESPROP, requiring it to be equal
--template|-t                     #'PATH' to TEMPLATE
--output|-o                       #'RULES_FILE' (def: stdout)

cfn-guard parse-tree              #Parse RULES into a JSON format (not documented yet)
                                  #Fails if syntax error, i.e. can be used for validation
--rules|-r                        #'RULES_FILE'
--output|-o                       #'PATH' (def: stdout)
--print-json|-p
--print-yaml|-y                   #JSON (def) or YAML

IDATA                             #Input data to `cfn-guard validate`
                                  #Any JSON|YAML OBJ, although originally meant for CloudFormation TEMPLATEs

TDATA                             #Input datas to `cfn-guard test`
                                  #JSON|YAML ARR of TDATUM
                                  #Often filename ends with _tests.json|yaml
TDATUM.name                       #'TEST_NAME'
TDATUM.input                      #IDATA
TDATUM.expectations.rules.RULE    #Asserts that RULE:
                                  #  - 'PASS'
                                  #  - 'FAIL'
                                  #  - 'SKIP', due to:
                                  #     - `when CLAUSE`
                                  #     - [...] filter resolving to empty

RULES                             #Newline-separated top-level:
                                  #  - RULE ("named rule"/"rule set")
                                  #  - CLAUSE ("unnamed rule")
                                  #  - when|QUERY { ... } blocks
                                  #Often use file extension .guard

#COMMENT                          #

{ ... }                           #Block with CLAUSEs
                                  #Can be nested

rule RULE { ... }                 #"Named rule"/"rule set". RULE composed on the product of all the CLAUSEs in the block
UNNAMED RULE ==>                  #All top-level CLAUSEs are implicitely put in `rule default { ... }`
[not] RULE                        #Can be used as a CLAUSE
                                  #  - only with:
                                  #     - `when`: meant to reduce verbosity by showing early errors first
                                  #     - inside another `rule`: meant to show that a rule failed due to another
                                  #  - the RULE is still evaluated at the top level
                                  #  - not with `default`

when CLAUSE { ... }               #Skip { ... } if CLAUSE is false
rule RULE when ... { ... }        #Combine `rule` and `when`

QUERY { ... }                     #Sets `this` as QUERY inside { ... }
this                              #Implicitely prepended to each QUERY (unless it starts with `this`), joined with .
                                  #Can also be used explicitly
                                  #Initially set to IDATA
                                  #To keep track of current `this` in children { ... }, can use `let MVAR = this`

QUERY OP [VAL|QUERY2]             #CLAUSE
                                  #Assertion on IDATA

CLAUSE <<MESSAGE>>                #Error message displayed with cfn-guard validate|test --verbose
                                  #Can include newlines or trailing whitespaces, ignored

CLAUSE [or]                       #Relation with next CLAUSE is either:
CLAUSE2                           #  - and (default)
                                  #  - `or`
                                  #`or` has higher priority than `and`

QUERY                             #Performed on input data OBJ
                                  #All of the following are QUERYs, are can be chained
VAR                               #Input data OBJ.VAR
                                  #To start with others (e.g. [*] .* [NUM] [...]), must use `this`
QUERY.VAR
QUERY."VAR"
QUERY.'VAR'
QUERY["VAR"]
QUERY['VAR']                      #
QUERY[NUM]                        #
QUERY.*                           #All OBJ values
QUERY[*]                          #All ARR values
                                  #If not an ARR, noop
                                  #  - but does not fail
                                  #  - this allows traversing values that are optionally ARRs
QUERY[...]
QUERY[
  ...                             #Filter only elements with CLAUSEs true, where [...] is a block of CLAUSEs
]                                 #Each ARR item is `this` inside [...]

EMPTY QUERY ==>                   #Resolves to false:
                                  #  - QUERY.VAR or QUERY[NUM] that is unknown
                                  #     - except with `exists|empty`
                                  #  - QUERY.* or QUERY[*] on empty OBJ|ARR
                                  #     - except with `empty`, or when followed by [...] filter
                                  #Resolves to true:
                                  #  - QUERY[...] resulting to empty OBJ|ARR
let MVAR = QUERY
when %MVAR !empty {
  %MVAR.QUERY2 ...
}                                 #Common pattern to allow possibly empty queries

let MVAR = VAL                    #Define MVAR as a VAL
                                  #Lexical scope: if inside { ... }, can only be used inside it
                                  #Actual variable, not macro
let MVAR = [some] QUERY           #Define MVAR
                                  #If QUERY returns ARR:
                                  #  - if `some`: only first item
                                  #  - if only 1 item: can be used as VAL
let MVAR = RULE                   #???
%MVAR                             #Reference MVAR
                                  #Can be inside a QUERY, e.g. %MVAR.VAR or VAR.%MVAR
                                  #Cannot be inside <<MESSAGE>> nor REGEXP

[some] ARR OP ...                 #Performs OP on each ARR item
                                  #Result is and'd (def) or or'd (`some`)
                                  #Stops at first false (def) or true (`some`), i.e. faster
                                  #Also MFUNC???
QUERY.*
QUERY[*]                          #Resolve to ARR. The rest of the QUERY operates on each item
[some] QUERY { ... }              #Each ARR item evaluates its own { ... }
                                  #Result is and'd (def) or or'd (`some`)
                                  #Does not stop at first false (def) or true (`some`), i.e. more thorough output

OP                                #One of the following
not OP                            #
!OP                               #Same. No space after !

VAL == != VAL2                    #
VAL IN [VAL2,...]                 #
VAL exists                        #Is undefined
VAL empty                         #Is undefined, or empty STR|ARR|OBJ

NUM < <= > >= NUM2                #
NUM IN r[NUM2, NUM3]              #NUM2 <= NUM <= NUM3
                                  #Can also use r[...) r(...] r(...) to use < instead

"CHAR" IN r[...]                  #Same as IN r[NUM, NUM] but with CHARs
STR == /REGEXP/                   #
STR IN [/REGEXP/,...]             #

VAL is_null                       #Is null
VAL is_bool                       #Is BOOL
VAL is_int                        #Is INT
VAL is_float                      #Is FLOAT
VAL is_string                     #Is STR
VAL is_struct                     #Is OBJ
VAL is_list                       #Is ARR

VAL                               #Any JSON value|type
/.../                             #REGEXP. Check if "/REGEXP/" is same ???

MFUNC(...)                        #Execute MFUNC(...). Must be either:
                                  #  - assigned to MVAR: let MVAR = MFUNC(...)
                                  #  - on right side of OP: QUERY OP MFUNC(...)
                                  #Cannot be on left side of OP
count(ARR)->NUM                   #
join(ARR, "DELIM")->STR           #
to_lower|to_upper(STR)->STR       #
substring(STR, NUM, NUM2)->STR2   #NUM is inclusive, NUM2 exclusive
regex_replace(STR, "REGEXP", STR2)
 ->STR3                           #Capture groups in STR2 must be ${NUM} (1-based)
json_parse(STR)->OBJ              #
url_decode(STR)->STR2             #
