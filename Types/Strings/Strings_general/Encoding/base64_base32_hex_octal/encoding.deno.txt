
            
   ENCODING  
            



VERSION ==>                       #See Deno doc
                                  #Part of std

std/encoding/base64.ts            #STR <-> base64
encode(STR|UINT8ARR)->STR         #
decode(STR)->UINT8ARR             #

std/encoding/base64url.ts         #Same with base64url
encode(STR|UINT8ARR)->STR         #
decode(STR)->UINT8ARR             #

std/encoding/base58.ts            #Same with base58
encode(STR|UINT8ARR)->STR         #
decode(STR)->UINT8ARR             #

std/encoding/base32.ts            #Same with base32
byteLength(STR)->NUM              #
encode(STR|UINT8ARR)->STR         #
decode(STR)->UINT8ARR             #

std/encoding/ascii85.ts           #Same with base85
encode(STR|UINTARR[, OPTS])->STR  #
decode(STR[, OPTS])->UINT8ARR     #
OPTS.delimiter                    #BOOL (def: false). Use delimiters <~ and ~>
OPTS.standard                     #'Adobe|btoa|RFC 1924|Z85'

std/encoding/hex.ts               #Same with hexadecimal
encode(STR|UINT8ARR)->STR         #
decode(STR)->UINT8ARR             #

std/encoding/binary.ts            #

readExact(READER, UINT8ARR)->>    #Like READER.read(UINT8ARR) but repeats it until UINT8ARR.length bytes read
getNBytes(READER, NUM)->>UINT8ARR #Like readExact(READER, new Uint8Array(NUM))

TYPE                              #'[u]int8|16|32|64' or 'float32|64'
sizeof('TYPE')->1|2|4|8           #
varnum(UINT8ARR[, OPTS])->NUM|null#Reads a specific TYPE from UINTARR
                                  #null if too large
                                  #OPTS:
                                  #  - type 'TYPE' (def: 'int32')
                                  #  - endian 'big' or 'little' (def)
putVarnum(UINT8ARR, NUM[, OPTS])  #Like varnum() but sets instead
 ->NUM2                           #Returns sizeof('TYPE')
readVarnum(READER[, OPTS])
 ->>NUM|null
writeVarnum(WRITER, NUM[, OPTS])
 ->>NUM2                          #Same but on a READER|WRITER
varnumBytes(NUM[, OPTS])->UINTARR #Like varnum() but creates a new UINTARR
varbig(...)
putVarbig(...)
readVarbig(...)                   #Same but:
writeVarbig(...)                  #  - returns BIGINT
varbigBytes(...)                  #  - default OPTS.type 'int64'
