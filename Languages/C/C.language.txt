
                
   C_SYNTHESE   
                

                                  ┌──────────────────┐
                                  │   AVANT-PROPOS   │
                                  └──────────────────┘

VERSIONS DE C ==>       #Créé en 1972. Trois standards :
                        #  - C89, avec 15 standard libraries notamment
                        #  - En 1995, iso646.h, wchar.h et wctype.h sont ajoutés
                        #    pour le support Unicode et international
                        #  - C99, avec notamment 6 standard libraries en plus :
                        #    complex.h, fenv.h, inttypes.h, stdbool.h,
                        #    stdint.h, and tgmath.h, notamment pour les
                        #    mathématiques poussées, et la résolution des
                        #    problèmes liés à la taille d'un int

CONVENTIONS D'ECRITURE  #Voici celles que j'utiliserai.
 ==>                    #Les suffixes :

VAR                     #Nom de variable ("label") contenant une LIT, et non
                        #une adresse.
ADR                     #Nom de variable ("label") contenant une adresse mémoire
                        #("pointeur")
LIT                     #Valeur littérale, data, simple (ex : 3, 'h') ou composé
                        #(ex : 1 + 1)
VAL                     #VAR ou LIT (dont FONC_LIT)

                        #Les préfixes :

CHAR_                   #Type char
SHORT_                  #Type short
INT_                    #Type int
LONG_                   #Type long
LONG_LONG_              #Type long long
TOUINT_                 #Type short, int, long ou long long
SIZE_T_                 #Type size_t, souvent un unsigned int
SSIZE_T_                #Type ssize_t, souvent un signed int
WCHAR                   #Type wchar_t

FLOAT_                  #Type float
DOUBLE_                 #Type double
LONGDOUBLE_             #Type long double
TOUFLOAT_               #Type float, double ou long double

U_                      #Unsigned

VOID_                   #Type void
FONC_                   #Fonction. FONC_VAR est le nom de la fonction, FONC_LIT
                        #la valeur qu'elle retourne.

                        #Les types complexes :

STKT                    #Type struct
STKTMBR                 #Type "membre de structure"
UNIO                    #Type union
UNIOMBR                 #Type "membre d'union"
ENUM                    #Type enum

                        #Les spéciaux :

ARR                     #Array, utilisé comme une ADR. ARR_ADR équivaut donc à
                        #une ADR_ADR.
STR                     #String, il s'agit d'une ARR, plus précisément d'une
                        #CHAR_ADR. STR_LIT signifie "STR" (dont les " ")
WSTR                    #Array de WCHAR
FILE                    #Pointeur vers un fichier, utilisé comme une ADR.
TYPE                    #Mot renvoyant un type :
                        #  - simple ("unsigned char", "int", etc.)
                        #  - complexe ("struct MOT", "enum MOT")
                        #  - créé par typedef
                        #Il peut être :
                        #  - précédé facultativement de const et/ou volatile
                        #  - précédé facultativement de extern, auto, register
                        #    ou static
                        #  - précédé facultativement de inline, pour une 
                        #    fonction
                        #  - suivi de * s'il s'agit d'un type de pointeur
                        #  - suivi de *() s'il s'agit d'un type de pointeur de 
                        #    fonction
MOT                     #Mot arbitraire.

KEYWORDS ==>            #Les voici :

auto      break     case      char      const     continue  default   do       
double    else      enum      extern    float     for       goto      if       
int       long      register  return    short     signed    sizeof    static   
struct    switch    typedef   union     unsigned  void      volatile  while     

IDENTIFIERS ==>         #Désigne :
                        #  - un nom de variable ("label"), pointeur ou non, ou 
                        #    de fonction.
                        #  - la nom d'une structure, union ou enum
                        #Limitations :
                        #  - maximum 31 caractères
                        #  - [[:alpha:]_][[:alnum:]_]\*
                        #  - une extern variable ou fonction a souvent besoin 
                        #    d'être unique dans ses 6 premiers caractères.
                        #Recommandations :
                        #  - const variables, #define macros et variables
                        #    globales doivent être en uppercase
                        #  - Si l'identifier contient plusieurs mots, les 
                        #    séparer par _, ou mettre une majuscule au début de
                        #    chaque mot concaténé.

DATA OBJECT ==>         #Désigne une variable, pointeur ou non, par opposition
                        #aux fonctions.

TRIGRAPHES ==>          #Obsolète.
                        #Pour les systèmes de disposant pas de tout ASCII lors
                        #de la compilation (option -trigraphs avec gcc),
                        #remplace les caractères manquant par des trigraphes :
??=                     #  - #
??(                     #  - [
??)                     #  - ]
??<                     #  - {
??>                     #  - }
??/                     #  - \
??!                     #  - |
??-                     #  - ~
??'                     #  - ^

                                  ┌─────────────────┐
                                  │   GENERALITES   │
                                  └─────────────────┘

int main(void) {        #La fonction main() est la fonction principale d'un
    COMMANDES ;...      #programme C. Obligatoirement nommée ainsi. Retourne une
    return EXIT_SUCCESS;#INT_LIT à l'environnment (pour qui souvent 0 == succès
}                       #et 1 == échec).
                        #main() doit donc retourner la valeur de vérité de
                        #l'environnment (constante EXIT_SUCCESS, souvent = 0, et
                        #opposée à EXIT_FAILURE, souvent = 1, voir <stdlib.h>)
                        #Le programme commence et s'achève avec main()
                        #main() n'a pas d'arguments, d'où le "void", sauf dans
                        #le cas qui suit.
int main(int argc       #Seul moyen pour donner des arguments à main(), dans cet
[, char *argv[]]        #ordre, et avec cette syntaxe.
[, char *arge[]]) {     #  - argc contient le nombre d'arguments positionnels de
    ...                 #    l'exécutable lors de son exécution (le script étant
                        #    lui-même un argument, l'argument n°0).
                        #  - argv est un array de strings contenant les
                        #    arguments positionnels. Elle trie automatiquement
                        #    ces derniers pour placer les options avant les
                        #    opérandes
                        #  - arge est un array de strings contenant les
                        #    environment variables sous la forme VAR=VAL. Il
                        #    est plus portable d'utiliser la variable globale
                        #    environ. Utiliser donc plutôt environ. Dans tous
                        #    les cas, c'est propre à Unix
                        #C'est le système qui invoquera main() avec ces trois
                        #arguments en fonction des arguments passés au programme
                        #en ligne de commande.
                        #Les noms des variables peuvent être différents, mais
                        #il s'agit de la convention.

COMMANDES;              #Une commande se termine toujours par ;, sauf les
                        #instructions au pré-processeur, qui se terminent par
                        #newline.
                        #Les whitespaces, dont newline, servent à séparer la 
                        #plupart des tokens (bien que non-nécessaire parfois, 
                        #comme pour FONC_VAR() ou FONC_VAR (), ou VAR++ ou 
                        #VAR ++). Leur nature et nombre n'importe pas (on peut
                        #utiliser les espaces autant que les newlines)
                        #Exception : entre deux " " ou ' ', on ne peut pas 
                        #inclure de newline, sauf en faisant un trailing newline
                        #auquel cas la tabulation qui suit est prise en compte
                        #dans les guillemets. Pour éviter cela, il est possible
                        #de fermer des " ", faire une newline, puis rouvrir les
                        #" ", qui seront concaténées toutes les deux.
                        #Les trailing newlines sont possibles pour les 
                        #instructions au pré-processeur aussi.

/*commen-
taires*/                #Commentaires, remplacés par un single espace par le
//commentaires          #préprocesseur

CASSE ==>               #C est sensible à la casse

VOCABULAIRE ==>         #Voici :

bloc                    #Ensemble de commandes entourées de { }

définir                  #Annoncer qu'une variable ou fonction existe, et qu'elle
                        #doit être utiliser sous ce type ou prototype. Toute
                        #définition déclare en même temps.
déclarer               #Synonyme de définir, sauf dans le cas d'un fichier 
                        #voulant utiliser une variable ou fonction définie dans
                        #un autre fichier : il ne peut pas la redéfinir, mais
                        #doit la redéclarer.
initialiser
affecter                #Associer une valeur à une variable
exécuter
déréférencer           #Utiliser la valeur affectée à une variable

ORDRE RECOMMANDE ==>    #Il est recommandé de suivre cet ordre :
                        #Un bloc doit commencer par :
                        #  - les déclarations
                        #  - puis les initialisations
                        #  - puis les exécutions
                        #Une fonction doit :
                        #  - être déclarée avant la fonction dans laquelle elle 
                        #    s'exécute (si cette dernière est dans le même 
                        #    fichier), et en dehors de tout bloc
                        #  - être exécutée dans un bloc
                        #  - être définie en dehors de tout bloc, après la 
                        #    fonction dans laquelle, etc.
                        #Une variable :
                        #  - doit être déclarée avant d'être initialisée, ou les
                        #    deux en même temps
                        #  - doit être déclarée et initialisée avant d'être 
                        #    exécutée

MANIPULATION DE
VARIABLES ==>           #Voici :

TYPE1 VAR1[ = VAL1]     #Déclare VAR... avec comme type TYPE1
[, [TYPE2] VAR2         #Si [ = VAL], affecte également VAL à VAR
[ =VAL2]]...            #Sit [TYPE2] est omis, TYPE1 est utilisé.
VAR                     #Exécute VAR

QUALIFIERS ==>          #Ils précèdent TYPE lors d'une déclaration uniquement :

const                   #Indique que la variable sera read-only (constante). Sa
                        #valeur est écrite en dur dans l'exécutable.
                        #Si TYPE désigne un pointeur :
                        #  - const TYPE *VAR signifie que la valeur pointée par
                        #    VAR est read-only
                        #  - TYPE const *VAR signifie que le pointeur lui-même
                        #    est read-only (et non sa valeur pointée)

volatile                #Empêche le compiler d'optimiser cette variable, par
                        #exemple en la supprimant (si inutile) ou en changeant
                        #son type tel que déclaré dans le source.
                        #Utilité possible : 
                        #  - permet à une variable sig_atomic_t de rester 
                        #    sig_atomic_t, et donc utilisable par un signal 
                        #    handler.
                        #  - avec longjmp : cf doc
                        #  - avec une variable static pouvant être accédée par
                        #    autre chose que le programme courant (par exemple
                        #    si on fait en sorte qu'elle soit dans un registre
                        #    CPU), et testée alors que sa valeur semble connue
                        #    à l'échelle du programme => évite l'optimisation
                        #    out.
                        #  - Autre exemple : variable partagée par deux threads
                        #    assez petite pour être optimisée dans un registre 
                        #    CPU, ou classe partagée dont l'une de ses CLASSDT
                        #    partagée peut l'être ; auquel cas elle deviendrait
                        #    locale à chaque thread.
                        #    Cela ne s'applique pas aux variable déclarées dans
                        #    des critical sections, qui ne peuvent pas être
                        #    partagées par plusieurs threads par définition :
                        #    utiliser éventuellement const_cast.

                                  ┌─────────────────┐
                                  │   COMPILATION   │
                                  └─────────────────┘

COMPILATION ==>     #Voici les étapes de la création d'un exécutable, à partir 
                    #d'un code source. Pour chaque fichier source
                    #(extension .c) :
                    #  - Le préprocesseur fait des remplacements de texte en
                    #    fonction des instructions commençant par #
                    #  - La compilation (compile-time) parse le contenu pour le 
                    #    traduire en assembleur (donne des résultats différents
                    #    en fonction de l'OS, car chaque OS a différents system
                    #    calls)
                    #  - L'assemblage traduit l'assembleur en langage machine 
                    #    (fichier objet)
                    #  - Le linking (link-time) lie les différents fichiers 
                    #    sources (s'il y en plusieurs) sous forme d'un seul 
                    #    exécutable (parfois appelé improprement loading)

LOADING ==>         #Le loading est le lancement d'un exécutable (exécuté par le
                    #system call execve() sous Unix), avec :
                    #  - la validation du lancement
                    #  - la copie en mémoire des éléments nécessaires au 
                    #    lancement du programme
                    #  - la création de la stack frame de ce programme
                    #  - l'initialisation des registres (dont le stack pointer)
                    #  - le saut vers l'adresse du code copié en mémoire

RUNTIME ==>         #Exécution à proprement parler de l'exécutable. Si une
                    #library dynamique est requise, elle est alors copiée en
                    #mémoire.

HEADERS ==>         #Un header est un fichier texte écrit en C, contenant des 
                    #déclarations de :
                    #  - constantes
                    #  - fonctions
                    #  - structures, unions et enum
                    #  - typedef
                    #  - enum
                    #et des instructions au préprocesseur, mais pas
                    #d'initialisations (sauf pour les constantes). Ainsi, seule 
                    #l'interface (l'aspect syntaxique) et non l'implémentation 
                    #(comment la fonction agit) est défini.
                    #L'extension est souvent .h sous Unix.
                    #L'extension pour un fichier C préprocessed, mais pas 
                    #compilé est souvent .i
                    #Ils se trouvent en général dans /usr/include
                    #Les headers sont en général spécifiques à l'OS (un même
                    #header varie en fonction de l'OS, et d'ailleurs les
                    #libraries auquel il fait référence aussi)

LIBRARIES ==>       #Un fichier objet est un fichier en langage machine (par 
                    #exemple un programme C après préprocesseur et assembleur, 
                    #et avant linker).
                    #Il est possible de lier un fichier objet lors de la 
                    #compilation avec un autre, ce qui permet d'utiliser les 
                    #fonctions et les constantes qu'il a initialisées comme si 
                    #elles l'étaient dans ce même programme.
                    #Il faut cependant pour ce faire les déclarer (et non les 
                    #définir) dans le premier fichier objet (avec le mot-clef 
                    #extern, ou en dehors de tout bloc), ce qui est le rôle des 
                    #headers. Sans cela, deux fichiers, même liés entre eux, ne 
                    #partagent aucune variable ni fonction, pas même constante 
                    #ou globale. Cela implique également qu'il faut #include 
                    #les headers pour chaque fichier objet le nécessitant.
                    #On peut outrepasser la question de la portée aveugle entre 
                    #deux fichiers en liant une fonction d'un fichier vers un 
                    #autre, et en faisant un call by address sur cette 
                    #fonction.
                    #Un fichier objet peut donc ne pas avoir de main(), et être 
                    #juste un "grimoire" de fonction. S'il est destiné à être 
                    #réutilisé, il s'agit d'une library (biblitothèque), sinon 
                    #d'un module du programme (ce qui permet de découper le 
                    #programme en plusieurs tâches).
    
LINKING ==>         #Il y a deux linkings possibles :
                    #  - static linking : copie en dur, lors du compile-time, 
                    #    dans l'exécutable, le contenu d'une library (static
                    #    library, .a sous Unix, .lib sous windows). Le terme 
                    #    s'applique aussi aux static variables, qui ont des 
                    #    mécanismes de linking, mais au sein d'un même fichier.
                    #  - dynamic linking : ne copier qu'une sorte de lien 
                    #    symbolique (par exemple le nom de la biblitothèque, 
                    #    qui est recherchée en runtime ensuite dans plusieurs 
                    #    répertoires types, et dont le contenu est seulement 
                    #    alors copié en mémoire). L'extension est .so sous Unix 
                    #    et .dll sous Windows.
                    #    Avantage :
                    #      - efficience
                    #      - si cette fonction est utilisée par un autre 
                    #        programme en cours, elle est partagée (shared 
                    #        library, ou dynamic library). Cela minimise la 
                    #        mémoire vive utilisée.
                    #      - updater la library update tous les programmes 
                    #        l'utilisant.
                    #    Cependant :
                    #      - la modifier peut donc poser des problème de 
                    #        backward compatibility, etc.
                    #Lorsque les libraries sont accessibles non pas via des 
                    #noms de fichiers, mais via une interface orientée objet, 
                    #cela devient des "shared objects".
                    #Les libraries se trouvent en général sous Unix dans /lib, /
                    #usr/lib et /usr/locale/lib sous Unix.

ASPECT PRATIQUE ==> #Pour un projet :
                    #  - faire un FICHIER.c contenant le main()
                    #  - mettre les définitions de fonctions dans des MODULE.c, 
                    #    regroupés par thème
                    #  - mettre toutes les déclarations précédant un main() 
                    #    dans un ou plusieurs headers, et inclure également cet 
                    #    header dans les modules appelant des fonctions 
                    #    déclarées dans cet header
                    #  - relier le tout avec un makefile

                                  ┌───────────────────┐
                                  │   PREPROCESSEUR   │
                                  └───────────────────┘

PREPROCESSEUR ==>       #Il s'agit de la première étape du compilateur.
                        #Si un texte est remplacé par une instruction au
                        #préprocesseur, le texte de remplacement est rescanné,
                        #ce qui permet d'avoir des instructions nested.
                        #Cependant un #define VAR MOTS qui contient VAR dans
                        #MOTS ne sera pas réévalué en fonction de lui-même.

#include "FILE"         #Est remplacé par le contenu de FILE (chemin relatif ou
                        #absolu). Parfois, la recherche est case insensitive, et
                        #seuls les six premiers caractères peuvent être
                        #recherchés. Chemin relatif si ne commence pas par /.
                        #FILE est souvent un header. 
#include <FILE>         #Même chose, mais recherche FILE (chemin relatif) dans
                        #le répertoire INCLUDE_PATH (souvent /usr/include/ sous
                        #Unix, ainsi que /usr/local/include/). Il est possible 
                        #d'ajouter des répertoires de recherche avec l'option -
                        #I DIR de gcc.
#define VAR [MOTS]      #Remplace toute occurence de VAR par MOTS, si MOTS est
                        #présent, sauf dans une STR_LIT.
                        #VAR ne peut plus être déclarée ou initialisée : définit
                        #donc une constante (appelée macro). Elle est typée
                        #automatiquement en fonction de MOTS.
                        #Déprécié en faveur de const VAR car #define :
                        #  - ne permet pas de typer manuellement VAR
                        #  - remplace VAR, mais ne l'évalue pas ensuite. Peut
                        #    entraîner des side-effects.
                        #  - est global, ce qui n'est pas toujours souhaité.
                        #Peut être utilisé cependant :
                        #  - car est utilisé par #ifdef, #ifndef et #undef
                        #  - sans MOTS, permet simplement de définir VAR, et de
                        #    l'utiliser ensuite avec #ifdef, etc.
                        #  - est en général utilisé dans les headers.
                        #Mettre MOTS entre parenthèses pour éviter de le coller
                        #à ce qui est à côté de lui.
#define MOT(VAR1        #Définit une macro également. MOTS doit contenir chaque
[, VAR2]...) MOTS       #VAR. Lorsque MOT( ... ) apparaît, il sera remplacé par
                        #MOTS. De plus, les valeurs se trouvant alors entre
                        #parenthèses et correspondant aux VAR de la macro seront
                        #remplacées par leurs équivalences dans MOTS.
                        #Ces équivalences peuvent :
                        #  - être précédées d'un #, ce qui fait que les 
                        #caractères seront tous échappés (dont " "), et que des
                        #" " englobantes seront rajoutées lors de la 
                        #substitution
                        #  - deux équivalences peuvent être séparées par ,
                        #    auquel cas, elles deviendront concaténées lors de
                        #    la substitution
                        #Il est parfois souvent de mettre MOTS entre parenthèses
                        #pour qu'il soit évalué avant les éventuels caractères
                        #contigus à lui, ainsi que chacun des équivalences des
                        #VAR dans MOTS.
#undef VAR              #Supprime l'effet d'un #define VAR, s'il y en a eu un,
                        #sinon, ne fait rien.
#if TEST                
    COMMANDES...        #Boucle if/else if/else évaluée par le préprocesseur.
#elif TEST              #TEST ne prend en compte qu'une macro en lvalue.
    COMMANDES...        #Ne peut pas contenir sizeof
#else TEST              #TEST peut également contenir l'expression :
    COMMANDES...        #  - define VAR
#endif                  #qui est vraie si VAR a été définie par #define.
                        #Mettre un commentaire :
                        #  - #endif // TEST 
                        #est une bonne pratique, pour rappeler le TEST de départ
                        #(notamment pour un header guard)
#ifdef VAR              #Equivaut à if define VAR
#ifndef VAR             #Equivaut à if ! ( define VAR ). Ces deux derniers sont
                        #souvent présents dans les headers (dont le début et la
                        #fin) pour :
                        #  - vérifier l'architecture d'un système
                        #  - vérifier que ce header n'a pas déjà été chargé. Si
                        #    ce n'est pas le cas, il est chargé, et un #define
                        #    est effectué sur VAR pour locker tout double
                        #    chargement (header guard)

#pragma MOT             #Envoie une pragma-option MOT au compilateur. Les
                        #pragma-options sont spécifiques à chaque compilateur.
#erreur STR_LIT         #Interrompt le programme et imprime STR_LIT (qui n'est 
                        #pas entouré de " " ici) comme message d'erreur.
#file INT_LIT [STR_LIT] #Fait que __LINE__ devient artificiellement INT_LIT, et,
                        #optionnellement, que __FILE__ devienne STR_LIT

                                  ┌─────────────────────────────────┐
                                  │   PORTEE, LIFETIME ET LINKAGE   │
                                  └─────────────────────────────────┘

SYNTHESE ==>            #Voici :

-----------------+---------+-----------+----------+-----------+--------+--------
       NOM       | PORTEE  | LIFETIME  | LINKING  |MEM. ALLOC.|IN-BLOC |OUT-BLOC
-----------------+---------+-----------+----------+-----------+--------+--------
      auto       | locale  | automatic | aucun    | automatic | défaut | non
    register     | locale  | automatic | aucun    | automatic | oui    | non
static (in-bloc) | locale  | static    | internal | static    | oui    | non
static (out-bloc)| globale | static    | internal | static    | non    | oui
     extern      | globale | static    | external | static    | non    | défaut
-----------------+---------+-----------+----------+-----------+--------+--------

PORTEE ==>              #Une variable peut avoir une portée :
                        #  - locale : son contenu ne peut être lu qu'au sein du
                        #    même bloc où elle a été déclarée (dont le bloc
                        #    d'une loop ou d'un statement). Le call by address
                        #    est un moyen de "tricher" sur la portée locale des
                        #    paramètres d'une variable.
                        #  - globale : son contenu peut être lu au sein de
                        #    n'importe quel bloc.

LIFETIME ==>            #La lifetime (duration) d'une valeur de variable peut 
                        #être :
                        #  - automatic : la mémoire est allouée à la variable 
                        #    sur le stack : dont dès qu'elle entre dans le
                        #    bloc où elle est déclarée, et est libérée une fois 
                        #    que l'on en est sorti. Si pas initialisé, rempli
                        #    du garbage du stack.
                        #  - static : la mémoire est allouée durant le loadtime.
                        #    Ainsi, elle peut toujours être accédée si la 
                        #    variable a une portée globale et le linking
                        #    adéquat, ou si la variable a une portée locale et
                        #    que le bloc de déclaration est à nouveau appelé.
                        #    Est initialisé à 0 compile-time si pas initialisé.

LINKING ==>             #Le linking d'une variable peut :
                        #  - ne pas exister (la variable n'a de sens qu'au sein
                        #    sein du bloc où elle a été déclarée, dans le stack)
                        #  - être interne : un linking est créé pour qu'au sein
                        #    du même fichier, la variable puisse continuer 
                        #    d'être accédée.
                        #  - être externe : un linking est créé pour que la
                        #    variable puisse être accédée par d'autres fichiers
                        #    (compilés en même temps, ou #include)

MEMORY ALLOCATION ==>   #Une valeur (et non une variable) peut avoir une memory 
                        #allocation :
                        #  - static : cf dessus.
                        #  - automatic : cf dessus.
                        #  - dynamic : la mémoire (taille) et l'allocation
                        #    précise de la zone mémoire ont lieu lors du runtime
                        #    (quand la variable est requise), dans le heap
                        #    (static lifetime donc). Une variable n'est jamais
                        #    dynamic, c'est sa valeur qui l'est. Il s'agit de
                        #    pointeurs (eux-mêmes auto, register, static ou 
                        #    extern) que l'on fait pointer vers des data dynamic
                        #    créées via malloc() par exemple.

RESUME DES CLASS        #Il est interdit de spécifier le class storage des
STORAGES ==>            #paramètres d'une fonction (car nécessairement auto) :
                    
[auto] TYPE VAR         #Déclare une variable auto.
                        #Ne peut être utilisé en dehors d'un bloc, c'est le
                        #type par défaut des variables au sein d'un bloc : est
                        #donc par nature redondant.
register TYPE VAR       #Comme auto, mais indique au compilateur d'essayer
                        #d'utiliser les registres plutôt que le stack (le 
                        #compilateur peut refuser). 
                        #Par ailleurs, l'opération &VAR est impossible.
                        #Ne marche pas pour les types complexes.
static TYPE [FONC_]VAR  #Deux cas :
                        #  - au sein d'un bloc (in-bloc) : portée locale, mais
                        #    lifetime static. Ainsi, à la fin du bloc où elle
                        #    a été déclarée, son contenu n'est plus accessible,
                        #    mais lors d'un nouvel appel de ce même bloc, son
                        #    contenu est toujours là, et accessible.
                        #    Utile pour des foncions récursives par exemple.
                        #    Prudent aussi lorsque l'une fonction renvoie un
                        #    pointeur vers la valeur d'une variable déclarée en
                        #    son sein (sinon cette valeur peut être écrasée en
                        #    mémoire ultérieurement)
                        #  - en dehors d'un bloc (out-bloc) : 
                        #    comme extern, sauf que le linking extern est
                        #    impossible (seul la portée globale au sein du
                        #    fichier est utilisée)
                        #Initialisé à 0, puis garde ses valeurs jusqu'à fin du
                        #programme.
                        #Ne peut pas être initialisée à partir de la valeur 
                        #d'une static ou extern VAR.
                        #Un static ne peut être déclaré que dans un seul 
                        #fichier, de même pour la définition. Ainsi, s'il est 
                        #déclaré dans un header, il ne peut être initialisé 
                        #que dans un fichier et non plusieurs.
                        #Il ne faut pas initialiser une static VAR en accédant 
                        #à une autre static VAR présente dans un autre 
                        #fichier, car on est jamais sûr que cette dernière 
                        #sera construite avant.
[extern] TYPE [FONC_]VAR#La variable, ou fonction, a une portée globale, une
                        #lifetime static et un linking extern est possible.
                        #Par défaut si en dehors d'un bloc pour une fonction : 
                        #ne doit donc être explicité que dans un bloc, ou en
                        #dehors d'un bloc pour certaines variables.
                        #Deux utilités donc :
                        #  - peut être utilisée dans tout le fichier courant
                        #  - permet de faire un linking extern.
                        #Le mécanisme du linking extern est le suivant :
                        #  - dans un premier fichier, la variable extern est
                        #    définie.
                        #  - dans un second fichier (compilé en même temps ou
                        #    #include), elle est à nouveau déclarée ce qui 
                        #    permet de pouvoir l'utiliser dans ce fichier
                        #    également (fait référence à la même valeur dans la
                        #    mémoire), mais ne pourra être exécutée qu'au sein
                        #    d'un bloc. C'est l'utilité des headers notamment.
                        #Une fonction devant être en dehors de tout bloc, est
                        #par défaut extern donc.
                        #Ne peut pas être initialisée à partir de la valeur 
                        #d'une static ou extern VAR.
                        #Initialisé à 0, puis garde ses valeurs jusqu'à fin du
                        #programme.

inline TYPE FONC_VAR    #Ce dernier specifier est apporté par C99, et ne 
                        #s'applique qu'à une fonction. Il signifie que lors de
                        #la compilation, il n'y aura pas de linking, mais que le
                        #contenu de la fonction sera incorporée en dur dans
                        #l'exécutable, ce qui permet d'éviter un appel vers la
                        #fonction (gain de performance), mais conduit à un temps
                        #de compilation plus long, et un exécutable plus gros.
                        #En général, éviter et préférer l'optimisation du
                        #compilateur, qui choisit lui-même si une fonction doit
                        #être inline ou non.

                                  ┌────────────────────────┐
                                  │   TYPES DE VARIABLES   │
                                  └────────────────────────┘

TYPES DE VARIABLES ==>  #Voici les types de variables simples. Les valeurs
                        #dépendent de l'architecture 16 / 32 / 64 bits. Le
                        #RANGE est celui d'un OS 64 bits. Les TOUINT et CHAR
                        #sont signed par défaut.
                        #%d et %i désignent des signed et %u, %o, %x et %X des
                        #unsigned TOUINT. Les deux RANGE pour chaque TOUINT
                        #dépend de sa signedness.

NOM                     SIZE               LETTRE           RANGE
                16 bits  32 Bits  64 bits

[[un]signed]                               %hhd, %hhi, %hhu +/-127 (ASCII)
char            1 octet                    %hhx, %hhX, %hho 255 (ASCII)
                                           %c

[[un]signed]    1 octet  2 octets          %hd, %hi, %hu    -/+32767 
short [int]                                %hx, %hX, %ho    65535
[[un]signed]    2 octets 4 octets          %d,  %i,  %u,    -/+2 147 483 647
[int]                                      %x,  %X,  %o     4 294 967 295
[[un]signed]             4 octets 8 octets %ld, %li, %lu    -/+9 223 372 036 854
long [int]                                 %lx, %lX, %lo    775 807
                                                            18 446 744 073 709
                                                            551 615
[[un]signed]             8 octets 8 octets %lld, %lli, %llu -/+9 223 372 036 854
long long [int]                            %llx, %llX, %llo 775 807
                                           %qd, %qi, %qu    18 446 744 073 709
                                           %qx, %qX, %qo    551 615

float                    4 octets          %f,  %F,  %e     3.4*10^(+/-38) (7 
                                           %E,  %g,  %G     chiffres exacts)
double                   8 octets          %lf, %lF, %le    1.7*10^(+/-308) (15
                                           %lE, %lg, %lG    chiffres exacts)
long double              10 octets         %Lf, %LF, %Le    3.4*10^(+/-4932) (19
                                           %LE, %Lg, %LG    chiffres exacts)

TYPE* (en fait
un int ou un 
long suivant
l'architecture) 2 octets 4 octets 8 octets %p              0xFFFF FFFF FFFF FFFF

CHAR ==>                #char est en fait un simplement un TOUINT d'1 octet, 
                        #mais est représenté par les fonctions comme un
                        #caractère ASCII.

VOID ==>                #Le type void a trois utilités :
                        #  - TYPE d'un FONC_VAR ne retournant rien.
                        #  - préciser qu'une argument ne prend pas d'argument. 
                        #    Mettre seulement FONC_VAR() laisse sinon 
                        #    l'interprétation au compiler.
                        #  - utilisé sur les pointeurs. L'opérateur & renvoie
                        #    un pointeur de type VOID *. Un pointeur initialisé
                        #    donc ainsi :
                        #      - void *VOID_ADR = &VAR
                        #    ne peut pas être exécuté sous la forme :
                        #      - *VOID_ADR
                        #    et ne peut pas avoir d'arithmétique des pointeurs
                        #    mais a deux utilités :
                        #      - être converti en un pointeur de n'importe quel
                        #        type, par transtypage :
                        #           - TYPE *ADR = VOID_ADR
                        #             (TYPE *ADR = (TYPE *)VOID_ADR est 
                        #             redondant et à éviter)
                        #             Utilisé égalament dans le corps d'une
                        #             fonction, après avoir passé le VOID_ADR en
                        #             argument à la fonction, via par exemple :
                        #              - FONC_VAR((void *)&VAR)
                        #      - être utilisé sous la forme printf("%p", 
                        #             VOID_ADR) par exemple

ARRAYS ET STRINGS ==>   #Les arrays sont des pointeurs (voir plus loin).
                        #Les strings sont des arrays de CHAR (correspond à %s)

BOOLEEN ==>             #Il n'y a pas de type booléen. Faux est noté 0, et vrai
                        #différent de 0.

SIGNEDNESS ==>          #Elle est obtenue par complément de 2. Une conversion de
                        #de signedness est transparente, à condition que la 
                        #valeur se trouve dans le range de la signedness opposée

POINTEUR ==>            #Le statut de pointeur fait partie du type de la 
                        #variable.

CONVERSION DE TYPE ==>  #Les types peuvent être convertis entre eux :
                        #Conversions à éviter :
                        #  - touint -> touint inférieur :  TOUINT % 
                        #    MAX(TOUINT_INFERIEUR)
                        #  - toufloat -> toufloat inférieur : perte de 
                        #    précision possible
                        #  - toufloat -> touint : troncature
                        #  - touint -> toufloat : peut provoquer des pertes de 
                        #    précision, quand taille de touint > taille du 
                        #    significand de toufloat
                        #  - toufloat -> toufloat moins précis : troncature de 
                        #    la précision
                        #Conversion sans problème : 
                        #  - toufloat -> toufloat supérieur
                        #  - touint -> touint supérieur
                        #Pour les convertir :
                        #  - transtypage implicite :
                        #     - VAR = VAL, où VAL a un type différent.
                        #       - aussi donc le cas lorsque l'on passe des 
                        #         arguments à une fonction, avec un type 
                        #         différent.
                        #     - après une opération arithmétique :
                        #      - deux nombres de même TYPE donne TYPE. Ainsi :
                        #          - DOUBLE_VAR = 5 / 9
                        #        devrait être écrit :
                        #          - DOUBLE_VAR = 5.0 / 9
                        #      - les CHAR et les SHORT sont toujours promus en
                        #        INT : cela s'appelle le widening. Si seulement
                        #        des SHORT ou des INT, donne donc au moins un
                        #        signed INT, puis unsigned INT si cela dépasse
                        #      - deux TOUINT donnent le TOUINT dont le type est
                        #        le plus large, ou un type supérieur encore si
                        #        cela dépasse les limites
                        #      - même chose pour les TOUFLOAT
                        #      - un TOUINT et un TOUFLOAT donne TOUFLOAT
                        #    - widening : les CHAR et SHORT passés en argument
                        #      d'une fonction, ou return value sont toujours 
                        #      promus en INT à la compilation x86, car le stack 
                        #      est aligné sur 4 bits
                        #  - transtypage explicite (cast) :
                        #    - (TYPE)VAL : Exemple de (TYPE) :
                        #      - (int)
                        #      - (int *)
                        #      - (int[30]) pour une array
                        #      - (int (*)()) pour un pointeur de fonction

NOTATION ==>            #Voici les notations précises :
                        #  - TOUINT_LIT : [0][0x]NOMBRE (0 dénote un octal et 0x
                        #                               un hexadécimal)
                        #  - TOUFLOAT_LIT : - NOMBRE[.NOMBRE]
                        #                   - NOMBRE / NOMBRE
                        #                   - NOMBRE[.NOMBRE]e|E-|+NOMBRE
                        #  - Un TOUINT_LIT ou un TOUFLOAT_LIT peut être terminé
                        #    par un caractère pour spécifier :
                        #    - L ou l : qu'il s'agit d'un long
                        #    - U ou u : qu'il s'agit d'un unsigned
                        #  - CHAR_LIT : 'LETTRE'
                        #  - STR_LIT : "STR"[ "STR"]... Il s'agit d'un char const*
                        #  - pour un CHAR_LIT ou un STR_LIT, les séquences 
                        #    d'échappement backslash suivantes sont 
                        #    disponibles :
                        #     - \xN, \xNN, \0N et \0NN. Les séquences \xNNN et 
                        #       \0NNN buguent, de sorte que si un caractère non 
                        #       whitespace ou ', ou " ne suit pas, cela produit 
                        #       un bug. On peut clore la STR_LIT et la rouvrir 
                        #       pour pallier le problème. 
                        #     - \a, \b, \f, \n, \t, \v
                        #     - \e produit le caractère ESC, 0x1b
                        #     - \r, retour au début de la ligne mais n'écrase
                        #       pas
                        #     - \ échappe \, ', " et ? (si trigraphes)
                        #     - \uXXXX pour un caractère Unicode, en fonction de la locale courante (UTF8 ou 16)
                        #    Ces séquences sont transformées vers le control
                        #    character correspondant pendant le compile-time :
                        #    ainsi, les caractères fournis par l'utilisateur
                        #    durant le runtime ne sont pas transformés

                                  ┌─────────────────────┐
                                  │   TYPES COMPLEXES   │
                                  └─────────────────────┘

TYPES COMPLEXES ==>     #TYPE peut aussi désigner :
                        #  - struct STKT_VAR
                        #  - union UNIO_VAR
                        #  - enum ENUM_VAR
                        #à condition que ces derniers doivent être déclarés 
                        #avant que TYPE ne soit utilisé

STRUCTURES ==>          #Voici :

struct STKT             #Déclaration d'une structure (utile seulement pour le
                        #linking externe)
struct [STKT] {         #Déclaration et initialisation d'une structure. 
    [TYPE STKTMBR;]...  #Crée une structure avec des membres STKTMBR,
    [[un]signed         #hétérogènes en son sein, de manière contigüe dans la 
    [STKTMBR3]          #mémoire (attention : un short prendra 4 octets). Les 
    :TOUINT_LIT]...     #membres peuvent être de TYPE différents.
} [STKT_VAR] ;          #
                        #STKTMBR peut être également :
                        #  - un pointeur (il faudra allouer la mémoire)
                        #     - TYPE *STKTMBR;
                        #  - dont un pointeur de fonction :
                        #     - TYPE (*STKTMBR)()
                        #  - un array :
                        #     - TYPE STKTMBR[TOUINT_VAL]
                        #Il faut allouer de la mémoire et affecter une ADR aux
                        #pointeurs pour pouvoir les utiliser (notamment une
                        #FONC_ADR pour un pointeur de fonction, qu'on exécute
                        #ensuite sous la forme (*STKT_VAR.STKTMBR)( ... )
                        #
                        #Trois sortes de membres possibles :
                        #  - Membre avec un TYPE simple.
                        #  - TYPE peut être complexe (comme struct STKT2), 
                        #    ce qui permet d'inclure des unions, enum et d'avoir
                        #    des nested structures (la structure enfant doit
                        #    être définie et déclarée avant la structure
                        #    parente). Exemple :
                        #      - struct STKT {
                        #           struct STKT2 STKTMBR;
                        #           union UNIO STKTMBR2;
                        #           ...
                        #       };
                        #    Il est possible d'initialiser ce type complexe en
                        #    même temps, par exemple :
                        #      - struct STKT {
                        #           struct [STKT2] {
                        #               TYPE1 STKTMBR1;
                        #               ...
                        #           } [STKTMBR];
                        #       };
                        #    Auquel cas si STKT2 et STKTMBR sont omis, il s'agit
                        #    d'une anonymous structure, et on pourra accéder aux
                        #    membres de la nested structure directement, sans
                        #    passer par STKTMBR :
                        #      - struct STKT STKT_VAR;
                        #        STKT_VAR.STKTMBR1 = VAL;
                        #    Pour inclure une structure étant la même que celle
                        #    déclarée (créant ainsi un struct récursif), il faut
                        #    la déclarer en tant que pointeur de structure :
                        #      - struct STKT {
                        #            struct STKT *STKTMBR;
                        #            ...
                        #        };
                        #    On doit allouer la mémoire à chaque STKTMBR dans 
                        #    la récursion (en faisant dans l'ordre, ce qui
                        #    signifie que pour accéder à la troisième récursion,
                        #    il faut allouer de la mémoire au premier pointeur
                        #    de structure dans la récursion, puis au deuxième,
                        #    puis à ce dernier)
                        #    Autre possibilité : 
                        #    Pour faire que deux struct s'incluent mutuellement,
                        #    il faut que la première déclarée déclare l'autre
                        #    comme pointeur de structure (car la deuxième struct
                        #    n'est pas encore déclarée). Il est d'usage que la
                        #    deuxième struct inclue également la première sous
                        #    forme de pointeur de structure (penser à allouer la
                        #    mémoire)
                        #  - Il est également possible de déclarer des bitfields
                        #    signed ou unsigned, ils n'ont pas de type 
                        #    particulier, mais occupe une place de TOUINT_LIT 
                        #    bits (et non octets).
                        #    Ils sont initialisés et exécutés via STKTMBR comme
                        #    les membres normaux d'une structure. On peut leur
                        #    affecter tout type de data, mais les data seront :
                        #      1) converties dans la signedness du field
                        #      2) tronquées si pas assez de place.
                        #    STKTMBR est optionnel (mais le bitfield sera alors
                        #    inacessible).
                        #    Sert en général dans avec une union englobant la 
                        #    structure pour associer la structure avec un stream
                        #    sériel de data, pour accéder à ce flux de manière
                        #    non sérialisé. Parfois non-portable
                        #
                        #Ne pas oublier le point-virgule final.
                        #Déclarer avant main() si possible, dont dans un header.
                        #La structure elle-même ne peut pas être un array en
                        #même temps, mais ses images STKT_VAR peuvent l'être 
                        #(voir plus bas)
                        #Il est possible d'initialiser des STKT_VAR en même 
                        #temps : STKT peut alors être omis, et ne pourra plus
                        #être accédé en dehors des STKT_VAR initialisées (utile
                        #parfois si cette déclaration de STKT est nested)

struct STKT STKT_VAR    #Déclaration d'une STKT_VAR comme étant de type struct
                        #STKT. Déclare donc en même temps tous ses STKTMBR_VAR.
                        #"struct STKT" est en fait un TYPE complexe.
                        #STKT_VAR peut être un array.
STKT_VAR = STKT_VAR2    #Initialisation des membres d'une STKT_VAR comme copies
                        #des membres d'une autre STKT_VAR, qui doit être du
                        #même type struct STKT.
STKT_VAR[.STKT_VAR2]... 
= STKT_VAR3             #Initialisation des membres d'une nested STKT_VAR
struct STKT STKT_VAR    #Déclaration + initialisation d'une STKT_VAR (marche 
= STKT_VAR2             #aussi pour les nested STKT_VAR)
struct STKT STKT_VAR    #Déclaration + initialisation d'une STKT_VAR (marche 
= { VAL1[, VAL2]... }   #aussi pour les nested STKT_VAR). { } possible seulement
                        #dans ce cas. VAL peut être une autre STKT_VAR. Elle
                        #peut aussi être une autre { } s'il s'agit d'une 
                        #STKT_VAL imbriquée.

STKT_VAR.STKTMBR_VAR    #Initialisation de STKTMBR_VAR (qui est du TYPE tel que
= VAL                   #décrit par sa struct STKT).
STKT_VAR[.STKT_VAR2]... #Initialisation de STKTMBR_VAR, au sein de nested
.STKTMBR_VAR = VAL      #structures.
STKT_VAR.STKTMBR_VAR    #Exécution de STKTMBR_VAR
STKT_VAR[.STKT_VAR2]... 
.STKTMBR_VAR            #Exécution de STKTMBR_VAR, au sein de nested structures

POINTEURS DE MEMBRES    #Si STKTMBR a été déclaré dans STKT comme pointeur, pour
DE STRUCTURES ==>       #y accéder, il faut faire :

*STKT_VAR[.STKT_VAR2]...
.STKTMBR_VAR            #Et non la même chose sans le *.
STKT_VAR[.STKT_VAR2]...
.STKTMBR_VAR = malloc   #De plus, il faut allouer la zone mémoire vers laquelle
(sizeof(TYPE *))        #pointe ce pointeur (sinon segfault)

POINTEUR DE             
STRUCTURES ==>          #Voici :

struct STKT *STKT_ADR   #Exemple de déclaration + initialisation de pointeur de
= &STKT_VAR             #structure
(*[STKT_VAR.]...        #Exécution de STKTMBR_VAR après déréférencement de
STKT_ADR).STKTMBR_VAR   #*STKT_ADR (les parenthèses importent)
[STKT_VAR.]...STKT_ADR
->STKTMBR_VAR           #Autre syntaxe pour la même chose.
                        #Il est possible de déclarer des pointeurs dans 
                        #structures imbriqués. Ainsi :
                        #  - (*(*STKT_VAR.STKT_ADR).STKT_ADR).STKT_VAR
                        #équivaut à :
                        #  - STKT_VAR.STKT_ADR->STKT_ADR->STKT_VAR
STKT_VAR[.STKT_VAR2]...
.STKTMBR_ADR = malloc   #De plus, il faut allouer la zone mémoire vers laquelle
(sizeof(TYPE *))        #pointe ce pointeur de structure (sinon segfault)

UNION ==>               #Voici :

union UNIO              #Déclaration d'une union (utile seulement pour le
                        #linking externe)
union UNIO {            #Déclaration et définition d'une union. 
    TYPE UNIOMBR;...    #Des TYPE différents sont possibles.
} [UNIO_VAR]            #UNIOMBR peut être un pointeur ou un array, comme pour
[, UNIO_VAR2]... ;      #STKTMBR.
                        #"union UNIO" est un TYPE complexe.
                        #Contrairement à une structure, une union utilise la 
                        #même adresse pour tous ses membres (juxtaposés et non 
                        #contigus).
                        #Ainsi, s'ils ont la même taille mémoire par exemple, 
                        #en modifier un modifie les autres. 
                        #Faire des imbrications d'unions n'a donc pas de sens.
                        #Ne pas oublier le point-virgule final. Déclarer avant
                        #main() si possible, dont dans un header.
                        #Il est possible de déclarer des UNIO_VAR en même temps,
                        #comme pour les structures.
                        #La syntaxe des unions et des structures est en fait la
                        #même.

union UNIO UNIO_VAR     #Déclaration d'une UNION_VAR de type union UNIO.
UNIO_VAR = UNIO_VAR2    #Initialisation d'une UNIO_VAR comme copie d'une autre 
                        #UNIO_VAR, qui doit être du même type union UNIO.
union UNIO UNIO_VAR     
= UNIO_VAR2             #Déclaration + initialisation d'une UNIO_VAR

UNIO_VAR.UNIOMBR_VAR    #Initialisation de UNIOMBR_VAR (qui est du type tel que
= VAL                   #décrit par l'union UNIO). Rajouter un * devant UNIO_VAR
                        #si UNIOMBR désigne un pointeur (même chose que struct 
                        #pour l'allocation de la mémoire pour les pointeurs)
UNIO_VAR.UNIOMBR_VAR    #Exécution de UNIOMBR_VAR. Même pour pour le *

ARITHMETIQUE DE         #Les STKT_VAR et UNIO_VAR sont bien des variables et
POINTEURS DE STRUCTURES #non des adresses. On peut assigner un pointeur de
ET D'UNIONS ==>         #structure ou d'union à un autre pointeur de type TYPE *
                        #ce qui permettra d'utiliser une arithmétique de
                        #pointeur, selon sizeof(TYPE) cependant, et non selon
                        #l'ordre des membres de la structure par exemple :
                        #  - TYPE *ADR = (TYPE *)&STKT_VAR
                        #    *ADR++ = VAL
                        #Il est nécessaire de faire un (TYPE *), sinon on ne
                        #peut pas assigner de STKT_ADR à une ADR d'autre type.
                        #C'est cependant risquer de faire cela car les unions et
                        #les structures rajoutent parfois des gaps entre les
                        #membres (par exemple après les short ints).
                        #Pour calculer les gaps, utiliser offsetof()
                        #(<stddef.h>)

EXEMPLE DE SERIALIATION #Voici la déclaration des types :
DESERIALISATION PAR     #  - struct STKT {
UNION ==>               #        TYPE STKTMBR1;...
                        #    } ;
                        #    union UNIO {
                        #        struct STKT STKTMBR2;
                        #        char STKTMBR3[sizeof(struct STKT)];
                        #    } ;
                        #Ensuite la déclaration et initialisation :
                        #  - union UNIO UNIO_VAR;
                        #    UNION_VAR.STKTMBR3_VAR = VAL
                        #STKT doit être de même taille que VAL (un special file,
                        #etc.)
                        #Et exécution non-sérielle :
                        #  - UNIO_VAR.STKTMBR2_VAR
                        #Exécution sérielle :
                        #  - UNIO_VAR.STKTMBR3_VAR

ENUM ==>                #Voici :

enum ENUM               #Déclaration d'un enum (utile seulement pour le linking 
                        #externe)
enum ENUM {             #Déclare et définit une enum ENUM. Chaque MOT... est
    MOT[=INT_VAL],      #associé à une INT_VAL... (par défaut la valeur
    ...                 #précédente + 1 (0 pour la première valeur))
} ;                     #Ne pas oublier le point-virgule. Séparer par des 
                        #virgules, non des point-virgules.
                        #L'enum doit être défini dans le fichier l'utilisant :
                        #le définir donc toujours dans un header. La 
                        #substitution a lieu compile-time.
enum ENUM ENUM_VAR      #Déclare une ENUM_VAR.
                        #"enum ENUM" est en fait un TYPE complexe.
ENUM_VAR = VAL;         #Si VAL contient un des MOT... du type ENUM, l'INT_VAL
                        #correspondante est renvoyée à la place de VAL.
                        #Sinon VAL est bien sûr renvoyé, mais en converti en
                        #INT_VAL.
enum ENUM [{
    MOT[=INT_VAL],
    ...
}] [ENUM_VAR[ = VAL]] ; #Les trois peuvent être combinés.

TYPEDEF ==>             #Voici :

typedef TYPE MOT        #Fait que MOT devient un alias pour TYPE (dont un type
                        #complexe). TYPE doit être déclaré.
                        #Peut être fait en même temps que la déclaration de 
                        #type, par exemple :
                        #  - typedef struct STKT {
                        #       TYPE STKTMBR;...
                        #    } MOT
                        #Cependant, MOT ne doit pas alors être contenu dans la
                        #déclaration du type elle-même. Si c'est le cas (par
                        #exemple struct récursif), faire d'abord la déclaration
                        #de type, puis le typedef, ou ne pas utiliser MOT à
                        #l'intérieur de la déclaration de type, mais plutôt ce à
                        #quoi MOT fait référence. Même chose pour des typedef
                        #pendant la déclaration de deux struct s'incluant
                        #mutuellement.
                        #Si MOT est précédé de *, toute invocation de MOT (sans
                        #le *) signifiera TYPE*.
                        #Si MOT est écrit sous la forme (*MOT)(), MOT sera
                        #l'alias d'un type de pointeur de fonction. Ainsi, toute
                        #invocation sous la forme MOT VAR, signifiera
                        #TYPE (*VAR)(), déclarant ainsi un pointeur de fonction
                        #de type TYPE.
                        #Si MOT est suivi de [TAILLE]..., toute variable 
                        #déclarée avec cet MOT sera, en plus d'être de type 
                        #TYPE, un array/matrice de dimension [TAILLE]... (pas 
                        #besoin de rajouter [TAILLE]... lors de la déclaration 
                        #de cette variable)

                                  ┌────────────────────────┐
                                  │   TYPES PARTICULIERS   │
                                  └────────────────────────┘

TYPES PARTICULIERS      #Il est possible à partir des types complexes de créer
COMPLEXES ==>           #des types encore plus complexes, personnalisés. On
                        #peut ensuite créer des fonctions pour ces types (par
                        #exemple pour l'insertion, suppression, lecture, etc.).
                        #Exemples :

LISTE ==>               #Structure avec un ARR dynamique, et un INT_VAR notant
                        #la taille de l'ARR.
FIFO ==>                #Liste dont les fonctions d'insertion et de suppression
                        #se font comme dans une FIFO.
FILO ==>                #Même chose.
TAMPON CIRCULAIRE ==>   #FIFO, avec une variable supplémentaire dans la 
                        #structure, indiquant l'endroit où à lieu le pop and
                        #push, et qui peut donc être déplacée.
LISTE CHAINEE ==>       #Structure "chainon" avec une data + un pointeur vers 
                        #le prochain "chainon" (ou NULL si dernier chainon).
                        #Possibilité d'avoir un chainon-maitre avec une 
                        #structure contenant : la taille de la chaine entière + 
                        #un pointeur vers le prochain "chainon"
LISTE DOUBLEMENT        #Même chose, mais la structure "chainon" contient aussi 
CHAÎNÉE ==>               #un pointeur vers le pointeur précédent.
ARBRE BINAIRE ==>       #Comme la liste chaînée, mais pointe vers 2 chainons à 
                        #chaque fois.
ARBRE ==>               #Comme l'arbre binaire, mais peut contenir n chainons, 
                        #et a un membre INT pour contenir le nombre de chainons 
                        #pointés par ce chainon. Cependant, il est impossible 
                        #d'avoir des structures avec un nombre variable de 
                        #membres : doit donc utiliser un array dynamique pour 
                        #chaque chainon, avec au début du chainon sa taille 
                        #totale ( = nombre de chainons pointés par ce chainon), 
                        #les chainons ne devant pas forcément être contigus 
                        #dans la mémoire.

                                  ┌───────────────┐
                                  │   POINTEURS   │
                                  └───────────────┘

OPERATEURS DE
POINTEURS ==>           #Voici :

&VAR                    #Renvoie ADR (l'adresse mémoire où est stockée la valeur
                        #de VAR), sous forme de void *
&ADR                    #Renvoie ADR_ADR (l'adresse mémoire où est stockée
                        #l'adresse stockée par ADR) sous forme de void **
*ADR                    #Renvoie la valeur stockée à l'adresse ADR. Si ADR ne
                        #stocke pas une adresse, mais une valeur, cette valeur
                        #est comprise comme une adresse, et une zone mémoire
                        #quelconque est recherchée, ce qui entraîne en général
                        #un segfault.
DECLARATION ET
INITIALISATION DE
POINTEURS ==>           #Voici :

TYPE *ADR[, *ADR2]      #Déclaration de pointeur (ajouter * après TYPE).
ADR = &VAR              #Initialisation de pointeur. Le TYPE de ADR doit être le
                        #même que celui de VAR. Il sert :
                        #  - à savoir le type de *ADR
                        #  - l'arithmétique des pointeurs et la recherche via
                        #    ADR[TAILLE] utilise sizeof(TYPE)
ADR = VAL               #Une ADR peut également être utilisée comme une VAR, si
                        #on lui affecte une VAL et non une adresse. 
TYPE *ADR = &VAR        #Déclaration + initialisation de pointeur.
*ADR                    #Exécution du pointeur ADR (renvoie la valeur se 
                        #trouvant à l'adresse ADR)
*ADR = VAL              #Affecte la valeur VAL à l'endroit où pointe ADR

AVANTAGES ==>           #  - cible directement l'adresse mémoire sans 
                        #    intermédiaire : permet de nombreuses possibilités
                        #  - ne crée qu'un emplacement mémoire et non deux pour 
                        #    utiliser la valeur
                        #  - plus rapides

NE PAS CONFONDRE ==>    #  - le * de TYPE *ADR, qui indique dans une    
                        #    déclaration et définition qu'ADR est un pointeur 
                        #    (la syntaxe TYPE* ADR et TYPE * ADR sont également 
                        #    possibles)
                        #  - le * de *ADR, qui indique un déréférencement de
                        #    ADR

POINTEURS DE POINTEURS  #Un pointeur a lui-même une adresse, qui peut être 
  ==>                   #adressée par &ADR. Ainsi il est possible de pointer un 
                        #pointeur :

TYPE **ADR_ADR = &ADR   #Déclaration + initialisation de pointeur de pointeur
*ADR_ADR                #Renvoie ADR
*(*ADR_ADR)
**ADR_ADR               #Renvoie la valeur pointée par ADR
TYPE ***ADR_ADR_ADR     #Déclaration + initialisation de pointeur de pointeur de
= &ADR_ADR              #pointeur de pointeur (et ainsi de suite...)
*(*(*ADR_ADR_ADR))
***ADR_ADR_ADR          #Renvoie la valeur pointée par ADR

REFLEXION SUR LES       #L'utilité de déclaré une variable avec TYPE * est :
POINTEURS  ==>          #  - d'avoir la possibité d'utiliser l'opérateur * 
                        #    (maximum autant de fois consécutivement que le
                        #    nombre de * dans la déclaration)
                        #  - VAR = &ADR, ou ADR = &ADR renverra une erreur car
                        #    on cherche à assigner un void * à un non pointeur
                        #    ou un void ** à un TYPE * dans le second cas. 
                        #    Cependant, c'est techniquement permis par le
                        #    compilateur

ARITHMETIQUE DE         #Les ADR peuvent être manipulés avec +, - ++ et --. Cela
POINTEURS   ==>         #est utile notamment avec les arrays, et les pointeurs
                        #de structure (voir ces parties).
                        #La priorité est :
                        #  1) ++ et --
                        #  2) le déférencement de *ADR
                        #  3) + et -
                        #Avec l'utilisation de parenthèses également. Ajouter
                        #ou soustraire 1 à un ADR ajoute ou ne soustrait pas 1
                        #octet mais sizeof(TYPE) octets, où TYPE est le type de
                        #*ADR (pour un pointeur de pointeur, il s'agira donc
                        #d'un type pointeur).
                        #Donc :
                        #  - *(ADR + 1) et *ADR++ utilise l'arithmétique des 
                        #    pointeurs
                        #  - *ADR + 1 et (*ADR)++ utilise une arithmétique 
                        #    normale
                        #Dans le cas d'une matrice :
                        #  - *(ARR_ARR + 1) et *ARR_ARR++ fait de 
                        #    l'arithmétique de pointeur sur l'array englobant
                        #  - *ARR_ARR + 1 et (*ARR_ARR)++ fait de 
                        #    l'arithmétique de pointeur sur l'array englobé
                        #  - **(ARR_ARR + 1) sur l'array englobant
                        #  - **ARR_ARR + 1 fait de l'arithmétique normale sur la
                        #    ARR_ARR[0][0]
                        #Synthèse :

 *(*(*(ADR + 1) + 1) ...) + 1
| | | |   a   |    |    |    |  a = aritm. de point. sur l'array englobante
| | |            b |    |    |  b = aritm. de point. sur la 1ère array englobée
| |                   c |    |  c = etc.
|                          d |  d = aritm. normale sur la valeur finale

COMPARAISON DE          
POINTEURS ==>           #Voici :

ADR == ADR2             #ADR et ADR2 pointent vers la même adresse
ADR != ADR2             #ADR et ADR2 ne pointent pas vers la même adresse
ADR > ADR2              #L'adresse ADR précède ou non ADR2. Cela peut être
ADR >= ADR2             #utile si deux pointeurs obtenus à partir d'opérations 
ADR < ADR2              #sur une même ARR, ce qui fait qu'ils commencent tous
ADR <= ADR2             #les deux à deux points différents de cette ARR 
                        #originelle : pour savoir donc lequel précède l'autre

NULL ==>                #NULL est une constante définie dans stdio.h.
                        #C'est un 0 de type INT_LIT ou (pour Linux notamment) 
                        #de type VOID_ADR parfois (donc un pointeur ayant comme
                        #valeur 0 (donc inutilisable), et non pointant vers 0). 
                        #NULL est donc différent de '\0' qui est un CHAR_LIT de
                        #valeur 0, et de "" (null string), qui est un ADR (dont
                        #la valeur n'est pas 0) pointant vers '\0'
                        #NULL est renvoyé en général par des fonctions sensées 
                        #renvoyer un pointeur, et échouant.
                        #Pour tester si un pointeur != NULL :
                        #  - if (ADR)

                                  ┌────────────┐
                                  │   ARRAYS   │
                                  └────────────┘

TYPE ARR[TOUINT_VAL]... #Déclaration d'array. TYPE est le type des éléments de
                        #l'array. TOUINT_VAL leur nombre. La dimension de 
                        #l'array ne peut donc être plus être modifiée ensuite.
                        #S'il y a plusieurs TOUINT_VAL..., il s'agit d'une array
                        #à plusieurs dimensions (matrice par exemple)
                        #TYPE peut être complexe.
                        #Les [ ] sont les signes littéraux, et ne signifient pas
                        #le fait que ce soit facultatif.
                        #Le type est noté TYPE[TOUINT_VAL], et ne peut pas être
                        #le type de la return value d'une fonction.
                        #Si l'array est d'une dimension trop grande, cela peut
                        #produire des erreurs.
                        #TOUINT_VAL devait être une constante avant C99 
                        #(allocation statique de la mémoire pour l'array alors),
                        #mais depuis, il peut aussi contenir une VAR
                        #(allocation auto alors)
                        #Si l'ARR est static ou extern, ses éléments sont
                        #initialisés à 0 par défaut
ARR[TOUINT_VAL]... = VAL#Affecte VAL à l'index TOUINT_VAL d'ARR avec. L'index
                        #commence à 0.
                        #Si plusieurs TOUINT_VAL, il s'agit des multiples indexs
                        #d'un array multi-dimensionnel (l'array englobant étant
                        #le premier index de la suite d'indexs). Si l'index est
                        #supérieur à la dimension de l'array, cela produit un
                        #buffer overflow (voir plus bas)
                        #Après déclaration simple, les valeurs d'un array sont 
                        #aléatoires, il faut donc les initalisées une à une, par
                        #exemple dans une boucle.
TYPE ARR[TOUINT_VAL]... #Déclare et initialise ARR (possible d'initialiser ainsi
= { [VAL][, VAL]... }   #que pendant la déclaration)
                        #Il ne peut pas y avoir plus de VAL que TOUINT_VAL.
                        #S'il y en a moins, les autres VAL de l'array sont
                        #initialisées à 0. Ainsi affecter { } initialisera à 0
                        #tous les éléments d'une array, quel que soit son nombre
                        #de dimensions (ne marche pas sur les arrays beaucoup
                        #trop grands)
                        #En cas d'array multi-dimensionnelles, VAL doit être lui
                        #même { [VAL][, VAL]... }
                        #Il est possible ici (et seulement ici) d'omettre la 
                        #première des dimensions TOUINT_VAL, et de ne mettre 
                        #que [], car elle sera devinée par le compilateur grâce 
                        #à la taille de la liste { [VAL][, VAL]... }
                        #Il est impossible d'affecter un ARR directement à un
                        #autre ARR.
                        #TOUINT_VAL ne doit pas être une const VAR.
ARR[TOUINT_VAL]...      #Exécution d'une array. En cas de matrice multi-
                        #dimensionnelle, toutes les dimensions doivent être 
                        #présentes (impossible de renvoyer une array comprise
                        #dans l'array englobante)

POINTEURS ET ARRAYS     #Un array est en fait un ADR (du moins d'un point de vue
  ==>                   #pratique, même s'il y a des différences (voir ci-
                        #dessous)). L'indexation ARR[TOUINT_VAL] utilise en 
                        #fait l'arithmétique des pointeurs. La zone mémoire 
                        #pointée est une suite de valeurs contigües en mémoire. 
                        #Ainsi :

*(ARR + TOUINT_VAL)     #Equivaut à ARR[TOUINT_VAL]. TOUINT_VAL[ARR] est aussi
                        #équivalent, mais c'est juste une prouesse syntaxique :
                        #à ne pas utiliser.
*(*(ARR + TOUINT_VAL1)  
+ TOUINT_VAL2)          #Equivaut à ARR[TOUINT_VAL1][TOUINT_VAL2]

ARRAYS DYNAMIQUES ==>   #Il est donc possible de manipuler un array sous la 
                        #forme :

TYPE * ARR              #Déclaration d'"array"
*(ARR + TOUINT_VAL)
= VAL                   #Initialisation d'"array"
*(ARR + TOUINT_VAL)     #Exécution d'"array"

                        #Il y a cependant trois différences :
                        #  - la déclaration + initialisation via { } n'est pas
                        #    disponible. De fait l'array est initialisé à des
                        #    valeurs aléatoires.
                        #  - la déclaration avec TYPE ARR[TOUINT_VAL] entre 
                        #    crochets alloue TOUINT_VAL * sizeof(TYPE) octets
                        #    en mémoire, consécutivement et de manière contigüe,
                        #    après l'adresse pointée par ARR. TYPE *ARR n'alloue
                        #    pas la mémoire qui le suit. Cela a pour effet
                        #    qu'accéder aux valeurs de ce dernier ARR peut :
                        #      - (c'est imprévisible) pointer vers une valeur
                        #        non accessible en écriture, entrainant un
                        #        segfault
                        #      - écrire là où la valeur d'autres variables a été
                        #        attribuée par la mémoire (buffer overflow).
                        #    (Ce sont aussi les risques de dépasser les limites
                        #    d'un array, quelle que soit sa forme)
                        #    Pour éviter que d'autres valeurs s'immiscent dans
                        #    ARR et que l'on ait accès en écriture vers les
                        #    emplacement mémoire de ses valeurs, il faut donc
                        #    allouer la mémoire. Pour allouer de la mémoire à un
                        #    array déclaré avec TYPE *ARR, il faut utiliser
                        #    malloc, realloc, etc. (voir stdlib.h)
                        #    L'allocation de mémoire via malloc diffère de celle
                        #    via TYPE ARR[TOUINT_VAL] car, contrairement à cette
                        #    dernière :
                        #      - malloc et realloc initialise parfois (et 
                        #        calloc toujours) la mémoire allouée avec des 0
                        #      - la taille allouée peut être réallouée (via 
                        #        realloc)
                        #      - l'allocation de la mémoire est dynamique, et 
                        #        non locale. Cela peut être souhaité par exemple
                        #        à l'intérieur d'une fonction retournant
                        #        l'array créé sous forme de pointeur. Avec une
                        #        allocation locale, dans ce cas, la mémoire
                        #        allouée aux valeurs de l'array ne l'est plus à
                        #        la fin de la fonction, et ses valeurs peuvent
                        #        être écrasées
                        #  - un ARR déclaré via TYPE ARR[TOUINT_VAL] a parfois 
                        #    le comportement d'une VAR et non d'une ADR,
                        #    contrairement à un TYPE *ARR. Par exemple :
                        #       - la sizeof(ARR) du premier est TOUINT_VAL *
                        #         sizeof(TYPE) alors que celle du second est
                        #         simplement la taille du pointeur ARR.
                        #       - on peut affecter une ADR au second mais pas au
                        #         premier. Ainsi, les opérations :
                        #           - ARR = ARR2
                        #           - ARR = ARR2 + 1
                        #           - ARR++
                        #         ne sont disponibles qu'avec le second.
                        #         On peut affecter une ARR statique à une ARR
                        #         dynamique, mais il semble que l'on ne puisse
                        #         pas affecter une ARR_ARR statique à une 
                        #         ARR_ARR dynamique.
                        #  - un ARR défini sous la forme TYPE ARR[TOUINT_VAL] 
                        #    dans un fichier doit êtré déclaré sous cette même
                        #    forme dans un autre fichier cherchant à l'inclure
                        #De manière générale, le second (appelé dynamic array),
                        #est préférable. Attention cependant à bien gérer la
                        #mémoire allouée dynamiquement

MATRICES DYNAMIQUES ==> #Une matrice est en fait une array de pointeur. 
                        #L'ensemble de la matrice n'est donc pas contigu en 
                        #mémoire :
                        #  - il y a un première dimension, contigüe en mémoire,
                        #    avec une liste de pointeurs
                        #  - chacun de ces pointeurs pointe vers un array,
                        #    contenant des valeurs contigus en mémoire, mais ces
                        #    arrays imbriqués ne sont pas forcément contigus
                        #    entre eux.
                        #On peut donc manipuler une matrice sous la forme :

TYPE **ARR_ARR          #Déclaration de matrice. La forme TYPE *ARR[TOUINT_VAL]
                        #est un mixte : il s'agit d'un array dynamique contenant
                        #des arrays non dynamiques.
*(*(ARR_ARR
+ TOUINT_VAL1)          #Initialisation de matrice. La forme mixte *(ARR_ARR + 
+ TOUINT_VAL2) = VAL    #TOUINT_VAL1)[TOUINT_VAL2] est possible
*(*(ARR_ARR
+ TOUINT_VAL1)
+ TOUINT_VAL2)          #Exécution de matrice

ALLOCATION DE MEMOIRE   #Les remarques précédentes sur les arrays dynamiques
DYNAMIQUE  ==>          #sont valable aussi ici. Cependant, il ne faut pas
                        #faire :
                        #  - TYPE **ARR_ARR = malloc(sizeof(TYPE) * TOUINT_VAL1
                        #    * TOUINT_VAL2)
                        #car la mémoire est ici allouée seulement à la première
                        #dimension de la matrice (l'array englobant, constitué 
                        #de pointeurs). La taille allouée est donc trop grande, 
                        #mais surtout, les pointeurs continuent eux-mêmes de
                        #pointer vers des zones mémoires non allouées. Il faut
                        #donc faire :
                        #  - TYPE **ARR_ARR = malloc(TOUINT_VAL1 *
                        #    sizeof(TYPE *));
                        #    int VAR;
                        #    for ( VAR = 0 ; VAR < TOUINT_VAL1 ; VAR++ )
                        #        ARR_ARR[VAR] = malloc(TOUINT_VAL2 * 
                        #        sizeof(TYPE));
                        #Ainsi, chaque malloc libère de l'espace pour un array
                        #englobé, et renvoie un pointeur vers cet array dans
                        #l'array englobant, et ce pour chaque pointeur de
                        #l'array englobant. L'array englobant devient donc une
                        #suite de pointeurs pointant vers des zones mémoires
                        #initialisées avec des 0.

DYNAMIC MULTI-          #Le raisonnement précédent peut être poursuivi pour des
DIMENSIONAL ARRAYS ==>  #arrays aux dimensions supérieures à 2.
                        #Avec les multidimensional arrays dynamiques, on peut
                        #aussi prendre n'importe quel sous-array de l'array
                        #englobant, et lui affecter un autre sous-array, pourvu
                        #que ce dernier ait le même niveau de récursion.
                        #Par exemple, dans un ARR_ARR_ARR, l'array englobant
                        #comprend plusieurs ARR_ARR, auxquelles il est possible
                        #d'affecter d'autres ARR_ARR (notamment entre elles).
                        #Il en va de même pour les ARR qu'elles-mêmes 
                        #contiennent

ARRAYS COMME PARAMETRES #Un array passé en argument à une fonction est forcément
D'UNE FONCTION ==>      #un call by address. Si l'on ne veut pas modifier
                        #l'array originel, il faut donc faire une copie soi-même
                        #au sein de la fonction.
                        #Par ailleurs, un array statique (ou l'array englobant
                        #d'un array multi-dimensionnel s'il est statique) ne
                        #souffre pas, au sein de la fonction, des 
                        #caractéristiques suivantes, décrites précédemment :
                        #  - sizeof égale à l'ensemble des membres de l'array
                        #  - impossible de lui affecter une ADR. Mais l'ADR sera
                        #    affecter à la copie du pointeur, et non à l'ARR
                        #    originel
                        #Mais il continue de souffrir des autres problèmes.
                        #Il pointe notamment la même zone mémoire, donc le fait
                        #qu'elle soit correctement ou non, dynamiquement ou non 
                        #allouée ne change pas.

TYPE FONC_NAME(TYPE1    #Déclaration d'une fonction ayant un array en paramètre.
ARR[TOUINT_VAL])        #L'une ou l'autre syntaxe n'importe pas, que l'array
TYPE FONC_NAME(TYPE1    #soit dynamique ou statique.
*ARR)                   #TOUINT_VAL peut être omis, et n'être que [], car la
                        #taille de ARR est devinée par la taille de l'ARR passée
                        #en argument.
FONC_NAME(ARR)          #Exécution de cette fonction
TYPE FONC_NAME(TYPE1    
ARR[TOUINT_VAL]) {
    COMMANDE;...
}       
TYPE FONC_NAME(TYPE1    
*ARR) {
    COMMANDE;...    
}                       #Initialisation de cette fonction.
TYPE FONC_NAME(TYPE1    
ARR[TOUINT_VAL1]
[TOUINT_VAL2])          #Déclaration d'une fonction ayant une matrice en
TYPE FONC_NAME(TYPE1    #paramètre. Seul le TOUINT_VAL de l'array englobant peut
**ARR)                  #être omis.

                                  ┌─────────────┐
                                  │   STRINGS   │
                                  └─────────────┘

STRINGS ET ARRAYS ==>   #Une string est en en fait un ARR composé de char, et
                        #terminé par '\0' (toujours le compter dans la taille 
                        #totale de la string). Il a pour seule différence la
                        #possibilité de faire :

char STR[TOUINT_VAL]    #Equivaut à char STR[TOUINT_VAL] = { CHAR_LIT
= STR_LIT               #[, CHAR_LIT]..., '\0' }. La mémoire est allouée selon
                        #les règles de tout TYPE ARR[TOUINT_VAL] = { ... }
char *STR = STR_LIT     #Déclare STR et lui affecte STR_LIT. Cependant, la
                        #mémoire n'est pas allouée, comme s'il on avait juste
                        #fait char *STR seulement.
STR = STR_LIT           #Affecte STR_LIT à STR. Possible seulement si STR a été
                        #déclaré sous la forme char *STR. La mémoire n'est pas
                        #non plus allouée. Si a été allouée, elle ne l'est plus
                        #(utiliser donc strcpy(), etc. pour initialiser une STR
                        #dynamique.
STR_LIT[TOUINT_VAL]
*(STR_LIT + TOUINT_VAL) #Sont des expressions valides

ARRAY DE STRINGS ==>    #Un array de strings répond aux même règles qu'une
                        #matrice normale. Une STR ne peut par ailleurs qu'être
                        #au plus bas niveau d'une matrice.

ALLOCATION DE LA        #Les fonctions écrivant sur des strings exigent que la
MEMOIRE D'UNE STRING    #mémoire leur soit correctement allouée, sinon elles
 ==>                    #produisent un segfault. Il faut donc éviter de déclarer
                        #une string via char *STR sans allouer ensuite de la
                        #mémoire dynamiquement.
                        #Par ailleurs, dépasser les limites de la string est une
                        #erreur courante, ou tentative de corruption par
                        #buffer overflow. Il faut donc vérifier cela, et donc
                        #préférer les strings dont l'allocation de la mémoire
                        #est dynamique, ce qui permet d'ajuster la taille
                        #maximale de la string en fonction des évènements.

                                  ┌──────────────────────────────────┐
                                  │   MULTIBYTE ET WIDE CHARACTERS   │
                                  └──────────────────────────────────┘

MULTIBYTE ET WIDE       #Il y a deux moyens d'encoder utf-8 et utf-16 :
CHARACTERS ==>          #  - utiliser des caractères multibyte signifie utiliser
                        #    une suite de char (1 octet), où un seul caractère 
                        #    imprimable peut être encodé avec un ou plusieurs
                        #    char. Le nombre de char n'est donc pas nécessaire-
                        #    ment égal au nombre de caractères imprimables.
                        #    Pour certaines fonctions qui ne font pas d'analyse
                        #    supposant qu'un octet doit == un caractère
                        #    imprimables, cela est ok, mais pour d'autres
                        #    (comparaison de strings, calcul de la taille d'une
                        #    string, etc.), il faut utiliser des wide characters
                        #    et les fonctions qui vont avec.
                        #  - utiliser des wide characters, signifie utiliser une
                        #    suite de wchar_t (2 ou 4 octets), où chaque wchar_t
                        #    encode un seul caractère imprimable, mais peut
                        #    encoder tout caractère unicode.
                        #Par défaut, si le système supporte Unicode, les strings
                        #respectent les caractères multibyte.
                        #Pour des wide caractères, il faut utiliser le type
                        #wchar_t (minimum 2 octets) ou wint_t (minimum 4 octets,
                        #peut donc avoir WEOF, sans que cela crée de collusion),
                        #et les fonctions qui vont avec. Pour moi, ils sont
                        #encodés en UTF-16 et non UTF-8
                        #Les locales doivent par ailleurs :
                        #  - être du langage désiré pour la conversion.
                        #  - supporter Unicode ("fr_FR.UTF-8" et non "fr_FR")
                        #<wchar.h>, et parfois <wctype.h>, doit être inclus.
                        #Une WSTR est terminé par L'\0' et non '\0'

L"MESSAGE"              #Renvoie une WSTR et non une STR
L'CHAR'                 #Renvoie un WCHAR et non un CHAR

                                  ┌───────────────┐
                                  │   FONCTIONS   │
                                  └───────────────┘

TYPE FONC_VAR           #Déclaration de fonction (aussi appelé prototype, ou
([TYPE1 [VAR1]]         #signature). Les paramètres de la fonction doivent être
[, TYPE2 [VAR2]]...)    #déclarés également, ainsi que leur type.
                        #Le TYPE de la fonction est celui de la valeur qu'elle
                        #retourne (void si elle ne retourne rien) : peut être
                        #complexe. Pour retourner un array, utiliser TYPE * et
                        #l'équivalence pointeurs/arrays.
                        #Si la fonction ne prend pas d'arguments, il est d'usage
                        #de mettre void comme argument.
                        #VAR peut être omis, mais :
                        #  - s'il s'agit d'une déclaration + définition, VAR ne
                        #    pourra pas être utilisé
                        #  - s'il s'agit d'une déclaration sans définition, de
                        #    toute façon, seuls les VAR dans la définition
                        #    importent. Ils peuvent alors être omis.
                        #Les paramètres sont les VAR... et les arguments sont
                        #les valeurs renvoyées par ces VAR...
FONC_VAR([VAL]          #Exécute une fonction, et renvoie ce qui est return par
[, VAL]...)             #la fonction. Peut donc avoir deux utilités :
                        #  - renvoyer une valeur. La valeur ne peut pas être
                        #    affectée à une static ou extern variable
                        #  - exécuter les commandes de la fonction
                        #Si la fonction exige des arguments, des VAL doivent 
                        #être apportées, et du même type que celui exigé par le
                        #prototype de la fonction.
                        #La fonction appelée initialise ses paramètres en 
                        #fonction de ces VAL, ce qui signifie que si ces 
                        #dernières sont des VAR, elles ne sont pas passées elles
                        #mêmes à la fonction, mais seulement leur valeur, et la
                        #fonction fait une copie locale de ces valeurs. Les
                        #variables nouvellement créées dans la fonction sont
                        #donc distinctes des variables passées lors de
                        #l'exécution de la fonction.
TYPE FONC_VAR           #Initialise une fonction. Doit correspondre au prototype
([TYPE1 VAR]            #de la fonction, sauf le nom des VAR, qui peut diverger.
[, TYPE2 VAR2]...) {    #Les arguments n'ont pas besoin d'être redéclarés dans
    COMMANDE;...        #le corps de la fonction, et seront initialisés en 
    [return VAL;]       #fonction de l'exécution de la fonction.
}                       #Les COMMANDE;... sont effectuées. Elles peuvent 
                        #contenir FONC_VAR, créant ainsi une fonction récursive
                        #(il pourra être utile dans ce cas d'utiliser des static
                        #VAR)
                        #VAL ne peut pas être un array entier, mais peut être un
                        #pointeur utilisé ensuite grâce à l'équivalence 
                        #pointeurs/arrays.

CALL BY VALUE OR        #Un call by address est l'exécution d'une argument
CALL BY ADDRESS ==>     #prenant des pointeurs comme argument. Le contraire est
                        #un call by value. Il est aussi parfois appelé par abus
                        #de langage call by reference (qui est une notion 
                        #distincte par exemple en C++)
                        #Un call by address est donc permis par un prototype
                        #de fonction comme :
                        #  - TYPE FONC_VAR([TYPE *ADR] ... )
                        #Et une exécution de fonction comme :
                        #  - FONC_VAR(ADR)
                        #  - FONC_VAR(&VAR)
                        #Contrairement à un call by value, l'argument ADR est
                        #bien local à la fonction (le pointeur lui-même), mais
                        #pas la valeur qu'il pointe. Ainsi, à l'intérieur de la
                        #fonction, la modification de *ADR modifiera la valeur
                        #en outrepassant la question de la portée locale de la
                        #fonction. Cela permet aussi de créer moins de mémoire,
                        #notamment si l'argument est une struct.

POINTEURS DE FONCTIONS  #Un pointeur de fonction désigne en fait l'adresse de la
  ==>                   #suite d'opcodes composant la fonction en mémoire :

TYPE1 (*)(TYPE...)      #Type d'un pointeur de fonction, d'une fonction ayant
                        #une return value TYPE1, et prenant des argument 
                        #TYPE...
typedef TYPE1 (*TYPEDEF)
(TYPE...)               #Syntaxe pour un typedef.
TYPE (*FONC_ADR)
(TYPE...)               #Déclaration de pointeur de fonction
FONC_ADR = &FONC_VAR    #Initialisation de FONC_ADR. Le TYPE renvoyé par 
FONC_ADR = FONC_VAR     #FONC_VAR doit être le même que celui de FONC_ADR. Les
                        #deux syntaxes sont équivalentes
TYPE (*FONC_ADR)()
= &FONC_VAR             
TYPE (*FONC_ADR)()      
= FONC_VAR              #Déclaration + initialisation 
(*FONC_ADR)(VAL1
[, VAL2]...)            
FONC_ADR
(VAL1[, VAL2]...)       #Revient à exécuter FONC_VAR(VAL1[, VAL2]...)

                        #Il n'est pas possible de passer une fonction comme
                        #argument à une autre fonction, mais il est cependant
                        #possible de lui passer un pointeur de fonction :

TYPE FONC_VAR2(TYPE2    #Prototype d'un fonction ayant un pointeur de fonction
(*FONC_ADR)())          #comme argument
FONC_VAR(FONC_VAR2)     #Exécution d'une telle fonction (les trois syntaxes sont
FONC_VAR(&FONC_VAR2)    #équivalentes, même si ça semble étrange). Ne pas mettre
FONC_VAR(FONC_ADR)      #de () à FONC_VAR revient en fait à désigner son adresse

TYPE DE FONCTION ==>    #Un type de fonction, par opposition à un type de pointeur de fonction est :
                        #  - TYPE( TYPE... )
                        #  - typedef TYPE FONCTION_TYPE( TYPE... )
                        #Ne peut pas être défini ni initialisé. Seuls intérêts :
                        #  - déclaration de fonction, sans initialisation : FONCTION_TYPE FONC;
                        #  - typedef de pointeur de fonction, à partir d'un type de fonction : 
                        #      typedef FONCTION_TYPE* POINTEUR_FONCTION_TYPE

                                  ┌────────────────┐
                                  │   OPERATIONS   │
                                  └────────────────┘

OPERATIONS
ARITHMETIQUES  ==>      #Les voici :

+
-
/
*
-VAL                    #Négation de VAL
sizeof(TYPE | VAL)      #Renvoie la taille en octets occupés par VAL ou TYPE (il
                        #s'agit d'un opérateur)

OPERATIONS
BINAIRES    ==>         #Les voici :

&
|
^
>>                      #VAL1 >> VAL2 est arithmétique si VAL1 est
<<                      #signed, logique sinon. Même chose pour <<.
~                       #Complément de 1
%                       #Modulo : ne marche que sur des TOUINT. Utiliser fmod()
                        #pour les floats.

OPERATIONS              #Les voici. Le résultat d'une assignation est renvoyé,
D'ASSIGNATIONS ==>      #et peut être récupéré, par exemple :
                        #  - VAR1 = ( VAR2 = VAL ) * 2

+=
-=
*=
/=
%=
<<=
>>=
&=
^=
|=
VAR++                   #Incrémente après avoir renvoyer la valeur de VAR
++VAR                   #Incrémente avant d'avoir renvoyer la valeur de VAR
VAR--
--VAR

                                  ┌───────────┐
                                  │   TESTS   │
                                  └───────────┘

VALEUR LOGIQUE ==>      #0 est faux, != 0 est vrai (par défaut 1).

TEST ==>                #Un TEST est une comparaison entre deux VAL avec les
                        #opérateurs de comparaison :

==                      #Et non =
!=                      
>                       
>=                      
<                       #Utiliser les fonctions, plutôt que les opérateurs pour
<=                      #comparer des STR et des CHAR !

                        #Ces TESTS peuvent être composés entre eux à l'aide des
                        #opérateurs logiques :

||
&&                      #|| et && n'évaluent l'expression qui suit que si celle
                        #qui précède est fausse ou vraie. Ainsi, cela peut être
                        #utilisé si l'expression qui suit peut provoquer une
                        #division par 0 :
                        #  - ( VAR == 0 || VAR2 / VAR ... )
                        #ou déréférence un pointeur NULL :
                        #  - ( ADR != NULL && *ADR ... )
!
( )
,                       #Evalue chaque TEST entre les virgules, mais ne renvoie
                        #que le dernier.

OPERATIONS              #Etant donné que 0 est faux, et != 0 vrai, on peut
ARITHMETIQUES ==>       #utiliser des opérations arithmétiques comme TEST

ASSIGNATION ==>         #On peut aussi inclure des assignations, qui seront
                        #évaluée, et renverront la nouvelle valeur de la lvalue.
                        #L'intérêt est de pourvoir faire les deux en même temps.
                        #Syntaxe souvent rencontrée par exemple :
                        #  - while (( VAR = FONC_VAR() ) != EOF )
                        #Mais VAR doit avoir été déclarée avant

VAR                     #Signifie VAR != 0
                        #Si VAR est une CHAR_VAR, équivaut à CHAR_VAR != '\0', 
                        #car la comparaison d'un CHAR et d'un INT transtype le 
                        #CHAR, or (int)'\0' == 0. Exemple :
                        #  - char *CHAR_ADR = STR_LIT;
                        #    while (*CHAR_ADR)
                        #        printf("%c\n", *CHAR_ADR++);
                        #Des arrays non-strings (notamment des arrays de 
                        #strings) utilisent aussi '\0' comme dernière valeur,
                        #ce qui permet d'utiliser VAR comme TEST dans une boucle

                                  ┌───────────────────────────┐
                                  │   BOUCLES ET STATEMENTS   │
                                  └───────────────────────────┘

if ( TEST ) {
    COMMANDE ;...   
}
[else if ( TEST ) {
    COMMANDE ;...
}]
[else {
    COMMANDE ;...
}]

( TEST ) ? COMMANDE1    #Est remplacé par COMMANDE1 si TEST est vrai, et par
: COMMANDE2             #COMMANDE2 sinon.

while ( TEST ) {
    COMMANDE...
}
do {
COMMANDE... 
} while ( TEST )        #Comme while, mais effectue d'abord COMMANDE avant TEST

for ( VAR = VAL
[, VAR = VAL] ; TEST ;
OPERATION
[, OPERATION] ) {
    COMMANDE... 
}                       #VAR... doit être déclarée avant la boucle for. 
for ( ; ; )             #Boucle infinie. En effet chacun des trois membres est 
                        #facultatif.

if ( TEST ) COMMANDE ;  
if ( TEST )             
    COMMANDE ;          
while ( TEST ) COMANDE; #Toutes les structures et boucles peuvent être 
while ( TEST )          #écrites :
    COMMANDE ;          #  - avec les accolades
for ( ... ) COMMANDE;   #  - sur une seule ligne ainsi
for ( TEST )            #  - sans accolade (en général indenté) sur la ligne 
    COMMANDE;           #    suivante, qui seule est comprise (si elle comprend
                        #    un début de boucle ou de statement, toute la boucle
                        #    ou statement est compris)

switch ( TOUINT_VAR ) {
    case TOUINT_VAL1 :
    [case TOUINT_VAL2 :]...
        COMMANDE ;...
        [break ;]       
    ...                 #Sans break, les instructions du case suivant seront
    [default :          #exécutées : deux case VAL1 et VAL2 : se suivant permet 
        COMMANDE ;...   #donc d'exécuter les COMMANDES pour VAL1 et VAL2
        break ;]        #Il est illégal de mettre deux case avec la même VAL
}                       

break                   #Interrompt la boucle courante.
continue                #Démarre le prochain loop de la boucle courante sans 
                        #terminer le loop courant

MOT:                    #Définit un label MOT (portée locale à la fonction 
                        #courante)
goto MOT                #Va au label MOT

{
    COMMANDE;...        #Bloc anonyme. Seul utilité est d'avoir une portée 
}                       #restreinte à l'intérieur

                                  ┌──────────────┐
                                  │   FICHIERS   │
                                  └──────────────┘

FILE ==>                #Voir stdio.h.

STREAM VS BUFFER VS     #Un type FILE se présente comme un stream.
CACHE  ==>              #Il représente un degré d'abstraction supérieur au
                        #file descriptor, et contient à la fois un flux d'octets
                        #de taille indéterminé, un file position indicator, des
                        #flags (EOF, erreur, ...), un buffer, ...
                        #Les file descriptors n'ont pas de buffer (mais ont un
                        #file position indicator et des flags)
                        #Ecrire ou lire sur le stream fait souvent intervenir
                        #des opérations hardware, lentes (rotation de la tête de
                        #lecture d'un DD par exemple). Pour éviter de répéter 
                        #ces opérations à chaque lecture/ériture d'un octet, les
                        #octets sont aglutinés dans une zone mémoire allouée,
                        #appelée buffer. Ce buffer est rempli à un taux plus
                        #rapide qu'il n'est libéré. Un buffer peut être :
                        #  - un output buffer :
                        #       STREAM -->  BUFFER --> HARDWARE
                        #    Exemple : écriture sur un fichier du DD
                        #  - un input buffer :
                        #       HARDWARE -->  BUFFER --> STREAM
                        #    Exemple : lecture d'un fichier du DD, lecture des
                        #    mouvements d'une souris
                        #Un cache n'est pas un buffer, car il n'est pas vidé une
                        #fois lu, mais a en général vocation a être lu à nouveau

TYPES DE BUFFER ==>     #Un FILE peut avoir trois types de buffers :
                        #  - Unbuffered    : pas de buffer
                        #  - Line buffered : le buffer est vidé lorsqu'il est
                        #                    plein, lorsqu'il rencontre une
                        #                    newline, ou lorsqu'il rencontre une
                        #                    tentative de lecture
                        #  - Full buffered : le buffer est vidé lorsqu'il est
                        #                    plein
                        #Un FILE ouvert est en général full buffered, sauf
                        #s'il est lié à un terminal interactif (exemple : les
                        #flux standards), auquel cas, il est line buffered
                        
BINARY FILE VS TEXT     #La différence entre les deux est que les text files
FILE  ==>               #suivent une logique "linewise". Sous Lunix, il n'y a 
                        #pas de différence entre les deux.
                        #Sous Windows, il peut y avoir des différences :
                        #  - \r\n est converti en \n à la lecture, et reconverti
                        #    en \r\n à l'écriture
                        #  - les whitespaces précédant la newline peuvent être
                        #    supprimés
                        #  - une ligne peut ne pas pouvoir contenir plus de
                        #    254 caractères (dont newline)
                        #  - parfois, seuls les caractères imprimables, tab et
                        #    newline sont supportés, les restes sont discarded
                        #  - une suite de '\0' est parfois appended après 
                        #    l'écriture d'un binary file
                        #  - le file position indicator n'indique pas forcément
                        #    l'offset d'octets exact.
                        #    Le random access marche donc mal

                                  ┌─────────────┐
                                  │   ERREURS   │
                                  └─────────────┘

ERREURS COMMUNES ==>    #Voici :

                        #  - stack overflow : avoir un stack trop grand, par 
                        #    exemple en :
                        #      - faisant une récursion infinie
                        #      - assignant des variables prenant trop de 
                        #        mémoire (par exemple un array avec des 
                        #        millions d'éléments)
                        #  - buffer overflow : assigner une VAL à une VAR 
                        #    supérieure à la taille en mémoire de cette VAR, ce 
                        #    qui fait que les octets restants sont imprimés sur 
                        #    la VAR2 contigüe, qui suit VAR. Cette VAR2 est 
                        #    donc modifiée. Arrive souvent sur des 
                        #    manipulations d'arrays (dont strings). Cela peut 
                        #    être utilisée de manière malveillante (si VAR2 est 
                        #    une adresse, en modifiant cette adresse pour que 
                        #    le programme aille à un endroit précis de la 
                        #    mémoire)
                        #  - segmentation fault (segfault) : essayer d'accéder 
                        #    à un endroit de la mémoire (généralement via *ADR) 
                        #    sans avoir le droit d'y accéder. Cela provient :
                        #      - du déférencement de pointeur non-initialisés 
                        #        (dangling pointers)
                        #      - de l'utilisation de *VAR alors que l'on 
                        #        pensait faire un *ADR (par exemple avec un 
                        #        pointeur mal initialisé (par exemple TYPE *ADR 
                        #         = VAR au lieu de TYPE *ADR = &VAR))
                        #      - d'écrire *ADR là ou seulement ADR est attendu 
                        #        (parce que l'on pense que VAR est attendu) : 
                        #        par exemple printf("%s\n", *STR)
                        #    Cependant, souvent, si une fonction prend un ADR en
                        #    argument, mais ne le modifie pas (n'utilisant que
                        #    son *ADR), il est possible de ne pas allouer de la
                        #    mémoire à ADR, et de ne faire que &VAR. Cela est
                        #    valable aussi pour un ADR_ADR, ou on peut faire 
                        #    alors &ADR (mais ADR doit alors être alloué quant à
                        #    lui), et ainsi de suite. Cela évite de faire un
                        #    malloc() en plus
                        #  - memory leak : ne pas désallouer la mémoire 
                        #    accordées aux variables dynamiques (notamment si 
                        #    le pointeur n'existe plus faute de portée, et la 
                        #    mémoire ne peut donc plus être libérée). Peut 
                        #    conduire un crash si plus de mémoire dans le heap 
                        #    et que code dépend de l'allocation de nouveaux 
                        #    pointeurs dynamiques

                                  ┌─────────────────────────┐
                                  │   STACK, HEAP ET CODE   │
                                  └─────────────────────────┘

TROIS PARTIES D'UN
PROGRAMME ==>           #En runtime, en mémoire, un programme est découpé en 4 :

                        #  - la pile (call stack), empile chaque fonction dans 
                        #    un nouveau stack frame. Une fonction appelle une 
                        #    autre fonction, pushant ainsi un nouveau niveau 
                        #    dans la pile. Chaque stack frame est composé :
                        #      - des paramètres passés à la fonction
                        #      - de l'adresse à laquelle renvoyer la return 
                        #        value lors de la fin de la fonction (et donc 
                        #        le pop de la stack frame)
                        #      - un espace alloué aux variables locales
                        #    Un stack pointeur pointe vers le haut de la pile. 
                        #    Un frame pointeur pointe vers la return adress.
                        #  - la global area, contenant les extern et static
                        #    variables (.data et .bss)
                        #  - le heap (tas, ou "free store") contient les 
                        #    dynamic  allocated variable
                        #  - le code (suite d'instructions du code), read-only

                                  ┌───────────────────────────┐
                                  │   VARIABLES PREDEFINIES   │
                                  └───────────────────────────┘

VARIABLES PREDEFINIES
 ==>                    #Il y a des constantes associées à chaque programme :

__LINE__                #Numéro de ligne courant du fichier source courant, 
                        #sous forme d'INT_VAR
__FILE__                #Basename du fichier source courant, sous forme de STR
__DATE__                #Date courante lors de la compilation, sous forme de STR
__TIME__                #Temps courant lors de la compilation, sous forme de STR
__STDC__                #Egal à 1, sous forme d'INT_VAR, si le compilateur est
                        #compatible C89

                                  ┌──────────────────────┐
                                  │   STANDARD LIBRARY   │
                                  └──────────────────────┘

STANDARD LIBRARY ==>    #La bibliothèque standard est un ensemble de fonctions
                        #généralement utilisées, et standardisées par C89, puis
                        #augmentées par C95 et C99.
                        #Son implémentation dépend de la library C utilisée, qui
                        #installe les headers également.
                        #Sous Linux, il s'agit de glibc.
                        #Voici un tableau récapitulatif :
NOM          STANDARD   EXEMPLES

<assert.h>   C89        Seulement assert()
<ctype.h>    C89        isalnum(), isalpha(), ..., toupper(), tolower()
<errno.h>    C89        errno, EDOM, ERANGE, ...
<float.h>    C89        FLT_RADIX, FLT_MAX, DBL_MIN, LDBL_DIG
<limits.h>   C89        CHAR_BIT, INT_MAX, ..., MB_LEN_MAX
<locale.h>   C89        LC_ALL, ..., setlocale(), struct lconv, localeconv()
<math.h>     C89        floor(), fabs(), modf(), sqrt(), pow(), exp(), cos()
<setjmp.h>   C89        setjmp(), longjmp(), struct jmp_buf
<signal.h>   C89        signal(), raise(), SIG_IGN, SIGKILL, SIGINT, ...
<stdarg.h>   C89        va_list, va_start(), va_arg(), va_end(), va_copy()
<stddef.h>   C89        NULL, size_t, wchar_t, offsetof()
<stdio.h>    C89        stdin, EOF, fopen(), printf(), fgets(), puts(), feof(),
                        fseek(), getline()
<stdlib.h>   C89        abort(), system(), rand(), abs(), div(), getenv(), 
                        atof(), malloc(), mblen()
<string.h>   C89        strlen(), strcpy(), strcat(), memcpy(), strcmp(),
                        strchr(), strtok(), strerr()
<time.h>     C89        clock(), time(), mktime(), ctime(), strftime()

<iso646.h>   C95        and, or, not, or_eq, ...
<wchar.h>    C95        mbstowcs(), fgetws(), fputws(), wcslen(), wcscpy()
<wctype.h>   C95        WEOF, iswalnum(), ..., iswctype(), towupper()

<complex.h>  C99        Arithmétiques des nombres complexes
<fenv.h>     C99        Manipulation poussée des floats
<stdint.h>   C99        int_least8_t, INT16_MAX, INT8_C(), intmax_t, SIZE_MAX
<inttypes.h> C99        PRIxMAX, SCNo16, ...
<stdbool.h>  C99        true, false, bool
<tgmath.h>   C99        Arithmétiques complexes
