
                
   R_SYNTHESE   
                


                                  ┌─────────────┐
                                  │   GENERAL   │
                                  └─────────────┘

VERSION ==>             #2.15

help(COMMAND)           
?COMMAND                #Commande d'aide
help.search(REGEX)
??REGEX                 #Recherche de commandes
example(COMMAND)        #Lance des commande montrant par l'example le fonctionnement de COMMAND

REGEXP ==>              #Regexps étendus ("limit-class"). Pas de globbing.
                        #Perl regexp avec argument "perl" parfois. Alors, faire un double échappement.
                        #  - seulement \w, \s, \d (dont majuscules)

SHORTCUTS ==>           #Look at /etc/inputrc

                                  ┌─────────────┐
                                  │   SYNTAXE   │
                                  └─────────────┘

#COMMENT                #Commentaires sontt jetés dès que possible et impossibles à capturer dans un language object.
#line NUM [FILE]        #Preprocessing directive, comme en C, peu utile pour l'user

SYNTAXE ==>             #R est case sensitive
                        #Les espaces (ou leur absence) n'ont pas d'importance
                        #On peut clore ligne par newline ou un ; comme en Bash.

VARIABLES ==>           #Object-oriented, les variables sont appelées "objets"
VAL                     #Si seul sur la ligne de commande, imprime vers stdout (/dev/null si non-interactive)

VAR                     #Expand valeur de VAR
`VAR`                   #` est utilisé pour quote un NAME (VAR).
                        #On peut utiliser tout caractère spécial (dont " ' Unicode, control chars, mais sauf `) comme nom de 
                        #variable, en utilisant cette syntaxe.
                        #Cependant, pour être portable, utiliser seulement [[:alnum:]._], avec _ jamais au début, et . 
                        #jamais suivi d'un [:digit:] si au début.
VAR = VAL               #Assigne VAR pour l'ENVIRONMENT courant
VAR <- VAL              #Préférer <-, car = ne peut pas être utilisé partout.
VAL -> VAR              #Renvoie VAL, donc multiple assignement possible : VAR1 <- VAR2 <- VAL
VAR <<- VAL             #Comme assign() avec inherits=TRUE, sauf qu'en plus n'utilise pas l'ENVIRONMENT courant. Donc :
VAL ->> VAR             #  - assigne le VAR de l'ENVIRONMENT le plus enfant parmi les parents.
                        #    - si aucun ENVIRONMENT parent ne contient VAR, désigne alors .GlobalEnv

EXPR                    #Désigne un statement (un CALL). Peut être simple ou compound.
{ EXPR... }             #Il s'agit d'une compound EXPR. Evalue EXPR... et renvoie la dernière EXPR (return value)
                        #Ex.: { 1+1;2+2 } * 3 
                        #Utilisé par les structures function(), if, etc.
VISIBILITY ==>          #Il s'agit du fait qu'un EXPR soit imprimée en console ou non si top-level EXPR. 
                        #Une visible EXPR "top-level" (compound, ou simple mais isolée) sera imprimée via print() après 
                        #évaluation dans une console.
                        #Même invisible, elle reste utilisable en arg d'une autre fonction, dont assignement.
                        #La visibilité d'une compound EXPR est celle de sa return value.
( EXPR )                #Equivaut à EXPR, sauf que visibilité est toujours activée.
                        #Ex: (VAR <- VAL)
invisible(EXPR)         #Equivaut à EXPR, sauf que visibilité n'est jamais activée.
withVisible(EXPR)       #Renvoie une LIST où $value est évaluation d'EXPR (sauf si LANGUAGE object, cad eval(enquote(EXPR)))
                        #et $visible est TRUE ou FALSE selon visibility.

if ( BOOL )             
  EXPR else EXPR2       #else doit être sur la même ligne que dernière EXPR ou } si bloc.
ifelse(BOOLv,VALv,VAL2v)#Version vectorisée : chaque élément du VALv renvoyé dépend de chaque élément de BOOLv
for ( VAR in VALv ) EXPR
repeat EXPR             #while true
while ( BOOL ) EXPR

break                   #Arrête une loop for, repeat ou while.
next                    #Lance la prochaine loop en sautant l'actuelle.

switch(VAL[=DEFAULT],   #VAL peut être :
[NAME=]EXPR...)         #  - UINT, auquel cas l'EXPR numéro UINT est évaluée
                        #  - STR, auquel cas l'EXPR dont le NAME (sans quote) == STR est évaluée.
                        #    Si STR == aucun NAME, évalue l'unnamed EXPR s'il y en a un et un seul (sert à définir un défault).
                        #    EXPR peut être omis, auquel cas, c'est le prochain EXPR qui est évalué (sert à définir plusieurs
                        #    NAME pour un seul EXPR
                        #Sinon n'évalue rien, mais pas d'erreur.

                                  ┌─────────────┐
                                  │   CONSOLE   │
                                  └─────────────┘

INITIALISATION FILES ==>#Dans l'ordre :
                        #  - R_PROFILE (R-env. var) : si unset, R_HOME/etc/Rprofile.site
                        #  - ./.Rprofile
                        #    - si absent, ~/.Rprofile
                        #    - si R_PROFILE_USER (R-env. var) est set, utilise R_PROFILE_USER au lieu de ces derniers

R_HOME                  #Signifie /usr/lib/R/
R_HOME/etc/             #Fichiers conf de R (Bash), pointant vers /etc/ :
                        #  - Renviron : environment variables lors du lancement de R (mettre NULL, sans guillemets, pour une 
                        #    VAR vide)
                        #  - Makeconf : compil flags lors d'installation+compilation de packages 
                        #  - repositories : repos lors d'installation de packages
OPTIONS ==>             #Pseudo-environment variables associées à un package donné.
options()               #Montre ensemble des options variables.
options(VAR=VAL)        #Initialise/set une option variable.
getOption(STR|default)  #Renvoie valeur d'option variable STR. Renvoie default (déf: NULL) si STR n'existe pas.

R.home(|component)      #Renvoie emplacement selon component :
                        #  - "home" (déf) : ex: /usr/lib/R
                        #    - peut aussi utilisant commande R RHOME
                        #  - "bin" : ex: /usr/lib/R/bin/
                        #  - "modules" : ex: /usr/lib/R/modules/
                        #  - "share" : ex: /usr/share/R/

interactive()           #Renvoie TRUE si console intéractive.

HISTORY ==>             #Touches haut et bas.
                        #Sauvé dans un fichier nommé .Rhistory dans le répertoire courant.
                        #Les sessions sont donc liées à un répertoire donné.
                        #r-environment variables :
                        #  - R_HISTFILE (déf: ".Rhistory")
                        #  - R_HISTSIZE (déf: 512)
.Last.value             #Dernière valeure imprimée ou assignée.
[load|save]history      
(|file)                 #  - file (déf: "./R_HISTFILE")
history(|max.show,      #Imprime historique.
reverse,pattern,...)    #  - max.show (déf: 25)
                        #  - reverse (déf: FALSE)
                        #  - pattern (déf: NULL) : n'imprime que les lignes matchant pattern. ... sont args pour grep.
timestamp()             #Imprime time courant, et le met dans l'historique

.First                  
.Last                   #Définir ces fonctions fait qu'elles sont exécutées au début et fin d'une session

RDA FILE ==>            #Fichier binaire contenant un ensemble de variables. .RData est en fait un .rda file.
                        #Fichier binaire (bytecode), ensuit gzippé.
load(FILE|envir)        #Charge un fichier .rda.
save(...|list,file,     #Sauvegarde des vars sous un fichier .rda. 
ascii,version,envir,    #  - ... et list (déf: rien) : vars à sauvegarder
compress,               #  - file (pas de déf) : fichier à créer
compression_level)      #  - ascii (déf: FALSE) : sauvegarde sous un format bizarre, mais non-binaire (me semble inutile)
                        #  - version (déf: 2)
                        #  - compress (déf: !ascii) STR (déf: "gzip") : parmi "gzip", "bzip2", "xz". TRUE équivaut à "gzip"
                        #  - compression_level (déf: 6 pour gzip et 9 pour xz et bzip2)
save.image()            #Equivaut à save(list=ls(all=TRUE),file=".RData"). (invoqué lors d'un quit())

RDS FILE ==>            #Comme .rda, mais pour une seule variable. Sert donc à sérialiser.
saveRDS(object|file,
ascii,version,compress) #Comme save(), mais pour un .rds
readRDS(file)
[un]serialize(...)      #Semble pareil, sans l'arg. ascii et file ne peut pas être une STR.

RDB ET RDX FILES ==>    #Utilisé par un package.
                        #Contient variables du package : .rdb est database (compressée), .rdx index de la database.
                        #Loaded par lazyLoad(), mais lui-même appelé par d'autres fonctions de plus haut niveau lors du load
                        #du package.

edit(VAR|file,          #Edite l'objet via le programme editor (déf: option "editor") et renvoire l'objet modifié.
editor,...)             #Si file (déf: ""), crée aussi un fichier avec l'objet. ... est passé à editor.
                        #Des versions pour un editor donné existent aussi : vi(), emacs(), pico(), xemacs(), xedit()
                        #La fonction data.entry() est un editeur GUI pas terrible.
fix(VAR)                #Equivaut à VAL <- edit(VAR)

proc.time()             #Imprime temps écoulé de la session
system.time(EXPRESSION) #Benchmark timing

sessionInfo()           #Donne plusieurs infos sur la session courant (R version,plateforme,locales,packages)

                                  ┌─────────────────┐
                                  │   BASIC TYPES   │
                                  └─────────────────┘

DYNAMIC TYPING ==>      #Lors de VAR <- VAL, VAL est transtypé vers le type qu'elle semble indiquer.
                        #FUNC(VAL) ne modifie pas le type, car functions sont génériques, sauf functions builtins qui
                        #transtype alors VAL vers un builtin type, par exemple VAL + VAL2.

DATA TYPES ==>          #Le type de base est un vector VALv pour les types les plus courants : NUM, STR, RAW, LIST, LANGUAGE,
                        #EXPRESSION.
                        #Tout VAL scalaire est alors en fait un VALv d'un seul élément.
                        #Les opérations sont en général effectués sur chaque élément :
                        #  - deux vecteurs de tailles différentes peuvent opérer ensemble. Alors, le plus court se répète 
                        #    alors (notamment vecteur de taille 1)
                        #Le "type" désigne le type sous-jacent.
                        #Tous les éléments du vecteur doivent avoir le même type primitif.
                        #Types primitifs :
                        #  - "character" : STR ou CHAR, notés "STR" (préférer) ou 'STR' (déf: "")
                        #  - "double" : DOUBLE, la plupart des nombres natifs, même entiers, sont interprétés en double
                        #    - Formats possibles : 
                        #      - 1, 1.1, 1e10, -1
                        #      - 0xf0
                        #  - "integer" : INT[L]
                        #  - "complex" : COMPLEX, noté [NUM±]NUMi (déf: 0+0i)
                        #  - "logical" : BOOL_VAL, noté TRUE ou FALSE (déf: FALSE)
                        #    - T et F sont aussi possibles comme raccourcis, mais sont des variables, donc overwritables par
                        #      le client: utiliser donc TRUE et FALSE
                        #    - NA peut être utilisée comme "indeterminate" en logique tribooléenne
                        #  - "raw" : VOID_ADR, octet, noté 00 ou f8, etc. (déf: 00). Un vecteur donne un flux d'octets.
                        #  - NULL
                        #  - "list" et "pairlist"
                        #  - "expression", "language", "symbol"
                        #  - "closure", "builtin", "special"
                        #  - "S4" : semble être des définitions de classes S4
                        #  - "environment"
                        #  - "bytecode" : un pointeur vers du bytecode
                        #  - d'autres rarement utilisés : "promise", "externalptr", "weakref"
                        #  - utilisés qu'en interne : "...", "char"
                        #  - "any" : tout type
                        #    - en fait pas un type, mais simplement de la convention des arguments mode ou type, qui peuvent
                        #      prendre comme valeur "any", signifiant "tout type"
                        #Une variable change de type (weak typing) lorsqu'on lui assigne une valeur de type différent.
                        #Le "mode" est un "surtype", plus commode que le type interne renvoyé par typeof :
                        #  - "numeric" : NUM, "integer" ou "double"
                        #  - "function" : "closure", "builtin" et "special"
                        #  - "name" : "symbol"
                        #  - autres : pareil
TYPE( INT )             #Renvoie un vecteur de NUM TYPE, initialisés à leur valeur par défaut.
                        #INT est par défaut 0, donc vecteur vide.
                        #Ne marche que pour "character", "double", "integer", "complex", "logical", "raw"
as.TYPE( VAL )          #Transtypage :
                        #  - vers STR : 3 -> "3", 1+3i -> "1+3i", TRUE -> "TRUE"
                        #  - vers NUM : 
                        #    - TRUE -> 1, FALSE -> 0, 
                        #    - "Hello" -> NA, "3.1" -> 3.1, 1+3i -> 1 (erreur)
                        #  - vers COMPLEX : comme NUM, mais +0i
                        #  - vers LOGICAL : 
                        #    - "TRUE" -> TRUE, "Hello" -> NA
                        #    - != 0 -> TRUE, 0 -> FALSE
                        #Le transtypage ("coercion") peut être implicite (arguments d'un autre type sont implicitement
                        #transtypés)
                        #Dans un code, si transtypage possible, faire if (!is.TYPE(VAL)) VAL <- as.TYPE(VAL)
is.TYPE( VAL )          #

typeof( VAL )           #Attribut interne type de VAL, sous forme de STR.
mode( VAL )             #Attribut interne mode de VAL.
storage.mode( VAL )     #Attribut interne storage.mode de VAL

object.size(VAR)        #Imprime taille occupée par un objet.

OPÉRATIONS AVEC TYPE    #  - NUM et COMPLEX : 
NATIFS ==>              #    - + - * / ( )
                        #    - ^ ** 
                        #      - identiques (préférer ^)
                        #    - %% %/%
                        #      - %% est modulo
                        #      - %/% est le quotient entier : as.integer(x/y)
                        #    - > >= < <= == !=
                        #  - BOOL_VAL et RAW (bitwise) : 
                        #    - > >= < <= == !=
                        #    - & && | || ! xor()
                        #      - && et || :
                        #        - compare des BOOL et renvoient un BOOL
                        #        - n'évalue pas le reste de chaîne si début est FALSE (pour &&) ou TRUE (pour ||)
                        #          - ex: TRUE || { EXPR ; BOOL } n'évalue pas EXPR
                        #      - les autres, dont & et | :
                        #        - compare des BOOLv et renvoient un BOOLv
                        #  - STR :
                        #    - > >= < <= == !=

identical(BOOL1,BOOL2)  #Renvoie TRUE si BOOL1 = BOOL2 est un ensemble de TRUE, et que BOOL1 et BOOL2 ont même taille.
isTRUE(BOOL)            #Same as identical(BOOL,TRUE)
any(BOOLv)              #Renvoie TRUE si BOOLv contient au moins un TRUE.
all(BOOLv)              #Renvoie TRUE si BOOLv ne contient que des TRUE.

VECTEUR VIDE ==>        #Un vecteur peut ne pas avoir d'élément, mais il conserve un type : character(0), numeric(0), etc.
                        #  - "" n'est pas character(0), car il y a un élément : ""
                        #  - NULL n'est pas *tout* vecteur vide, mais un vecteur vide de type NULL :
                        #     - NULL est toujours de longueur 0
                        #  - NA est une constante spéciale, de tout type NUM ou STR, comptant pour un élément :
                        #     - en fait englobe cinq sous-constantes pour chaque type : NA_integer_, NA_real_, NA_complex_
                        #       NA_character_ et NA (logical). NA est coercibles vers les autres.
                        #     - indique une valeur absente
                        #     - sens possibles :
                        #       - Valeur absente/non recueillie d'un sample
                        #       - Notamment résultat d'une action sur empty set.
                        #       - Parfois passé à un argument pour dire que l'on veut pas utiliser cet argument.
                        #       - valeur problématique (ex: as.numeric("Hello"))
                        #     - is.na(VAL) disponible (détecte aussi NaN)
                        #     - VAL [!=]= NA renvoie toujours NA
                        #     - beaucoup de fonctions ont arg. optionnel na.rm (déf: FALSE) : si TRUE, NA et NaN sont ignorés
                        #  - NaN est une constante spéciale, de type DOUBLE, comptant pour élément
                        #     - indique une valeur arithmétique indéterminée
                        #     - is.nan(VAL) disponible (ne détecte pas NA)
                        #     - VAL [!=]= NaN renvoie toujours NA
                        #Résumé :
                        #            +--------------+------------+------------+-------------+------------+-------------+
                        #            | character(0) | numeric(0) |     ""     |     NULL    |     NA     |     NaN     |
                        # +----------+--------------+------------+------------+-------------+------------+-------------+
                        # | Type     |     STR      |    NUM     |     STR    |     NULL    | NUM ou STR |    DOUBLE   |
                        # | Length   |      0       |     0      |      1     |      0      |     1      |      1      |
                        # +----------+--------------+------------+------------+-------------+------------+-------------+
na.fail(VALv)           #Si VALv contient un NA : emet erreur.
na.omit(VALv)           #Si VALv contient un NA : 
                        #  - renvoie VALv sans ces NA (si ARRAY ou DATA.FRAME, enlève la rangée complète)
                        #  - rajoute CLASS "omit"
                        #  - rajoute attribut "na.action" UINTv avec anciens indexs des NA
na.exclude(VALv)        #Comme na.omit, mais avec CLASS "exclude" (différence sémantique pour naresid())
na.pass(VALv)           #Si VALv contient un NA : ne fait rien de particulier.
naresid(NA.ACTION,VALv) #NA.ACTION est na.action( VALv ), where VALv est na.*( VAL2v) . Renvoie VALv :
napredict(NA.ACTION,VAL)#  - si CLASS "exclude", en rajoutant des NA (ou rangées de NA pour ARRAY et DATA.FRAME) là où un NA
                        #    a été détecté.
                        #  - si CLASS "omit", tel quel
                        #Donc :
                        #  - VAR <- na.omit(VALv) ; napredict(na.action(VAR),VAR) renvoie VALv sans ses NA/rangée contenant un
                        #    NA
                        #  - VAR <- na.exclude(VALv) ; napredict(na.action(VAR),VAR) renvoie VALv en remplçant rangée contenant
                        #    un NA par une rangée de NA
                        #Cela sert à ajuster une MODEL.FRAME devant être analysée.

vector(|mode)           #Représente tout VALv de NUM STR ou RAW. Mode (déf: BOOL)

                                  ┌────────────────┐
                                  │   ATTRIBUTES   │
                                  └────────────────┘

ATTRIBUTS ==>           #Tout objet R peut avoir un ensemble d'attributs associés :
                        #  - ils sont secondaires à l'objet principal, et accessibles via la LIST attributes(VAL)
                        #    (lecture/écriture/création)
                        #  - en général un getter/setter ATTR(VAL) existe comme raccourci à attributes(VAL)$ATTR
                        #Les éléments d'un vecteur/array n'ont pas d'attributs, seul le vecteur/array entier a une liste
                        #d'attributs pour chaque élément. Par ex., names(NUMv[VAL]) <- STR ne marche pas, mais 
                        #names(NUMv) <- STRv si.
attributes(VAL)         #Renvoie l'ensemble des attributs définis pour VAL sous forme de LIST. Lecture/Ecriture.
attr(VAL, STR|exact)    #Equivaut à attributes(VAL)$STR
                        #  - exact : si FALSE (déf: FALSE), match seulement partie de VALv possible.
structure(VAL,
ATTR=VAL...)            #Renvoie VAL avec les ATTR donnés.

names(VALv)             #Attribut nom STRv associé à chaque élément.
                        #Est imprimé au-dessus de cet élément lors d'un print.
                        #Grâce à la possibilité d'indexation via names, cela fait aux objets R des vectors associatives 
                        #nativement via cet attribut.
                        #Assignation à l'ensemble de VALv remet ses names à NULL.
                        #name "" est possible, mais ne peut pas être indexé. Un name "" est assigné à tous les names non
                        #assignés une fois que names n'est plus == NULL
                        #Confusion possible :
                        #  - VALv : names sont ceux des élements. Indexation par VAL["STR"]
                        #  - LIST : names sont ceux des composants. Indexation par LIST$STR
                        #  - ARRAY : names sont ceux des éléments lorsqu'ARRAY applatie. dimnames != names, et indiquent
                        #            noms des rangées, tandis que names(dimnames) indiquent noms des dimensions.
comment(VALv)           #Attribut commentaire STRv associé à l'ensemble de VALv. 
                        #Faire plusieurs STR permet d'accéder à des parties du comment par index, ou d'insérer break
                        #typographique ou logique entre deux commentaires.
                        #Le commentaire n'est pas affiché sur la console, il doit être requested par comment()

                                  ┌──────────┐
                                  │   LIST   │
                                  └──────────┘

list([NAME=]VAL,...)    #Renvoie une LIST.
                        #Une LIST est un tuple de components aux types potentiellement différents. 
                        #Il s'agit donc d'un vector generic. 
                        #Chaque component est désigné par un index (sa position) et un NAME (déf: "", c'est-à-dire pas de 
                        #NAME). 
                        #Pour accéder aux components (écriture/lecture), soit :
                        #  - LIST[[INDEX]]
                        #  - LIST$NAME : toujours partial matching
                        #  - LIST[[NAME_STR|exact]] : contrairement à LIST$NAME :
                        #    - cela permet d'utiliser une variable STR.
                        #    - exact (déf: TRUE, forcément named) : si FALSE, partial matching possible. 
                        #      Si NA, pareil, mais issue un warning.
                        #  - getElement(LIST,NAME_STR)
                        #Il s'agit de primitives fonctions [[,$,[[<- et $<-
                        #L'index d'une LIST n'est pas imprimé par print lorsqu'un NAME existe pour un component, mais il y a 
                        #tout de même un index.
                        #La structure basique de LIST est en fait celle englobant un seul component (une LIST d'un seul 
                        #component), et les LISTv ne sont que des arrays de cette structure. C'est pourquoi :
                        #  - LIST[INDEX] renvoie non le component à cet index, mais la structure basique l'englobant.
                        #  - pour écrire sur une LISTv, il faut faire LIST[INDEX] <- list(VAL)
pairlist(...)           #Comme LIST, sauf que pairlist(0) est NULL. Rarement utilisé

                                  ┌─────────┐
                                  │   RAW   │
                                  └─────────┘

RAW ==>                 #Il s'agit d'un octet (comme un UCHAR numérique)
                        #Initialisé/assigné avec un UINT de 0 à 255
                        #Représenté par print sous forme hexadécimale
                        #Bitwise opérations possibles (shift : utiliser rawShift())
charToRaw(STR)          #Conversion STR -> RAW
rawToChar(RAW|multiple) #Inverse
                        #  - multiple (déf: FALSE): si TRUE, renvoie non une STR de length n, mais n STR de length 1
rawToBits(RAW)          #Renvoie un RAW2 avec la représentation binaire de RAW (en fait RAW2 est hexadécimal, mais semble
                        #binaire dans l'output)
intToBits(UINT)         #Pareil mais pour UINT.
packBits(RAW|type)      #Conversion RAW (représentation binaire) -> RAW (représentation normale) si type est "raw" (déf) ou 
                        #UINT (type = "integer")

rawShift(RAW,n)         #RAW >> n

                                  ┌──────────────┐
                                  │   LANGUAGE   │
                                  └──────────────┘

LANGUAGE OBJECTS ==>    #Les language objects prennent leur contenu tel quel, non évalué, mais parsed. Doit être donc
                        #syntaxiquement correct.
                        #  - "name" (mode) / "symbole" (typeof) : 
                        #    - symbole d'une variable, dont symbole d'une fonction, etc.
                        #  - "call" (mode) / "language" (typeof) : 
                        #    - LIST-like de :
                        #      - NAME d'une fonction
                        #      - arguments de la fonction :
                        #        - VAL... si non-var
                        #        - NAME... si var non-functions
                        #        - CALL... si var functions: compound CALL 
                        #          (ex: 1+1+1 -> +(1,+(1,1)) ou { CALL... } -> {(CALL...) )
                        #    - [[INDEX]] possible. Si arguments sous la forme VAR=VAL, CALL$VAR possible.
                        #  - "expression" : 
                        #    - LIST-like de CALL :
                        #      - ensemble de lignes de commandes, dont fichiers .R
                        #    - [[INDEX]] possible. EXPRESSION$VAR possible si expression(VAR=STATEMENT)
quote(EXPR)             #Renvoie EXPR sous forme de CALL ou (si pas fonction) SYMBOL ou VAL.
                        #Pour quote(VAR = VAL), faire quote(`=`(VAR,VAL))
bquote(EXPR|where)      #Comme quote(), sauf que les .(EXPR2) dans EXPR sont remplacés par eval(EXPR2)
                        #Peut être utilisé à la place d'un substitute( EXPR, list( ... ) )
substitute(EXPR|env)    #Comme quote(), sauf que les NAME sont remplacés par leur VAL non évaluée.
                        #  - à condition qu'env (déf: ENVIRONMENT courant) ne soit pas .GlobalEnv, auquel cas renvoie NAME
                        #    tels quels
                        #  - env peut aussi être une LIST désignant alors les VAR=VAL d'un ENVIRONMENT temporaire.
                        #Sert à avoir le CALL d'un arg tel qu'il a été appelé, sans évaluation.
                        #Ex: 
                        #  - x <- 3 ; function(val) { deparse(substitute(val)) }(x) renvoie "x"
                        #  - x <- 3 ; function(val) { deparse(val) }(x)             renvoie "3"
                        #Pour substitute non une EXPR mais un CALL contenant EXPR, faire :
                        #  - eval( substitute( substitute( CALL ), list( CALL = CALL ) ) )
call(STRING,ARGS)       #Renvoie appel d'une function dont le nom est STRING avec ARGS..., sous forme de CALL
expression
([VAR=]EXPR...)         #Renvoie sous forme d'EXPRESSION

eval(LANGUAGE|envir)    #Perform le language object. Les NAMES sont recherchés dans envir (def: ENVIRONMENT courant)
                        #A noter qu'eval(VAL) sur un objet non-LANGUAGE est équivalent à VAL (pas d'action et arguments envir
                        #et enclos inutiles)
                        #eval(EXPRESSION) renvoie la VAL du dernier eval(CALL) des CALL... d'EXPRESSION
evalq(VAL|envir)        #Equivaut à eval(quote(VAL)|envir)
eval.parent(LANGUAGE|n) #Equivaut à eval(LANGUAGE,parent.frame(n))
local(LANGUAGE|envir)   #Comme evalq(), sauf qu'envir par déf. est new.env()
with(VAL,EXPR)          #Comme evalq(EXPR,envir=VAL), sauf que :
                        #  - envir peut également être :
                        #    - une DATA.FRAME, utilisée alors comme LIST de VAR. Cela permet de faire un attach() temporaire, 
                        #      et c'est d'ailleur l'usage principal
                        #    - un UINT comme dans sys.call() pour désigner un ENVIRONMENT
                        #  - l'ENVIRONMENT est temporaire, les assignations sont perdues aussitôt
within(VAL,EXPR)        #Pareil, sauf que :
                        #  - VAL est seulement LIST ou DATA.FRAME
                        #  - sa copie temporaire après évaluation d'EXPR est renvoyée

deparse(LANGUAGE)       #Renvoie LANGUAGE sous forme de STR
parse(|file,n,text,     #Inverse, renvoie EXPRESSION à partir d'une STR. Utilisé par exemple par source() ou par la console R.
prompt,srcfile)         #  - input peut venir d'un file ou d'un text STR. Si file est stdin, prompt (déf: "?", NULL pour 
                        #    default R prompt, option "prompt") est imprimé.
                        #  - n (déf: NULL) : taille maximum d'EXPRESSION. Si stdin et que n=0, en fait n=1, et si n<0, en fait
                        #    n=0
enquote(CALL)           #Semble renvoyer un CALL2 avec "quote(CALL)", afin qu'un eval() renvoie CALL non évalué.

match.call(|definition, #Renvoie le CALL de l'appel à la fonction courante. Contrairement à sys.call :
call,expand.dots)       #  - le name des named parameters est rajouté si omis dans l'appel, et rallongé si abbrégés
                        #  - si expand.dots FALSE (déf: TRUE), ... est non remplacés par arguments mis, mais sous la forme
                        #    "... = list(ARGS)"
                        #      - on peut alors faire CALL$... pour avoir une LIST des arguments variadic
                        #Et moins utile :
                        #  - définition (déf: NULL) NAME : utilise les formals non de la fonction courant, mais de la fonction
                        #    NAME
                        #  - call (déf: CALL courant) : CALL à utiliser
                        #Utilisation en général :
                        #  - deparse le CALL afin de l'imprimer ou de le mettre en attribut
                        #  - ou passer les arguments actuels non évalués à une seconde fonction.
                        #    - ex: VAR <- match.call
                        #          VAR$ARG <- VAL... (NULL si suppression)
                        #          VAR[[1]] <- as.name(FUNC_STR)
                        #          eval.parent(VAR)
                        #    - en général, expand.dots FALSE, ce qui permet de faire VAR$... <- NULL parceque FUNC_STR ne
                        #      prendra peut-être pas les mêmes args variadiques
                        #Si pour un seul arg, march.call()$VAR, préférer substitute(VAR)

all.names(LANGUAGE      #Renvoie une STRv de tous les NAMES contenus dans LANGUAGE.
|functions,max.names,   #  - functions (déf: TRUE) : si FALSE, les NAMES de nom de fonction sont omis
unique)                 #  - max.names (déf: -1) : length max du result
                        #  - unique (déf: FALSE)
all.vars(...)           #Pareil, mais avec défaut inversés pour functions et unique (renvoie donc NAMES de VAR uniquement)

                                  ┌──────────────┐
                                  │   FORMULAE   │
                                  └──────────────┘

FORMULAE ==>            #Il s'agit de Y ~ X, où Y est une response variable et X une explanatory variable.
                        #Y et X doivent être de même taille n.
                        #Chaque yₙ correspond avec un xₙ, de sorte que si xₙ, alors yₙ.
                        #Avec un plot, cela donne un ensemble de points (xₙ,yₙ)
                        #Il s'agit en fait d'un CALL `~`(Y,X) qui a je crois juste comme effet de créer un CALL jumeau.
                        #Est en général manipulé par les fonctions qui convertissent formula en DATA.FRAME via model.frame() :
                        #  - fonction prend (formula,data) (FORMULA ou DATA.FRAME) et le passe à model.frame() qui renvoie une
                        #    DATA.FRAME
                        #La première colonne de la DATA.FRAME est la response variables, les autres sont explanatory. 
                        #Cf model.frame pour les différentes syntaxes d'une FORMULA.
                        #Attention, si X est exprimé avec les mêmes termes/mots que Y, il devient 1:n
                        #De nombreuses fonctions peuvent prendre (une DATA.FRAME ou une ...) ou une FORMULA (via missing())
                        #remplaçant alors ... . Alors, souvent les args de model.frame sont possibles en plus : data, subset,
                        #na.action.
model.frame(|formula,   #Renvoie une DATA.FRAME à partir de FORMULA ou data (une DATA.FRAME). FORMULA est prioritaire : si
data,subset,na.action,  #deux sont présents, data est ignoré, si ce n'est que son ENVIRONMENT peut être utilisé (ce qui
drop.unused.levels)     #permet de faire VAR1 ~ VAR2 au lieu de DATA.FRAME$VAR1 ~ DATA.FRAME$VAR2.
                        #  - subset (déf: NULL) UINTv : si non-NULL, ne garde que les rows numéro UINTv.
                        #  - na.action NAME_STR : fonction NAME prenant une VAL et la renvoyant en fonction des NA qu'elle
                        #    contient. Par ex, na.omit, na.fail, na.exclude ou na.pass. Déf: 1) attribut na.action(VAL),
                        #    2) options("na.action") (déf: na.omit), 3) na.fail
                        #  - drop.unused.levels (déf: FALSE) : si droplevels() doit être effectué
                        #DATA.FRAME a un attribut terms qui garde la FORMULA en mémoire :
                        #  - CALL de la FORMULA
                        #  - avec comme attributs :
                        #    - variables : LIST des NAME de la FORMULA
                        #    - term.labels : STR des NAME des explanatory var.
                        #    - intercept : 0 si l'intercept doit être 0, 1 sinon
                        #    - dataClasses : CLASS des var
                        #    - factors : matrix de chaque VAR avec chaque combinaison de VAR... :
                        #      - 1 si unique(VAR, VAR...) sont combinés via * (potentiellement dans une combinaison plus large 
                        #        encore)
                        #      - combinaison / est bizarre, rajoute des 2, enlève des colonnes...
                        #    - order : nombre éléments des colonnes de combinaisons de VAR...
                        #FORMULA possibles et colonnes de la DATA.FRAME en résultant et attributs autre (X,Y,Z sont NUMv ou
                        #FACTORv) :
                        #  - Y ~ Y                 -> Y
                        #    - membres à droite identiques à membres à gauche sont ignorés
                        #  - Y ~ X + Z + ...       -> Y,X,Z,...
                        #  - Y ~ ... [±0|1]        -> ... (intercept 1 si +, 0 si -)
                        #Combinaisons (ne semble pertinent que pour factors) :
                        #  - B ~ A + C + ...       -> A xor C xor ...
                        #  - B ~ A - C - ...       -> A
                        #  - B ~ A * C * ...       -> A or C or ...
                        #  - B ~ A:C:...           
                        #    B ~ A %in% C %in% ... -> A and C and ...
                        #  - B ~ (...)^NUM         -> ..., avec taille max de NUM
                        #  - B ~ A / C             -> A or (A and C) ???
                        #X, A, etc. peuvent être des résultats de fonction, par exemple log(X) :
                        #  - cependant, si fonction est + - * ou ^, il faut protéger avec I() (ex: Y ~ X + I(X*Z) + I(X^2))
I(VAL)                  #Rajoute classe AsIs. But :
                        #  - pour data.frame(VAL), cf data.frame
                        #  - pour formulas, cf dessus

                                  ┌──────────────────┐
                                  │   ENVIRONMENTS   │
                                  └──────────────────┘

ENVIRONMENTS ==>        #Il s'agit de pointeurs vers une frame contenant des variables locales à une fonction/frame donnée.
                        #Les variables qu'elle accède par défaut sont ceux de son ENVIRONMENT et de ses parents.
                        #Un ENVIRONMENT est une addresse, mais peut être caractérisée :
                        #  - par un ENVIRONMENTNAME, comme c'est le cas des packages loaded, de R_EmptyEnv et de .GlobalEnv
                        #  - par un attribut name, comme c'est le cas des objets attached (qui n'ont pas par déf. 
                        #    d'ENVIRONMENTNAME)
                        #Une frame n'a qu'un ENVIRONMENT, mais un ENVIRONMENT a toujours un parent (sauf R_EmptyEnv)
                        #Le "search path" est l'ensemble des ENVIRONMENT de la function courante, soit l'ENVIRONMENT courant
                        #et ses parents. Il commence par les enfants, prioritaires, puis les parents :
                        #  - le dernier enfant est l'environment courant
                        #  - puis vient à un moment .GlobalEnv, hérité par défaut par tout nouvel ENVIRONMENT, et 
                        #    ENVIRONMENT de la fonction globale.
                        #    Accédé via variable .GlobalEnv ou globalenv()
                        #  - l'avant-dernier parent est package::base, précédé de tous les autres packages loaded
                        #    Accédé via variable .BaseNamespaceEnv ou baseenv()
                        #  - le dernier parent est R_EmptyEnv, ne pouvant contenir aucune variable.
                        #    Accédé via emptyenv()
                        #Il faut distinguer :
                        #  - l'ENVIRONMENT de la définition de la closure, typiquement .GlobalEnv (mais peut être modifié)
                        #  - l'ENVIRONMENT de chaque exécution de la closure, enfant du dernier. Par conséquent, par défaut,
                        #    chaque exécution de fonction hérite de .GlobalEnv. Par conséquent -> lexical scoping
                        #Il faut aussi distringuer :
                        #  - le parent de l'ENVIRONMENT, qui est lié au search path (parent.env())
                        #  - la frame parente de la frame contenant ENVIRONMENT, qui est lié au call stack (parent.frame())
                        #    call stack != search path
                        #A noter :
                        #  - si l'on veut que la frame enfant hérite de l'ENVIRONMENT courant, faire :
                        #     - environment(FUNC) <- environment() ; FUNC()
                        #  - cependant, fonctions non enfants, mais définies dans fonction courante ont l'ENVIRONMENT
                        #    courant. Donc une FUNC2 définie (et non invoquée) par une FUNC1 peut utiliser les variables de 
                        #    FUNC1.
                        #     - ex: b <- function() { a <- 1 ; function() a }, alors b() renvoie function() 1
                        #  - les { CALL... } et ( CALL... ) sont des arguments de { et ( et sont donc évalués dans la frame
                        #    courante. Par conséquent leur ENVIRONMENT est le même que la fonction courante.
                        #Si une VAR existe pour un ENVIRONMENT et l'un de ses parents, celui de l'ENVIRONMENT "masque" le
                        #parent.
                        #Plusieurs fonctions ont un argument pour spécifier l'ENVIRONMENT :
                        #  - pos/name/where : 
                        #    - si UINT, position dans le search path
                        #    - si -1, ENVIRONMENT courant (défaut)
                        #    - si STR, nom dans le search path
                        #    - ENVIRONMENT
                        #  - envir : ENVIRONMENT (déf: ENVIRONMENT courant) ou LIST( VAR=VAL ) créant un ENVIRONMENT temp avec
                        #    des VAR...

environment([CLOSURE])  #Renvoie l'ENVIRONMENT de CLOSURE, par défaut fonction courante. Ecriture ne marche pas si
                        #fonction courante.
parent.env(ENVIRONMENT) #Renvoie ENVIRONMENT parent d'ENVIRONMENT
new.env(|hash,parent)   #Crée un ENVIRONMENT :
                        #  - hash (déf: TRUE) : s'il doit utiliser une hash table
                        #  - parent (déf: parent.frame())

sys.frames()            #Renvoie PAIRLIST des ENVIRONMENT d'exécution de la fonction actuelle et de ses parents 
                        #(ancêtre == 1), hors fonction globale.
sys.frame(|which)       #Renvoie l'ENVIRONMENT d'exécution de la fonction désignée par which (déf: 0) (cf which en bas)
                        #Cependant pour 0, semble indiquer non la fonction courante mais la top level fonction.
parent.frame(|n)        #Pareil, mais désigne la fonction comme sys.parent()

sys.calls()             #Pareil avec les CALL ayant invoqué la fonction actuelle et ses parents.
sys.call(|which)        #Renvoie le CALL de la fonction désignée par which (déf: 0) :
                        #  - nombre négatif, dont -0 : énième parent (0 est fonction courante)
                        #  - nombre positif : 1 est ancêtre, etc.

sys.function(|which)    #Renvoie le body sous forme de CALL.

sys.parents()           #Comme sys.calls mais avec numéro dans le call stack (ancêtre == 0)
sys.nframe()            #Pareil pour frame actuelle
sys.parent(|n)          #Pareil pour le parent numéro n (1:parent direct, 2: grand-parent, etc.) (déf: 1)

sys.status()            #Fait un sys.frames(), sys.calls() et sys.parents() et le traduit en PAIRLIST

environmentName
(ENVIRONMENT)           #Attribut ENVIRONMENTNAME

search()                #Imprime nom des ENVIRONMENT du search path courant sous forme de STRv.
searchpaths()           #Indique les paths STR associées à chaque élément du search path :
                        #  - pour un package, son chemin de répertoire
                        #  - pour les autres, leur nom de variable.

ENVIRONMENT$VAL         #Accède à la valeur VAL d'ENVIRONMENT
get(STR|pos,envir)      #Pareil, avec le nom de variable STR

exists(STR|where,envir, #Renvoie TRUE si variable dont nom est STR existe dans ENVIRONMENT
inherits)               #  - inherits : comme assign(), mais déf: TRUE

assign(STR,VAL          #Assigne VAL à variable dont nom est STR, et dont l'ENVIRONMENT est pos/envir.
|,pos,envir,inherits)   #VAR <- VAL est un alias, avec l'ENVIRONMENT courant
                        #  - inherits (déf: FALSE) : si TRUE :
                        #    - l'ensemble des ENVIRONMENT parents sont aussi considérés, avec les enfants prioritaires
                        #    - l'assignement échoue si VAR n'existe pas encore (création impossible donc)
rm(STRouVAR|pos,envir)  #Enlève une variable d'ENVIRONMENT
                        #remove() est un alias

ls(|name,envir,         #Imprime nom des variables d'ENVIRONMENT sous forme de STRv.
all.names,pattern)      #  - all.names (déf: FALSE) : si FALSE, n'imprime pas STR commençant par "."
                        #  - pattern (déf: ".*") : regexp filter (STR contenant, non matchant, pattern)
                        #objects() est un alias de ls()

attach(LIST|pos,name,   #Transforme LIST en ENVIRONMENT, et l'attach au search path, sous le nom STR name (déf: nom de var.),
warn.conflicts)         #à la position pos (déf: 2, min. 2).
                        #Attention, attach une copie, donc LIST$VAR et VAR désignent deux choses différentes.
                        #But est surtout de ne pas taper LIST$
                        #  - warn.conflicts (déf: TRUE) : si TRUE, warning si vars masquées
detach(LIST|pos)        #Inverse.

                                  ┌──────────────────────────┐
                                  │   INDEXATION ET ARRAYS   │
                                  └──────────────────────────┘

INDEXATION ==>          #Pour VARv[UINTv] et [STRv], si n'existe pas, écriture en rajoutant des NA si besoin de rallonger
                        #taille. En lecture, renvoie NA. Ne marche pas si VARv n'existe pas encore.
                        #Argument possible pour tout indexation : drop (déf: TRUE) : effectue un drop() sur le résultat avant
                        #de le renvoyer.
VARv[BOOLv]             #Renvoie un VAR2v, après élimination des indexs dans VARv correspondant à un FALSE dans BOOLv
                        #BOOLv est répété si besoin.
VARv[UINTv]             #Renvoie un VAR2v, où chaque élément est celui à l'index UINTv correspondant dans VARv.
                        #UINTv n'est pas répété: taille de VAR2v == taille de UINTv.
                        #UINTv -> donc VAL:VAL2 est possible.
                        #Indexation commence à 1, non 0. 0 est ignoré (peut donc indiquer un élément à ne pas indexer)
                        #Un FLOAT est trunc'd().
VARv[-UINTv]            #Renvoie un VAR2v, après élimination des indexs dans VARv correspondant aux indexs UINTv.
VARv[STRv]              #Renvoie un VAR2v, avec l'ensemble des premiers éléments ayant l'un des name STRv.
                        #Si n'existe pas, en écriture, le rajoute à la fin du vecteur.
[                       #[ est une fonction spécialisable, signature : (x,i,drop).
                        #(i,j) avec missing() pour prendre en charge d'un seul arg., si objet est de dimension 2, etc. 
[[                      #Pareil

ARRAYS ET MATRICES ==>  #Une "array" est un vecteur VALv avec un attribut dim indiquant le nombre de dimensions, et un attribut
                        #optionnel dimnames indiquant le nom de chaque rangée.
                        #Il s'agit de matrices informatiques, non mathématiques. Elles peuvent cependant être manipulées
                        #mathématiquement (cf dessous)
                        #La première dimension est la rangée, puis colonne, contrairement à C. Donc arrays 1-dimension, dont
                        #c() et 1:10 sont des columns, bien qu'imprimées en rangée.
dim(VAL)                #Attribut étant un UINTv dont chaque élément est la taille d'une dimension. 
                        #Donc longueur de ce vecteur == nombre de dimensions de VAL.
                        #prod(dim(VAL)) == nombre d'éléments de VAL.
                        #Lors d'un changement de dimensions, l'array est dépliée/repliée pour matcher les nouvelles dimensions.
                        #Attributs désignant les éléments de VAL les désigne parfois comme si VAL était applati (ex: names)
dimnames(VAL)           #Attribut LIST étant comme names, mais pour les rangées de chaque dimension et les dimensions 
                        #elles-mêmes.
                        #Les names des components de la LIST <-> nom des dimensions, et chaque component STRv <-> nom des 
                        #rangées de cette dimension.
                        #Un STRv peut être NULL. Sinon, il soit être de length == nombre de rangées de la dimension.
                        #Les dimnames sont imprimés en console à la place des indexs, et peuvent être utilisés comme indexs 
                        #(noms des rangées, pas des dimensions).
ARRAY[VAL,...]          #Indexation comme pour un vecteur normal : UINT, -UINT, BOOLv, STRv, pour chaque dimension.
                        #BOOLv doit avoir même taille que la dimension qu'elle indexe. Dans tous les cas, BOOLv n'indexe 
                        #qu'une dimension.
                        #STR désigne le dimname, non le name.
                        #VAL absente signifie ensemble de la dimension, par ex. VAL[VAL2v,]
ARRAY[VALv]             #Si pas de virgule dans l'indexation, applati l'array en une dimension avant son indexation.
                        #Indexation STRv sera alors par name, non dimname.
ARRAY[MATRIX]           #Chaque rangée de MATRIX indique un élément à indexer. Une rangée == coordonnées de l'élément à 
                        #indexer, dimension par dimension. Par conséquent, nb.colonnes de MATRIX == nb.dimensions d'ARRAY.
array(VALv|dim,dimnames)#VALv <- array(VALv,VAL2v) équivaut à dim(VALv) <- VAL2v, mais est à préférer.
                        #as.array() et is.array() sont dispos.
                        #  - dim (déf: length(VALv)), dimnames (déf: NULL)
matrix(VALv|nrow,ncol,  #Comme array(VALv, c(nrow, ncol)).
byrow,dimnames)         #  - byrow : si TRUE (déf: FALSE), remplit rangée par rangée, non colonne par colonne.

rbind(ARRAY...)         #Renvoie une ARRAY étant la superposition verticale des ARRAYS (VALv possible). Ils doivent avoir
                        #un nombre de colonnes divisibles entre eux (si plus petit, est itéré).
                        #Le nom des dimnames est celui des ARRAY pour les rangées, et celui du premier ARRAY pour les colonnes.
cbind(ARRAY...)         #Pareil inverse avec superposition horizontale.
aperm(ARRAY,UINTv)      #Transpose ARRAY, c'est-à-dire permute dimensions. Exemple d'UINTv : c(4,1,2,3) pour mettre 4ème
                        #dimension en 1ère dimension
t(ARRAY)                #Equivaut à aperm(ARRAY,2:1)
drop(ARRAY)             #Supprime les dimensions de taille 1.

MATRICE MATHEMATIQUE ==>#Ces opérations sont mathématiques, pas éléments par éléments :
ARRAY %*% ARRAY2        #Fait une multiplication de matrices.
                        #Doivent avoir mêmes dimension.
ARRAY %o% ARRAY2        #Outer product (cf plus bas pour autre usage)
solve(ARRAY[,ARRAY2])   #Renvoie ARRAY⁻¹ %*% ARRAY2
                        #  - défaut d'ARRAY2 est Iₙ, donc renvoie alors inverse d'ARRAY
                        #  - sinon résout système d'équation ARRAY * X = ARRAY2
                        #Erreur si ARRAY est singular

                                  ┌───────────────┐
                                  │   FONCTIONS   │
                                  └───────────────┘

TYPES DE FONCTIONS ==>  #  - attributs, que l'on peut utiliser en lecture ATTR(...), ou en écriture ATTR(...) <- ...
                        #  - getter, qui renvoie un résultat.
                        #  - setter, qui effectuent une action.
                        #Je précise "Attributs" ou "Renvoie" pour les deux premiers. Leur absence pour le dernier.

FUNC                    #Imprime notamment déclaration de fonction (sauf si builtin)
FUNC(...)               #Exécute fonction
function(ARGS)          #Renvoie une FUNC (CLOSURE), que l'on peut ensuite assigner à une variable.
{                       #Si VAL est le dernier statement, on peut omettre return(). return() renvoie NULL.
  ...                   #ARGS = VAR...
  return(VAL)           #A trois éléments : 
}                       #  - une liste d'arguments, sous forme de PAIRLIST
                        #    - accédé via formals(CLOSURE) :
                        #      - valeur du component est celle par défaut
                        #    - ou args(CLOSURE)
                        #  - un ENVIRONMENT (par défaut enfant de .GlobalEnv)
                        #    - accédé via environment(CLOS)
                        #  - un body, sous forme de CALL 
                        #    - accédé via body(CLOSURE)
                        #Une closure peut être byte-compiled (par opposition à une primitive compiled)

ARGUMENTS ==>           #  - positionnels, avec en plus named parameter si invoqué sous la forme FUNC(VAR=VAL,...)
                        #    - possibilité d'utiliser abbréviation des noms, si pas ambigu
                        #  - génériques (pas de type)
                        #  - valeur par défaut : function(VAR=DEF_VAL)
                        #    - peut la changer via formals(FUNC)$VAR <- DEF_VAL
                        #  - variadic argument : 
                        #    - function(...)
                        #    - nom des VAR est "...", mais doit être concaténé via c(...) ou list(...) pour être utilisé
                        #      (préférer list())
                        #    - ..UINT désigne le variadic arg. numéro UINT
                        #    - list(...) est list(0) (et c(...) est NULL) si aucun arg. n'est rentré
                        #    - si l'on passe des named parameters dans ..., list() récupère les names
                        #    - souvent utilisé par un wrapper pour passer argument à la fonction sous-jacente
                        #  - void : rien
                        #  - liste ARG_STR de STR possibles, avec abbréviation possible, pour un arg STR :
                        #    - sous la forme var=STRv
                        #    - ensuite faire dans la fonction arg <- match.arg(var|choices,several.ok)
                        #    - fonctionnement :
                        #      - match.arg() renvoie premier STR de choices contenant var (partial matching)
                        #      - choices est par défaut la default value de l'argument de la fonction courante ayant le name 
                        #        var
                        #      - si var est NULL (par ex., pas d'argument lors du call), la première valeur de choices est
                        #        renvoyée (valeur par défaut donc)
                        #      - var peut être un vecteur et renvoyé un vecteur de même taille avec une série de matching, si
                        #        several.ok est TRUE (déf: FALSE)
                        #      - erreur si pas de matching possible
                        #  - peut prendre comme VAL un autre argument VAR
                        #Un argument, même non-optionnel, peut être omis par le caller sans erreur, à condition que cet
                        #argument ne soit pas utilisé dans la fonction. Seule utilité selon moi :
                        #  - missing(ARG) : renvoie TRUE si ARG n'a pas été spécifié. Permet par exemple de définir deux
                        #    comportements : un quand caller supplies ARG, l'autre non.
                        #    Contrairement aux default values qui change la valeur d'une ARG non supplied, ceci change le
                        #    comportement de la fonction.
                        #    Ne pas l'invoquer si ARG a été modifié dans la fonction.
                        #Call sont toujours par value, jamais par référence.

LAZY EVALUATION ==>     #Un argument enregistre d'abord seulement le CALL du paramètre passé mais ne l'évalue pas ("promise")
                        #Lorsque l'argument est utilisé, il est évalué : on utilise alors l'ENVIRONMENT de la frame du
                        #paramètre pour l'évaluer, soit :
                        #  - pour un paramètre normal, la frame parente
                        #  - pour une valeur par défaut, la frame courante
                        #Donc :
                        #  - changer la frame parente avant l'utilisation d'un argument peut donc modifier cet argument.
                        #  - changer valeur d'un argument VAR1 sur laquelle est basée la default value d'un argument VAR2 avant
                        #    que VAR2 soit évalué, changera VAR2
                        #Dans les deux cas, on peut forcer l'évaluation en faisant seulement VAR1 sur une ligne 
                        #(ou force(VAR1) qui est équivalent)
                        #Promises peuvent être créer manuellement via :
                        #  - delayedAssign(NAME_STR,EXPR|eval.env,assign.env)
                        #     - fait que dès que VAR dont nom est NAME_STR devra être évaluée, VAR <- EXPR sera d'abord
                        #       effectué.
                        #       eval.env et assign.env sont par défaut le parent.env()

RECURSION ==>           #Recursion et mutual references ne posent pas de prob. puisque la définition d'une fonction n'est 
                        #évaluée que lors de son exécution (sinon il s'agit d'une EXPRESSION non évaluée)

(function(ARGS) EXPR)
(VAL...)                #Anonymous function

`FUNC<-` <- function    #Définition d'un getter :
(ARGS,value)            #  - exécuté sous la forme FUNC(ARGS) <- VAL
                        #  - value est obligatoire, et remplacé par VAL
                        #  - ARGS semble devoir être de taille au moins 1
                        #  - `` pour échapper <-

FUNCTORS ==>            #  - faire FUNC <- match.fun(FUNC|STR,descend) pour une fonction prenant un FUNC permet de produire une
                        #    erreur si argument n'est pas une FUNC
                        #      - descend (déf: TRUE) : si TRUE, si arg pas FUNC, recherche dans environments parents si
                        #        symbole du même nom (masqué donc par le premier) est lui une FUNC
                        #      - intérêt est check du type, ou récupération de la FUNC à partir de son NAME ou STR
                        #  - une FUNC1 peut renvoyer un functor FUNC2 et :
                        #    - puisque définition de function FUNC2 a l'ENVIRONMENT courant de la fonction locale FUNC1, 
                        #      la définition/comportement de functor renvoyé peut dépendre des arguments de FUNC1
                        #    - en plus, grâce au language objects, le corps même du functor peut être variable

ARGUMENT BINDING ==>    #Plutôt que de laisser l'user créer un wrapper de functor, en général, une fonction prenant un 
                        #FUNC comme argument, permet de spécifier des args pour FUNC via un ... (ex: apply)

ARGUMENT CALL ==>       #  - faire CALL <- match.call() pour avoir le CALL de la fonction courante, mais sans abbréviation
                        #    éventuelle, avec name de tous paramètres, et dans l'ordre.

PRIMITIVE FUNCTIONS ==> #Liste par builtins() (en fait pas vraiment)
                        #Pour les fonctions symboles, on peut les utiliser également via :
                        #  - .Primitive("+")(1,1)
                        #  - `+`(1,1)
                        #En fait souvent FUNC est un simple wrapper invoquant .Primitive(FUNC_STR). 
                        #Contrairement aux CLOSURE, elles n'ont pas de body + formals + environment, mais sont compilées.
                        #Elles n'ont pas de named parameters non plus.
SPECIAL FUNCTIONS ==>   #Certains builtins n'évaluent pas leur argument :
                        #  - while, switch, return, repeat, next, if, function, for, break
                        #  - &&, ||, =, <-,  <<-, ~, $, @, {, [[, [
                        #  - quote, substitute, expression, call
                        #  - on.exit, UseMethod, signif, round, rep, missing, log, .Internal
                        #Ils ont alors le type "special".

%NAME%                  #Si le nom d'une fonction est ainsi et qu'elle prend slt 2 args, elle peut être exécutée sous la
                        #forme VAL1 %NAME% VAL2

                                  ┌────────────────────┐
                                  │   TYPES COURANTS   │
                                  └────────────────────┘

table(FACTORv...|dnn,   #Renvoie une TABLE comptant le nombre d'occurences croisées de FACTORv :
deparse.level)          #ARRAY UINT où :
                        #  - 1 dimension == 1 FACTORv (chaque FACTOR == une rangée)
                        #  - éléments UINT compte le nombre d'occurences de l'union des FACTORv entre eux. 
                        #    L'élément n de chaque FACTORv doit donc être sémantiquement le même.
                        #Si un seul FACTORv, compte donc seulement les occurences d'un FACTORv.
                        #Chaque dimension est triée alphabétiquement selon son dimname.
                        #  - dnn : name des dimensions elles-mêmes (déf: cf deparse.level). 
                        #  - deparse.level UINT : par défaut dnn est rempli avec le nom de variable des UINT premiers 
                        #                         FACTOR, et les autres avec NULL (déf: 1)

data.frame(NAME=VAL,... #Construit une DATA.FRAME, type souvent utilisé comme database.
|row.names)             #Il s'agit d'une LIST dont chaque component est traité comme la colonne d'un tableau.
                        #Une VAL == une colonne. En général, colonnes sont des variables statistiques, et rangées des
                        #observations.
                        #Chaque component doit avoir même length, ou sinon les colonnes plus courtes sont itérées, à condition
                        #d'être un facteur divisible.
                        #Si VAL est une STR, elle est coerced en FACTOR. Sinon coerced en NUM.
                        #NAME est par défaut le nom de la VAR. Aucun name ne devrait être "", et names doublons doivent être 
                        #évités.
                        #L'attribut STRv row.names désigne le nom des rangées. Par défaut, les names ou dimnames de la 1ère 
                        #VALv ou, si absent, un nombre s'incrémentant.
                        #Puisque DATA.FRAME est une LIST, les col names sont ses names.
                        #Comportement spécial d'une VAL en input :
                        #  - pour une ARRAY :
                        #    - elle est applatie à deux dimensions, avec chaque colonne == une colonne dans la DATA.FRAME
                        #  - pour une LIST :
                        #    - chaque component de la LIST == une colonne
                        #Elle peut être indexée comme une matrice avec comme différences :
                        #  - D.F[VAL] équivaut à D.F[,VAL], et imprime non un vecteur, mais une matrice de largeur 1 
                        #    (verticale)
                        #  - names et row.names, et non dimnames[[1]] et dimnames[[2]]
                        #VAL peut être I(VAL), auquel cas :
                        #  - type de VAL n'est pas coerced vers NUM ou FACTOR
                        #  - LIST et ARRAY sont mis sur une seule colonne

ts(NUMv|start,end,      #Crée une TS, time-serie avec NUMv. Le temps est calculé en time unit (année, etc.), elle-même 
frequency,deltat,class) #fractionnée en measurement unit (mois, etc.). Le rapport time unit/measurement unit est frequency 
                        #(déf: 1) ou deltat (1/frequency). start et end sont des NUMv de taille 2 (si taille 1, 2ème élément 
                        #== 1), spécifiant {time unit,measurement unit}. La taille de TS est le nombre de measurements entre
                        #start et end, selon le measurement unit (NUMv tronquée à la fin si besoin). start et end comprennent
                        #l'ensemble de NUMv par déf.
                        #  - class STR : nom de classe au lieu de "ts"
                        #TS a un seul attribut tsp : NUMv de taille 3 (start,end,frequency). Start et end sont des décimaux 
                        #exprimés en time unit.
                        #hadTsp(NUM) existe.
window(...)             #Mêmes arg. que ts() sauf que prend un TS comme NUMv. Sert à repréciser son start/end/frequency afin
                        #d'obtenir une "fenêtre" partielle de la TS.
time(TS)                #Renvoie un NUMv allant de start à end, avec un pas de 1/frequency (et attribut tsp).
cycle(TS)               #Renvoie un NUMv représentant numéro de la measurement unit par rapport à sa time unit pour 
                        #l'ensemble de time(TS) (et attribut tsp)

                                  ┌────────┐
                                  │   OO   │
                                  └────────┘

OBJECT-ORIENTED ==>     #La classe d'un objet est seulement un attribut STRv class, désignant également les classes
                        #ancêtres. Si type fondamental, class == type.
                        #Mis à part types courants STR, NUM, etc., CLASS signifie que CLASS est une classe.
                        #Le . dans un nom de variable n'est pas OO-syntaxique, juste OO-sémantique
                        #Fondée sur la prog. générique :
                        #  - les objets sont génériques, leur classe est seulement un attribut class, que l'on peut changer.
                        #  - un attribut est générique : on peut rajouter un attribut à tout OBJET, et les fonctions ne
                        #    checkent pas le type de l'objet, mais seulement la présence d'un ATTR(OBJET) non-vide.
                        #      -> ATTR(OBJET), non OBJET.ATTR
                        #  - les fonctions prennent des types génériques, checkent la CLASS de l'argument, et invoquent des
                        #    fonctions spécialisées, appelées "méthodes" pour cette CLASS, par opposition à la "fonction
                        #    générique"
                        #      -> FONC.CLASS(OBJET) invoqué par FONC(OBJET), non OBJET.FONC()
class(VAL)              #Attribut class STRv. Dernier STR est ancêtre.
                        #Si pas de CLASS, une classe implicite est substituée, en général le mode()
unclass(VAL)            #Supprime l'attribut class.
is.object(VAL)          #Renvoie TRUE si VAL a une CLASS explicite.

"S3 SCHEME" ==>         
UseMethod(FUNC_STR      #Invoque FUNC_STR.THISCLASS(ARGS) où :
|object)                #  - ARGS sont les ARGS de la fonction courante
                        #  - THISCLASS est la CLASS d'object (déf: premier ARG)
                        #    - commence par classe enfant jusqu'à ancêtre
                        #    - si aucune FUNC_STR.THISCLASS définie, invoque FUNC_STR.default
                        #  - en général FUNC_STR est le nom de la fonction courante (fonction générique)
                        #  - variables présentes dans la fonction spécifique "FUNC_STR.THISCLASS":
                        #    - .Generic : FUNC_STR
                        #    - .Method : FUNC_STR.THISCLASS
                        #    - .Class : 
                        #      - CLASSE du premier ARG, à partir de THISCLASS comme premier enfant
                        #      - si .default, vide
                        #  - l'ENVIRONMENT de la méthode spécifique est une copie de l'ENVIRONMENT de la fonction générique.
                        #    - cependant, utiliser des VAR définis par la fonction générique, bien que possible, semble
                        #      générer un warning (à moins de faire VAR <- VAR) et est déconseillé
                        #  - toutes les expressions suivants UseMethod() ne sont pas exécutées
NextMethod(|FUNC_STR    #Pareil sauf que :
,object,...)            #  - THISCLASS est la CLASS d'object, sans le premier élément (premier enfant)
                        #  - FUNC_STR est par défaut .Generic (NULL donne la valeur par défaut)
                        #  - THISCLASS est par défaut le deuxième élément de .Class ("default" si aucun)
                        #  - le .Class est définie comme :
                        #    - le .Class actuel sans son premier élément (NULL donne val par défaut)
                        #    - avec un attribut previous contenant .Class actuel et (si non premier appel) avec comme attribut 
                        #      le previous de .Class. Ainsi .Class contient la chaîne des classes des méthodes appelées.
                        #  - si les ARGS ont été modifiés, leur version modifiée est passée. Donc en général, une méthode
                        #    enfant modifie les ARGS, et appelle la méthode parente.
                        #  - utilisé donc dans une FUNC_STR.THISCLASS() pour invoquer la méthode de la THISCLASS parent.
                        #    En général méthode enfant est effectuée avant la méthode parente.
                        #  - ne copie pas l'ENVIRONMENT
                        #  - les expressions suivant NextMethod() sont exécutées
                        #  - il est possible de passer des arguments supplémentaires ou remplacer des named arguments existants
                        #    via ...
                        #    - ex: NextMethod(NULL,NULL,ARGS)
INVOCATION DIRECT D'UNE #Alors :
METHODE ==>             #  - .Class est la CLASS du premier ARG
                        #  - .Generic n'est pas définie, ce qui fait buguer NextMethod si FUNC_STR est la valeur par défaut
                        #    - cela peut être résolu en faisant un .Generic <- FUNC_STR au début, mais je ne sais pas s'il
                        #      s'agit d'une bonne pratique
                        #Invocation directe via fonction anonyme d'une méthode ne marche jamais.

methods
(|generic.function,     #Liste les méthodes pour la fonction générique donnée (déf: toutes), ou la classe donnée (déf: toutes)
class)                  #Fondé uniquement sur la convention de nom FONC.CLASS.

"S4 SCHEME" ==>         #Une S4 classe est définie par :
                        #  - un nom CLASS_STR
                        #  - un ensemble de slots, valeur auxiliaires :
                        #    - accédé via VAR@SLOT
                        #    - Equivaut à un attribut
                        #    - representation : classes des slots, en général généré via representation()
                        #    - prototype : 
                        #      - valeur par défaut des slots généré en général via prototype()
                        #      - si pas valeur par défaut spécifiée pour un slot, utilise le prototype() de sa classe
                        #        - il s'agit de vecteurs vides pour les types basiques
                        #    - dont un "unnamed" slot @.Data, valeur centrale :
                        #      - son type est défini dans representation() et sa valeur par défaut dans prototype()
                        #      - là où [VAR=]VAL est attendu avec comme VAR un name de slot, omettre VAR désigne alors toujours
                        #        le @.Data
                        #      - semble devoir être une basic class ou virtual class ???
                        #  - des classes parents ("superclasses") :
                        #    - désigné via contains de setClass()
                        #    - il semble que la classe du @.Data == classe parent
                        #Une CLASS est registered via setClass(), qui crée en fait un objet de type "S4" (classe définition)
                        #.__C__CLASS, dans .GlobalEnv ou, si namespace, dans le namespace.
                        #attributes(S4) contient nombreuses infos sur la définition de la CLASS.
setClass(Class,         #Register une CLASS
representation,prototype
|contains)
                        #Renvoie un FUNC, wrapper de new(CLASS,...), à nommer en général CLASS.
new(CLASS_STR,...)      #Renvoie une CLASS avec les slots ayant leur valeur par défaut, ou celle indiquée par ...
representation          
([VAR=]STR...)          #Renvoie une LIST de classes STR de slots VAR
prototype([VAR=]VAL...) #Renvoie un CLASSPROTOTYPEDEF, définissant des valeur par défaut VAL de slots VAR :
                        #  - @object S4 : la @.Data est la VAL (vide si pas spécifié), et les named slots sont mis en attributs
                        #  - @slots STRv : slot names (VAR=...)
                        #  - @dataPart : TRUE s'il y a une @.Data

as(VAL,CLASS_STR) et is(VAL,CLASS_STR) ???

setMethod(FUNC_STR,CLASS_ARGSv,FUNC) pour définir FUNC_STR.CLASS_ARGSv[1](CLASS_ARGSv[-1]) <- FUNC ???

NAMESPACE ==>           #Noté namespace::membre
                        #Namespaces courants sont ceux importés via library() ??

                                  ┌────────────┐
                                  │   ERRORS   │
                                  └────────────┘

EXCEPTIONS ==>          #Il s'agit d'un objet :
                        #  - TRY-ERROR (S3)
                        #  - CONDITION (S4), avec comme enfants :
                        #    - SIMPLEERROR, enfant ERROR, invoqué par ex. par stop()
                        #    - SIMPLEWARNING, enfant WARNING, invoqué par ex. par warning()
                        #    - SIMPLEMESSAGE, enfant MESSAGE, invoqué par ex. par message()
                        #    - SIMPLECONDITION
                        #    - ils sont tous quatre créés par simpleError(STR|call) (ou simpleCondition, etc.), avec call 
                        #      (déf: NULL)
                        #Il :
                        #  - est une STR avec le message d'erreur
                        #    On peut le retrouver avec ConditionMessage(CONDITION)
                        #  - a un attribut $call avec le CALL (non STR) de la fonction ayant lancé l'exception.
                        #    On peut le retrouver avec ConditionCall(CONDITION)
                        #Faire as.character pour l'imprimer.
                        #Une exception se propageant jusqu'à la top fonction invoque son default handler :
                        #  - Message: imprime immédiatement STR sur stderr
                        #  - Warning: pareil sauf que :
                        #    - précédé de "Warning message:"
                        #    - en fonction de valeur de l'option "warn":
                        #      - <0 : n'imprime pas
                        #      - 0  : imprimé quand la top-level function s'est achevé (déf)
                        #      - 1  : imprime tout de suite
                        #      - 2  : warning devient error
                        #    - si "warn" est 0, warnings de dernière top-level function peut être imprimé par warnings()
                        #      (variable last.warning)
                        #    - peut remplacer un nouveau default handler avec option EXPRESSION warning.expression ?? 
                        #  - Error : 
                        #    - interrompt programme ou ligne de commande si intéractif
                        #    - met le message d'erreur dans un buffer de taille 1 STR, que l'on peut retrouver via 
                        #      geterrmessage()
                        #    - imprime sur stderr le message d'erreur (si options "show.error.messages" est TRUE (déf:TRUE))
                        #    - peut ajouter un nouveau default handler avec option EXPRESSION error
                        #Message imprimés par Warning et Error sont tronqués selon l'option "warning.length" (déf:1000)

stop(VAL|call.)         #Envoie une exception SIMPLEERROR:
                        #  - si VAL est STR, son texte est STR
                        #  - si VAL est CONDITION, texte est déjà compris
                        #Si call. est TRUE (déf), le CALL actuel fait partie du message d'erreur de l'exception.
warning(VAL|call.,      #Pareil sauf qu'avec exception SIMPLEWARNING et :
immediate)              #  - immédiate. (déf: FALSE) : si TRUE, option "warn" devient momentanément 1
suppressWarnings(EXPR)  #Fait que les warnings d'EXPR sont ignorés
message(VAL|domain,     #Pareil sauf qu'avec exception SIMPLEMESSAGE. domain est pour gettext.
appendLF)               #  - appendLF (déf: TRUE) : rajouter un newline à la fin
suppressMessages(EXPR)
packageStartupMessage
(...)                   #Pareil avec exception PACKAGESTARTUPMESSAGE, enfant de SIMPLEMESSAGE
suppressPac...Msage(...)#Permet de suppress messages seulement du Startup

tryCatch(EXPR           #Si EXPR lance une exception, le catch et invoque toute FUNC dont la CLASS est celle de l'exception 
|CLASS=FUNC...,finally) #(ou enfant). FUNC doit prendre un seul argument, l'exception.
                        #Puis invoque finally (EXPR, déf: NULL) (exception ou non).
                        #Si pas d'exception, renvoit valeur d'EXPR.
withCallingHandlers
(EXPR|CLASS=FUNC...)    #Pareil, sauf que l'exception catchée est rethrown.
try(EXPR|silent)        #Comme tryCatch(), mais plus simple :
                        #  - ne catche que les ERROR. 
                        #  - Si ERROR, catchée, imprime son message d'erreur (sauf si silent (déf: FALSE)), mais n'interrompt 
                        #    pas le programme. But est donc de signaler ERROR sans interrompre programme.
                        #  - renvoie silencieusement une TRY-ERROR, qui n'est pas une condition mais une info sur l'ERROR
                        #    catchée :
                        #     - STR contenant le message d'erreur imprimé
                        #     - attribut condition contenant l'ERROR

on.exit(EXPR|add)       #Exécute EXPR quand fonction courate (sauf si top-level) s'achève.
                        #  - add (déf: FALSE), si TRUE ne remplace précédent handler pas mais ajoute
                        #  - si EXPR est NULL, supprime handlers actuels
                        #sys.on.exit() renvoie handlers actuels

DEBUGING ==>            #

traceback(VAL,max.lines)#Renvoie call stack de la dernière uncaught exception, sous forme de LIST.
                        #Utilise pour cela l'objet .Traceback (déf de VAL), mais VAL peut aussi être :
                        #  - un UINT, auquel cas, il s'agit du current call stack moins les UINT premiers enfants
                        #  - une LIST de CALL
                        #max.lines (déf: option "deparse.max.lines" (déf: NULL)): nb. lignes max par CALL

                                  ┌────────────────────────┐
                                  │   FONCTIONS BASIQUES   │
                                  └────────────────────────┘

c(VALv...)              #Renvoie un VALv avec tous les VALv, avec le type le plus supérieur parmi : 
                        # NULL < raw < NUM < STR < LIST < EXPRESSION
                        #  - NULL < raw : NULL sont supprimés
                        #  - raw < NUM : octets sont transformés en nombre
                        #  - ... < STR : transformés en STR
                        #  - ... < LIST : transformés en components d'une LIST
                        #NUM est lui-même LOGICAL < INT < DOUBLE < COMPLEX
                        #Enlève tous les attributs, sauf names : applatit donc les arrays.

append(VALv,VAL2v|after)#Renvoie VALv avec VAL2v inséré à la place after (déf: à la fin)

NUM1:NUM2               #Equivaut à seq(from=NUM1,to=NUM2). : a une précédence sur autres opérateurs.
seq(from,to|by,         #Equivaut à {from..to..by} en Bash.
length.out,along.with)  #  - by NUM : (déf: 1)
                        #  - length.out : modifie by de sorte que NUM valeurs sont crées allant de from à to. 
                        #  - along.with VALv : équivaut à seq(from,to,length.to=length(VALv))
                        #Toujours utilisé names "from" et "to"
seq_along(along.with)   #Equivaut à 1:length(along.with)
seq_len(length.out)     #Equivaut à 1:length.out, sauf que seul nombre positif marche.

rep(VAL|times,          #Renvoie VALv en repétant ses valeurs :
length.out,each)        #  - times UINT : tout VALv UINT fois (déf: 1)
                        #  - each UINT : chaque élément de VALv UINT fois (déf: 1)
                        #  - length.out UINT : l'ensemble des répétitions est tronqué ou répété jusqu'à former un vecteur
                        #    de UINT éléments. (déf: NA)
replicate(UINT,EXPR     #Renvoie un VALv de taille UINT où chaque élément est le résultat d'une nouvelle évaluation d'EXPR.
|simplify)              #  - simplify (déf: TRUE) : si FALSE, renvoie sous forme de LIST
                        #Meilleur qu'une boucle for si simple.

length(VALv)            #Attribut interne désignant nombre d'éléments de VALv.
head(VALv|n)            #Ne garde que les n (déf:6) premiers éléments (pour un ARRAY/DATA.FRAME: rangées)
tail(VALv|n)            #Inverse
min(VALv...|na.rm)      #
max(VALv...|na.rm)      #Min d'un numeric(0) est +Inf et max -Inf.
pmin(VALv...|na.rm)     
pmax(VALv...|na.rm)     #Revient à mapply(min,...)
range(VALv...|na.rm)    #Renvoie vecteur (min,max)
which.min(VALv)
which.max(VALv)         #Renvoie index du premier maximum ou minimum.

sort(NUMv|decreasing)   #  - decreasing (def: FALSE)

apply(ARRAY,UINTv,      #Pour chaque combinaison des dimensions spécifiées par UINTv, prend l'ensemble des valeurs d'ARRAY
FUN,...)                #et applique FUN(,...) dessus, et renvoie le résultat sous forme d'ARRAY.
                        #On peut utiliser les dimnames à la place d'UINTv.
                        #Par exemple :
                        #  - apply(MATRIX,2,FUN) applique FUN() sur chaque colonne
                        #  - apply(CUBE,c(1,2),FUN) applique FUN() sur chaque rangée et chaque colonnes
mapply(FUN,VALv...,...  
|simplify)              #Applique FUN sur ensemble des éléments des VALv, pour chaque position. 
tapply(VALv,FACTORv|FUN,#Pareil mais effectue FUN() sur des groupes de VALv en fonction de FACTORv (VALv correspondant avec
...,simplify)           #FACTORv).
                        #FACTORv marche aussi avec un BOOLv coerced implicitement.
                        #Si FUN est NULL (défault), renvoie une UINTv étant, pour chaque VAL, le numero du level correspondant 
                        #dans FACTOR. Peut être utilisé pour indexer le résultat normal de tapply()
                        #  - simplify (déf: TRUE) : si FALSE, renvoie résultat sous forme de LIST
by(...)                 #Comme tapply(...), mais plus joli print.
sapply(LIST,FUN,...     #Pareil mais sur chaque component de LIST (notamment colonne de DATA.FRAME). Renvoie LIST si FALSE,
|simplify)              #ARRAY si TRUE (déf).
lapply(...)             #Same as sapply(..., simplify = FALSE)

outer(ARRAY1,ARRAY2     #Produit un ARRAY de dimensions = dim(ARRAY1)+dim(ARRAY2), correspondant au résultat de la 
|FUN,...)               #fonction binaire FUN (défaut: `*`) sur chaque élément d'ARRAY1 avec chaque élément d'ARRAY2.
                        #... sont les args à passer à FUN
                        #%o% est un raccourci ne permettant pas de spécifier FUN ni ...

sum(NUMv|na.rm)         #sum(BOOLv) permet d'avoir nb d'occurences
col[|row]Sums(VAL...    #Somme non de tous les éléments, mais par dimension (row/col)
|na.rm,dims)            #  - dims: dimension considérée pour les sommes, défaut 1 (rangée ou colonne)
cumsum(NUMv)            #Renvoie un NUMv2 représentant la somme cumulée de NUMv1.
prod(NUMv|na.rm)        # ∏ NUMv

mean(VALv|na.rm)        #Arithmetic mean
                        #mean(BOOLv) permet d'avoir pourcentage.
col[|row]Means(VAL...   #
|na.rm,dims)            #Comme pour colSums.

                                  ┌─────────┐
                                  │   I/O   │
                                  └─────────┘

FILE ==>                #Les fichiers sont des CONNECTION
                        #Il s'agit en interne seulement d'un integer fd, mais est imprimé via info recueillie par
                        #summary(CONNECTION)
                        #Une CONNECTION est ouverte si sauvegardée dans un objet.
                        #Par FILE, je signifie une STRING de nom de fichier, ou une CONNECTION.

file(STR,open|blocking, #Renvoie une CONNECTION du fichier dont le chemin est STR
encoding,raw)           #  - open :
                        #    - [rwa][+][bt]
                        #    - si ni b, ni t -> t
                        #    - "" -> closed connection
                        #    - w+ truncate, r+ non
                        #  - encoding (déf: option "encoding" (déf: "native_enc"))

std[in|out|err]()       #Renvoie sa CONNECTION (ouvert par défaut)
showConnections(|all)   #Imprime infos similaires à summary(), mais aussi fd number, sur CONNECTION ouvertes dont, si all TRUE
                        #(déf: FALSE) les standard streams et les CONNECTION dont mode est ""
getConnection(INT)      #Renvoie CONNECTION du fd NUM.
closeAllConnections()   #Détruit toutes CONNECTION hors standard streams. Supprimer objet contenant CONNECTION ne ferme pas la 
                        #connexion.

isatty(CONNECTION)      #Renvoie TRUE si CONNECTION associée à un terminal.

OUTPUT ==>              #L'output d'une console interactive est la console, sinon /dev/null. Une commande dans un bloc de
                        #bloc de commande est considérée non-interactive.
sink(|FILE)             #Redirige l'output de la console (déf: stdout)

download.file(URL,FILE) #Télécharge fichier URL et le nomme FILE


INPUT FORMAT ==>        #  - CSV
                        #  - .dat :
                        #    - peut être n'importe quoi (binaire ou texte)
                        #  - .dif :
                        #    - pour interopérabilité entre spreadsheets programs (texte file)
                        #  - .mtx :
                        #    - MatrixMarket file, pour spreadsheets
                        #  - .tsv/.tab :
                        #    - comme .csv, sauf que séparés par Tab, non virgule
                        #    - .dsv est une généralisation, avec tout délimiteur

read.csv(file|header,   #Renvoie un fichier .csv sous forme de DATA.FRAME.
sep,quote,dec,fill,     #Les names sont un nombre s'incrémentant, précédé par "V".
comment.char,...)       #Les row.names sont un nombre s'incrémentant.
                        #  - file      : chemin du fichier
                        #  - header    : si TRUE, première ligne est utilisée comme names (def: FALSE)
                        #  - sep       : field separator. Si "", est "whitespace" soit [ \t\n\r]+ (def: ",")
                        #  - quote     : quoting character (def: \"). Si "", pas de quoting.
                        #  - dec       : decimal point (def: ".")
                        #  - fill      : si TRUE, lignes avec moins de fields sont remplis avec des NA (def: TRUE)
                        #  - comment.char : si "", aucun (def: "")
                        #  - ...       : mêmes args que read.table
read.csv2(...)          #Pareil, sauf que def. de sep est ";" et de dec est ","
read.delim(...)         #Pareil, sauf que def. de sep est "\t" et de dec est "."
read.delim2(...)        #Pareil, sauf que def. de sep est "\t" et de dec est ","

read.table(file|header, #Généralisation de read.csv
sep,quote,dec,row.names,#  - sep (déf: ""), comment.char (déf: "#")
col.names,comment.char) #  - header, quote, dec : cf read.csv
                        #  - row.names et col.names :
                        #    - pas de doublons possibles
                        #    - possible d'utiliser NOMBRE ou STR pour désigner une colonne (index ou name) du file, 
                        #      utilisé alors comme nom de rangée et non plus comme data.

                                  ┌───────────┐
                                  │   MATHS   │
                                  └───────────┘

INFINITE ==>            #Constantes DOUBLE : NaN, Inf, -Inf
                        #Opérations arithmétiques avec NaN produisent NaN, et logiques produisent NA
                        #Détection : is.[in]finite(VAL), is.nan( VAL )

CONSTANTES MATHS ==>   
pi

abs(VAL)
ceiling(VAL)            #Arrondi vers le haut
floor(VAL)              #Arrondi vers le bas
trunc(VAL)              #Arrondi vers 0
round(VAL|digits)       #Arrondi vers le plus proche (vers 0 si .5), et à digits (déf: 0) décimales. digits négatif possible.
signif(VAL|digits)      #Pareil, mais à digits significant chiffres, non décimales (comprend aussi chiffres avant virgule, et
                        #digits négatifs -> 1)

sqrt(VAL)               #Racine carrée

log(VAL|, base)         #
logb(VAL|, base)        #(déf: ℮)
log10(VAL)              #Pareil, base 10
log2(VAL)               #Pareil, base 2
exp(VAL)                #exp(1) permet de donner ℮

sin(VAL)
cos(VAL)
tan(VAL)
asin(VAL)
acos(VAL)
atan(VAL)
atan2(VAL1, VAL2)

[l]factorial(NUMv)
[l]choose(NUMv1,NUMv2)  #Binomial coefficient (avec logarithm scale ou non)
[l]gamma(NUMv)          #Gamma function

                                  ┌─────────────┐
                                  │   STRINGS   │
                                  └─────────────┘

CONSTANTES STRING ==>   #
LETTERS                 #Vecteur de STR "A", "B", ..., "Z"
letters                 #Vecteur de STR "a", "b", ..., "z"
month.abb               #Vecteur de STR "Jan", "Feb", ..., "Dec"
month.name              #Vecteur de STR "January", "February", ..., "December"

ECHAPPEMENT BACKSLASH==>#Possibles pour les STR et les `VAR`
                        #Ne semble s'afficher que lors des plots et non impression console (sauf \u, \xNN et \NNN)
                        #Peut pas mixer ( \xNN ou \NNN ) et \u dans une même STR

paste(STRv...           #Renvoie une seule STRv, où chaque élément est la concaténation de chaque élément de chaque STRv
|sep,collapse)          #ensemble, séparés par sep (déf: " ").
                        #  - collapse STR : si donné (déf: NULL), la STRv renvoyé est elle-même concaténée en une seule 
                        #                   STR, en séparant ses propres éléments par STR

factor(|VALv,levels,    #Renvoie un FACTOR. Il s'agit d'un enum. VAL est déf: factor(0)
labels,exclude,ordered) #Utilisé pour décrire une variable qualitative (factor/category).
                        #levels est un attribut STRv, par défaut sort(as.character(unique(VAL))). Ce sont les valeurs 
                        #possibles de l'enum.
                        #VALv sont les valeurs actuelles. Toute VAL n'étant pas dans levels devient NA. 
                        #L'argument "levels" n'est utilisé que lors de l'utilisation de factor() pour parser VAL. Ensuite, 
                        #c'est l'argument "labels" (déf: == levels) qui est utilisé pour définir l'attribut "levels".
                        #Les valeurs de FACTOR sont lues et écrites selon leur levels, mais manipulées de manière interne 
                        #comme des nombre s'incrémentant. Par conséquent, leur coercion peut réserver des surprises.
                        #  - exclude : VALv à exclure de levels et labels lors cration du FACTOR (déf: NULL). Ne marche que
                        #              si VALv est présent à la fois dans levels et labels.
                        #  - ordered : si TRUE, renvoie non un FACTOR, mais un ORDERED (déf: is.ordered)
                        #              ORDERED est un enfant de FACTOR, avec même propriétés, mais but différents.
                        #              ORDERED indique que chaque catégorie est incluse dans la suivante, et non soeur.
                        #              Les ORDERED peuvent être comparés avec < <= > >= et non seulement != et == contrairement
                        #              aux FACTOR simples.
                        #NA est un élément n'étant pas dans les labels. Peut être écrit soit via :
                        #  - FACTOR[...] <- AUTRE_VAL (warning)
                        #  - is.na(FACTOR)[...] <- TRUE (no warning)
ordered(...)            #Comme factor, sauf que ordered est absent car toujours TRUE.
droplevels(FACTORv)     #Renvoie FACTORv sans les levels sans éléments.
droplevels              #Le fait sur les colonnes FACTORv de DATA.FRAME, sauf celles spécifiées par except (même syntaxe qu'une
(DATA.FRAME|except)     #indexation []

match(VALv,VAL2v        #Renvoie l'index dans VALv du premier élément matchant exactement l'un des éléments de VAL2v, ou 
|nomatch, incomparables)nomatch (integer, déf: NA).
                        #  - incomparables (déf: NULL) : assign nomatch aux éléments de VALv == un des éléments d'incomparables
                        #    avant de faire action principale.
VALv %in% VAL2v         #Equivaut à match(VALv,VAL2v), sauf que renvoie non index mais FALSE ou TRUE.
                        #Ex : VARv[VARv %in% VAL2v]

split(VALv,FACTORv|drop)#Soit VALv et FACTORv correspondant, fait des groupes de VALv en fonction de FACTORv, et renvoie
                        #une LIST ou chaque component contient un groupe, avec le level du FACTORv en name.
                        #  - drop (déf: FALSE) : si TRUE, un groupe vide ne donne pas de component (et non un component vide)
unsplit
(LIST,FACTORv|drop)     #Inverse
cut(NUMv,NUM2v|labels,  #Renvoie NUMv sous forme de FACTORv, coupés selon les "breaks" NUM2v :
dig.lab)                #  - si NUM2v a une length > 1, chaque NUM2 (après tri numérique) est un "break". Chaque NUMv est 
                        #    transformé en un FACTOR dont le level est "(BRK1,BRK2]" ou BRK1 est le plus proche break inférieur
                        #    (exclus) et BRK2 supérieur (inclus)
                        #  - si NUM2 a une length == 1, divise NUMv avec NUM2v ranges, c'est-à-dire équivaut à 
                        #    cut(NUMv,seq(min(NUMv)-0.1,max(NUMv),length.out=NUM2v+1))
                        #  - labels : labels du FACTOR, par défaut construit sur le model "(BRK1,BRK2]". Si FALSE, labels sont
                        #             nombres s'incrémentant.
                        #  - dig.lab : nb chiffres max. affichage
unique(VALv             
|incomparables)         #Supprime les doublons, sauf les NUMv == un NUM de incomparables (déf: FALSE, équivalent de NULL)

sQuote( STR )           #Renvoie STR entouré de single guillemets américaines (pour un error message).
                        #Si options( "useFancyQuotes" ) (déf: TRUE) est :
                        #  - TRUE -> single guillemets américaines
                        #  - FALSE -> single guillemets ASCII
                        #  - "TeX" -> `'
                        #  - STRv -> STR1 - STR2 (STR3 - STR4 pour double guillemets)
dQuote( STR )           #Pareil avec double guillemets .

grep(STR,STR2v          #Renvoie indexs UINTv des STR2 contenant STR (regexp) (integer(0) si aucune)
|ignore.case,perl,value,#  - ignore.case (déf: FALSE)
fixed,useBytes,invert)  #  - perl,fixed (déf: FALSE) : perl ou fixed regexp
                        #  - value (déf: FALSE) : si TRUE, renvoie non index, mais STR matchant
                        #  - invert (déf: FALSE) : si TRUE, renvoie indexs des éléments ne matchant pas
                        #  - useBytes (déf: FALSE) : byte-wise et non character-wyse
grepRaw(RAW,RAW2|offset,#Pareil mais avec des RAW. RAW peut être une regexp : faire alors charToRaw(regexp).
ignore.case,value,fixed,#  - offset (déf:1) : début de la recherche dans RAW2
all,invert)             #  - all (déf: FALSE) : si FALSE, ne renvoie que le premier index
grepl(...)              #Pareil sauf que renvoie non index mais TRUE ou FALSE.
                        #De plus invert et value absents (pareil pour fonctions suivantes)
[g]sub(STR,replacement, 
STR2v,...)              #Pareil mais substitution, comme sed 's/STR/replacement/[g]' <<<"STR2v"
regexpr(STR,STR2v,...)  #Renvoie index du premier caractère dans STR2v matchant STR (-1 si aucun match), avec en plus comme 
                        #attribut :
                        #  - match.length: longueur du match (-1 si aucun match)
                        #  - useBytes: présent que si TRUE. TRUE si useBytes() utilisé, ou si utiliser useBytes() n'aurait pas
                        #    changé le résultat (par ex. ASCII des deux côtés)
                        #regmatches(STR2v, regexpr(STR, STR2v)|invert) peut être utilisé pour extraire les matches, et 
                        #possiblement les remplacer avec <-
gregexpr(...)           #Pareil mais renvoie un vecteur de ce résultat, pour chaque match et non le premier match.
regexec(...)            #Comme regexpr, mais ajoute, en plus du premier élément renvoyé, l'index des expressions entre ()
                        #ensuite.

agrep(STR,STR2v         #Comme grep, mais approximate matching possible ("fuzzy matching"). 
|max.distance,costs,    #Un approximate match est un match demandant n transformations pour être un exact match.
ignore.case,value,fixed,#Transformations possibles sont insertion/suppression/transformation d'un caractère.
useBytes)               #  - max.distance : LIST avec nb d'opérations max si UINT ou pourcentage de transformations si 
                        #    DOUBLE (ceiling(DOUBLE * length(STR2)) donne UINT) avec :
                        #      - cost (déf: =all) : comme all, sauf que insertions, deletions et substitutions sont pondérées
                        #        par costs. Appelé Levenshtein edit distance.
                        #      - all (déf: 0.1) : insertion ou deletion ou substitution (hors cost)
                        #      - insertions (déf: = all) (hors cost)
                        #      - deletions (déf: = all) (hors cost)
                        #      - substitutions (déf: = all) (hors cost)
                        #    Peut donner un NUM, alors pour cost seulement.
                        #  - costs (déf: NULL): LIST des pondérations d'insertions, deletions et substitutions.
                        #                       NUMv possible.

glob2rx(PATTERN|        #Renvoie PATTERN, avec conversion globbing -> regexp.
trim.head,trim.tail)    #  - trim.head (déf: FALSE) : si TRUE, supprime "^.*" du result au début, si PATTERN commence par *
                        #  - trim.tail (déf: TRUE) : si TRUE, supprime ".*$" du result à la fin, si PATTERN finit par *

chartr(old,new,STRv)    #Comme tr 'old' 'new' <<<"STRv"
tolower(STRv)
toupper(STRv)
casefold(STRv|upper)    #  - upper (déf: FALSE)

                                  ┌───────────┐
                                  │   STATS   │
                                  └───────────┘

weighted.mean(VALv,
VAL2v|na.rm)            #Weighted mean, où VAL2v sont les coefficients.
median(VALv|na.rm)
quantile(VALv|probs,    #Renvoie un VAL2v avec les percentiles, selon probs (déf: 0:5/5), de VAL.
na.rm,names)            #  - names : si FALSE (déf: TRUE), pas de names (plus rapide) (sinon "25%", etc.)
IQR(VALv|na.rm)         #Renvoie longueur de l'IQR
fivenum(VALv|na.rm)     #Renvoie le Tukey's summary
var(VALv)               #Variance
sd(VALv)                #Standard deviation
cov(VALv,VAL2v)         #Covariance
cor(VALv,VAL2v)         #r (index de correlation)

summary(VALv,...)       #Affiche occurences pour FACTOR, et min./med./etc. pour autres.
                        #En fonction de classe de VALv :
                        #  - générique : renvoie SUMMARYDEFAULT, enfant de TABLE, avec mêmes valeurs que fivenum() + median,
                        #                et des names, non dimnames, avec "Min.", etc.
                        #  - FACTOR : renvoie même chose que table(), sauf que pas classe "table", et que names, non dimnames
                        #  - MATRIX et DATA.FRAME : effectue summary() sur chaque colonne/component.
                        #Argument pour FACTOR et DATA.FRAME
                        #    - maxsum NUM : la NUMème colonne et celles qui suivent devient "(Other)" (déf: 100 pour FACTOR et
                        #                   7 pour DATA.FRAME)

stem(NUMv|scale,width)  #Stem-and-leaf plot : sorte d'histogramme vertical en console. 1 caractère = 1 variable.
                        #  - scale (déf: 1) : unité des barres de l'histogramme
                        #  - width (déf: 80) : si max. de variables pour une unité est > width, sera tronqué

density(NUMv)           #KDE, renvoie un DENSITY, LIST avec les valeurs NUMv en $x et leur prob. (pdf) en $y.
                        #  - $n : length(NUMv)
                        #  - $bw : bandwidth
                        #  - $has.na
                        #  - $data.name
                        #  - $call : CALL l'ayant invoqué
ecdf(NUMv)              #Empirical CDF, renvoie un ECDF, enfant de STEPFUN (CLOSURE).

sample(VALv|size,       #Renvoie un VAL2v choisi at random parmi VALv, de taille size.
replace,prob)           #Si VALv est scalaire, équivaut à 1:VAL.
                        #  - size (déf: length(VALv), par conséquent permutation si replace est FALSE)
                        #  - replace (déf: FALSE) : si FALSE, pas de doublons
                        #  - prob (déf: NULL) NUMv : probabilité distribution (weight, pas pourcentage) du random choice.

dbinom(VALv,n,p|log)    #Pour chaque VAL, renvoie la probabilité pour X ~ Binomial(n,p) que X soit VAL (pdf)
                        #C'est-à-dire applique P(VALv)
                        #  - log (déf: FALSE) : si TRUE, renvoie le log() des résultats
pbinom(VALv,n,p         #Pareil, mais que X soit <= VAL (ou >= si !lower.tail (déf: TRUE)) (cdf)
|lower.tail,log)        #C'est-à-dire la densité cumulée.
qbinom(VALv,n,p         #Pour chaque VAL (pourcentage), renvoie la VAL2 tel que P(X <= VAL2) == VAL% (cad VAL% de la 
|lower.tail,log)        #distribution est derrière) (quantile function)
rbinom(UINT,n,p)        #PRNG de Binomial(n,p). Produit UINT valeurs.
*norm(*|mean,sd,*)      #Pareil pour la distribution Normale(mean,sd) (déf: normale standard (mean: 0, sd: 1))
*unif(*|min,max,*)      #Distribution Uniform(min,max) (déf: [0,1])
*exp(*|rate,*)          #Distribution Exponential(rate) (déf: 1)
*pois(*,lambda,*)       #Poisson(lambdala)
*nbinom(*)              #NB(n,(1-p))
*t(*,df,*)              #Student's t(df)
*chisq(*,df,*)          #χ²(df)
*f(*,df1,df2,*)         #F(df1,df2)
*geom(*,prob,*)         #Geometrical(1-p)
*hyper(*,m,n,k,*)       #Hypergeometric(m,n,k)
*hypr(*,m,n,k|odds,*)   #Non-centralgeometric(m,n,k,odds) (déf:1, donc central par défaut) (Package BiasedUrn)
*mhypr(*,m,k|odds,*)    #Non-central Multivariate geometric(m,n,k,odds). m et odds sont des vecteurs, k non. 
                        #(déf:c(1,...,1), donc central par défaut) (Package BiasedUrn)
                        #Seuls d* et r* existent.
*gamma(*,shape          
|rate,scale,*)          #Gamma(shape,rate)
*beta(*,shape1,shape2,*)#Beta(shape1,shape2)
*cauchy(*
|location,shape,*)      #Cauchy(location,shape)
*weibull
(*,shape|scale,*)       #Weibull(shape,scale) (déf: 1)
*lnorm
(*|meanlog,sdlog,*)     #Lognorm(meanlog,sdlog) (déf: 0 et 1)

*multinom               #Multinomial(size,prob). prob est un NUMv. size est déduit de taille de prob pour dmultinom.
(*,size,prob|log)       #Pas de q* ni de p*

*birthday               #Birthday(classes), (déf: 365) avec coincident nombre d'events min. coincidant (déf: 2)
(*|classes,coincident)  #Contrairement aux autres dist. :
                        #  - pas de  :
                        #    - rbirthday, mais peut générer via qbirthday(runif())
                        #    - dbirthday, mais peut générer via pbirthday(n+1)-pbirthday(n)
                        #  - premier arg. est un VAL, non un VALv
                      

STATISTICAL TESTS ==>   #
t.test(NUMv|y,          #Renvoie un HTEST, qui est une LIST étant un compte-rendu de t-test. Est imprimé comme un rapport
alternative,mu,paired,  #par print().
var.equal,conf.level)   #Soit s₁ NUMv, s₂ y (déf: NULL), s₀ mu (déf: 0), alors H₀ est :
                        #  - μ₁ Op μ₀, si mu est spécifié
                        #  - μ₁ Op μ₂, sinon :
                        #    - paired si paired est TRUE (déf: FALSE). Revient à remplacer NUMv,y par NUMv-y
                        #    - pooled si var.equal est TRUE (déf: FALSE), unpooled sinon
                        #paired : ???
                        #Op de H₀ est le contraire d'alternative, parmi == "two-sided", < "lesser" et > "greater", initiale
                        #possible (déf: "t").
                        #Un confidence interval pour le test statistic est également présenté, pour un conf.level (déf:
                        #0.95) donné. Il ne s'agit pas de la rejection region (̊t si H₀ est vraie), mais d'un interval de 
                        #valeurs réelles probables pour t étant donné que le t calculé est issu de samples, donc estimé 
                        #(donc ̊t étant donné samples actuels, que H₀ soit vraie ou non). 
                        #Les names de HTEST sont : 
                        #  - statistic : test statistic (ici t)
                        #  - parameter : paramètres de t() (ici df)
                        #  - p.value
                        #  - conf.int : confidence interval de t (cf dessus)
                        #  - estimate : sample statistics (ici μ₁ avec, si présent, μ₂)
                        #  - null-value : d₀ (ici inutile)
                        #  - alternative : STR, cf dessus
                        #  - method : STR, nom du test
                        #  - data.name : STR, nom des variables NUMv et, si présent, y
                        #Premier argument peut être FORMULA au lieu de NUMv et y. Il s'agit d'une FORMULA donc le X est
                        #un FACTOR à deux levels. Ensemble des yₙ pour chaque level forment les deux groupes NUMv et y.
var.test(NUMv|y,ratio,  #Renvoie également un HTEST (mêmes membres), mais pour un two samples variance F-test.
alternative,conf.level) #  - ratio (déf: 1) : d₀

lm(FORMULA)             #Renvoie un LM, régression linéaire sur FORMULA.
                        #Membres :
                        #  - $coefficients : valeur des coef.
                        #  - $model NUMv : ensemble des observed values
                        #  - $fitted.values NUMv : ensemble des expected values
                        #  - $residuals NUMv : ensemble des residuals, non-squared
                        #  - $df.residual : n-2
                        #  - $call : CALL de FORMULA
                        #Plus bavard avec un summary(LM) : 
                        #  - $call, $residuals
                        #  - fivenum(residuals)
                        #  - $coefficients : non seulement estimation, mais aussi standard error et t test H₀: coef. == 0
                        #  - $sigma: σ(εₙ)
                        #  - df (n-2)
                        #  - $r.squared et $adj.r.squared
                        #  - $f.statistic : F test H₀: b² == 0
coef(OBJECT)            #Accessor pour les coefficient d'un OBJECT, dont LM.
confint(OBJECT)         #Pareil pour un confidence interval de chaque coefficient (MATRIX)
resid(OBJECT)           #Pareil pour les residuals.
fitted(OBJECT)          #Pareil pour les expected values.

                                  ┌───────────┐
                                  │   PLOTS   │
                                  └───────────┘

COULEURS ==>            #Il s'agit de string sous la forme "NOM" ou "#RRGGBB". Souvent pour un argument "col"
rgb(red,green,blue,alpha#La valeur max est maxColorValue (def: 1), mais toujours 8bits/channel.
[, names,maxColorValue])#red, etc. peuvent être des VECT_NOMBRE, auquel cas un VECT_STR est renvoyé.
                        #names est un VECT_STR : le nom de chaque élément du vecteur (def: NULL)
hsv([h,s,v,alpha])      #Valeur de 0 à 1. Def: 1
colo[u]rs()             #Renvoie une VECT_STR des noms de couleurs possibles, comme "red"

PLOT ==>                #Types :
                        #  - high-level : crée plot entier, dont axes, légendes, etc.
                        #  - low-level : rajoute des choses à un graphe existant
                        #  - interactive
                        #  - graphical paramètres

HIGH-LEVEL ==>          #
plot(VAL)               #Fonction générique de plot :
                        #  - NUMv[NUMv2], DATA.FRAME, MATRIX, FORMULA : 
                        #    - point plots de ARG1 ~ ARG2
                        #    - NUMv2 (déf: 1:n)
                        #  - FACTOR : fat bar plot
                        #  - TABLE : fine bar plot
                        #  - TS : connected point plot
                        #  - FUNCTION : continuous point plot
                        #  - ECDF : step function plot
                        #  - LM : un ensemble de 4 graphs bizarres
hist(VALv)              #Histogramme.
boxplot(NOMBRE_VECT...) #Boxplot. Par défaut extrémités sont max. 1.5*IRQ, et les outliers dessinés.
                        #  - col : couleur de l'intérieur de la box.

ppoints(NUM)            #Renvoie un ensemble de NUM points à égale distance dans range [0,1]. L'écart entre 0 et le premier
                        #point (et 1 et dernier point) est la moitié de cette distance (3/8 si NUM <= 10)
                        #A utiliser pour définir le X d'un PP.Plot via plot(X,Y), où Y est alors :
                        #  - cdf(D₁) lorsque cdf(D₂) = X
qqplot(NUMv1, NUMv2)    #QQ-Plot.
                        #Ajouter ligne avec abline(0,1).
                        #Regression line de QQ-Plot, à comparer avec abline(0,1), peut être faite via qqline(NUMv2)
qqnorm(NUMv1)           #Pareil mais NUMv2 est N()

LOW-LEVEL ==>           
abline(NUM1,NUM2|h,v,   #Trace une ligne y = NUM2*x+NUM1
coef,reg)               #  - h : trace une ligne horizontale à l'ordonnée indiquée
                        #  - v : pareil pour vertical
                        #  - coef : un COEF à utiliser à la place de NUM1 et NUM2
                        #  - reg : un objet auquel on peut appliquer coef()

                                  ┌───────────────┐
                                  │   EXECUTION   │
                                  └───────────────┘

source(FILE)            #FILE est un script .R :
                        #  - exécute les expressions.
                        #  - même syntaxe qu'en ligne de commande, sans shebang

BYTE-COMPILER ==>       #Permet meilleure performance. Package compiler::
cmpfun(CLOSURE|options) #Renvoie CLOSURE, byte-compiled.
                        #Semblera exactement pareil, il y aura juste un pointeur vers une zone mémoire contenant le bytecode
                        #de la fonction.
                        #Les fonctions primitives sont déjà byte-compiled.
compile(EXPR|env,       #Renvoie EXPR sous forme de BYTECODE (pointeur vers bytecode)
options)                #  - options : cf setCompilerOptions()
cmpfile(FILE|outfile,   #Crée un fichier outfile .Rc (fichier contenant du bytecode) à partir de fichier source FILE.
ascii,env,verbose,      #  - ascii (déf: FALSE) : format alternatif où le bytecode est écrit en ASCII.
options)                
loadcmp(FILE
|envir,chdir)           #Comme source() mais avec un fichier .Rc
enableJIT(level)        #Set le level de JIT (Just-In time compilation). R bytecompile automatiquement une EXPR ou CLOSURE :
                        #  - 0 (déf) : jamais
                        #  - 1 : CLOSURE quand elle est exécutée pour la première fois
                        #  - 2 : CLOSURE quand elle est définie
                        #  - 3 : également boucle (EXPR) quand elle est exécutée
                        #Renvoie level précédent.
                        #R-envir var R_ENABLE_JIT à définir pour avoir le défaut.
compilePKGS(BOOL)       #Bytecompile package lors du loading ? (déf: FALSE) R-envir var R_COMPILE_PKGS pour défaut.

disassemble(BYTECODE)   #Renvoie une LIST montrant le désassemblage de BYTECODE

setCompilerOptions      #Options possibles :
(VAR=VAL...)            #  - optimize (déf: 2) : 0 à 3
                        #  - suppressAll (déf: FALSE) : par rapport aux messages d'erreur, peu important
                        #  - suppressUndefined (déf: c(".Generic",".Method",".Random.seed",".self")): pareil
getCompilerOption(STR)

gc(|verbose )           #R utilise de la garbage collection automatiquement. gc() permet de forcer la garbage collection 
                        #immédiatement.
                        #  - verbose (déf: option "verbose" (déf: FALSE)) : imprime statistics
gcinfo( verbose )       #Pour changer verbosity toujours
gc.time()               #Imprime le temps passé pour la garbage collection dans la session courante

                                  ┌──────────────┐
                                  │   PACKAGES   │
                                  └──────────────┘

LIBRARY ==>             #Il s'agit des DIR contenant des packages :
                        #  - R_HOME/library/ (R object .Library)
                        #Et n'existant pas par défaut (comma-separated, peut spécifier plusieurs DIR) :
                        #  - R_HOME/site-library (ou R_LIBS_SITE)
                        #  - R_LIBS_USER
                        #Un DIR dans un library = un package, toujours même structure
                        #.libPaths() renvoie/set le STRv des libraries courantes.

PACKAGES ==>            #Default packages == option "defaultPackages", elle-même == R-environment-var R_DEFAULT_PACKAGES
                        #Packages peuvent être en language compilé ou interprété. Sont distribués en .tar.gz
                        #CRAN est le repository officiel de R.
                        #Installer packages :
                        #  - R CMD INSTALL [-l LIB] PACKAGE_NAME...
                        #  - install.packages(PACKAGE_NAMEv|LIB,dependencies)
                        #    - dependencies (déf: FALSE) : si TRUE, installation des dépendances
                        #    - repos STRv : mirror sites. Si NULL, install local, PACKAGE_NAME est alors un .tar.gz. Défault
                        #                   est option "repos", par défaut "@CRAN@", à remplacer dans le .Rprofile
                        #                   setRepositories(FALSE) permet de choisir parmi les repos de ce fichier.
                        #Màj : update.packages(|ask) 
                        #  - ask (déf: TRUE)
                        #Remove : comme "install" mais avec remove/REMOVE
                        #Les deux installent par défaut via mirroir site, mais peuvent aussi installer en local.

library(NOM)            #Load une bibliothèque ("add-on package").
require(NOM)            #Beaucoup de bibliothèques sont déjà installées lors de l'installation de R.

data(|STR)              #Imprime les datasets disponibles avec les packages.
                        #Si STR, crée une variable STR avec le dataset STR (inutile car elles sont déjà disponibles)

apropos(PATTERN|where,  #Imprime objets dont le nom match PATTERN. 
ignore.case,mode)       #  - where (déf: FALSE) : si TRUE, imprime aussi leur position dans le search path
                        #  - ignore.case (déf: TRUE)
                        #  - mode (déf: "any") : mode de l'objet
find(PATTERN|mode,      #Pareil (numeric == where), sauf que :
numeric,simple.words)   #  - renvoie le nom de l'ENVIRONMENT, non le nom de l'objet
                        #  - case-sensitive
                        #  - simple.words (déf: TRUE) : doit matcher le nom complet

FILE FORMAT ==>         #  - .R : R script
                        #  - .Rd : R doc file (Latex-like)
                        #  - .Rnw : Autre R doc file, latex-like, utilisant utilitaire Sweave
                        #  - .rda : fichier comme .RData
                        #    - .rds : comme .rda mais pour une seule variable. Sert donc à sérialiser.
                        #  - .rdb : database d'objects : concaténation de serialised objects. Utilisé pour un package.
                        #    - .rdx : fichier des indexes d'un .rdb (en fait un .rds contenant une LIST)
                        #  - .Rc : bytecode file

ORG SOURCES ==>         #Dans un répertoire nommé PACKAGE :
                        # - Courants :
                        #   - répertoires :
                        #     - R/    : 
                        #       - *.R files
                        #     - data/ : 
                        #       - data pour le programme ou pour l'user
                        #       - surtout *.RData, *.rda
                        #       - mais aussi data *.txt, *.tab, *.csv
                        #       - parfois un fichier texte "datalist" où chaque ligne == un fichier du répertoire data/, sans
                        #         l'extension
                        #     - man/  : *.Rd files
                        #     - inst/ :
                        #       - CITATION file : 
                        #         - comment citer le package dans une publication
                        #         - il s'agit d'un .R file (sans l'extension), définissant des structures citHeader, etc.
                        #         - cf ?citation
                        #       - doc/ : documentation hors *.Rd : online, .pdf, *.Rnw, etc.
                        #     - src/
                        #       - fichiers source non R : C (*.c, *.h), C++ (*.cpp,*.hpp), FORTRAN (*.f)
                        #       - Makevars file pour Make ??
                        #     - test/ :
                        #       - *.R file à sourcer pour test
                        #       - *.Rout.save, output de ces tests
                        #     - demo/ ou examples/ : *.R file à sourcer pour démo du package
                        #     - vignettes : comme inst/doc/, mais en résumé sur un seul document
                        #   - fichiers roots :
                        #     - DESCRIPTION :
                        #       - Un champs = "CHAMPS: TEXTE"
                        #       - TEXTE peut revenir à la ligne (si ligne commence par whitespace ??)
                        #       - champs :
                        #         - Package: PACKAGE
                        #         - Type: 
                        #           - "Package": type commun
                        #         - Title: titre descriptif
                        #         - Version: MAJOR.MINOR[.RELEASE]
                        #         - Date: YYYY-MM-DD
                        #         - Author
                        #         - Maintainer: MAINTAINER <ADDR@ADDR.com>
                        #         - Descripion
                        #         - License: titre seulement
                        #         - Depends: PACKAGE dépendances
                        #         - Packaged: date (comme date()); username
                        #     - NAMESPACE :
                        #       - fichiers utilisant export(), exportPattern(), useDynLib(), import(), exportMethods(),
                        #         exportClasses(), S3method()
                        #     - INDEX : description rapide de chaque fonction
                        #     - MD5
                        #     - NEWS ou ChangeLog
                        #     - TODO
                        #     - THANKS
                        #     - README[.platform]
                        #     - COPYING[.LIB] ou LICENSE
                        #     - CHANGES
                        #     - parfois ./configure file
                        # - Moins courants :
                        #   - répertoires :
                        #     - incl/ : *.Rex ?? (semble fichier *.R normal)
                        #     - po/ : *.po et *.pot
                        #Source compilé sont PACKAGE_VERSION.tar.gz

                                  ┌──────────────────────┐
                                  │   INTEROPERABILITE   │
                                  └──────────────────────┘

.Platform               #Liste avec :
                        #   - OS.type : "unix" ou "windows"
                        #   - file.sep : en général "/", même sur "windows" (pour file.path)
                        #   - path.sep : séparateur de variables tel $PATH, ":" ou ";"
                        #   - dynlib.ext : ".so" ou ".dll"
                        #   - GUI : "X11" ou "Tk" (Linux), "Aqua" (Mac), "Rgui" ou "RTerm" (Win)
                        #   - endian : "big" ou "little" (utilisé par read/writeBin)
                        #   - pkgType : ???
                        #   - r_arch : arch-specific dir (pour moi "")

Sys.info()              #Infos sur l'OS : OS, version, users

.Machine                #LIST avec les limites des types numériques de l'archi courante.

R.Version()
R.version               #Version STR sous forme de LIST, dont plateforme et OS
R.version.list          #Pareil sous forme de STR

                                  ┌──────────────────────┐
                                  │   SYSTEM OPERATION   │
                                  └──────────────────────┘

system(STR|intern,      #Exécute STR avec le shell de l'OS en utilisant mêmes stdin, stdout et stderr. 
ignore.stdout,          #Avec Linux, utilise /bin/sh
ignore.stderr,wait,     #Renvoie silencieusement exit code, sauf si intern (déf: FALSE), renvoie stdout sous forme de STR.
input)                  #  - ignore.std[out|err] (déf: FALSE) : si TRUE, redirige vers /dev/null
                        #  - wait (déf: FALSE) : si TRUE, le lance en background (incompatible avec intern = TRUE)
                        #  - input (déf: NULL) STR : si non-NULL, redirige stdin avec <<<"STR"
system2(STR|args,stdout,#Comme system(), mais plus portable :
stderr,stdin,input,env, #  - commande est toujours shQuoted()
wait)                   #  - STR est $0 uniquement, ses arguments sont une STRv args
                        #  - stderr,stdout (déf: "") : si "", ShellStdout -> RStdout ; si FALSE ShellStdout -> /dev/null ;
                        #    si TRUE ShellStdout -> STRv
                        #  - stdin (déf: "") : FILE redirigeant stdin
                        #  - input (déf: NULL) : STR redirigeant stdin
                        #  - env (déf: character()) STRv : environment variables sous forme "VAR=VAL"
                        #  - wait : comme system()
shQuote( STR|type )     #Renvoie STR échappé de telle sorte qu'il peut être évalué dans un shell de type type 
                        #(val: c("sh","csh","cmd"))
Sys.which(STRv)         #Comme commande which. Si commande inexistante, renvoie ""
                        
Sys.getenv(STRv|unset,  #Renvoie valeur d'environment variables (du shell) STRv. Si non existante, renvoie unset (déf: "", 
names)                  #mettre NA pour distinguer "" d'unset).
                        #  - names (déf: FALSE) : si TRUE, rajoute STRv comme names du résultat

file.path(STRv|fsep)    #concatène STRv (liste de dir) avec file.sep, donc interopérable
path.expand(STRv)       #Performe la tilde expansion sur les chemin STRv. 
                        #Automatiquement effectué sur file.exists,create,remove,rename,copy,append,symlink,link,access,info et
                        #Sys.glob
Sys.glob(STRv|dirmark)  #Renvoie STRv des fichiers matchant globbing STRv. 
                        #  - dirmark (déf: FALSE) : rajoute "/" fin des répertoires

ECHEC DES OPERATIONS ==>#Opérations suivantes renvoient un BOOLv selon succès/échec.
file.exists(STRv...)    #Renvoie si les fichiers existent (symlinks déréférencés), sous forme de BOOLv.
file.create(STRv...|    #Crée fichiers réguliers si non-existants, truncate si existants
                        #Permissions du fichier créé dépend d'umask.
                        #  - showWarnings (déf: TRUE): warning si échec
file.remove(STRv...)    #Effectue un rm (fichiers réguliers (DIR possible, mais pas pour Windows))
file.rename(STRv,STR2v) #Effectue un mv.
file.copy(STRv,STR2v    #Effectue un cp.
|overwrite,recursive,   #Pour un cp -R DIR :
copy.mode)              #  - STR2 doit être un DIR aussi
                        #  - si overwrite est TRUE, DIR2 sera vidé avant la copie
                        #Alors :
                        #  - overwrite (déf: recursive)
                        #  - recursive (déf: FALSE)
                        #  - copy.mode (déf: TRUE) : essaye de préserver les droits d'accès
file.append(STRv,STR2v) #Effectue un cat STR STR2 > STR. 
file.symlink(STRv,STR2v)#Effectue un ln -s (symlinks ne marchent pas sous Windows ?)
file.link(STRv,STR2v)   #Effectue un ln

file.info(FILE...)      #Renvoie une DATA.FRAME avec colonnes d'infos : size, isdir, mode, [mca]time, [ug]id, [ugr]name
file.access(STRv|mode)  #Test mode (0: existence, 1: x, 2: w, 3: r (déf: 0)) des fichiers pour le RUID courant.
                        #Pour tester permission avant exécution/écriture/accès, préférer faire un try()

list.files(|path,       #Effectue un ls path/pattern. path (déf: ".") et pattern (déf: NULL)
pattern,all.files,      #  - all.files (déf: FALSE) : inclue dot files
full.names,recursive,   #  - full.names (déf: FALSE) : rajoute path/ devant résultat
ignore.case,            #  - recursive (déf: FALSE)
include.dirs)           #  - ignore.case (déf: FALSE)
                        #  - include.dirs (déf: FALSE) : si FALSE, avec recursive, n'imprime pas nom des répertoires dont le
                        #    contenu est affiché
list.dirs(|path,        #Pareil mais n'imprime que les répertoires. full.names (déf: TRUE) et recursive (déf: TRUE)
full.names,recursive)   #Toujours all.files TRUE.
file.choose()           #Demande à l'user de taper un nom de fichier, et le renvoie. 
                        #Me semble inutile, car pas de Tab completion, ni de check du fichier.

file.show(FILE...
|header,title,
delete.file,pager)      #Effectue un less (pager, option "pager" par défaut (soit R-environment var PAGER (déf: less)))
file.edit
(FILE...|editor)        #Edite fichiers avec editor

                                  ┌───────────┐
                                  │   AUTRE   │
                                  └───────────┘

Sys.sleep(NUM)          #sleep en secondes (jusqu'à milliseconde)

Sys.Date()              #Renvoie DATE, imprimé comme un STR (dont timezone), mais en fait un UINT
Sys.time()              #Renvoie date + heure POSIXCT, enfant de POSIXT, STR (dont timezone)
                        #Imprimé comme un STR (dont timezone), mais en fait un UINT
