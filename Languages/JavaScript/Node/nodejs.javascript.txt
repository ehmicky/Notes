
          
   NODEJS  
          



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         COMMAND LINE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PURPOSE ==>                                     #Execute JavaScript code server-side
                                                #Based on Chrome JavaScript engine V8

VERSION ==>                                     #14.11.0 (current), 13.14.0 (current), 12.18.4 (active LTS), 10.22.1 (active LTS), 8.17.0 (active LTS)
                                                #Branches:
                                                #  - "current": latest major version. New one every 0.5 years
                                                #  - LTS: every even-numbered version
                                                #     - when not current anymore, becomes "active LTS" (only bug fixes) for 1.5 years
                                                #     - then "maintainance LTS" (only critical bug fixes) for 1 more year
                                                #  - non-LTS also have a maintainance period of 0.5 years
                                                #Features are often backported.
                                                #For libraries I should support >=10.17.0
                                            NUM*#Means introduced by NUM.*.*

ES6 ==>                                         #Support is documented in JavaScript doc

node[js] [--] [FILE] [FILE_ARGS]                #Command-line
node[js] -e|--eval|-p|--print STR [--] [ARGS]   #nodejs is symlink to node (prefer the later as this is what nvm uses).
                                                #FILE is JavaScript file (def: stdin). Can be - too
                                                #With -e, evaluates STR
                                                #With -p, evaluates STR, and prints last return value.
                                                #All CLI flags can use underscores instead of dashes
NODE_OPTIONS=--OPT,... ENVVAR                   #Same as using node --OPT ...
--v8-options                                    #Prints available v8 options.
process.allowedNodeEnvironmentFlags             #Read-only SET with all available NODE_OPTIONS

-i
--interactive                                   #Enters REPL even if stdin does not come from a terminal
-c
--check                                         #Run-dry (syntax check)

--completion-bash                               #Output Bash completion script (for CLI flags)

#!/usr/bin/env node                             #Shabang to execute a Node file directly with ./FILE

npm                                             #Node packet manager (see doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EVENT QUEUE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


clear|setTimeout|Interval(...)                  #Like DOM ones (see DOM doc), but extra members
                                                #Unlike DOM, error if INT > 2 ** 31 - 1 (25 days)
clear|setImmediate(...)                         #
ID.[un]ref()->ID                                #Yield the macrotask (see JavaScript doc)
ID.hasRef()->BOOL                            11*#
ID.refresh()->ID                                #Reset the counter
ID[Symbol.toPrimitive]()->ID_NUM         12.9.0*#
ID_NUM                                   12.9.0*#Can be passed to clear*(...)

queueMicrotask(FUNC())                       11*#Add a new microtask (see JavaScript doc)
                                            <12*#Experimental (throw warning)
process.nextTick(FUNC()[, ...])                 #Add a new microtask (see JavaScript doc)
                                                #As opposed to queueMicrotask(), always processed before other microtasks,
                                                #including when calling itself recursively.,


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASYNC HOOKS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TASK_ID                                         #Microtask ID
                                                #Is incrementing counter, with top-level microtask having ID 1
                                                #Specifics:
                                                #  - ID 0 means executed from C++, not JavaScript
                                                #  - PROMISE report parent microtask's, not their actual microtask ID, unless
                                                #    an enabled HOOK exists
                                                #  - async|await (but PROMISE) report parent microtask's, not their actual microtask ID
RESOURCE                                        #Any resource, firing 0, 1 or several microtasks (depends on RESOURCE_TYPE)
                                                #RESOURCE properties depend on RESOURCE_TYPE. They might not be populated yet in init()
RESOURCE_TYPE                                   #Can be:
                                                #  - TickObject: process.nextTick()
                                                #     - properties: callback FUNC, [args 'VAL'_ARR]
                                                #  - Immediate: setImmediate()
                                                #     - properties: _onImmediate FUNC, [_argv 'VAL'_ARR]
                                                #  - Timeout: setTimeout|setInterval()
                                                #     - properties:
                                                #        - _onTimeout FUNC
                                                #        - _idleTimeout NUM
                                                #        - _repeat null|NUM: same but null with setTimeout()
                                                #        - [_timerArgs 'VAL'_ARR]
                                                #  - TIMERWRAP: setTimeout|setInterval()
                                                #  - PROMISE:
                                                #     - on:
                                                #        - new Promise(FUNC), Promise.resolve|reject()
                                                #        - PROMISE.then|catch|finally(FUNC), await PROMISE
                                                #        - calling an async FUNC
                                                #  - TTYWRAP: console.*
                                                #     - properties: callback FUNC, [args 'VAL'_ARR]
                                                #  - SIGNALWRAP: OS signal
                                                #  - FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,
                                                #    JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,
                                                #    STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, UDPSENDWRAP, UDPWRAP,
                                                #    WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST, RANDOMBYTESREQUEST, TLSWRAP: others

executionAsyncId()->TASK_ID                     #Current microtask
triggerAsyncId()->PARENT_TASK_ID                #Parent microtask, i.e. caller
executionAsyncResource()->RESOURCE           12*#Current microtask's RESOURCE

createHook(OPTS)->HOOK                          #Fires callbacks on new microtasks|resources, using OPTS:
                                                #  - init(TASK_ID, RESOURCE_TYPE, PARENT_TASK_ID, RESOURCE):
                                                #     - when RESOURCE is initialized.
                                                #  - before|after(TASK_ID):
                                                #     - before|after each microtask starts|ends
                                                #     - since some RESOURCE create no microtasks, or several,
                                                #       this might not be called, or be called several times
                                                #  - destroy(TASK_ID): when RESOURCE is destroyed
                                                #  - promiseResolve(TASK_ID):
                                                #     - when a PROMISE is resolved|rejected, including to another PROMISE2
                                                #     - only for RESOURCE_TYPE PROMISE
                                                #Exceptions thrown in callbacks are uncaught exceptions, but cannot be handled.
                                                #Doing async operations (i.e. creating microtasks) inside callbacks:
                                                #  - can cause infinite recursion
                                                #  - this includes console.*(), which can be replaced e.g. by
                                                #    fs.writeSync(1, util.format(VAL))
HOOK.enable|disable()->HOOK                     #HOOK callbacks will only be fired in enabled (disabled by def)

new AsyncResource('RESOURCE_TYPE'[, OPTS])      #Custom RESOURCE
                                                #OPTS:
                                                #  - triggerAsyncId PARENT_TASK_Id (def: executionAsyncId())
                                                #  - requireManualDestroy BOOL: if false (def), calls emitDestroy() when object
                                                #    is garbage collected
ASYNCRESOURCE.runInAsyncScope
 (FUNC[, THIS][, ...ARGS])                      #This is automatically create a new TASK_ID and call 'before|after' events
ASYNCRESOURCE.bind(FUNC)->FUNC2              14*#Like ASYNCRESOURCE.runInAsyncScope.bind(FUNC)
AsyncResource.bind(FUNC[, 'RESOURCE_TYPE'])  14*#Like (new AsyncResource('RESOURCE_TYPE')).bind(FUNC)
 ->FUNC2                                     14*#Def 'RESOURCE_TYPE': 'bound-anonymous-fn'
ASYNCRESOURCE.emitDestroy()                     #
ASYNCRESOURCE.asyncId()->TASK_ID                #
ASYNCRESOURCE.triggerId()->PARENT_TASK_ID       #

--no-force-async-hooks-checks                   #Do not do extra runtime checks related to async hooks

new AsyncLocalStorage()                      12*#Create STOREs, i.e. objects available inside a specific function and its closures (including async)
ASYNC_LOCAL_STORAGE.run(STORE, FUNC())       12*#Creates a STORE that only exists within the current async context.
                                             12*#An async context is the current function and its closures including async ones (promise or callback).
                                             12*#Creates a new async context
                                             12*#STORE is undefined outside that context.
                                             12*#STORE is cleaned up once the context stops.
                                             12*#STORE can be anything (e.g. an OBJ or MAP)
ASYNC_LOCAL_STORAGE.getStore()->STORE        12*#Retrieve the STORE
ASYNC_LOCAL_STORAGE.disable()                12*#Make all STORE undefined until run*() called again
                                             12*#Should be called to cleanup ASYNC_LOCAL_STORAGE itself (not its STOREs)
ASYNC_LOCAL_STORAGE.enterWithStore(STORE)    12*#Make getStore() return STORE for the current synchronous context (current function and its sync closures)
ASYNC_LOCAL_STORAGE.exit                     12*#Opposite
 (FUNC([...ARGS])[, ...ARGS])                12*#Creates a new async context


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           DEBUGGER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--inspect[-brk][=[HOST:]PORT] ...               #Launches node ... but with debugger server.
                                                #Must connect to it with a debugger client:
                                                #  - go to chrome://inspect and click on a link to open devtools
                                                #  - or directly click on the Node symbol in devtools
                                                #Also forwards console messages
                                                #If -brk, will put breakpoint at first line
                                                #  - unless -brk, breakpoints are ignored until a client is connected
                                                #HOST: def 127.0.0.1
                                                #PORT: def 9229, 0 for "any available"
                                                #Child processes must be started with node --inspect as well
--inspect-publish-uid=STR,...                   #How the debugging information is communicated among:
                                                #  - 'http' (def): endpoint at HOST:PORT/json/list
                                                #  - 'stderr' (def)

IRON-NODE ==>                                  ##Another way to debug is to use Electron.
JAM3 DEVTOOL ==>                               ##Those two apps do this
                                               ##There are many problems I encountered with those, so I prefer node --inspect


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ERROR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ERROR                                           #Are v8 errors, i.e. what follows is shared by Chrome
                                                #See JavaScript doc for more information, including on async stack trace

Error.captureStackTrace(OBJ[, FUNC])            #Adds OBJ.stack, unless already exists
                                                #Automatically done by ERROR, i.e. Error.captureStackTrace(ERROR) is useless
                                                #If FUNC, stops stack frame at FUNC
--stack-trace-limit=NUM
Error.stackTraceLimit                           #Def: 10

Error.prepareStackTrace                         #When set with FUNC(ERROR, CALL_ARR)->'STACK', override how OBJ.stack is get
                                                #Default is something along the lines of:
                                                #  ERROR.name: ERROR.message
                                                #    at [new] CALL.getFunctionName() [as methodName] (LOCATION)
                                                #    at <anonymous> (LOCATION)
                                                #    at eval (PARENT_CALL, <LOCATION2>)
                                                #    at native
                                                #    at unknown location
                                                #    ...
                                                #LOCATION is:
                                                #  (CALL.getFileName():CALL.getLineNumber():CALL.getColumnNumber())
CALL.getFileName()->'FILENAME'                  #undefined if eval
CALL.getEvalOrigin()->'FILENAME'                #Same but when using eval() (or related)
CALL.getScriptNameOrSourceURL()->'FILENAME'     #Same but when using eval() (or related) with //# sourceURL comment
CALL.getFunction()->FUNC                        #undefined in 'strict mode'
CALL.getFunctionName()->'[CLASS.]FUNC|null'     #
CALL.getMethodName()->'FUNC'|null               #
CALL.getThis()->THIS                            #undefined in 'strict mode'
CALL.getTypeName()->STR|null                    #THIS's TYPE
CALL.getLine|ColumnNumber()->NUM                #
CALL.getPosition()->NUM                         #Byte index
                                             11*#Does not includes CommonJS wrapper anymore
CALL.isToplevel()->BOOL                         #
CALL.isEval()->BOOL                             #From eval() (or related)
CALL.isNative()->BOOL                           #From native C++ code
CALL.isConstructor()->BOOL                      #Using new
CALL.isAsync()->BOOL                         12*#True if async stack trace
                                                #Only for the CALL that triggered an async operation, e.g. `await`.
CALL.isPromiseAll()->BOOL                    12*#True if Promise.all()
CALL.getPromiseIndex()->NUM                  12*#PROMISE index inside Promise.all()


NERROR                                          #Node internal error, as opposed to standard JavaScript ERROR
                                                #Often filesystem errors, including permissions
NERROR.code                                     #NERROR_NAME
                                                #Either:
                                                #  - E*: cross-OS
                                                #  - W*: Windows-specific
                                                #  - ERR_*: otherwise
                                                #E*|W*:
                                                #  - only if SYSTEMERROR
                                                #  - have an underlying NERROR_NUM (OS-specific number)

SystemError                                     #NERROR related to OS/environment issue.
SYSTEMERROR.errno                               #-NERROR_NUM
                                            <12*#Can also be NERROR_NAME
UTIL.getSystemErrorName(-NERROR_NUM)->NEROR_NAME#
OS.constants.errno.NERROR_NAME                  #NERROR_NUM

SYSTEMERROR.syscall                             #STR (e.g. 'access')
SYSTEMERROR.path|dest                           #Src|dest 'PATH', if any
SYSTEMERROR.address|port                        #HOST|PORT, if any
SYSTEMERROR.info                                #Extra info, if any


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new EventEmitter([OPTS])                        #Base class of all objects receiving events
                                                #'EVENT' can be a SYM
                                                #Events are emitted synchronously
EVENTEMITTER.on('EVENT', FUNC)->EVENTEMITTER    #
EVENTEMITTER.once('EVENT', FUNC)->EVENTEMITTER  #
EVENTEMITTER.prepend[Once]Listener(...)         #Like on[ce](...) but adds to beginning of listeners list, not end
once(EVENTEMITTER|EVENTTARGET, 'EVENT')         #Like EVENTEMITTER.once() but using PROMISE:
 ->PROMISE_ARG_ARR                              #  - resolved with ARG_ARR on emit('EVENT', ...ARGS)
                                                #  - rejected with VAL on emit('error', VAL) (unless 'EVENT' is 'error' itself)
on(EVENTEMITTER|EVENTTARGET, 'EVENT')
 ->ASYNC_ITERATOR                            12*#Same but for EVENTEMITTER.on(), as a an ASYNC_ITERATOR
EVENTEMITTER.off|removeListener('EVENT', FUNC)
  ->EVENTEMITTER                                #
EVENTEMITTER.removeAllListeners(['EVENT'])
  ->EVENTEMITTER                                #
EVENTEMITTER.emit('EVENT'[, ...])->BOOL         #True if there were listeners
                                                #If 'EVENT' is 'error' and there are not listeners, throws instead

EVENTEMITTER.listeners(EVENT)->FUNC_ARR         #
EVENTEMITTER.rawListeners(EVENT)->FUNC_ARR      #Same but also with what Node.js adds, e.g. once() wrapper
EVENTEMITTER.listenerCount(EVENT)->NUM          #Slightly faster than EVENTEMITTER.listeners(STR).length
EVENTEMITTER.eventNames()->'EVENT'_ARR          #
EVENTEMITTER.setMaxListeners(NUM)->EVENTEMITTER #0 for unlim. Beyond max, does not stops adding listeners, only print warning.
EVENTEMITTER.getMaxListeners()->NUM             #
EVENTEMITTER.defaultMaxListeners                #10
EVENTEMITTER.on                                 #Event when a new event handler is added or removed.
 ("new|removeListener", FUNC(EVENT, FUNC2))     #Added|removed FUNC2 might still [not] be in EVENTEMITTER.listeners(EVENT)

OPTS.captureRejections                       12*#BOOL. Enables Symbol.for('nodejs.rejection')
EventEmitter.captureRejections               12*#Default value for OPTS.captureRejections (def: false)
EVENTEMITTER[Symbol.for('nodejs.rejection')] 12*#Can be set to a FUNC(VAL, 'EVENT', ...ARGS)
EVENTEMITTER[captureRejectionSymbol]         12*#Fired when an EVENTEMITTER handler returns a PROMISE rejected with VAL.
                                             12*#If not set, fire 'error' event handler FUNC(VAL) instead.
                                             12*#Not recursive (not done if 'nodejs.rejection' or 'error' event handler rejects
                                             12*#a PROMISE themselves).

EventEmitter.errorMonitor                    12*#Special 'EVENT' that behaves like 'error' except if no 'error' listener is
                                             12*#defined, an error is still thrown afterwards

EventTarget                                  14*#Like DOM except:
                                             14*#  - can be async
                                             14*#  - no event nesting
                                             14*#Notable differences between DOM EventTarget and Node.js EventEmitter:
                                             14*#  - listeners can be either FUNC or { handleEvent() }
                                             14*#  - cannot add same listener several times to same OBJ
                                             14*#Not exposed globally
NodeEventTarget                              14*#Child of EventTarget that mixes most Node.js EventEmitter properties|methods:
                                             14*#  - only on|once|off|removeListener|removeAllListeners|listeners|listenerCount|eventNames|*etMaxListeners|defaultMaxListeners
                                             14*#Not exposed globally
Event                                        14*#Like DOM.
                                             14*#Not exposed globally


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GLOBAL             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GLOBAL VARIABLES ==>                            #  - global|globalThis: global scope reference
                                                #  - clear|setImmediate|Interval|Timeout, Object, URL, console, encodeURI, WebAssembly, etc.: JavaScript globals
                                                #  - module, require, exports, __filename, __dirname: CommonJS globals
                                                #  - process, url: core modules
                                                #  - Buffer: core modules property
                                                #  - _, _error: REPL only
                                                #  - all core modules (e.g. http): in CLI only

--frozen-intrisics                              #Call Object.freeze():deeply on all global objects.

require('timers')                               #Module for clear|setImmediate|Interval|Timeout
                                                #Prefer globals as they work on browsers too

--disable-proto=STR                          12*#Disallow OBJ.__proto__ (often used for security vulnerabilities)
                                             12*#STR is 'throw' (throw on access) or 'delete' (remove it)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SCOPE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SCOPE ==>                                       #Variables are local to each file, except for MODULE.exports|require() or export|import

TOP-LEVEL ==>                                   #CommonJS, import(): any level
                                             12*#import: must be top-level

TOP-LEVEL CONTEXT ==>                           #CommonJS:
                                                #  - has exports, require, module, __filename, __dirname
                                                #  - before Node 11, was wrapping in anonymous function, with global variables as
                                                #    arguments, i.e. (function(GLOBALS...){...})(...)
                                             12*#ESM: only import, export, import.meta

TOP-LEVEL THIS ==>                              #CommonJS: module.exports
                                             12*#ESM: undefined


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STEPS ==>                                       #  - resolve relative PATH to absolute PATH
                                                #  - fetch|read file
                                                #  - sets top-level context
                                                #  - parsing
                                                #  - running|evaluating
                                                #  - cache return value

PARSE-TIME VS RUNTIME ==>                       #CommonJS, import(): everything done runtime
                                             12*#import: everything done parse-time:
                                             12*#  - cannot do e.g. export { VAL as [DYNAMIC_VAR] }
                                             12*#  - cannot catch errors in try/catch (e.g. optional dependency)
                                             12*#  - better static analysis
                                             12*#  - VAR are implicitely const
                                             12*#  - also find imported|exported symbols (VAR) and link them

SYNC VS ASYNC ==>                               #CommonJS: sync
                                             12*#import:
                                             12*#  - async parsing (parse-time)
                                             12*#  - sync loading (runtime)
                                             12*#import(): async with PROMISE

CIRCULAR DEPENDENCIES ==>                       #import(), dynamic require(): no issues
                                                #top-level require():
                                                #  - retrieve `module.exports` (not individual properties) by reference (not value)
                                                #  - if accessed during file load, empty object (parent not done loading)
                                                #     - including destructuring during `require()`
                                                #  - but works after file load:
                                                #     - unless parent does `module.exports = VAL` (as opposed to `module.exports.VAR = VAL`), as it removes the reference
                                             12*#import:
                                             12*#  - retrieve individual properties by reference (not value)
                                             12*#  - if accessed synchronously, throws error (parent not done loading)
                                             12*#  - otherwise works

DEFAULT EXPORT ==>                              #CommonJS: it is the whole export (module.exports)
                                             12*#ESM: it is a property named 'default'

FORMAT ==>                                   12*#Decided by:
                                             12*#  - FILE.mjs|cjs -> ESM|CommonJS
                                             12*#  - FILE[.js] -> PACKAGE.type 'module|commonjs' (def: 'commonjs')
                                             12*#     - `package.json` can be in nested directories
                                             12*#  - stdin|--eval|--print -> --input-type module|commonjs (def: 'commonjs')

MIXING ==>                                   12*#ESM can import CommonJS:
                                             12*#  - only default|namespace import (no named import)
                                             12*#  - can use dynamic require() with createRequire()
                                             12*#CommonJS cannot import ESM:
                                             12*#  - including if ESM is a package (node_modules)
                                             12*#  - but can use dynamic import(), which allows importing ESM
require('module')                            12*#Returns CommonJS require().
 .createRequire('/PATH'|'URL'|URL)           12*#'PATH|URL' is the relative base (relative itself to __dirname)
 ->require(STR)                              12*#Can be used to use CommonJS or load PATH.json|node in ESM
                                             12*#Usually createRequire(import.meta.url)

DUAL PACKAGES ==>                            12*#Alternatives when supporting both old and new Node.js:
                                             12*#  - use different PACKAGE.exports.PATH for CommonJS and ESM
                                             12*#  - use different PACKAGE.exports.CONDITION for CommonJS and ESM
                                             12*#ESM can be either:
                                             12*#  - ESM source
                                             12*#     - this could be an issue as user could load twice (once with require(), once with import)
                                             12*#        - not an issue if no logic triggered on load nor top-level state
                                             12*#  - ESM small file that loads transpiled ESM source
                                             12*#     - so that exports are known parse-time and named imports can be used

--force-context-aware                        12*#Forbids native modules that do side effects during initialization


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          FILE TYPES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


require|import ... 'PATH[.js]'                  #

require|import ... 'PATH.json'                  #
--experimental-json-modules                  12*#Required with ESM (experimental in browsers too).
                                             12*#Only default|namespace exports (no named exports)

require('PATH.node')                            #Machine code file.
                                                #Not possible with ESM (like in browsers)
                                                #Loaded by dlopen()
                                                #exports available in void init(Handle<Object> exports)
                                                #Must use libraries: V8, libuv, others
                                                #Use node-gyp for packaging/compilation
                                                #On Windows, must first npm install -g windows-build-tools as admin

import ... from 'URI.wasm'                   12*#Only with ESM
--experimental-wasm-modules                  12*#Required for WebAssembly imports

import 'data:MIME,...'                       12*#For MIMEs text/javascript, application/json, application/wasm
                                             12*#Cannot do a nested import inside ...
                                             12*#Only with ESM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           COMMONJS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


require(STR)                                    #Load file STR:
-r STR                                          #  - 'ID': core module
--require STR                                   #  - 'FILE' (absolute or relative)
                                                #  - 'DIR' (absolute or relative):
                                                #     - DIR/package.json, using main 'PATH' (relative to DIR)
                                                #     - DIR/index[.EXT]
                                                #  - 'MODULE[/PATH]':
                                                #     - i.e. anything that does not start with / or .
                                                #     - tries require('DIR2/MODULE'), with DIR2 [.../[..]]./node_modules/
                                                #Paths can omit extensions: .js, .mjs, .cjs, .json, .node
                                                #  - decide file type based on file extension
                                                #If not found, throw ERROR with code "MODULE_NOT_FOUND"
                                             12*#and ERROR.requireStack 'PATH'_ARR
MODULE.require(...)                             #Reference to require(...)

require.resolve(STR[, OPTS])->'/PATH'           #How require(STR) would resolve, based on __filename.
                                                #OPTS:
                                                #  - paths 'DIR'_ARR: alternative directories to look into.
                                                #    Their [.../[..]]./node_modules will always be searched.
require.resolve.paths(STR)->'DIR'_ARR           #Directories that would be looked into when require(STR) would resolve
import.meta.resolve(STR[, CURRENT_URL])
 ->PROMISE_'/PATH'                           12*#Same as require.resolve() but for ESM
--experimental-import-meta-resolve           12*#Needed for import.meta.resolve()

require.cache['/PATH']                          #require() cache (i.e. modules are only loaded once).
                                                #'/PATH' is require.resolve() result
                                                #Does not include builtins.
                                                #Can delete it to remove cache, or restart current code.

--preserve-symlinks                             #When require()|import a symlink, use symlink path instead of symlinked file's path for:
                                                #  - caching
                                                #  - module resolution (when walking up the tree)
                                                #Does not apply to main file
--preserve-symlinks-main                        #Same but only for main file

exports                                         #Return value (by reference if OBJ) when required. Must be assigned sync.
                                                #Can be any type.
MODULE.exports                                  #Reference to exports.
                                                #Must be used when want to overwrite, i.e. exports = VAL (as opposed to exports.VAR = VAL)

module                                          #Current MODULE, i.e. file being loaded.
                                                #There are builtin modules, which are the chapters of this doc.
require.main                                    #Root file (first to have been loaded) MODULE
process.mainModule                              #Same but updated if root file changed at runtime
MODULE.children                                 #MODULE[_ARR]|null

MODULE.loaded                                   #False for the first time the file is loaded (i.e. sync)
                                                #True for async functions
require('module').builtinModules                #List of system 'MODULE'_ARR (e.g. 'http') including internal ones
require('repl').builtinModules               14*#Same

__filename                                      #Current file absolute path.
MODULE.filename                                 #Reference to __filename
MODULE.id                                       #For core modules, a string like "buffer". For others, module.filename.
__dirname                                       #Current file absolute dirname

CLI ==>                                         #Not defined: require.main, process.mainModule, __filename, __dirname, MODULE.parent
                                                #MODULE.loaded: false
                                                #MODULE.id: '<repl>'
                                                #MODULE.exports: empty OBJ
                                                #MODULE.filename null


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ES MODULES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


import|export ...                            12*#ES modules
                                            <14*#Prints an experimental warning
import('URI')->PROMISE                       12*#

import ... from 'URI'                        12*#Import from 'URI' not PATH
                                             12*#Need to be URI encoded
                                             12*#Must use file:/// if absolute
                                             12*#Can use #HASH or ?QUERY
                                             12*#  - included in cache key, providing imported file is ESM
                                             12*#  - i.e. can load twice a file by using different ?QUERY
                                             12*#Can use fileURLToPath|pathToFileURL() to convert

--experimental-specifier-resolution=STR      12*#Whether:
                                             12*#  - 'node': can omit file extension or use index.js
                                             12*#  - 'explicit' (def): cannot (like in browsers)
                                             12*#Both use same algorithm to find node_modules (unlike browsers)

import.meta.url                              12*#Like __filename but as 'file:///URI'.
                                             12*#Should be used instead of __filename|__dirname

syncBuiltinESMExports()                      12*#Can monkey-patch core modules by modifying their default import.
                                             12*#This must be called after it so that dynamic import(...) can use it

--experimental-loader FILE                   12*#Customize the behavior of import|import()
                                             12*#FILE must be ESM, and have a default export LOADER
                                             12*#Each of the methods below:
                                             12*#  - represent one step of the resolution to customize
                                             12*#  - are reducing in order the same OBJ
                                             12*#  - are optional, and get their default value as FUNC(...), whose arguments
                                             12*#    are the three arguments (including FUNC itself)
                                             12*#     - should always be used as a default branch
                                             12*#Common OBJ and values:
                                             12*#  - 'PATH': relative path
                                             12*#  - OBJ.parentURL 'URL': absolute base
                                             12*#     - is a URL, e.g. file: protocol with filesystem
                                             12*#     - can be undefined, e.g. REPL
                                             12*#  - OBJ.url 'URL': resolved absolute URL
                                             12*#  - OBJ.format: 'module' (ESM), 'commonjs', 'json', 'builtin' (core module), 'wasm' or 'dynamic'
                                             12*#  - OBJ.source 'SOURCE'_STR|BUFFER: file content
LOADER.resolve
 ('PATH', { parentURL }, FUNC(...))
 ->PROMISE_{ url }                           12*#
LOADER.getFormat(URL, {}, FUNC(...))
 ->PROMISE_{ format }                        12*#
LOADER.getSource(URL, { format }, FUNC(...))
 ->PROMISE_{ source: 'SOURCE' }              12*#
LOADER.transformSource
 ('SOURCE', { url, format }, FUNC(...))
 ->PROMISE_{ source: 'SOURCE' }              12*#
LOADER.dynamicInstantiate(URL)               12*#Customize loading, for custom formats beyong ESM/CommonJS/JSON
 ->PROMISE_{ exports, execute(EXPORTS) }     12*#Only when LOADER.resolve() returns format 'dynamic'
                                             12*#  - URL: returned by LOADER.resolve()
                                             12*#  - exports is the 'VAR'_ARR of exported variables
                                             12*#  - execute() must call EXPORTS.VAR.get()|set(VAL) to set the value of the exported variables

PACKAGE.exports                              12*#'URI'[_ARR]. Like PACKAGE.main except:
                                             12*#  - priority over it
                                             12*#  - start from Node 13, i.e. can be used to target Node that supports ESM
                                             12*#  - must start with '.'
                                             12*#  - only import|require from 'MODULE[/...]' not relative|absolute paths|URI
                                             12*#  - can be an ARR for fallbacks
                                             12*#     - only skips 'URI' that is not valid identifier with current Node.js version
                                             12*#       e.g. not starting with '.'
                                             12*#     - i.e. only meant for forward compatibility with new Node.js features
                                             12*#Used with both CommonJS|ESM

PACKAGE.exports.CONDITION                    12*#'URI'[_ARR]. Like PACKAGE.exports except only if CONDITION matches.
                                             12*#Available CONDITION:
                                             12*#  - require: loaded by require()
                                             12*#  - import: loaded by ES import|import()
                                             12*#  - node: Node.js environment (loaded by require()|import)
                                             12*#  - browser: browser environment
                                             12*#  - default: always match, but least priority
                                             12*#  - custom ones, e.g. 'electron', 'deno', etc.
                                             12*#CONDITION can be nested.
                                             12*#Matched|tried in object properties order.
--conditions=CONDITION,...               14.9.0*#Specify custom CONDITION

PACKAGE.exports[.CONDITION].PATH             12*#'PATH2'. Like PACKAGE.exports[.CONDITION] except final 'URI' maps input path.
                                             12*#PATH must start with '.':
                                             12*#  - matched against 'MODULE' in imported path
                                             12*#  - can be single '.'
                                             12*#If PATH ends with:
                                             12*#  - '/':
                                             12*#     - is a prefix
                                             12*#     - PATH2 must end with '/'
                                             12*#     - if several matches, longer prefixes prevail
                                             12*#  - otherwise: exact match
                                             12*#If no matches, errors.
                                             12*#Always errors:
                                             12*#  - i.e. forbid any 'MODULE/...'
                                             12*#  - when PACKAGE.exports does not use PACKAGE.exports.PATH
                                             12*#     - including PACKAGE.exports {}
                                             12*#     - including PACKAGE.exports false

PACKAGE.imports[.CONDITION].#PATH            14*#PATH2. Remaps import "PATH[...]" to "PATH2[...]"
                                             14*#Same PATH syntax as PACKAGE.exports[.CONDITION].PATH


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          SOURCE MAPS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--enable-source-maps                         12*#Use source maps for ERROR.stack
                                             12*#Does not work with ERROR.prepareStackTrace()
                                             12*#Also enables MODULE.findSourceMap|SourceMap

new MODULE.SourceMap(SOURCEMAP_OBJ)          12*#SOURCEMAP.
                                             12*#SOURCEMAP_OBJ has source map v3 raw properties
                                             12*#(version|sources|sourceRoot|sourcesContent|names|file|mappings)
SOURCEMAP.payload                            12*#SOURCEMAP_OBJ
SOURCEMAP.findEntry(LINE_NUM, COL_NUM)->OBJ  12*#Use "mappings" to map compiled|generated file LINE_NUM|COL_NUM to
                                             12*#source|original file
                                             12*#OBJ:
                                             12*#  - generatedLine|Column NUM
                                             12*#  - originalLine|Column NUM
                                             12*#  - originalSource 'SOURCE_PATH'|null

MODULE.findSourceMap('PATH'[, ERROR])        12*#Parse SOURCEMAP using sourceMappingURL comment (inline or external)
 ->SOURCEMAP                                 12*#If inside an Error.prepareStackTrace(ERROR), should specify ERROR for caching reasons


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            POLICY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--experimental-policy=PATH                   11*#PATH to POLICY file

POLICY                                       11*#JSON file
                                             11*#Verify checksum of every loaded file.
                                             11*#Every loaded file must be present and match POLICYFILE.integrity
                                             11*#Running process should not be able to modify it, i.e.:
                                             11*#  - no write permission
                                             11*#  - does not own file (i.e. cannot do chmod)
POLICY.resources.PATH|URL                    11*#POLICYFILE
POLICYFILE.integrity                         11*#STR: 'sha256|384|512' followed by 'HASH'
                                             12*#Can also be true to bypass (during local development)
--policy-integrity=STR                       12*#Same as CLI, i.e. works even if POLICY file was tampered with.
POLICYFILE.dependencies                      12*#OBJ.MODULE to configure module resolution during policy check. Either:
                                             12*#  - 'PATH': make resolving 'MODULE' resolve 'PATH' instead
                                             12*#  - true: use normal resolution
POLICY.onerror                               11*#What do on integrity failures:
                                             11*#  - 'throw' (def): throw ERROR
                                             11*#  - 'exit': print ERROR + process.exit(1)
                                             11*#  - 'log': print ERROR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        STRING_DECODER         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new StringDecoder(['ENCODING'])                 #Returns DECODER. Def: "utf8"
                                                #Does TDBUFFER -> STR translation
DECODER.write|end(TDBUFFER)->STR                #Adds to current string. If:
                                                #  - it still contains incomplete chars, returns ''
                                                #  - otherwise, resets and returns current string
DECODER.end()->STR                              #Returns current string, but does not reset.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BUFFER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Buffer                                          #Child of Uint8Array (including constructors), with extra methods:
                                                #  - mixes in DATAVIEW flexibility (of changing current type)
                                                #  - better serialization: toString(), toJSON()
                                                #  - can decode STR according to different encodings
                                                #  - can swap bytes, compare bytes
                                                #  - some performance improvements, and some convenience functions

[S][T][D][U][A]BUFFER                           #Means BUFFER|[STR]|[TYPED_ARR]|[DATAVIEW]|[UINT8ARR]|[ARRBUFFER]
BVAL                                            #UINT (like Uint8Array), STR, BUFFER or UINT8ARR

constants.MAX_LENGTH                            #Max BUFFER.length
constants.MAX_STRING_LENGTH                     #Max STR.length

Buffer.isEncoding('ENCODING')->BOOL             #
transcode(UBUFFER, "ENCODING", "ENCODING2")
 ->BUFFER2                                      #Returns BUFFER2 with ENCODING2, based on UBUFFER with ENCODING

kMaxLength                                      #Max BUFFER size (2 ** 32 on my machine)

new TYPED_ARR(BUFFER)                           #Copy, not reference
                                                #Each single BUFFER BVAL -> a single TYPED_ARR VAL
Buffer.allocUnsafe[Slow](NUM)->BUFFER           #Similar to new TYPED_ARR(NUM)
                                                #Unless "Slow", will reuse preallocated buffer from a pool (i.e. faster)
                                                #if NUM <= Buffer.poolSize (def: 8192) / 2
Buffer.alloc(NUM[, NUM2|SBUFFER[, 'ENCODING']]) #Like Buffer.allocUnsafeSlow(NUM).fill(NUM2|SBUFFER, 'ENCODING') (def: \0),
 ->BUFFER                                       #for security reasons
                                                #If node --zero-fill-buffers, will fill with \0 even Buffer.allocUnsafe[Slow]()
Buffer.from(NUM_ARR)->BUFFER                    #Similar to new TYPED_ARR(NUM_ARR)
Buffer.from(ARRBUFFER, ...)->BUFFER             #Similar to new TYPED_ARR(ARRBUFFER, ...)
Buffer.from(STR[, 'ENCODING'])->BUFFER          #
Buffer.from(BUFFER)->BUFFER                     #Copies
Buffer.concat(UBUFFER_ARR[, UINT])->BUFFER      #Similar to Array.prototype.concat.call(null, ...) but with UBUFFER_ARR
                                                #Providing final length UINT can speed up performance.
BUFFER.buffer                                   #Inherited from UINT8ARR. Reference to underlying ARRBUFFER

Buffer.byteLength(STDABUFFER[, 'ENCODING'])->NUM#Similar to TYPED_ARR.byteLength

Buffer.isBuffer(VAL)->BOOL                      #
BUFFER.equals(UBUFFER2)->BOOL                   #
BUFFER.compare(UBUFFER2[, 4 NUM])->-1|0|1       #Sort comparison. NUMs are UBUFFER2 start|end and UBUFFER start|end
Buffer.compare(UBUFFER, UBUFFER2)->-1|0|1       #Same as BUFFER.compare(UBUFFER2)

BUFFER.toString(['ENCODING'[, ...])->STR        #Like:
                                                #  let decoder = new StringDecoder('ENCODING');
                                                #  decoder.write(BUFFER.slice(...));
                                                #  return decoder.end()
BUFFER.toJSON()                                 #Returns as '{"type": "Buffer", "data": [...]}'

BUFFER.slice(...)->BUFFER                       #Like [TYPED_]ARR, but returns a reference
BUFFER.[last]indexOf(..., 'ENCODING')->NUM      #Like [TYPED_]ARR but:
BUFFER.includes(..., 'ENCODING')->BOOL          #  - VAL is BVAL
BUFFER.fill(...[, 'ENCODING'])                  #  - can use 'ENCODING'

BUFFER.write(STR[, UINT[, UINT2[, 'ENCODING']]])#Writes STR on BUFFER
 ->NUM                                          #UINT is offset (def: 0) and UINT2 is length (def: all)
BUFFER.copy(UBUFFER2[, 3 UINT])->UINT4          #Copies bytes from BUFFER at position UINT to UBUFFER2 from position UINT2 to
                                                #UINT3 (def: UBUFFER2.length)

BUFFER.readFloat|Double|[U]Int8|16|32]LE|BE
(UINT[, BOOL])->VAL                             #Similar to DATAVIEW.get|set* but:
BUFFER.writeFloat|Double|[U]Int8|16|32LE|BE     #  - use LE|BE instead of BOOL argument
(VAL, UINT[, BOOL])                             #  - if BOOL true, faster but no validation of UINT buffer overflow
BUFFER.read[U]Int[LE|BE](UINT, UINT2[, BOOL])
BUFFER.write[U]Int[LE|BE](VAL,UINT,UINT2[,BOOL])#Same but specifies [U]Int size UINT2 (up to 48)
BUFFER.readBig[U]Int64LE|BE
 (UINT)->BIGINT                         10.20.0*#
BUFFER.readBig[U]Int64LE|BE
 (BIGINT, UINT)                         10.20.0*#
BUFFER.*int*(...)                        14.9.0*#Like BUFFER.*Int*(...)

BUFFER.swap16|32|64()->BUFFER                   #Swaps every couple of 1|2|4 bytes. Return value is reference


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STREAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SVAL                                            #UBUFFER or (if setEncoding() called) STR, or null if nothing to read
OBJECT MODE ==>                                 #SVAL is any VAL (except null):
                                                #  - encoding is ignored
                                                #  - both ISTREAM and OSTREAM must be in objectMode
                                                #  - ISTREAM.read() NUM argument is ignored (always 1)
                                                #  - highWaterMark is per-SVAL and defaults to 16

ISTREAM ==>                                     #Input stream. Actually called Readable
                                                #Is an ASYNC_ITERABLE
new STREAM.Readable([OBJ])                      #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. uses BUFFER)
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM:
                                                #     - buffer size (def: 16KB)
                                                #     - on ISTREAM: data available for read but not read yet
                                                #     - on OSTREAM: data not flushed yet
                                                #     - if buffer full, waits
ISTREAM.on("readable", FUNC())                  #New chunks available, or just before "end"
ISTREAM.on("data", FUNC(SVAL))                  #Each new chunk available. Firing FUNC() consumes that chunk.
                                                #Not fired if ISTREAM is empty
ISTREAM.read([UINT])->SVAL                      #Like on("data") but:
                                                #  - sync: waits until chunk available (i.e. prefer on("data"))
                                                #  - specify (max) chunk size UINT (def: all)
                                                #  - SVAL is null if ISTREAM empty
ISTREAM.on("end", FUNC())                       #When all chunks have been read
ISTREAM.on("close", FUNC())                     #When underlying fd is closed (not all ISTREAM close)
ISTREAM.on("error", FUNC(ERROR))                #
ISTREAM.pause|resume()                          #Makes it stop|resume emit "data" events.
ISTREAM.isPaused()                              #
ISTREAM.readable                                #BOOL
ISTREAM.readableEncoding                     12*#'ENCODING'
ISTREAM.setEncoding('ENCODING')                 #
ISTREAM.readableObjectMode                   12*#BOOL
ISTREAM.readableHighWaterMark                   #NUM
ISTREAM.readableLength                          #NUM. Number of bytes not read yet
ISTREAM.readableFlowing                         #Can be:
                                                #  - null: when all data has been consumed, or stream has not started been read yet
                                                #  - true: when stream is being read, i.e. after on('data')
                                                #  - false: when stream is being paused, i.e. after pause()
ISTREAM.readableEnded                        12*#BOOL. Whether 'end' event was fired.
ISTREAM.pipe(OSTREAM[, { end: BOOL }])->OSTREAM #Same as ISTREAM.on("data", sval => OSTREAM.write(SVAL))
                                                #If BOOL true (def), call OSTREAM.end() on ISTREAM.on('end|error') (except on stdout|stderr)
ISTREAM.unpipe([OSTREAM])                       #Stops pipe() (def: all)
ISTREAM.unshift(SVAL[, 'ENCODING'])             #Put last SVAL read back in ISTREAM
                                             12*#Can specify 'ENCODING'
ISTREAM.destroy([ERROR])                        #
ISTREAM.destroyed                               #BOOL

Readable.from(SVAL_ITERABLE[, OBJ])             #OBJ:
 ->ISTREAM                                      #  - same as new Readable(OBJ)
                                                #  - def objectMode is true

OSTREAM ==>                                     #Output stream. Actually called Writable
STREAM.Writable([OBJ])                          #Constructor for OSTREAM. OBJ members are:
                                                #  - decodeStrings BOOL: if true (def), decodes to BUFFER before
                                                #    calling underlying OSTREAM._write()
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM: see above
OSTREAM.write(SVAL[, 'ENCODING'[,FUNC()]])->BOOL#Writes chunks.
                                                #FUNC() is fired when buffered + flushed.
                                                #BOOL:
                                                #  - false if data cannot be buffered anymore (i.e. buffer is full)
                                                #  - i.e. should wait for OSTREAM.once('drain') before writing again
OSTREAM.end(SVAL[, 'ENCODING'[, FUNC()]])       #Same but for final chunk. FUNC is the finish event handler
 ->OSTREAM                                   14*#or error event handler
OSTREAM.destroy([ERROR])                        #
OSTREAM.destroyed                               #BOOL
OSTREAM.setDefaultEncoding('ENCODING')->OSTREAM #Def: 'utf-8'. Used by write() and end()
OSTREAM.writable                                #BOOL
OSTREAM.writableObjectMode                   12*#BOOL
OSTREAM.writableHighWaterMark                   #NUM
OSTREAM.writableLength                          #NUM. Number of bytes not flushed yet
OSTREAM.[un]cork()                              #cork() forces buffering to disk, uncork() flushes
                                                #Can be called several times, in which case uncork() must be done several times.
                                                #To do when writing a lot of small I/O, to make them all flush at once.
OSTREAM.writableCorked                       12*#NUM of times to call uncork()
OSTREAM.on("close", FUNC())                     #Like ISTREAM
OSTREAM.on("finish", FUNC())                    #Fired when end() done
OSTREAM.writableEnded                        12*#BOOL. Whether end() was called
OSTREAM.writableFinished                     12*#BOOL. Whether 'finish' event was fired.
OSTREAM.on("[un]pipe", FUNC(ISTREAM))           #Fired by ISTREAM.[un]pipe()
OSTREAM.on("error", FUNC(ERROR))                #

finished(STREAM[, OPTS], FUNC([ERROR]))         #Call FUNC([ERROR]) when STREAM (which can also be EVENTEMITTER|REQ|RES) completes:
 ->FUNC2()                                      #  (success)
                                                #  - all: 'end', 'finish', 'close', destroy()
                                                #  - REQ|RES: 'complete', underlying stream 'finish'
                                                #  (ERROR)
                                                #  - all: 'error', premature 'close', destroy(ERROR)
                                                #  - REQ|RES: 'abort'
                                                #`this` inside FUNC is STREAM
                                                #FUNC2() undoes it.
                                                #OPTS:
                                                #  - readable|writable BOOL (def: guessed)
                                                #  - error BOOL (def: true): use 'error' event
END-OF-STREAM(...)                             ##Ponyfill for finished() (1.4.4)
ON-FINISHED(...)                               ##Similar but slightly different, i.e. not preferred (2.3.0)

pipeline(SRC[, TRANSFORM...], DEST,             #Like SRC.pipe(TRANSFORM)....pipe(DEST) except:
 FUNC(ERROR, SVAL))->OSTREAM                    #  - has a final FUNC() like finished()
                                                #  - if one STREAM errors then other STREAM are closed (with STREAM.close|abort|destroy())
                                                #Can use streams
                                             13*#or sync|async iterables:
                                                #  - SRC: ISTREAM or [ASYNC_]ITERABLE|ITERATOR
                                                #  - TRANSFORM: IOSTREAM or FUNC(ASYNC_ITERABLE)->ASYNC_ITERABLE
                                                #  - DEST: OSTREAM or FUNC(ASYNC_ITERABLE)->PROMISE_SVAL
                                                #Can use ARR of arguments [SRC, TRANSFORM..., DEST] instead of variadic arguments
PUMP(...)                                      ##Ponyfill for pipeline() (3.0.0) without iterable support


IOSTREAM ==>                                    #Implement both ISTREAM and OSTREAM. Actually called either:
                                                #  - STREAM.Duplex
                                                #  - STREAM.Transform:
                                                #     - same but where there is a correlation between input and output (ex: crypto, but not HTTP)
                                                #     - only semantic

INHERITING STREAMS ==>                          #To create STREAM child classes, just inherit them and reimplement functions
                                                #_read(), _write[v](), _transform() or _flush() (see online doc), without calling them directly.

process.stdin|stdout|stderr                     #Standard streams
                                                #Unless other STREAMs which are async, writes are sync|async depending on to what it is piped to:
                                                #  - a file -> sync
                                                #  - a terminal -> sync (Unix), async (Windows)
                                                #  - another process (pipe) or a socket -> async (Unix), sync (Windows)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TTY              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STREAM.isTTY
isatty(FD_INT)->BOOL                            #true|undefined if is READSTREAM|WRITESTREAM

ReadStream                                      #ISTREAM of a text terminal.
                                                #For process.stdin unless !isTTY
                                                #Child of TCPSOCKET, but without destroy(), connect event nor *address*
                                                #Will keep process alive until destroyed.
READSTREAM.isRaw                                #If false (def):
                                                #  - echoes input to output
                                                #  - buffer input until next newline (i.e. line-wise input instead of character-wise)
                                                #  - buffered input can be removed with Backspace|Delete
                                                #  - can quit with CTRL-D, CTRL-C, CTRL-Z
                                                #  - emit sounds (bell)
                                                #  - normalize any non-ASCII to ASCII (by removing MSB)
                                                #  - '\r\n' -> '\n'
                                                #In either case:
                                                #  - use replace mode (not insert mode)
                                                #  - no Emacs keybindings (CTRL-A, etc.)
                                                #  - can move cursor (Left|Right|Home|End)
READSTREAM.setRawMode(BOOL)                     #
READSTREAM.bytesRead                            #So far (including newlines)

WriteStream                                     #Same as READSTREAM but for OSTREAM of a text terminal
                                                #For process.stdout|stderr unless !isTTY
WRITESTREAM.columns|rows                        #UINT. Automatically updated.
WRITESTREAM.on("resize", FUNC())                #

WRITESTREAM.getColorDepth([process.env])->NUM   #Number of bits per channel: 1|4|8|24
                                                #Used by console.*() and REPL
                                                #Based on heuristic on process.env and os.release():
                                                #  - Linux:
                                                #     - ENVVAR TERM 'dumb': 1 bit
                                                #     - ENVVAR TMUX, ENVVAR TERM 'eterm|cons25|console|cygwin|dtterm|gnome|
                                                #       hurd|jfbterm|konsole|kterm|mlterm|mosh|putty|st' or contains
                                                #       'ansi|color|linux|con|rxvt|screen|term|vt100', ENVVAR COLORTERM: 4 bits
                                                #     - ENVVAR TERM 'xterm-256*': 8 bits
                                                #     - ENVVAR TERM 'terminator|rxvt-unicode-24bit',
                                                #       ENVVAR COLORTERM 'truecolor|24bit': 24 bits
                                                #  - Mac (base on ENVVAR 'TERM_PROGRAM'):
                                                #     - 'Apple_Terminal', old 'iTerm.app': 4 bits
                                                #     - 'HyperTerm', 'MacTerm', new 'iTerm.app': 24 bits
                                                #  - Windows:
                                                #     - <10: 4 bits
                                                #     - 10 before build 14931: 8 bits
                                                #     - after: 24 bits
                                                #  - CI:
                                                #     - Travis/CircleCI/AppVeyor/GitLab/Codeship: 8 bits
                                                #     - others: 1 bit
                                                #  - Teamcity:
                                                #     - old versions: 1 bit
                                                #     - new versions: 4 bits
                                                #  - otherwise: 1 bit
ENVVAR FORCE_COLOR=0|1|2|3                   11*#Force getColorDepth() to assume color support for 1|4|8|24 bits per channel
ENVVAR NO_COLOR=1                            11*#Same as FORCE_COLOR=0
ENVVAR NODE_DISABLE_COLORS=1                 11*#Same as FORCE_COLOR=0 but also change REPL (prefer NO_COLOR)
WRITESTREAM.hasColors([NUM][, process.env])     #Returns true if 2 ** getColorDepth([process.env]) >= NUM
 ->BOOL                                         #I.e. NUM should be 2 (2**1), 16 (2**4) (def), 256 (2**8) or 16 million (2**24)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           READLINE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INTERFACE                                       #Interactive TTY

createInterface(OPTS)->INTERFACE                #OPTS:
                                                #  - input ISTREAM
                                                #  - output OSTREAM
                                                #  - terminal BOOL (def: OSTREAM.isTTY):
                                                #     - do not use raw mode
                                                #     - handle sequences:
                                                #        - removing chars (Backspace|Delete|CTRL-H|D|U|K|W)
                                                #        - exiting (CTRL-C|D|Z)
                                                #        - moving cursor (Left|Right|Home|End|CTRL-A|E|B|F)
                                                #        - clear screen (CTRL-L)
                                                #     - use tab completion
                                                #     - use history
                                                #        - including history navigation (Up|Down|CTRL-N|P)
                                                #     - use emitKeypressEvents()
                                                #  - completer(STR[, FUNC(ERROR, ARR)])[->ARR]:
                                                #     - used to tab completion
                                                #     - ARR: [STR2_ARR, STR]
                                                #        - STR is original string
                                                #        - STR2_ARR are possible matches.
                                                #           - if have common prefix, autocompletes
                                                #  - historySize NUM (def: 30) (0 for none): in-memory, not persisted
                                                #  - removeHistoryDuplicates BOOL (def: false): new history lines that are duplicate
                                                #    of a previous one removes that older one
                                                #  - prompt STR (def: '> ')
                                                #  - crlfDelay NUM (def: 100, cannot be lower): if input reads \r and \n
                                                #    successively but more than NUMms apart, treat them as two newlines, not one
                                                #  - escapeCodeTimeout NUM (def: 500) (in ms): how long to wait when starting an ESC sequence
                                             12*#  - tabSize NUM (def: 8)
INTERFACE.close()                               #Called by ISTREAM.end() and CTRL-C|D|Z
INTERFACE.on("close", FUNC())                   #

INTERFACE.on("line", FUNC(STR))                 #Fired each time a line is read from ISTREAM.
INTERFACE[Symbol.asyncIterator]                 #Defined
INTERFACE.line                                  #STR input in the current line. Flushed after each newline/'line' event
INTERFACE.cursor                                #Cursor horizontal position within current line
INTERFACE.getCursorPos()->OBJ                12*#Current cursor position in the screen. Takes into account wrapping.
                                             12*#OBJ: rows NUM, cols NUM

INTERFACE.write(STR[, OBJ])                     #Prints STR on OSTREAM
                                                #Use CTRL|META|SHIFT-STR if OBJ: ctrl|meta|shift: true, name: STR
                                                #Be careful as it will be read by ISTREAM, if ISTREAM and OSTREAM point to same thing (e.g. terminal).
                                                #  - like process.stdout.write(), but as opposed to console.*()

INTERFACE.setPrompt(STR)                        #Change OPTS.prompt (see above)
INTERFACE.prompt([BOOL])                        #Write in beginning of current OSTREAM line the OPTS.prompt
                                                #If false (def), move cursor back to beginning of line

INTERFACE.question(STR, FUNC(STR2))             #Replace current prompt by STR on OSTREAM, and fires FUNC(STR2) on line event instead of normal line event.

INTERFACE.pause|resume()                        #Like ISTREAM.pause|resume()
                                                #ISTREAM still accept input but buffers it, and reads it once resumed.
                                                #pause() is called by SIGCONT or SIGTSTP (CTRL-Z)
                                                #resume() is called by write(), prompt() and question()
INTERFACE.on("pause|resume", FUNC())            #
INTERFACE.on("SIGINT|SIGTSTP|SIGCONT", FUNC())  #

clearLine(OSTREAM, NUM[, FUNC()])->BOOL         #Can be 0 (entire line, \e2k) or -1|1 (to the left|right of cursor, \e0k, \e1k)
                                                #FUNC|BOOL are from the underlying OSTREAM.write()
cursorTo(OSTREAM, NUM, NUM2[,FUNC()])->BOOL     #Move cursor absolutely (\eNUMa, \eNUMb)
moveCursor(OSTREAM, NUM[, NUM2][,FUNC()])->BOOL #Move cursor relatively (\eNUM2c, \eNUM2d)
clearScreenDown(OSTREAM[, FUNC()])->BOOL        #Clear all following lines (\e0j). To clear screen, combine with cursorTo(OSTREAM, 0, 0)

emitKeypressEvents(OSTREAM[, INTERFACE])        #Enable OSTREAM.on('keypress')
                                                #If OSTREAM (e.g. process.stdin) is connected to an INTERFACE, can specify it to disable completion on copy-pasted input
OSTREAM.on('keypress', FUNC(STR, OBJ))          #STR is what to print (e.g. 'a', undefined or '') (for a, LeftArrow and CTRL-C)
                                                #OBJ:
                                                #  - sequence STR (e.g. 'a', '\u001b[d' or '\u0003')
                                                #  - name STR (e.g. 'a', 'left' or 'c')
                                                #  - shift|ctrl|meta BOOL
                                                #Can use ESC sequences
                                                #As opposed to 'data', it is for each character, not for bulk:
                                                #  - e.g. when copy-pasting, 'data' will be emitted once but 'keypress' once per character


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             REPL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


REPLSERVER                                      #Child of INTERFACE, meant for read-eval-print loop.

start([OPTS])->REPLSERVER                       #Forwards to INTERFACE:
                                                #  - forwards OPTS.input|output|prompt|historySize|terminal|completer
                                                #  - def OPTS.input|output is process.stdin|stdout
                                                #  - def OPTS.completer is JavaScript autocompletion
                                                #OPTS:
                                                #  - eval(STR, CONTEXT, FILENAME, FUNC(ERROR, VAL)):
                                                #     - input handler:
                                                #        - STR is input (including final newline)
                                                #        - VAL is passed to OPTS.writer()
                                                #        - FILENAME is 'repl' if default REPL
                                                #        - if ERROR is new Recoverable(''), keep prompt ongoing (e.g. for multiline input)
                                                #           - current input is added to next input
                                                #     - def:
                                                #        - VM.createScript(STR, {filename: FILENAME, displayErrors: true})
                                                #        - then SCRIPT.runInContext(REPLSERVER.context, {breakOnSigint: OPTS.breakEvalOnSigint, displayErrors: true})
                                                #  - writer(VAL)->STR:
                                                #     - serialization
                                                #     - def: util.inspect() using util.inspect.defaultOptions except:
                                                #        - showProxy true
                                                #        - colors OPTS.useColors (def: process.stdout.hasColors())
                                                #  - ignoreUndefined BOOL (def: false): if true, doesn't print output when it is undefined
                                                #  - useGlobal BOOL (def: false): see below
                                                #  - replMode either:
                                                #     - REPL_MODE_STRICT: "use strict"
                                                #     - REPL_MODE_SLOPPY (def): inverse
                                                #  - breakEvalOnSigint BOOL: if true (def: false), stops on CTRL-C
                                             12*#  - preview BOOL (def: true): show autocomplete and output preview
REPLSERVER.on("exit", FUNC())                   #
REPLSERVER.on("reset", FUNC())                  #When ".clear" or resetContext() is called.

REPLSERVER.context                              #Global CONTEXT object
                                                #If OPTS.useGlobal false (def):
                                                #  - is a new CONTEXT (using VM.createContext())
                                                #  - contains all core modules, e.g. GLOBAL.child_process
                                                #Also contains the following:
_                                               #Last expression evaluated
_error                                          #Last uncaught exception

REPL COMMANDS ==>                               #
.exit
CTRL-D                                          #
.break
CTRL-C                                          #
.editor                                         #Start multiline session
REPLSERVER.resetContext()
.clear                                          #Reinitialize REPLSERVER.context
.help                                           #
REPLSERVER.defineCommand                        #Custom .COMMAND [...ARGS]
 ('COMMAND', OBJ|FUNC(...ARGS))                 #OBJ:
                                                #  - action(...ARGS)
                                                #  - help STR
REPLSERVER.displayPrompt([BOOL])                #Like INTERFACE.prompt(BOOL) except if there is currently some input, use '...' prompt instead
                                                #Meant to be used inside defineCommand() OBJ.action()
REPLSERVER.clearBufferedCommand()               #Discard|ignore the line currently entered
                                                #Meant to be used inside defineCommand() OBJ.action()

REPLSERVER.setupHistory                      11*#Must be called to use history.
 ('PATH', FUNC(ERROR, REPLSERVER))           12*#Can search for history using CTRL-R
.save FILE                                      #Save all input so far to FILE
.load FILE                                      #Input FILE

--experimental-repl-await                       #Allow using await top-level in REPL

DEFAULT REPL ==>                                #Uses REPL except:
                                                #  - calls REPLSERVER.setupHistory('PATH')
                                                #     - using ENVVAR NODE_REPL_HISTORY (def: ~/.node_repl_history)
                                                #  - OPTS.terminal can be set with ENVVAR NODE_NO_READLINE=1
                                                #  - OPTS.replMode can be set with ENVVAR NODE_REPL_MODE 'sloppy|strict'
                                                #  - OPTS.historySize can be set with ENVVAR NODE_REPL_HISTORY_SIZE (def: 1000)
                                                #  - OPTS.breakEvalOnSigint true
                                                #  - can override defaults util.inspect() options (for OPTS.writer()) with util.inspect.replDefaults

ENVVAR NODE_REPL_EXTERNAL_MODULE                #'PATH' to a file to execute instead of built-in REPL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DGRAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createSocket(STR|OPTS[, FUNC(BUFFER, OPTS)])    #OPTS:
 ->UDPSOCKET                                    #  - type "udp4|6"
                                                #  - reuseAddr BOOL (def: false): make UDPSOCKET.bind() reuse an address already bound
                                                #  - lookup FUNC (def: DNS.lookup)
                                                #  - recvBufferSize|sendBufferSize NUM: in|out buffer size
                                             11*#  - ipv6Only BOOL (def: false)
                                                #STR is OPTS.type
                                                #FUNC is 'message' event handler.
UDPSOCKET.address()                             #{ address, port, family }

UDPSOCKET.bind(OBJ[, FUNC()])                   #Start listening. OBJ:
UDPSOCKET.bind(PORT_NUM[, 'ADDR'][, FUNC()])    #  - port PORT_NUM
                                                #  - address 'ADDR' (def: all available)
                                                #FUNC() is 'listening' event handler
                                                #Program will block until UDPSOCKET.close() is called. Can also use UDPSOCKET.[un]ref()
UDPSOCKET.on("listening", FUNC())               #After bind()
UDPSOCKET.on("message", FUNC(BUFFER, OBJ))      #OBJ is like UDPSOCKET.address()
UDPSOCKET.close([FUNC()])                       #FUNC is close event handler
UDPSOCKET.on("close", FUNC())                   #
UDPSOCKET.on("error", FUNC(ERROR))              #

UDPSOCKET.connect(PORT_NUM[, 'ADDR'][, FUNC()]) #Connects to other port.
                                                #Def 'ADDR': '127.0.0.1' (udp4) or '::1' (udp6)
UDPSOCKET.disconnect()                          #
UDPSOCKET.on("connect", FUNC())                 #After connect()
UDPSOCKET.remoteAddress()->OBJ                  #OBJ: address, family, port (like TCPSERVER.address())

UDPSOCKET.send                                  #Sends to PORT_NUM, address 'ADDR'.
(SUBUFFER[_ARR][, UINT, UINT2],                 #Payload is first arg, from byte UINT, length UINT2
PORT_NUM, 'ADDR'[, FUNC(ERROR, UINT3)])         #If bind() has not been called, UDPSOCKET gets assigned a random port, and an adress "0.0.0.0"
                                                #When done, fires FUNC: UINT3 is the number of bytes sent.
                                                #Max. SUBUFFER size is the MTU, which must be found with PMTUD.
                                                #'ADDR' is optional
                                             14*#SUBUFFER can also be STDUBUFFER

UDPSOCKET.setRecv|SendBufferSize(NUM)           #
UDPSOCKET.getRecv|SendBufferSize()->NUM         #

UDPSOCKET.setBroadcast(BOOL)                    #
UDPSOCKET.setMulticastLoopback(BOOL)            #
UDPSOCKET.setMulticastInterface(STR)            #
UDPSOCKET.add|dropMembership(STR[, STR2])       #Routing options
UDPSOCKET.add|dropSourceSpecificMembership
 (STR3, STR[, STR2])                            #Same but specifies source STR3
UDPSOCKET.set[Multicast]TTL(UINT)               #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              NET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createServer([OBJ, ][FUNC(TCPSOCKET)])          #FUNC is 'connection' event handler
 ->TCPSERVER                                    #OBJ:
                                                #  - allowHalfOpen BOOL: see below
                                                #  - pauseOnConnect BOOL (def: false): if true, calls TCPSOCKET.pause()

TCPSERVER.listen                                #Makes the TCSERVER:
(PORT_NUM|'PORT'[, 'ADDR'][, UINT][, FUNC()])   #  - listen to PORT_NUM|'PORT':
                                                #     - if 0, random port
                                                #     - can fire 'error' event with ERROR.code "EADDRINUSE" if another process
                                                #       already uses this port.
                                                #  - listen to 'ADDR':
                                                #     - def: INADDR_ANY, i.e. any available IP on the machine will work
                                                #  - UINT:
                                                #     - max number of pending connections, i.e. TCP sent SYN packet, but not
                                                #       ACK yet.
                                                #     - refuse connection if above max.
                                                #     - def: 511 (which is pretty ok)
                                                #     - OS limits are determined by sysctl settings like tcp_max_backlog
                                                #       and somaxconn (which is 511 in my system)
                                                #  - FUNC is 'listening' event hander
                                                #Can only be called once.
TCPSERVER.listen('PATH'[, UINT][, FUNC()])      #Same but by explictely creating a socket at 'PATH' (should be in /tmp)
TCPSERVER.listen(OBJ[, UINT][, FUNC()])         #Same but for either:
                                                #  - { fd: UINT }: with file descriptor, not on Windows
                                                #  - TCPSERVER|TCPSOCKET
TCPSERVER.listen(OBJ[, FUNC()])                 #Same with OBJ:
                                                #  - port, host, path, backlog UINT
                                                #  - readableAll|writableAll BOOL (def: false): file permission for the socket
                                             11*#  - ipv6Only BOOL (def: false)
TCPSERVER.on("listening", FUNC())               #Fired when listen() is called.
TCPSERVER.listening                             #BOOL
TCPSERVER.close([FUNC()])                       #Stops the server from accepting new connections:
                                                #  - keeps existing ones
                                                #  - when existing ones have stopped, emits "close" event
                                                #FUNC is 'close' event listener
TCPSERVER.on("close", FUNC())                   #Fired on TCPSERVER.close()
TCPSERVER.address()->OBJ                        #Returns { port: UINT, address STR, family: "IPv4|6" }
                                                #After listen() has been called
TCPSERVER.[un]ref()->TCPSERVER                  #Yield the macrotask (see JavaScript doc)
                                                #listen() call ref(), and stop() or stop event handlers call unref()

TCPSERVER.on("connection", FUNC(TCPSOCKET))     #Fired when a TCP connection is initiated.
TCPSERVER.on("error", FUNC(ERROR))              #Fired when connection problem. Will fire TCPSERVER.close()
TCPSERVER.maxConnections                        #Def: null
                                                #0|null means no limits.
                                                #Above that, will refuse connections.
TCPSERVER.getConnections([FUNC(ERROR, UINT)])   #Number of connections


connect|createConnection(OPTS[, FUNC()])        #Same as new Socket(OPTS) followed by TCPSOCKET.connect(OPTS, FUNC)
  ->TCPSOCKET                                   #OPTS can also have:
                                                #  - timeout NUM: calls TCPSOCKET.setTimeout(NUM)
TCPSOCKET                                       #IOSTREAM but:
                                                #  - no readable event, read() or unshift() (but still data event)
                                                #  - nothing about piping
                                                #  - close event handler: FUNC(BOOL): true if close because of error
                                                #  - error event handler: FUNC(ERROR)
new Socket([OBJ])                               #OBJ:
                                                #  - fd: UINT
                                                #  - readable|writable BOOL (def: false): only when fd was used
                                                #  - allowHalfOpen BOOL (def: false):
                                                #     - if true, when other socket closes connection, doesn't automatically
                                                #       call end()
                                                #     - which means:
                                                #        - can still write to it (but non-readable)
                                                #        - must manually call end()
TCPSOCKET.connect(ARGS[, FUNC()])               #ARGS:
                                                #  - OBJ:
                                                #     - port PORT_NUM|'PORT'
                                                #     - host 'ADDR'
                                                #     - localAddress|localPort
                                                #     - path 'PATH' (only for UNIX sockets, only option then)
                                             12*#     - onread OBJ:
                                             12*#        - callback(NUM, BUFFER)[->BOOL]:
                                             12*#           - called on new data
                                             12*#           - NUM is BUFFER length
                                             12*#           - can return false to pause
                                             12*#        - buffer BUFFER|UINT8ARR[()]: to store each data chunk
                                                #     (see DNS.lookup())
                                                #     - family 4|6|null
                                                #     - hints
                                                #     - lookup (def: DNS.lookup())
                                                #  - HOST[, PORT]
                                                #  - "PATH"
                                                #FUNC() is 'connect' event handler.
TCPSOCKET.pending                               #BOOL: true before connect() or before 'connect' event
TCPSOCKET.connecting                            #BOOL: true after connect() but before 'connect' event
TCPSOCKET.on                                    #Fired after hostname resoution, but before TCP connection.
("lookup", FUNC(ERROR, 'IP', VAL, 'HOST'))      #VAL is family 4|6|null
TCPSOCKET.on("connect", FUNC())                 #
TCPSOCKET.on("ready", FUNC())                   #
TCPSOCKET.destroy([ERROR])                      #No more read|write. Only necessary when error happened.
                                                #If ERROR, 'error' event is fired
TCPSOCKET.destroyed                             #BOOL
TCPSOCKET.[un]ref()->TCPSOCKET                  #Like TCPSERVER

TCPSOCKET.setTimeout(UINT[, FUNC()])->TCPSOCKET #Emits timeout event after UINTms of idleness.
                                                #Not emitted after TCPSOCKET is destroyed.
                                                #0 (def) disables.
                                                #By def, timeout handler does not do anything, but can end|destroy()
                                                #FUNC is 'timeout' event handler
                                                #Uses setTimeout(), i.e. done at macrotask level, i.e. might take longer than
                                                #UINTms if long macrotasks.
                                                #Error handling:
                                                #  - exceptions thrown in FUNC are uncaught exceptions.
                                                #  - TCPSOCKET.emit('error', ERROR) is usually better
TCPSOCKET.on('timeout', FUNC())                 #

TCPSOCKET.setKeepAlive(BOOL, UINT)->TCPSOCKET   #Def: false and 0.
                                                #TCP keepalive
TCPSOCKET.setNoDelay(BOOL)->TCPSOCKET           #If false (def), use buffers:
                                                #  - to reduce amount of requests i.e. send data in chunks
                                                #  - more efficient when using a lot of small requests, but can delay them
                                                #  - even disabled, underlying IOSTREAM still use buffer to keep up with
                                                #    high demand
TCPSOCKET.bytesRead|Written                     #So far

TCPSOCKET.address()->OBJ                        #Like TCPSERVER
TCPSOCKET.local|remotePort|Address              #
TCPSOCKET.remoteFamily                          #'IPv4|6'
isIp('ADDR')->0|4|6                             #
isIpv4|6('ADDR')->BOOL                          #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TLS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getCiphers()->STR_ARR                           #All suite of SSL ciphers are [PREFIX-]ALGO[-HASH]
                                                #ALGO: AES128|256, 3DES, DES, Camellia128|256, IDEA, RC4, SEED
                                                #PREFIX:
                                                #  - ECDH[E]-ECDSA|RSA: for AES, DES, RC4
                                                #  - DH[E]-DSS|RSA: for AES, Camellia, SEED
                                                #  - EDH-DSS|RSA: for DES
                                                #  - PSK: for AES, 3DES, RC4
                                                #  - SRP-[DSS|RSA]: for AES, 3DES
                                                #HASH ([-]#ALGO means ALGO with[out] PREFIX SPK|SRP):
                                                #  - sha: -#AES*, Camellia*, RC4, SEED
                                                #  - gcm-sha256: -#AES128
                                                #  - gcm-sha384: -#AES256
                                                #  - sha256: -#AES*
                                                #  - cbc3-sha: -#DES
                                                #  - cbc-sha: IDEA, #AES
                                                #  - md5: RC4 (unless any PREFIX)
                                                #  - ede-cbc-sha: #DES
                                                #Can be changed with node --tls-cipher-list=LIST
TLSSOCKET.getSharedSigalgs()->STR_ARR        12*#Returns SSL ciphers for signatures shared by client and server, ordered by preference
TLSSOCKET.getEphemeralKeyInfo()->OBJ            #Gets information about cipher's (only [EC]DH) use of perfect forward secrecy:
                                                #  - type '[EC]DH'
                                                #  - name STR
                                                #  - size NUM

TLS.createSecureContext(OBJ)->SECURECONTEXT     #OBJ:
                                                #  - key STR[_ARR]|BUFFER|OBJ_ARR:
                                                #     - server private key, in PEM format
                                                #     - OBJ is { pem STR|BUFFER, passphrase STR }
                                                #        - passphrase is optional
                                                #  - cert STR[_ARR]|BUFFER[_ARR]: server certificate, in PEM format
                                                #  - pfx STR[_ARR]|BUFFER[_ARR]|OBJ_ARR:
                                                #     - key+cert+ca in PFX or PKCS12 format
                                                #     - OBJ is { buf STR|BUFFER[, passphrase STR] }
                                                #  - ca STR[_ARR]|BUFFER[_ARR]:
                                                #     - list of root certificates, in PEM format
                                                #     - def: TLS.rootCertificates
                                                #     - otherwise, can be used to authorize self-signed certificates
                                                #  - passphrase STR: passphrase used to decrypt the server private key (when a private key is encrypted)
                                                #  - crl STR[_ARR]: CRLs, in PEM format
                                                #  - secureProtocol STR:
                                                #     - "SSLv2|3|TLSv1_[client|server_]method": forces SSL version for client and|or server
                                                #        - no client|server means both
                                                #     - def: uses the best one accepted by client
                                                #  - honorCipherOrder BOOL:
                                                #     - if true, server will choose cipher preference, not client
                                                #     - list is designated by ciphers STR
                                                #     - def: false, but true recommended
                                                #  - ciphers STR:
                                                #     - defaults to "*AES*:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
                                                #     - AES are in order: 128 > 256, SHA384 > SHA256, ECDHE > DHE, RSA > ECDSA
                                             12*#  - sigalgs 'STR:...': same for signature algorithms
                                                #  - sessionTimeout (def: 300, in sec): expiration for TLS identifiers and session tickets
                                                #  - ticketKeys BUFFER: 48 bytes divided in three 16 bytes parts: prefix, HMAC, AES key
                                                #     - can use TLSSERVER.getTicketKeys()->BUFFER and TLSSERVER.setTicketKeys(BUFFER)
                                                #  - sessionIdContext STR:
                                                #     - STR concatened in front of SSL session ID.
                                                #     - if requestCert is true, it is a MD5 nonce. Otherwise, it is "".
                                                #  - ecdhCurve STR (def: "auto"): for ECDH
                                                #  - dhparam STR|BUFFER: for DH
                                                #  - clientCertEngine STR: OpenSSL engine
                                                #  - secureOptions { CRYPTO.SSL_OP_*: VAL }: OpenSSL options
                                                #  - min|maxVersion 'TLSv1[.1|2|3]'
                                                #     - def: TLS.DEFAULT_MIN|MAX_VERSION (def: 'TLSv1.2|3')
                                        10.20.0*#     - can be set with --tls-min|max-v1.0|1|2|3
                                             11*#     - TLSv1.3 only for Node >=11
                                             12*#  - enableTrace BOOL (def: false): print TLS packets to stderr, for debuggin
                                             12*#  - hints NUM: like DNS.lookup()
                                             12*#  - privateKeyIdentifier STR: instead of OPTS.key, use a private key within OpenSSL engine
                                             12*#  - privateKeyEngine STR: OpenSSL engine usedwith privateKeyIdentifier
TLS.rootCertificates                         12*#STR_ARR. Default well-known root CAs
                                             12*#Are known builtin, either:
                                             12*#  - node --use-bundled-ca (def): Mozilla CA store
                                             12*#  - node --use-openssl-ca:
                                             12*#     - OpensSSL CA store, modified by distributions, can be modified by ENVVARs
                                             12*#     - can use ENVVAR SSL_CERT_DIR=DIR and SSL_CERT_FILE=FILE
                                             12*#Can also be augmented with ENVVAR NODE_EXTRA_CA_CERTS=FILE

TLSSERVER                                       #Child of TCPSERVER:
                                                #  - since it inherits from TCPSERVER, can accept TCP connections, not only SSL ones.
                                                #  - all TLSSERVER will fire for both SSL and normal TCP connections.
                                                #Authorization:
                                                #  - if rejectUnauthorized is true:
                                                #     - non-authorized SSL are still accepted (and communication is encrypted)
                                                #     - but can be checked as non-authorized
                                                #  - certificate check will follow CA chain until CA roots:
                                                #  - authorization also checks the domain in certificate === host being connected
createServer(OBJ[, FUNC(TLSSOCKET)])->TLSSERVER #OBJ:
                                                #  - any SECURECONTEXT.* property
                                             12*#  - any NET.createServer() options
                                                #  - requestCert BOOL (def: false): request authentication (with certificate) of other end (i.e. client)
                                                #  - rejectUnauthorized BOOL (def: true): throw error to other end if cannot authentify it
                                                #  - handshakeTimeout (def: 120000, in ms): when timing out, emits tlsClientError
                                                #  - ALPNProtocols SUBUFFER[_ARR]: list of application protocols that can be used, ordered by priority.
                                                #  - SNICallback('HOST', FUNC(ERROR, OBJ)):
                                                #     - when client asks for SNI, calls it with requested server 'HOST'
                                                #        - if success, must call FUNC(null, OBJ2), where OBJ2 is TLSSOCKET.secureContext
                                                #     - can also use TLSSERVER.addContext('HOST', SECURECONTEXT)
                                                #FUNC is 'secureConnection' event handler
TLSSERVER.setSecureContext(OBJ)              11*#OBJ: any SECURECONTEXT.* property
TLSSERVER.on("secureConnection",FUNC(TLSSOCKET))#Like TCPSERVER.on("connection"), but for SSL.
                                                #Only fired by SSL connections, not normal TCP ones.
TLSSERVER.on
("tlsClientError", FUNC(ERROR, TLSSOCKET))      #See handshakeTimeout
TLSSERVER.on("newSession",FUNC(ID,DATA,FUNC2()))#Fired when client creates new session: ID is the session ID, DATA the shared secret.
                                                #Must fire FUNC2 when done
TLSSERVER.on("resumeSession",                   #Fired when client wants to resume a session. Must call FUNC2() to do so:
FUNC(ID, FUNC2(ERROR, DATA)))                   #  - DATA is the one stored with newSession event
                                                #  - if no new session, ERROR|DATA should be null

connect([PORT_NUM[,'HOST']]OBJ[,FUNC(TLSSOCKT)])#Like TCP.connect(), but for TLS (client connection). OBJ members are:
  ->TLSSOCKET                                   #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - rejectUnauthorized, ALPNProtocols: like createServer()
                                                #     - except rejectUnauthorized is true by def.
                                                #  - session: like new TLSSocket()
                                                #  - timeout: like TCP.connect() OPTS.timeout
                                                #  - host 'HOST', port PORT_NUM, path 'PATH'
                                                #  - socket TCPSOCKET|IOSTREAM: use an existing TCPSOCKET (host+port can be ommitted then)
                                                #  - servername: for SNI, hostname to choose
                                                #  - checkServerIdentity('HOST', CERT_BUFFER): if throw error, refuse connection
                                                #  - minDHSize NUM (def: 1024)
                                                #  - lookup FUNC: DNS lookup, def: DNS.lookup()
                                             12*#  - allowHalfOpen: like NET.createServer()
                                             12*#  - pskCallback('HINT')->{ psk TDBUFFER, identity STR }|null
                                             12*#  - highWaterMark NUM
                                                #FUNC is 'secureConnect' event handler
                                                #Returns a TLSSOCKET.

TLSSOCKET                                       #Child of TCPSOCKET, but for SSL.
                                                #Contains other end's authentication status and certificate, providing requestCert: true has been used.
new TLSSocket(TCPSOCKET, OBJ)                   #OBJ:
                                                #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - requestCert, rejectUnauthorized, ALPNProtocols, SNICallback: like createServer()
                                                #  - session BUFFER
                                                #  - requestOCSP BOOL (def: false):
                                                #     - OCSP is alternative protocol to use CRL
                                                #        - ask to Certificate authority instead of using CRL list
                                                #     - TLSSERVER.on('OCSPRequest', FUNC(BUFFER, BUFFER2, FUNC(ERROR, BUFFER3))):
                                                #        - BUFFER[2] are primary|issuer DER-encoded certificates
                                                #        - BUFFER3: see just below
                                                #     - TLSSOCKET.on('OCSPResponse', FUNC(BUFFER3))
                                                #  - isServer BOOL
                                                #  - server TCPSERVER
TLSSOCKET.on("secureConnect", FUNC())           #Like TCPSOCKET.on("connect"), but for SSL.
TLSSOCKET.on('session', FUNC(BUFFER))           #On new TLS session|ticket.
                                                #Same BUFFER as connect() and new TLSSocket() OPTS.session
TLSSOCKET.getPeerCertificate([BOOL])->OBJ       #Returns other end's certificate.
                                                #OBJ: subject, issuer, valid_from|to, fingerprint[256], pubkey, etc.
                                                #If true, returns full chain, i.e. OBJ.issuer
TLSSOCKET.getCertificate()->OBJ                 #Same but for current end.
TLSSOCKET.encrypted                             #Always true. To distinguish from TCPSOCKET.
TLSSOCKET.authorized                            #False if certificate was not signed by CA specified in ca: STR_ARR
                                                #If false, reason might be given in TLSSOCKET.authorizationError STR
TLSSOCKET.getCipher()->OBJ                      #Current SSL cipher used as OBJ:
                                                #  - name STR (e.g. 'AES128-SHA256')
                                             12*#  - standardName STR: IETF name (e.g. 'TLS_RSA_WITH_AES_128_CBC_SHA256')
                                                #  - version STR (e.g. 'TLSv1.2')
TLSSOCKET.getProtocol()->STR                    #Among 'SSLv3|TLSv1[.1|2]|unknown'
TLSSOCKET.alpnProtocol                          #Protocol selected among ALPNProtocols (see above)
TLSSOCKET.servername                            #For SNI, chosen 'HOST'
TLSSOCKET.renegotiate(OBJ[, FUNC(ERROR)])       #OBJ: rejectUnauthorized, requestCert
                                                #Automatically done after session expires:
                                                #  - TLS.CLIENT_RENEG_LIMIT (def: 3) times every TLS.CLIENT_RENEG_WINDOW (def: 600, in sec),
                                                #to avoid DDoS as it takes resources
TLSSOCKET.disableRenegotiation()                #
TLSSOCKET.setMaxSendFragment(NUM)->BOOL         #Def|max: 16384. Min: 512.
                                                #True on success.
                                                #Smaller: smaller latency but slower.
TLSSOCKET.getSession()->OBJ                     #OBJ: ASN.1 encoded
TLSSOCKET.getTLSTicket()->BUFFER                #
TLSSOCKET.get[Peer]Finished()->BUFFER           #Returns the "Finished" message, i.e. a hash of the handshake
TLSSOCKET.exportKeyingMaterial
 (NUM, STR[, BUFFER])->BUFFER2               12*#Returns keying material, used to prevent some network attacks

--trace-tls                                  12*#
TLSSOCKET.enableTrace()                      12*#Same as SECURECONTEXT.enableTrace

TLSSERVER.on
 ('keylog', FUNC(BUFFER, TLSSOCKET))    10.20.0*#TLS key in NSS SSLKEYLOGFILE format. Usually used with Wireshark to decrypt SSL traffic.
TLSSOCKER.on('keylog', FUNC(BUFFER))    10.20.0*#Can be emitted multiple times: concatenation of BUFFER is the whole file.
--tls-keylog=FILE                       10.20.0*#Same but written to a file


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTP              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STATUS_CODES                                    #{ STATUS_NUM: 'STATUS_NAME', ... }
                                                #Misses 419
METHODS                                         #STR_ARR of HTTP methods, including common ones, WEBDEV and more obscure ones

HTTPSERVER                                      #Child of TCPSERVER
createServer([OPTS, ][FUNC()])->HTTPSERVER      #FUNC is 'request' event handler
                                                #OPTS:
                                                #  - IncomingMessage|ServerResponse FUNC: to replace constructors of REQ|RES
                                             12*#  - maxHeaderSize NUM: see --max-http-header-size
HTTPSERVER.on("request", FUNC(REQ, RES))        #Fired on client request
HTTPSERVER.on("checkContinue", FUNC(REQ, RES))  #Fired on client request with Expect: 100-continue [C]
                                                #If request is ok, should use RES.writeContinue() to sends a 100 status code
                                                #to the client.
HTTPSERVER.on                                   #Fired on client request with CONNECT method
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on                                   #Fired on client request with Upgrade [C]
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on("clientError",FUNC(ERR,TCPSOCKET))#Fired on connection problem.
                                                #Def: TCPSOCKET.destroy()
                                                #ERR has members:
                                                #  - bytesParsed NUM
                                                #  - rawPacket BUFFER

HTTPSERVER|REQ.maxHeadersCount                  #Maximum number of headers incoming (def: 2000, 0 for unlim)
HTTPSERVER.maxHeaderSize
--max-http-header-size NUM                      #Def: 16KB. If above, fires 'clientError'.
                                            <12*#Def: 8KB
                                             12*#If no 'clientError' handler, returns 431.

RES|CLIENTREQ.setTimeout(UINT[, FUNC()])        #Call underlying TCPSOCKET.*
RES|CLIENTREQ.on("timeout", FUNC())             #Unless 'timeout' event handler overriden, calls RES|CLIENTREQ.socket.destroy()
HTTPSERVER.setTimeout(UINT[, FUNC()])           #Calls RES.setTimeout(...) on each new RES
HTTPSERVER.timeout                              #Same
--http-server-default-timeout NUM            12*#Default value of HTTPSERVER.setTimeout|timeout
                                             12*#Def: 0, i.e. disabled
HTTPSERVER.on("timeout", FUNC(RES))             #Called when any RES 'timeout' event is fired
HTTPSERVER.headersTimeout                    11*#Like HTTPSERVER.timeout but for the time taken to receive HTTP headers.
                                             12*#Def: 6e4, i.e. one minute
                                             11*#  - used to be 4e4, i.e. 40 secs
HTTPSERVER.requestTimeout               14.11.0*#Like HTTPSERVER.timeout but for the time taken to receive HTTP headers + body.
                                        14.11.0*#If over, sends 408
                                        14.11.0*#Def: 0

HTTPSERVER.keepAliveTimeout                     #Keep TCPSOCKET NUMms (def: 5000) after RES.end() was called, so it can be
                                                #reused if a new request from same host arrives.
                                                #0 to disable.
                                                #It is different from REQ|CLIENTREQ|HTTPSERVER.timeout:
                                                #  - HTTPSERVER.timeout is for idleness while request is ongoing
                                                #  - HTTPSERVER.keepAliveTimeout is for idleness between requests
                                                #Is not Keep-Alive: timeout=NUM [S] but behaves like if Keep-Alive: timeout=NUM [C]
                                                #was specified (although that header does not exist).
                                                #As long as TCPSOCKET is opened, TCPSOCKET.unref() won't be called, keeping the
                                                #server open.

CLIENTREQ.NoDelay|SocketKeepAlive(...)          #Call underlying TCPSOCKET.*

REQ                                             #ISTREAM, reading the body
REQ.httpVersion[Major|Minor]                    #
REQ.method                                      #"GET|DELETE|..." (not for CLIENTREQ's REQ)
REQ.url                                         #STR (not for CLIENTREQ's REQ). Does not include origin
REQ.host                                     14*#STR
REQ.protocol                                 14*#STR
REQ.headers                                     #As { VAR: 'VAL'[_ARR] ... }. Normalized:
                                                #  - 'VAR' lowercase
                                                #  - duplicates:
                                                #     - common ones are merged as 'VAL'
                                                #     - Set-Cookie: 'VAL'_ARR
                                                #     - others are joined with ','
REQ.rawHeaders                                  #As [ 'VAR', 'VAL', ... ]. Not normalized
REQ.[raw]trailers                               #Same for trailer headers
REQ.statusCode|Message                          #Only for CLIENTREQ's REQ
REQ.socket                                      #TCPSOCKET
REQ.flushHeaders()                              #Send the headers right away, instead of trying to send in same TCP packet as body.
                                                #Useful if headers are given quickly but body retrieval takes time.
REQ.destroyed                                   #BOOL
REQ.reusedSocket                             12*#BOOL. Whether underlying TCP has been used by another REQ before.
                                             12*#This can happen when using an AGENT with a high keepAliveMsecs.

RES                                             #OSTREAM, writing the body:
                                                #  - headers must be set first
                                                #  - write() sends to client
                                                #  - end() finishes
                                                #Automatically create following headers:
                                                #  - Date [S] (if RES.sendDate true (def))
                                                #  - Connection: keep-alive [S]
                                                #  - Transfer-Encoding: chunked [S]
RES.on("close", FUNC())                         #Fired if closed before end() was called
RES.headersSent                                 #True if headers are sent
RES.writableEnded                            12*#Same
RES.writableFinished                         12*#True if all sent + flushed
RES.statusCode|Message                          #If statusMessage not set, use STATUS_CODES[statusCode]
RES.setHeader('VAR', 'VAL'[_ARR])               #'VAL'_ARR: same as doing setHeader() several times.
RES.getHeader('VAR')->'VAL'[_ARR]               #
RES.getHeaderNames()->'VAR'_ARR                 #
RES.getHeaders()->OBJ                           #
RES.hasHeader('VAR')->BOOL                      #
RES.removeHeader('VAR')                         #
RES.writeHead(STATUS_NUM[, 'STATUS_NAME'][,OBJ])#Sets RES.statusCode|Message|headers (must be done only once)
                                             11*#Returns RES
RES.addTrailers(OBJ)                            #Add trailing header fields, i.e. between write() and end() of the body.
                                                #Do not forget Trailer [C] at beginning of response
RES.writeProcessing()                           #Send 102 response

ON-HEADERS(RES, FUNC())                        ##Fires FUNC() (with RES as this) just before RES starts sending headers
                                               ##Node module 'on-headers' (1.0.1)

CLIENTREQ                                       #Outgoing HTTP request (as opposed to incoming)
                                                #OSTREAM (like RES)
                                                #Headers:
                                                #  - Content-length [C]: only compatible with utf8 encoding for write()
                                                #  - Expect: 100-continue [C]:
                                                #     - call end() right away
                                                #     - should set a timeout
                                                #     - and listen to 'continue' event
                                                #  - default:
                                                #     - all:
                                                #         Host: HOST:PORT [C]
                                                #         Connection: keep-alive [C]
                                                #     - not GET|HEAD:
                                                #         Transfer-Encoding: chunked [C]
request(['URI'|URI][, OBJ][, FUNC(REQ)])        #Sends a HTTP request.
 ->CLIENTREQ                                    #Can use URI
                                                #Can use both first arguments, instead of OBJ.url
                                                #OBJ:
                                                #  - url 'URL'
                                                #  - protocol STR (def: 'http:')
                                                #  - host[name] STR (def: "localhost")
                                                #     - prefer hostname
                                                #     - will fire exception if non existing
                                                #  - family 4|6 (def: both)
                                                #  - port PORT_NUM (def: 80)
                                                #  - socketPath STR: incompatible with host[name] and port
                                                #  - localAddress STR
                                                #  - method STR (def: "GET")
                                                #  - path STR (def: "/"): including hash and query string
                                                #  - headers OBJ
                                                #  - auth STR: e.g. "auth:password"
                                                #  - agent AGENT|false (def: globalAgent)
                                                #  - keepAlive[Msecs]: see AGENT
                                                #  - createConnection(...): see AGENT
                                                #  - timeout NUM
                                                #  - lookup(...) (def: DNS.lookup(...))
                                             12*#  - maxHeaderSize NUM: see --max-http-header-size
                                             12*#  - highWaterMark NUM
                                                #FUNC is 'response' event handler.
get(['URI'|URI][, OBJ][, FUNC(REQ)])            #Same but use method "GET" and automatically calls OSTREAM.end()
CLIENTREQ.on("socket", FUNC(TCPSOCKET))         #Fired when socket is created to send the request.
CLIENTREQ.on("response", FUNC(REQ))             #Response of the server.
                                                #REQ must be read, no matter what.
CLIENTREQ.on("continue", FUNC())                #Fired when server responds with Expect: 100-continue [S]
CLIENTREQ.on("checkExpectation",FUNC(REQ, RES)) #Fired when server responds with Expect [S], except Expect: 100-continue [S]
CLIENTREQ.on("information", FUNC(OBJ))          #Fired when server responds with 1** (excluding 101)
                                                #OBJ:
                                                #  - statusCode STR
                                             12*#  - headers OBJ, rawHeaders ARR, httVersion STR, httpVersionMinor|Major NUM
CLIENTREQ.on
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds to a CONNECT request
CLIENTREQ.on
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds with Upgrade [S]
CLIENTREQ.destroy()                             #
CLIENTREQ.flushHeaders()                        #Send request headers right away, even if request body not ready for send yet

AGENT                                           #Socket pools manager for CLIENTREQ (not REQ|RES)
new AGENT(OBJ)                                  #OBJ is:
                                                #  - maxSockets NUM (def: Infinity):
                                                #     - max busy + free sockets per host.
                                                #     - increasing just affect pooling, i.e. more memory used but faster
                                                #     - but does not affect max. number of sockets per host (unlim.)
                                                #  - maxFreeSockets NUM (def: 256):
                                                #     - max free sockets.
                                                #     - only relevant if keepAlive true
                                                #  - keepAlive BOOL (def: true): keep free sockets opened for use
                                                #  - keepAliveMsecs NUM (def: 1000)
                                                #  - timeout NUM
                                             14*#  - scheduling 'fifo' (def) or 'filo':
                                             14*#     - FIFO keep number of open sockets as high as possible, i.e. good for speed
                                             14*#     - FILO keep it as low as possible, i.e. good for memory
                                             14*#     - FILO lowers risk of re-using sockets closed by server due to inactivity
AGENT.max[Free]Sockets                          #
AGENT.[free]sockets                             #Current TCPSOCKET_ARR
AGENT.maxTotalSockets                        14*#Like AGENT.maxSockets but for all origins
AGENT.requests                                  #Current REQ_ARR, not assigned to sockets yet.
AGENT.destroy()                                 #To do to destroy free sockets if keepAliveMsecs high, to avoid hanging.
AGENT.keepSocketAlive = FUNC(TCPSOCKET)         #Override function fired on new free socket.
                                                #Def: TCPSOCKET.setKeepAlive(true, keepAliveMsecs); TCPSOCKET.unref(); return true;
AGENT.reuseSocket = FUNC(TCPSOCKET, CLIENTREQ)  #Override function fired when free socket is being picked.
                                                #Def: TCPSOCKET.ref();
AGENT.getName(OBJ)                              #Returns OBJ (host, port, localAddress) as unique ID STR
AGENT.createConnection(...)->IOSTREAM           #Same as TCP createConnection(), but can be customized and use any IOSTREAM

validateHeaderName('NAME')
validateHeaderValue('NAME', 'VAL')           14*#Throw if invalid HTTP header name|value. Automatically done by RES.setHeader()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTPS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HTTPS ==>                                       #Has exactly same members as HTTP except:
                                                #  - createServer(OBJ[, FUNC]): OBJ is same as TLS|HTTP.createServer()
                                                #  - all members:
                                                #      - inherit from HTTP, e.g. HTTPSSERVER inherits HTTPSERVER
                                                #      - use TLS* objects instead of TCP*, e.g. TLSSERVER <- TCPSERVER, TLSSOCKET <- TCPSOCKET, etc.
                                                #      - as such, can be used as HTTP server too
                                                #  - new AGENT(OBJ) and request(OBJ) can use:
                                                #     - all options from TLS.createSecureContext(OBJ)
                                                #     - 'rejectUnauthorized|servername' options from TLS.connect(OBJ)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              URL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NODE_URI                                        #Prefer URI
                                                #OBJ:
                                                #  - protocol STR|null
                                                #  - slashes BOOL: if AUTHORITY starts with //
                                                #  - auth STR|null
                                                #  - host STR|null
                                                #  - port STR|null
                                                #  - hostname STR|null
                                                #  - pathname 'PATH'|null
                                                #  - path 'PATH?QUERY'|null
                                                #  - search '?QUERY'|QUERY_OBJ|null
                                                #  - query 'QUERY'|null
                                                #  - hash '#HASH'|null
                                                #  - href 'URI'
                                             11*#Deprecated
parse('URI'[, BOOL[, BOOL2]])->NODE_URI         #BOOL: if true (def: false), NODE_URI.search is QUERY_OBJ
                                                #BOOL2: if true (def: false), protocol can be omitted
                                             11*#Deprecated
resolve('BASE_URI', 'RELATIVE_URI')->'URI'      #
                                             11*#Deprecated

URI                                             #As opposed to NODE_URI, is isomorphic, i.e. same as in browser (see DOM doc)
                                                #Including the fact that URL is a global object
new URL("URI"[, URI2|'URI2'])->URI              #See DOM doc
format(URI[, OPTS])->'URI'                      #OPTS:
                                                #  - auth BOOL: if false (def: true), ignores username|password
                                                #  - fragment BOOL: if false (def: true), ignores hash
                                                #  - search BOOL: if false (def: true), ignores search
                                                #  - unicode BOOL: if false (def), uses Punycode. Otherwise, URI encoding

ORIGIN                                          #OBJ: scheme STR|null, host STR|null, port STR|undefined, domain STR|null
originFor(...)->ORIGIN                          #Like URL constructor, but returning ORIGIN instead

domainToASCII(STR)->STR2
domainToUnicode(STR)->STR2                      #IDN from|to Punycode

fileURLToPath(URI|'URI')->'PATH'                #Conversion between file://* and 'PATH' considering:
pathToFileURL('PATH')->URI                      #  - 'PATH' is OS-specific
                                                #  - URI requires percent encoding, but not 'PATH'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          QUERYSTRING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


stringify(QUERY_OBJ[, STR[, STR2[, OPTS]]])     #'QUERY' is escaped
  ->'QUERY'                                     #STR is separator (def: '&'), STR2 delimiter (def: '=')
                                                #ARR is serialized as several VARs
                                                #OPTS:
                                                #  - encodeURIComponent(...) (def: escape(...)): customize escaping
parse('QUERY'[, STR[, STR2]][, OPTS])->QUERY_OBJ#Inverse.
                                                #OPTS:
                                                #  - maxKeys NUM (def: 1000, 0 for unlim)
                                                #  - decodeURIComponent(...) (def: unescape(...)):
                                                #     - customize escaping
                                                #     - transforms + to spaces (instead of escaping)
                                                #Note: QUERY_OBJ does not inherit from OBJ
[un]escape(STR)                                 #Same as en|decodeURIComponent(), but can be overriden to change stringify|parse() behavior

QS ==>                                         ##See QS module for more features


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              DNS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DIFFERENCE ==>                                  #DNS.resolve*|reverse() and DNS.lookup*() are similar but:
                                                #  - resolve*|reverse(): use C-Ares, a fast library for DNS resolution, which does DNS query directly.
                                                #  - lookup*():
                                                #     - uses getaddrinfo(), which is slower.
                                                #     - it uses underlying OS, i.e. how DNS resolution would behave on that system (e.g. /etc/hosts)
                                                #     - it is used by http.*, tcp.* and udp.* modules.
                                                #Resolving manually the host can give better performance.

lookup('HOST'[, OBJ], FUNC(ERROR, 'HOST', STR4))#DNS forward lookup.
                                                #STR4 is family: 4 (IPv4), 6 (IPv6) or null (both).
                                                #OBJ:
                                                #  - family 4|6|null
                                                #  - hints NUM: or'd flags among:
                                                #     - DNS.ADDRCONFIG
                                                #     - DNS.V4MAPPED: if look for IPv6 but none found, return IPv4 mapped as IPv6
                                             12*#     - DNS.ALL: with V4MAPPED, also return IPv6 too
                                                #  - all BOOL: if true (def: false), return all address as STR4_ARR, not only first one
                                                #  - verbatim BOOL: if false (def), reorder IPv4 before IPv6
                                                #The ERROR.name can correspond to several DNS.*, like DNS.NOTFOUND, DNS.NODATA, DNS.NOMEM, etc. (see online doc)
lookupService
(IP, PORT, FUNC(ERROR, 'HOST', 'SCHEME'))       #

new Resolver([OPTS])                            #RESOLVER
                                             12*#OPTS:
                                             12*#  - timeout NUM (-1 for def) (in ms)
                                                #In following methods, if RESOLVER is missing, use builtin RESOLVER
[RESOLVER.]resolve
 ('HOST'[, STR2], FUNC(ERROR, VAL_ARR))         #Same as lookup() but STR2 can any PTR record type: "A" (def), "AAAA", "MX", "TXT", "SRV", "PTR", "NS", "CNAME", "SOA", "NAPTR" or "ANY" (guesses)
[RESOLVER.]resolveSTR2                          #Same. STR2 is camelcase, and "A"|"AAAA"->4|6
 ('HOST', [OBJ, ]FUNC(ERROR, VAL_ARR))          #OBJ (only with records "A"|"AAAA"):
                                                #  - ttl BOOL: if true (def: false), VAL is { address STR, ttl NUM }
[RESOLVER.]reverse('IP', FUNC(ERROR,'HOST'_ARR))#DNS reverse lookup.

[RESOLVER.]setServers('IP[:PORT]'_ARR)          #Sets list of servers IP to use for DNS resolution
[RESOLVER.]getServers()->'IP[:PORT]'_ARR        #List of servers

RESOLVER.cancel()                               #Cancel all current resolve*|reverse() calls, with ERROR with code 'ECANCELLED'

promises.*(...)                                 #Like DNS.*(...) except returns PROMISE and no RESOLVER.cancel()
                                                #No more experimental warning


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              OS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


platform()->STR                                 #"linux", "darwin", "win32", "android" or "sunos", "aix", "freebsd", "openbsd"
type()->STR                                     #Similar to platform() but slightly more precise.
                                                #E.g. "Linux", "Darwin", "Windows_NT", "CYGWIN_NT*", ""SunOS", "AIX", "FreeBSD", "OpenBSD"
                                             12*#or "MinGW"
release()->STR                                  #OS version number, e.g. "5.3.0-40-generic" (Linux), "18.0.0" (Mac), "10.0.17763" (Windows)
version()->STR                               12*#OS version number more precise, e.g.:
                                             12*#  - "#32-Ubuntu SMP Fri Jan 31 20:24:34 UTC 2020" (Linux)
                                             12*#  - "Darwin Kernel Version 18.0.0: Wed Aug 22 20:13:40 PDT 2018; root:xnu-4903.201.2~1/RELEASE_X86_64" (Mac)
                                             12*#  - "Windows 10 Home" (Windows)
arch()->STR                                     #"arm[64]", "ia32", "x32|x64", "mips[el]", "ppc[64]", "s390[x]"
endianness()->STR                               #"BE" or "LE"

NODE_SKIP_PLATFORM_CHECK=1                   14*#Unless set, Node.js fails to boot on old deprecated OS such as Windows 7

uptime()->DOUBLE                                #In seconds
loadavg()->DOUBLE_ARR                           #For last 1, 5 and 15 minutes.
                                                #Returns [0,0,0] on Windows
totalmem|freemem()->NUM                         #RAM

cpus()->OBJ_ARR                                 #OBJ:
                                                #  - model STR
                                                #  - speed UINT (MHz): varies with the load
                                                #  - times OBJ, ms spent by CPU on each member since uptime: user, sys, idle, nice, irq
                                                #     - nice is always 0 on Windows
networkInterfaces()->OBJ_ARR                    #OBJ:
                                                #  - key is interface name ("lo", "wlan0", etc.)
                                                #  - value is OBJ2_ARR, with OBJ2:
                                                #     - address 'IP'
                                                #     - netmask 'MASK'
                                                #     - cidr 'IP/MASK'
                                                #     - family "IPv4|6"
                                                #     - mac STR
                                                #     - internal BOOL (true if boucle local)
                                                #     - scopeid NUM

hostname()->STR                                 #E.g. "ether-laptop"
tmpdir()->STR                                   #E.g.:
                                                #  - Linux: `/tmp`
                                                #  - Mac: `/var/folders/RANDOM/T`
                                                #  - Windows: `C:\Users\USER\AppData\Local\Temp`
                                                #Uses ENVVAR TMPDIR|'/tmp' (Unix), '{SystemRoot|windir}\\temp' (Windows), TMP|TEMP (any OS)
homedir()->STR                                  #E.g.:
                                                #  - Linux: `/home/USER`
                                                #  - Mac: `/Users/USER`
                                                #  - Windows: `C:\Users\USER`
                                                #Based on ENVVAR HOME (Linux) or USERPROFILE (Windows), or defaults to userInfo().homedir
userInfo([OBJ])->OBJ2                           #OBJ2:
                                                #  - uid|gid NUM (-1 on Windows)
                                                #  - username 'USER' (ENVVAR USER on Unix, USERNAME on Windows)
                                                #  - homedir 'PATH' (based on OS syscalls)
                                                #  - shell 'PATH' (null on Windows)
                                                #Throws in Docker when `--user` points to user with no home nor username.
                                                #OBJ: encoding 'utf8' (def) or 'buffer'

EOL                                             #OS-specific newline "\n" or "\r\n"

setPriority([PID, ]NUM)                         #Sets OS process scheduling priority ("niceness").
                                                #If 0 (def), current process
                                                #NUM is between -20 (high priority) and 19 (low priority) or using os.constants:
                                                #  - PRIORITY_LOW: 19
                                                #  - PRIORITY_BELOW_NORMAL: 10
                                                #  - PRIORITY_NORMAL: 0
                                                #  - PRIORITY_ABOVE_NORMAL: -7
                                                #  - PRIORITY_HIGH: -14
                                                #  - PRIORITY_HIGHEST: -20
getPriority([PID])->NUM                         #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PATH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PATH ==>                                        #All these functions look at PATH without caring if file exists.

CROSS-OS ==>                                    #Summary:
                                                #  - should usually use Unix path
                                                #  - except when dealing with input|output outside Node (in shell): use PATH.* then
                                                #  - Node methods input:
                                                #     - Unix path allowed on all OS
                                                #        - but Windows path also allowed in Windows (including mixed)
                                                #     - e.g. require(), PATH.*, FS.*, process.chdir()
                                                #  - Node methods output:
                                                #     - OS-specific
                                                #        - but it's ok since input in Node in Windows allows mixing Unix/Windows
                                                #     - e.g. PATH.*, __dirname, process.argv|execPath|cwd(), OS.userInfo().homedir
                                                #     - exceptions:
                                                #        - PATH.posix|win32.*
                                                #        - output based on input, e.g. createReadStream().path, fs.mkdtemp()
                                                #  - input|output outside Node (in shell): OS-specific

normalize('PATH')->'PATH'                       #Remove leading "./", useless ".." and duplicate "/"
join('PATH',...)->'PATH2'                       #Join with PATH.sep, then do normalize()
resolve('PATH',...)->'PATH2'                    #Like doing several cd 'PATH' from current directory:
                                                #  - 'PATH' can be relative or absolute
                                                #  - 'PATH2' is final DIR, normalized()
relative('PATH', 'PATH2')->'PATH3'              #Print relative PATH3 to go from dir PATH to dir PATH2.
                                                #Return '' if same dir
                                                #On Windows, PATH3 might be absolute if either different root folder or drive.
                                                #On Windows, PATH3 might start with Windows drive if different.

isAbsolute('PATH')->BOOL                        #

dirname('PATH')->'DIR'                          #
basename('PATH'[, '.EXT'])->'FILE'              #
extname('PATH')->'.EXT'                         #

parse('PATH')->PATH_OBJ                         #PATH_OBJ: root STR, dir STR, base STR, ext STR, name STR
format(PATH_OBJ)->'PATH'                        #Inverse

sep                                             #OS-specific path delimiter "/" or "\"
delimiter                                       #OS-specific ENVVAR PATH delimiter ":" or ";"
posix|win32.*                                   #Like PATH, but always behave like if on those platforms
toNamespacedPath('PATH')->'PATH'                #Returns namespaced path '\\?\LETTER:\'.
                                                #Noop unless on Windows.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              FS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--trace-sync-io                                 #console.trace() when sync I/O is used

CROSS-OS PERMISSIONS ==>                        #Windows permissions are not supported
                                                #  - except for `readonly` file attribute on regular files, which maps to `a+w`
                                                #  - all other permissions are always on
                                                #This affects `umask()`, `chmod()`, `access()`, `stat().mode` and `opts.mode`
                                                #for `mkdir()` and `open()`.

FS-EXTRA                                       ##Replacement for FS, with extra methods.
                                               ##Version 0.16.3
                                               ##Works well with BLUEBIRD.promisifyAll(FS-EXTRA)
WRENCH                                         ##Other filesystem module, but not drop-in replacement of FS.
                                               ##Version 1.5.8

PATH|FILENAME|DIR                               #Either:
                                                #  - STR
                                                #  - URI
                                                #  - BUFFER (less interoperable)
f*                                              #Variant using file descriptior FD_INT
l*                                              #Doesn't deference symlinks

PWD ==>                                         #All relative to process.cwd()
...Sync(...)                                    #All functions have a synchronous variant, without FUNC, except
                                                #[un]watch[File]() and createRead|WriteStream()
                                                #Will throw exceptions instead of using ERROR.

copyFile(PATH, PATH2[, NUM][, FUNC(ERROR)])     #NUM is an or'd flag:
                                                #  - COPYFILE_EXCL: fail if PATH2 already exists
FS-EXTRA.copy(FILE|DIR, FILE|DIR2, FUNC(ERROR))##
WRENCH.copyDirSync[Recursive]                  ##OBJ:
(FILE|DIR, FILE|DIR2[, OBJ][,FUNC(ERROR)])     ##  - forceDelete BOOL: overwrite destination
                                               ##  - excludeHiddenUnix BOOL: copy dotfiles
                                               ##  - preserveFiles BOOL: keep copy when overwriting
                                               ##  - preserveTimestamps BOOL
                                               ##  - inflateSymlinks BOOL: follow symlinks
                                               ##  - filter REGEXP|FUNC(STR)->BOOL: exclude files to copy
                                               ##  - whitelist BOOL: if true, filter works
                                               ##  - include|exclude REGEXP|FUNC(STR)->BOOL
rename(PATH, PATH2, FUNC(ERROR))                #Cannot be done between partitions on Linux (see move-file doc)
FS-EXTRA.move(FILE|DIR, FILE|DIR2[, OBJ],
FUNC(ERROR))                                   ##Can use OBJ.clobber true to overwrite.
GULP-RENAME(VAL)                               ##Rename filenames. VAL can be:
                                               ##  - FILENAME_STR (single file)
                                               ##  - OBJ: dirname STR, basename STR, prefix STR, suffix STR, extname STR
                                               ##    (e.g. ".js")
                                               ##  - FUNC(OBJ)->OBJ, with same OBJ as above
                                               ##Version 1.2.0

[f]truncate(PATH|FD_INT, UINT, FUNC(ERROR))     #

[f|l]chown(PATH|FD_INT, UID, GID, FUNC(ERROR))  #Noop on Windows
WRENCH.chownSyncRecursive(DIR, UID, GID)       ##
[f|l]chmod(PATH|FD_INT, UINT, FUNC(ERROR))      #See above for Windows behavior
                                                #lchmod() is only on Mac
WRENCH.chmodSyncRecursive(DIR, UINT)           ##

[f]utimes(PATH|FD_INT, ATIME, MTIME, FUNC(ERR)) #Change atime|mtime
lutimes(...)                                 14*#
access(PATH[, NUM], FUNC(ERROR))                #Checks if has permission, according to NUM or'd flags:
                                                #  - FS.constants.F_OK (def, always implied):
                                                #     - files exists and its directory list it
                                                #     - also fails if directory and is not executable
                                                #  - FS.constants.R|W|X_OK:
                                                #     - can be read|written|executed
                                                #     - on Windows, only W_OK works and only means "no readonly attribute"
[f|l]stat(PATH|FD_INT,[OPTS,]FUNC(ERROR,FSSTAT))#FSSTAT:
                                                #  - isFile|Directory|Block|CharacterDevice|FIFO|Socket(), (only with lstat()) isSymbolicLink()
                                                #     - on Windows: can only be file, directory or symlink
                                                #  - dev UINT
                                                #  - ino UINT
                                                #  - mode UINT (see above for file type and permissions behavior)
                                                #  - nlink UINT
                                                #  - uid|gid UINT (0 on Windows)
                                                #  - rdev UINT
                                                #  - size UINT
                                                #  - blksize UINT, blocks UINT (both undefined on Windows)
                                                #  - a|m|ctime DATE
                                                #  - birthtime DATE: creation time (Windows only)
                                                #  - a|m|ctime|birthtimeMs NUM
                                             12*#  - a|m|ctime|birthtimeNs NUM (only if OPTS.bigint true)
                                                #OPTS:
                                                #  - bigint BOOL (def: false): make FSSTAT.* BIGINT instead of UINT

symlink(PATH, PATH2[, STR], FUNC(ERROR))        #STR is 'dir', 'file' or 'junction' (Windows only)
                                            <12*#Def: 'file'
                                             12*#Def: 'file|dir' depending on PATH
link(PATH, PATH2, FUNC(ERROR))                  #Hardlink
GULP-SYMLINK.relative|absolute                 ##Creates a symlink in DIR (creates it if not existing, overwrite if OBJ.force
(DIR_ARR|FUNC(VINYL)->VINYL[,OBJ])             ##true) with same filename as current file, poiting to that file (with a
                                               ##relative|absolute path). Version 2.0.1
readlink(PATH[, OBJ], FUNC(ERROR, PATH2))       #Follow symlink (only once)
                                                #PATH must be a symlink
                                                #OBJ: encoding 'ENCODING'
realpath[.native]                               #Like normalize(), but also follow symlinks (several times if needed), and PATH must exist.
 (PATH[, OBJ], FUNC(ERROR, PATH2))              #OBJ: encoding 'ENCODING'
                                                #If "native" does not cache and do less normalization

unlink(PATH, FUNC(ERROR))                       #
rmdir(PATH, FUNC(ERROR)[, OPTS])                #OPTS:
                                             12*#  - recursive BOOL (def: false):
                                             12*#     - recursively on children
                                             12*#     - no error if PATH does not exist
                                             12*#  - maxRetries NUM (def: 0)
                                             12*#     - retry NUM times with linear backoff (starting at OPTS.retryDelay NUMms (def: 100)) on
                                             12*#       EBUSY, ENOTEMPTY, EPERM, EMFILE or ENFILE
                                             12*#     - requires OPTS.recursive true

FS-EXTRA.remove(FILE|DIR, FUNC(ERROR))         ##Like rm -rf
WRENCH.rmdirSyncRecursive(FILE|DIR[, BOOL])    ##Same. If true, fails silently.

mkdir(PATH[, MODE_INT|OPTS],                    #OPTS:
 FUNC(ERROR[, 'PATH2']))                        #  - mode MODE_INT (def: 0777) (see above for Windows behavior)
                                                #  - recursive BOOL (def: false):
                                                #     - create intermediary directories
                                                #     - no error if directory exists
                                                #     - see make-dir (see its doc) for a ponyfill
                                             12*#'PATH2' is the topmost subdirectory that did not exist before mkdir() (undefined if none)
FS-EXTRA.ensureFile|Dir(FILE|DIR,FUNC(ERROR))  ##Create file|dir, including parent dirs, if not existing.
FS-EXTRA.mkdirs(DIR, FUNC(ERROR))              ##Like ensureDir()
WRENCH.mkdirSyncRecursive(DIR[, MODE_INT])

readdir(DIR, [OPTS, ]                           #ls: 'FILE' excludes . and ..
 FUNC(ERROR, 'FILE'|DIRENT_ARR))                #OPTS:
                                                #  - encoding 'ENCODING'
                                                #  - withFileTypes BOOL (def: false): whether to return DIRENT_ARR or 'FILE'_ARR
WRENCH.readdirSync[Recursive]
(DIR[, OPTS][, FUNC(ERROR, STR2_ARR)])         ##Same but recursive
DIRENT.isFile|Directory|Block|CharacterDevice|
 FIFO|Socket|SymbolicLink()->BOOL               #
DIRENT.name                                     #STR

opendir(DIR[, OPTS], FUNC(ERROR, FSDIR))     12*#Like readdir() but:
                                             12*#  - iteratively, in batch of OPTS.bufferSize NUM (def: 32) files internally
                                             12*#     - i.e. slower but lower memory
                                             12*#        - on my machine: 1s per 1e6 files, in big directories
                                             12*#        - on my machine: 4x|5x for <1e5 files files, 2x for 1e5 files, 1x for 1e6 files, slightly faster above
                                             12*#     - higher OPTS.bufferSize makes it faster up until a point where it makes it slower
                                             12*#        - on my machine: fastest seem to be 256
                                             12*#  - only useful for very big directories (>1e6 files)
                                             12*#  - unordered
                                             12*#OPTS:
                                             12*#  - encoding 'ENCODING'
FSDIR.path                                   12*#'DIR' (as specified in input)
FSDIR.read()->PROMISE_DIRENT|null            12*#Get next directory entry or null if no more
FSDIR.close()->PROMISE                       12*#Cleanup file descriptor after iteration done
FSDIR                                        12*#Is ASYNC_ITERATOR iterating over PROMISE_DIRENT, doing read() and close()

open(PATH, STR|NUM[, MODE], FUNC(ERROR, FD_INT))#Open a file and return a file descriptor.
                                                #STR are flags: "r|w|a[s|x][+]":
                                                #  - r: O_RDONLY
                                                #  - w: O_TRUNC + O_CREAT + O_WRONLY
                                                #  - a: O_APPEND + O_CREAT + O_WRONLY
                                                #  - +: O_RDONLY|WRONLY -> O_RDWR
                                                #  - x: O_EXCL. Not with 'r'
                                                #  - s: O_SYNC. Not with 'w'. Can be done with 'a'
                                                #NUM are or'd flags:
                                                #  - O_RDONLY|O_WRONLY|O_RDWR: read|write-only or not
                                                #  - O_TRUNC: truncate
                                                #  - O_APPEND: append
                                                #  - O_CREAT: create if not exist
                                                #  - O_CREAT + O_EXCL: fail if exist
                                                #  - O_DIRECTORY: fail if not a directory
                                                #  - O_NOFOLLOW: fail if is a symlink
                                                #  - O_SYMLINK: do not follow symlinks
                                                #  - O_NOATIME: do not update atime (Linux only)
                                                #  - O_DIRECT: try to avoid caching|buffering
                                                #  - O_SYNC: synchronous (wait for data)
                                                #  - O_DSYNC: synchronous (wait for data+metadata)
                                                #  - O_NOCTTY: if file is a terminal device, treat it as a normal file
                                                #  - O_NONBLOCK: use async when opening special files like serial ports
                                                #  - UV_FS_O_FILEMAP: use memory file mapping, i.e. bytewise copy of file in RAM. Only on Windows.
                                                #On Windows, those flags are mapped to file attributes, file permissions and share permissions
                                                #MODE INT is 0666 by def.
close(FD_INT, FUNC(ERROR))                      #
write(FD_INT, TDBUFFER, INT, INT2, [ INT3,]     #Write INT2 bytes from TDBUFFER at its position INT to file FD_INT at its position INT3 (def: current).
FUNC(ERROR, INT4, TDBUFFER))                    #INT4 is the number of bytes written.
                                                #INT|INT2 are optional
write(FD_INT, STR[, INT3,
['ENCODING', ]] FUNC(ERROR, INT4, STR))         #Same but with STR
writev(FD_INT, ARRAYBUFFERVIEW_ARR[, INT3],
 FUNC(ERROR, INT4, ARRAYBUFFERVIEW_ARR))     12*#Same but with ARRAYBUFFERVIEW_ARR
read(FD_INT, TDBUFFER, INT, INT2,
INT3, FUNC(ERROR, INT4, BUFFER))                #
read(FD_INT[, OPTS],FUNC(ERROR,INT2,BUFFER)) 12*#Read INT2 bytes from file FD_INT and return as BUFFER
                                             12*#OPTS:
                                             12*#  - buffer TDBUFFER (def: Buffer.alloc(16384))
                                             12*#  - offset INT (def: 0)
                                             12*#  - length INT2 (def: OPTS.buffer.length)
                                             12*#  - position INT3 (def: null)
readv(FD_INT, ARRAYBUFFERVIEW[, INT3]
 FUNC(ERROR, INT4, ARRAYBUFFERVIEW_ARR))     12*#Same but with ARRAYBUFFERVIEW_ARR
f[data]sync(FD_INT, FUNC(ERROR))                #Flushes to disk
                                                #If 'data', does not flush metadata (e.g. mtime)

readFile                                        #Easier way than using open() and read()
(PATH|FD_INT, [OPTS, ]FUNC(ERROR, BUFFER|STR))  #OPTS:
                                                #  - encoding 'ENCODING' (def: null, i.e. returns BUFFER, otherwise returns STR)
                                                #  - flag STR (def: "r")
                                                #Prefer createReadStream(...).pipe(OSTREAM)
FS-EXTRA.readJson(...)                         ##Same as readFile(), but return as OBJ
write|appendFile(FILENAME|UINT,                 #OPTS has same members but also mode MODE_INT (def: 0666), and default encoding is 'utf8'
[STDBUFFER,] [OPTS, ] FUNC(ERROR))              #Def flag is "w|a"
FS-EXTRA.outputFile(...)                       ##Same as writeFile(), but calls ensureFile() first
FS-EXTRA.writeJson|outputJson(...)             ##Same as writeFile|outputFile(), but with an OBJ (JSON.stringify'd).
createReadStream(PATH[, OPTS])->ISTREAM         #Preferred over readFile().
                                                #Useful with ISTREAM.[.pipe(IOSTREAM)...]pipe(OSTREAM):
                                                #  - transmits to OSTREAM by chunks ("data" events) instead of at once
                                                #    (readFile())
                                                #  - can use IOSTREAM as modular transforms functions (like Unix commands)
                                                #OPTS has members:
                                                #  - flags STR (def: "r")
                                                #  - encoding 'ENCODING' (def: null)
                                                #  - fd FD_INT (def: null)
                                                #  - mode NUM (def: 0666) (see above for Windows behavior)
                                                #  - autoClose BOOL (def: true): close the file descriptor on error|end event
                                             12*#  - emitClose BOOL (def: false): emit a 'close' event when destroyed
                                                #  - start|end UINT: only use from bytes UINT to UINT2
                                             12*#  - fs FS or null (def): override FS.*
                                                #ISTREAM has extra:
                                                #  - same members as OPTS
                                                #  - on('open', FUNC(FD_INT))
                                                #  - on('ready', FUNC())
                                             11*#  - pending BOOL: true if 'ready' event not emitted yet
                                                #  - path PATH
                                                #  - pos UINT
createWriteStream(PATH[, OPTS])->OSTREAM        #OPTS has members flags, defaultEncoding, fd, mode, autoClose, start
                                                #OSTREAM has extra:
                                                #  - same members as OPTS
                                                #  - 'open', 'ready', path, pos: like createReadStream()
                                             11*#  - pending: like createReadStream()
                                                #  - bytesWritten UINT
new WRENCH.LineReader(FILE)                    ##Returns LINEREADER
LINEREADER.hasNextLine()                       ##
LINEREADER.getNextLine()                       ##Returns FILE line by line
LINEREADER.close()                             ##

mkdtemp('PATH', FUNC(ERROR, 'PATH2'))           #Create temp file at 'PATHrandom', with random being 6 chars [:alnum:] (36 bits of entropy)
TEMP.open(PREFIX, FUNC(ERROR, OBJ))            ##Creates temp file with permission 0600 under temp directory.
                                               ##OBJ:
                                               ##  - path STR
                                               ##  - fd NUM
                                               ##PREFIX:
                                               ##  - OBJ: prefix STR, suffix STR, dir DIR (def: "", "", OS temp dir)
                                               ##  - STR: only PREFIX_STR
                                               ##  - Path will be TMP_DIR/PREFIX-UUID-AFFIX
                                               ##If TEMP.track() called before, it will erase file on process exit.
                                               ##Version 0.8.1
TEMP.mkdir(PREFIX,FUNC(ERROR,PATH))            ##Same with directory
TEMP.createWriteStream()                       ##Same for file as OSTREAM
TEMP.path(PREFIX)                              ##Same for only the path
TEMP.cleanup(FUNC(ERROR,OBJ))                  ##Remove temp files. TEMP.track() must have been called before.
                                               ##OBJ: files|dirs NUM


watch('FILE|DIR'[, OPTS][, FUNC])->FSWATCHER    #FSWATCHER fires events when file changes name or content.
                                                #OPTS:
                                                #  - persistent BOOL: if true (def), calls ref(), yielding the macrotask
                                                #  - recursive BOOL (def: false) (not on Linux)
                                                #  - encoding 'ENCODING' (def: 'utf8')
                                                #FUNC is the FSWATCHER 'change' event handler.
                                                #Unstable. Prefer Chokidar.
FSWATCHER.on
('change', FUNC('change|rename', SBUFFER))      #SBUFFER is the FILENAME and is not always provided (e.g. never on MacOSX, and not always on other OS)
FSWATCHER.close()                               #
FSWATCHER.on('close', FUNC())                   #
FSWATCHER.on('error', FUNC(ERROR))              #
FSWATCHER.[un]ref()                          14*#

[un]watchFile                                   #Uses polling
 (FILE[, OPTS], FUNC(PREV_STAT, NEW_STAT))      #OPTS:
 ->STATWATCHER                                  #  - persistent BOOL
                                                #  - interval (def: 5000)
STATWATCHER                                  14*#
STATWATCHER.[un]ref()                        14*#

constants                                       #Low-level file-system constants, for the current OS


FS.promises                                     #Like FS but:
                                                #  - return PROMISE instead
                                                #     - no FS.unwatch|watch[File]() nor FS.*Stream()
                                                #  - FD_INT are FILE_HANDLE instead
                                                #     - no FS.close() but FILE_HANDLE.close() is available
                                                #  - FS.constants|Stats|*OK remain on FS.*
require('fs/promises')                       14*#Same
FILE_HANDLE                                     #Abstraction of a file descriptor, with automatic closing on FS PROMISE rejection
FILE_HANDLE.fd                                  #FD_INT
FILE_HANDLE.FUNC(...)                           #Same as FSP.[f]FUNC(FILE_HANDLE, ...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ZLIB              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createGzip|Deflate[Raw]([OBJ])->COMPRESS        #COMPRESS is a IOSTREAM, so should do:
                                                #  ISTREAM.pipe(IOSTREAM).pipe(OSTREAM)
                                                #See HTTP for different formats.
                                                #Raw: same but does not append a zlib header.
                                                #OBJ can be:
                                                #  - [finish]flush, among:
                                                #     - constants.Z_NO_FLUSH (def)
                                                #     - constants.Z_PARTIAL_FLUSH
                                                #     - constants.Z_SYNC_FLUSH
                                                #     - constants.Z_FULL_FLUSH
                                                #     - constants.Z_FINISH
                                                #     - constants.Z_BLOCK
                                                #     - constants.Z_TREES
                                                #  - chunkSize (def: 16*1024): higher means faster but more memory
                                                #  - windowBits (def: 15): from 9 to 15, higher means better compression but
                                                #    more memory.
                                                #  - dictionary TDABUFFER (deflate|inflate only) (def: "")
                                                #OBJ (compression only):
                                                #  - level: higher means better compression but slower, among:
                                                #     - constants.Z_DEFAULT_COMPRESSION (def)
                                                #     - constants.Z_BEST_SPEED
                                                #     - constants.Z_BEST_COMPRESSION
                                                #     - constants.Z_NO_COMPRESSION
                                                #  - memLevel (def: 8): from 1 to 9, higher means better compression but more
                                                #    memory.
                                                #  - strategy, make compression better, according to type of data, among:
                                                #     - constants.Z_DEFAULT_STRATEGY: almost random data, and small values
                                                #     - constants.Z_FILTERED: in-between
                                                #     - constants.Z_HUFFMAN_ONLY: less random, and large repeating chunk
                                                #     - constants.Z_RLE: same, but specially for PNG data
                                                #     - constants.Z_FIXED: only specific application
                                             14*#  - maxOutputLength NUM (def: Buffer.kMaxLength): not used in streaming mode
                                                #Memory required (in bytes) is:
                                                #  - for compression:
                                                #     - 2^(windowBits+2) + 2^(memLevel+9) + chunkSize, i.e. 272K by def
                                                #  - for decompression:
                                                #     - 2^windowBits + chunkSize, i.e. 48K by def
createBrotliCompress([OBJ])->COMPRESS           #Same with Brotli. OBJ:
                                                #  - flush NUM, finishFlush ENUM, among:
                                                #     - constants.BROTLI_OPERATION_PROCESS (def)
                                                #     - constants.BROTLI_OPERATION_FINISH (def for last chunk)
                                                #     - constants.BROTLI_OPERATION_FLUSH (def for flush())
                                                #     - constants.BROTLI_OPERATION_EMIT_METADATA
                                                #  - chunkSize NUM (def: 16KB)
                                                #  - params OBJ:
                                                #     - [constants.BROTLI_PARAM_MODE] ENUM, among:
                                                #        - constants.BROTLI_MODE_GENERIC (def)
                                                #        - constants.BROTLI_MODE_TEXT: best for UTF-8 text
                                                #        - constants.BROTLI_MODE_FONT: best for WOFF 2.0 fonts
                                                #     - [constants.BROTLI_PARAM_QUALITY] NUM:
                                                #        - between constants.BROTLI_MIN|MAX_QUALITY (0|11)
                                                #        - def constants.BROTLI_DEFAULT_QUALITY (11)
                                                #        - higher gives better compression but consumes more CPU-time
                                                #     - [constants.BROTLI_PARAM_LGWIN] NUM:
                                                #        - between constants.BROTLI_MIN|MAX_WINDOW_BITS (10|24)
                                                #           - max BROTLI_LARGE_MAX_WINDOW_BITS (30) if BROTLI_PARAM_LARGE_WINDOW true
                                                #        - def constants.BROTLI_DEFAULT_WINDOW (22)
                                                #        - higher gives better compression, but consumes more memory, i.e. 2**NUM (i.e. def is 4MB)
                                                #     - [constants.BROTLI_PARAM_LGBLOCK] NUM:
                                                #        - between constants.BROTLI_MIN|MAX_INPUT_BLOCK_BITS (16|24)
                                                #        - higher gives better compression, but consumes more memory, i.e. 3 ** NUM
                                                #     - [constants.BROTLI_PARAM_SIZE_HINT] NUM:
                                                #        - input size hint
                                                #        - def 0, i.e. unknown
                                                #     - [constants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING] BOOL:
                                                #        - if true (def: false), poorer compression but faster decompression
                                                #     - [constants.BROTLI_PARAM_LARGE_WINDOW] BOOL:
                                                #        - if true (def: false), allow large windows, good for huge files
                                                #     - [constants.BROTLI_PARAM_NPOSTFIX|NDIRECT] NUM:
                                                #        - def 0
                                                #        - hint for number of direct distance codes and postfix bits.
                                                #        - those are two internal parameters of the algorithms, to use only when knowing it.
                                             14*#  - maxOutputLength: like createGzip|Deflate()
createGunzip|Inflate[Raw]|Unzip([OBJ])->UNCOMPRS#UNCOMPRESS is a IOSTREAM.
                                                #Unzip: autodetect whether Gunzip or Deflate (but not DeflateRaw).
createBrotliDecompress([OBJ])->UNCOMPRESS       #Same with Brotli. OBJ:
                                                #  - [constants.BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION] BOOL:
                                                #     - affects internal memory allocation
                                                #  - [constants.BROTLI_DECODER_PARAM_LARGE_WINDOW] BOOL: same as for compression
[UN]COMPRESS.flush([NUM, ]FUNC(ERROR))          #Compression uses an internal cache. Flush it.
                                                #Don't call unless necessary, because it impacts performance.
                                                #NUM def is constants.Z_FULL_FLUSH|BROTLI_OPERATION_FLUSH. See above for other values.
[UN]COMPRESS.reset()                            #Stop compressing any data going through.
                                                #Only for Deflate|Inflate
[UN]COMPRESS.params(LEVEL, STRATEGY,FUNC(ERROR))#
[UN]COMPRESS.bytesWritten                       #NUM

gzip|deflate[Raw]|brotliCompress
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER))         #
gunzip|inflate[Raw]|unzip|brotliDecompress
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER2))        #Convenience methods
*Sync(...)                                      #Same but sync


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           WARNINGS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WARNINGS ==>                                    #Are similar to console.warn() except:
                                                #  - can be handled similarly to an exception, but does not stop execution
                                                #  - not part of normal JavaScript code flow
                                                #  - used by Node.js internal warnings, e.g. deprecations
                                                #  - should try to emit only once
                                                #By def, printed to console with console.warn()

--no-warnings
NODE_NO_WARNINGS=1 ENVVAR                       #Does not print to console
--trace-warnings                                #Use console.trace() instead of console.warn()
--redirect-warnings=FILE
NODE_REDIRECT_WARNINGS=FILE ENVVAR              #I.e. will not be printed to console

PROCESS.emitWarning(ERROR)
PROCESS.emitWarning('MESSAGE'[, 'TYPE']         #Creates a warning
[, 'ID'][, FUNC(ERROR)->ERROR])                 #Def TYPE: 'Warning'
PROCESS.emitWarning('MESSAGE',                  #Same.
[{ type, code, ctor, detail }])                 #detail is extra message on next line (e.g. stack trace)

process.on('warning', FUNC(ERROR))              #Fired on warnings.
                                                #ERROR: message 'MESSAGE', name 'TYPE', code 'ID', detail STR
                                                #ERROR.code|detail might be undefined


DEPRECATION ==>                                 #Type of warning with TYPE "DeprecationWarning"

UTIL.deprecate(FUNC, 'MESSAGE'[, 'ID'])->FUNC   #Make FUNC fire PROCESS.emitWarning('MESSAGE', 'DeprecationWarning', 'ID')

--no-deprecation
--trace-deprecation                             #Like --no|trace-warnings but for deprecations
--throw-deprecation                             #throw error on deprecation
--pending-deprecation
NODE_PENDING_DEPRECATION=1 ENVVAR               #Includes upcoming deprecations

--trace-atomics-wait                         14*#Print debugging information on Atomics.wait()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROCESS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXIT EVENTS ==>                                 #  - normal exit: beforeExit, exit
                                                #  - uncaught exception: uncaughtException, exit
                                                #  - process.exit(): exit
                                                #  - process.abort(): none
                                                #  - signals: only signals events
                                                #The only handler that will prevent exit from happening (graceful exit)
                                                #are SIGINT|SIGTERM
on("beforeExit", FUNC(INT))                     #FUNC() can be async. If async, it will be fired again. To avoid infinite loop,
                                                #last iteration must not add any microtask|macrotask.
                                                #INT is the exit code
on("exit", FUNC(INT))                           #FUNC() must be sync
process.exitCode                                #INT set in 'exit' handler providing either process.exit() or uncaught exception.
                                                #Can be set too
--trace-exit                                 12*#Print a stack when calling process.exit()
                                             12*#Not for other exit types (normal exits, signals, uncaught exceptions, etc.)

on("uncaughtException", FUNC(VAL, STR))         #Any exception VAL thrown and not caught in try/catch
                                                #VAL is usually an ERROR
                                                #Can be exception top-level or within a microtask/macrotask
                                                #  - e.g. a callback or request handler
                                                #  - not possible with Express since it catches any error within request handler
                                                #Unless an event handler exists, calls process.exit(1)
                                                #  - should always call process.exit(1) within event handler to keep this behavior
                                                #STR is either:
                                                #  - 'unhandledRejection': came from --unhandled-rejections=strict
                                                #  - 'uncaughtException': otherwise
on('uncaughtExceptionMonitor',FUNC(VAL,STR)) 12*#Same as on('uncaughtException') except:
                                             12*#  - does not prevent process.exit(1)
                                             12*#  - called first
setUnaughtExceptionCaptureCallback              #Same as on("uncaughtException") except:
 (FUNC(VAL)|null)                               #  - unsets "uncaughtException" handler
                                                #  - unsets --abort-on-uncaught-exception
hasUnaughtExceptionCaptureCallback()->BOOL      #
--abort-on-uncaught-exception                   #Create a dump file when process exited because of uncaught exception
--trace-uncaught                             12*#Make default uncaughtException handler also print stack trace of the line that threw
                                             12*#If ERROR throw, this will be same stack trace, shown twice.
                                             12*#But for non-ERROR, this is useful since they don't have stack traces otherwise.
                                             12*#Can be bad for garbage collection.

exit([UINT])                                    #Exit with exit code UINT (def: 0)
                                                #Pending microtasks|macrotasks will be aborted. Streams won't be flushed.
abort()                                         #Aborts: exits + produce a core file.

pid                                             #
ppid                                            #Parent's pid

SIGNALS ==>                                     #Node specifics:
                                                #  - signal 0 can be used to test for process existence
                                                #  - "SIGUSR1" will start debugger (not on Windows)
                                                #  - handling SIGINT|SIGTERM will remove default handler
                                                #  - cannot handle SIGKILL|SIGSTOP
                                                #Only on Linux: SIGPOLL, SIGPWR, SIGUNUSED
                                                #Only on Mac: SIGINFO
                                                #On Windows, only following work:
                                                #  - process.kill() only: 0, SIGINT, SIGTERM, SIGKILL
                                                #     - SIGINT can use process.on() but only with CTRL-C
                                                #  - process.on() only:
                                                #     - SIGBREAK: CTRL-BREAK on Windows, similar to CTRL-C
                                                #     - SIGHUP: closing cmd.exe window
                                                #     - SIGWINCH, SIGILL, SIGABRT, SIGFPE, SIGSEGV

kill(PID_INT[, 'SIGNAME'|SIGNUM])->BOOL         #Sends a signal (def: "SIGTERM").
                                                #If PID_INT doesn't exist, throw exception (can use 0 to just test process existence).
                                                #If PID_INT is negative, targets also descendants (Unix only)
                                                #Return true if succeeded
OS.constants.signals.SIGNAME                    #SIGNUM
                                                #SIGNAME is OS-agnostic, SIGNUM is OS-specific
                                                #All OS miss SIGEMT SIGCLD SIGRTMIN SIGRTMAX
                                                #Linux misses SIGINFO
                                                #Mac misses SIGPOLL SIGPWR SIGUNUSED
                                                #Linux|Mac miss SIGBREAK
                                                #Windows signals are emulated by Node.js and only for:
                                                #  - process.kill(): SIGINT SIGTERM SIGKILL
                                                #  - process.on(): SIGINT SIGABRT SIGHUP SIGBREAK SIGWINCH SIGILL SIGFPE SIGSEGV
on('SIGNAL', FUNC('SIGNAL'))                    #Fires when signal emitted on current process.
--trace-sigint                               12*#Print a stack trace on SIGINT. Still keep SIGINT default handler

on('unhandledRejection, FUNC(VAL, PROMISE))     #When PROMISE:
                                                #  - is rejected
                                                #  - and has no handler (PROMISE.catch())
--unhandled-rejections=STR                      #What to do on 'unhandledRejection':
                                                #  - 'strict': 'unhandledRejection' event + uncaughtException
                                                #  - throw: 'unhandledRejection' event + (unless that event was handled) uncaughtException
                                             14*#  - default: 'unhandledRejection' event + (unless that event was handled) warning + (once) deprecation warning
                                             14*#  - warn-with-error-code: 'unhandledRejection' event + (unless that event was handled) warning + process.exitCode 1
                                                #  - 'warn': warning
                                                #  - 'none': nothing
on('rejectionHandled, FUNC(PROMISE))            #When adding PROMISE.catch() on a PROMISE that:
                                                #  - was already rejected
                                                #  - and had no handler when it was rejected (i.e. 'unhandledRejection')
                                                #  - and was rejected in a previous macrotask
on('multipleResolves',                          #When PROMISE is resolved|rejected more than once
 FUNC(STR, PROMISE, VAL))                       #  - including being resolved after being rejected, or vice-versa
                                                #STR is 'resolve|reject'. VAL is the resolved|rejected value.
                                                #STR|VAL are not the initial resolution|rejection but the extra one.

argv                                            #Command line args as STR_ARR. Doesn't include node options.
                                                #First is "node", second the absolute path of FILE, then the other arguments.
execArgv                                        #Same but only for node options (exclude all STR of argv)
execPath                                        #Absolute path of node executable used.
env                                             #Environment variables, as OBJ. Values are strings.
                                                #Case-insensitive on Windows.
title                                           #Process title displayed in ps. Read/write. Usually short max length.
                                                #Cannot set to smaller length than the initial value
--title STR                                     #Set PROCESS.title

cwd()->'DIR'                                    #Current directory
                                                #Is the one of the main file. Required files do not change it.
chdir('DIR')                                    #

CROSS-OS ==>                                    #All the following throw on Windows
get[e]gid|[e]uid()                              #
set[e]gid|[e]uid(UINT|STR)                      #
getgroups()
setgroups(STR_ARR)                              #Supplementary GIDs.
initgroups(STR, STR2[_ARR])                     #

umask(UINT)                                     #See below for Windows behavior

version                                         #Node.js version 'vSERMVER'
release.name                                    #'node|io.js'
release.sourceUrl|headersUrl                    #'URL'
release.lts                                     #'NAME' when LTS
versions                                        #OBJ with members node v8 uv zlib ares modules nghttp2 napi llhttp http_parser openssl icu unicode cldr tz
config                                          #Config flags and variables used during compilation, as OBJ

arch                                            #Same as OS.arch()
platform                                        #Same as OS.platform()

memoryUsage()->OBJ                              #OBJ
                                                #  - rss NUM: space occupied by process (including code)
                                                #  - heapUsed|heapTotal NUM: subset of rss for heap
                                                #  - external NUM: subset of heap for JavaScript objects stored in C++
                                             12*#  - arrayBuffers NUM: subset of external for [SHARED_]ARR_BUFFER
cpuUsage([OBJ])->OBJ                            #OBJ: user|system NUM (time usage, in microseconds)
                                                #If OBJ passed, is difference.
uptime()                                        #

resourceUsage()->OBJ                         12*#OBJ:
                                             12*#  - user|systemCPUTime NUM: same as cpuUsage().user|system
                                             12*#  - maxRSS NUM (in KB): max RSS memory
                                             12*#  - minor|majorPageFault NUM: number of page faults
                                             12*#  - fsRead|fsWrite NUM: number of I/O operations
                                             12*#  - [in]voluntaryContextSwitches NUM: CPU time slices switches (not on Windows)
                                             12*#  - sharedMemorySize|unsharedDataSize|unsharedStackSize|swappedOut|ipcSent|ipcReceived|signalsCount NUM: does not work on any OS

hrtime([VAL])->VAL                              #Current time as [UINT, UINT2], where UINT is seconds and UINT2 nanoseconds.
                                                #Not real time, but arbitrary one just to compare with another time check.
                                                #If VAL passed, is difference.
                                                #Better that using new Date(), notably because ns not ms
                                                #Resolution:
                                                #  - 1ms to 1ns, depending on hardware
                                                #  - often 1ns on Linux/Mac machines
hrtime.bigint()->BIGINT                         #Same but using BIGINT nanosecs instead of [UINT, UINT2]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        CHILD_PROCESS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


spawn(STR[, STR2_ARR][, OPTS])->CHILDPROCESS    #Creates and runs a CHILDPROCESS from command line "STR ...STR2_ARR"
                                                #  - cwd STR (def: null, i.e. current)
                                                #  - env OBJ (def: process.env)
                                                #  - uid|gid UINT (def: current ones)
                                                #  - encoding 'ENCODING' (def: "buffer")
                                                #  - stdio STR_ARR:
                                                #     - how parent can access child's file descriptors
                                                #     - at least first three ones, stdin|out|err, but can continue with fd 3, etc.
                                                #     - among:
                                                #        - "pipe":
                                                #           - anonymous pipe
                                                #           - write-only (parent to child) if stdin, read-only (child to parent) otherwise
                                                #           - enable CHILDPROCESS.stdio[FD_INT]|stdin|out|err
                                                #        - "ipc":
                                                #           - bidirectional anonymous pipe
                                                #           - enable CHILDPROCESS.send()
                                                #           - can only do it for one file descriptor.
                                                #           - file descriptor will be available in child's ENVVAR NODE_CHANNEL_FD
                                                #        - "ignore": with nothing
                                                #        - STREAM: pipe file descriptor to it (like NUM> FILE)
                                                #        - FD_INT: same with parent file descriptor (like NUM&>FD_INT) (not on Windows)
                                                #        - null|undefined (def): "pipe" for stdin|out|err, "ignore" for others.
                                                #     - can use the following shortcuts STR instead:
                                                #        - "ignore": [ "ignore", "ignore", "ignore" ]
                                                #        - "pipe": [ "pipe", "pipe", "pipe" ]
                                                #        - "inherit": [ 0, 1, 2 ]
                                             12*#  - serialization STR:
                                             12*#     - how to serialize VAL of CHILD_PROCESS.send()
                                             12*#     - either 'json' (def) or 'advanced' (V8.[de]serialize())
                                                #  - shell STR3|BOOL (def: false)
                                                #     - false (def): runs 'STR ...STR2_ARR'
                                                #        - on Windows, only works with `*.exe|com|cmd|bat`
                                                #        - no shell escaping done on either Linux/Windows
                                                #     - STR3: runs 'STR3 -c "STR ...STR2_ARR"'
                                                #        - 'STR3 /d /s /c "STR ...STR2_ARR"' instead if cmd.exe
                                                #     - true: same but using '/bin/sh' (Unix) or ENVVAR ComSpec or 'cmd.exe' (Windows)
                                                #  - windowsVerbatimArguments BOOL:
                                                #     - no shell escaping (Windows only)
                                                #     - def: true if OPTS.shell with 'cmd.exe', false otherwise
                                                #  - argv0 STR (def: STR): process.argv[0]
                                                #     - does not work with node.js binary itself
                                                #     - does not modify `process.title` on Windows
                                                #  - detached BOOL (def: false):
                                                #     - child process will outlive parent
                                                #        - regardless on how parent was terminated: normally, runtime error,
                                                #          programmatic signal, CTRL-C, CTRL-\
                                                #        - on Unix, child process always does, even if `detached: false`, except for `CTRL-C` (in terminal)
                                                #     - create a new process group
                                                #  - windowsHide BOOL (def: false) (Windows only):
                                                #     - if detached true and in terminal:
                                                #        - do not create new terminal window
                                                #        - but cannot use CTRL-C
                                                #Use CHILDPROCESS.ref(), so needs to use unref() if program can exit while CHILDPROCESS is running.
fork(STR[, STR2_ARR][, OPTS])->CHILD_PROCESS    #Same as spawn() but using 'node STR ...STR2_ARR'
                                                #OPTS:
                                                #  - shell: always false
                                                #  - stdio:
                                                #     - def 'inherit'
                                                #     - always add 'ipc' to fourth ARR value
                                                #Extra OPTS:
                                                #  - execPath 'PATH': instead of 'node'
                                                #  - execArgv STR_ARR: arguments passed to execPath (e.g. node CLI flags)
                                                #  - silent BOOL (def: false): same as OPTS.stdio 'pipe'
execFile(STR[, STR2_ARR][, OPTS],               #Same as spawn() but using FUNC() instead of returning CHILDPROCESS.
 FUNC(ERROR, SVAL, SVAL2))->CHILD_PROCESS       #  - SVAL|SVAL2 is stdout|stderr
                                                #Cannot use OPTS: stdio, argv0, detached
                                                #Extra OPTS:
                                                #  - encoding 'ENCODING' (def: 'utf-8')
                                                #  - timeout NUM (def: 0) (in ms)
                                                #  - maxBuffer NUM (def: 200KB): stdout|stderr max size
                                                #  - killSignal 'SIGNAL'|SIGNUM (def: 'SIGTERM'): sent (with CHILD_PROCESS.kill()) on timeout|maxBuffer
exec(STR[, OPTS], FUNC(ERROR, SVAL, SVAL2))
 ->CHILD_PROCESS                                #Same as execFile() but with OPTS.shell def true

spawnSync(...)                                  #Like spawn() except for the following.
                                                #Extra OPTS:
                                                #  - input STDBUFFER: overrides OPTS.stdio[0]
                                                #  - encoding (def: 'buffer')
                                                #  - timeout, killSignal, maxBuffer
                                                #Returns:
                                                #  - pid UINT
                                                #  - stdout|stderr SVAL
                                                #  - output [stdout, stderr]
                                                #  - status NUM: null if killed by signal
                                                #  - signal 'SIGNAL'
                                                #  - error ERROR
exec[File]Sync(...)                             #Like exec[File]() except for the following.
                                                #Extra OPTS: input, stdio, detached, argv0
                                                #Returns SVAL (stdout). Throws on non-0 exit code.

CHILDPROCESS.pid                                #

CHILDPROCESS.stdio[FD_INT]                      #I|OSTREAM for file descriptor FD_INT. null if not 'pipe'
CHILDPROCESS.stdin|out|err                      #Same for 0|1|2

PROCESS|CHILDPROCESS.send                       #Communication:
(VAL[, TCPSOCKET|TCPSERVER][, OPTS]             #  - parent use CHILDPROCESS.on("message") and CHILDPROCESS.send(...)
[, FUNC([ERROR])])                              #  - child use PROCESS.on("message") and PROCESS.send(...)
                                                #Child process must have been created using "ipc" (see above)
                                             12*#See OPTS.serialization above for which VAL type is allowed
                                                #When sending a TCPSOCKET|TCPSERVER, it will be shared between parent and child:
                                                #  - packets will arrive randomly at both
                                                #  - only one needs to listen
                                                #  - for TCPSERVER, both can listen to 'connection' event
                                                #FUNC is fired after sending, before target received.
                                                #If FUNC specified, no 'error' event emitted.
                                                #OPTS:
                                                #  - keepOpen BOOL (def: false): see TCPSOCKET
CHILDPROCESS.on("message",
FUNC(VAL[, TCPSOCKET|TCPSERVER]))               #CHILDPROCESS will not exit until disconnect() is called or parent exits.
CHILDPROCESS.disconnect()                       #Flush all communication, then becomes impossible to do send()
                                                #Do it before exiting.
CHILDPROCESS.connected                          #
CHILDPROCESS.on("disconnect", FUNC())           #
CHILDPROCESS.on("error", FUNC(ERROR))           #When CHILDPROCESS could not spawn() or send|kill|disconnect()
                                                #The exit event might be fired or not after error event.
CHILDPROCESS.on("exit|close",FUNC(UINT,SIGNAME))#UINT is the exit code, SIGNAME the terminating signal.
                                                #Only one of them is always defined, the other is null.
                                                #exit is when process exits, close is when its file descriptors are closed.
                                                #file descriptors don't close if shared by other processes.
process.signalCode                              #Like process.exitCode but for SIGNAME
CHILDPROCESS.kill(['SIGNAL'|SIGNUM])            #Def: "SIGTERM"
CHILDPROCESS.channel                            #Underlying IOSTREAM for send()
                                             14*#Different shape. Can ref|unref()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CLUSTER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GOAL ==>                                        #A single process will only use only one CPU core.
                                                #Using CHILDPROCESS.fork() on the same code to create one child for each CPU
                                                #core.
                                                #Can manage the workers: kill some, manage a pool, etc.
                                                #Work should be done by child processes, master should only manage them.
                                                #Child processes cannot fork() to grandchild processes.
                                                #One common task is to make CHILDPROCESS TCPSERVER.listen(), in which case:
                                                #  - connections will arrive randomly at the child processes listening to
                                                #    the same port.
                                                #    The randomness uses CLUSTER.schedulingPolicy:
                                                #      - CLUSTER.SCHED_RR (def on Unix): improved round-robin
                                                #      - CLUSTER.SCHED_NONE (def on Windows): previous version
                                                #    or use ENVVAR NODE_CLUSTER_SCHED_POLICY "rr|none"
                                                #  - be careful:
                                                #     - listen(TCPSERVER|TCPSOCKET): TCPSERVER|TCPSOCKET must have been sent by master
                                                #       to child, or will create problems
                                                #     - listen({ fd: INT }): looks at parent file descriptor
                                                #  - if UDPSOCKET.bind() or TCPSERVER.listen() OBJ.exclusive true (def: false), socket is not shared
fork([OBJ])                                     #Like CHILD_PROCESS.fork(), but returns a WORKER, which gives extra functions.
                                                #Can fork a separate file for children, but if forking the same file, should
                                                #use if ( CLUSTER.isMaster|Worker ) in beginning of code.
                                                #OBJ is env (def: process.env).
                                                #Options are controlled by CLUSTER.settings, that is available for read once
                                                #CLUSTER.setupMaster(OBJ) has been called to change it (only once):
                                                #  - exec STR: the file the child is forked with (def: process.argv[1])
                                                #  - args STR (def: process.argv.slice(2)): to worker
                                                #  - execArgv STR_ARR (def: process.execArgv): to node
                                                #  - silent BOOL: like CHILDPROCESS.fork() (def: false)
                                                #  - cwd, windowHide: like CHILD_PROCESS.spawn()
                                             12*#  - serialization: like CHILD_PROCESS.spawn()
                                                #  - uid|gid UINT, stdio
                                                #setupMaster() fire 'setup'(OBJ) event
on("fork|online", FUNC(WORKER))                 #Fired when a child process is created|ready to respond.
WORKER.on("online", FUNC())                     #
on("listening", FUNC(WORKER, OBJ))              #Fired when a child process use TCPSERVER.listen().
                                                #OBJ has members { address, port, addressType: "[udp]4|6|-1(Unix socket)" }
WORKER.on("listening", FUNC(OBJ))               #

workers                                         #All WORKER in an OBJ, where the key is the WORKER.id
                                                #Only available in parent process.
worker                                          #Current WORKER. Only available in child processes.
WORKER.id                                       #
WORKER.process                                  #The underlying CHILDPROCESS.
                                                #In a WORKER, can use process.* directly

WORKER.send(VAL[,TCPSOCKET|TCPSERVER][, FUNC()])#
WORKER.on
("message", FUNC(OBJ[, TCPSOCKET|TCPSERVER]))   #
on('message', FUNC(WORKER TCPSOCKET|TCPSERVER,
OBJ))                                           #
WORKER.kill(['SIGNAL'])                         #Calls WORKER.disconnect(), then in:
                                                #  - the parent, sends signal (def: "SIGTERM")
                                                #  - the child processes, exit with error code 0

WORKER.disconnect()->WORKER                     #If listen() was called, don't accept new connections and emit TCPSERVER.close()
                                                #when no more connections (only server connections, not CLIENTREQ, that
                                                #are closed directly).
                                                #Might be useful to use a timeout to kill the WORKER if connections keep on
                                                #living.
disconnect(FUNC())                              #Call disconnect() on all child processes (must be done from parent).
on("disconnect", FUNC(WORKER))                  #Fired when a child process use disconnect()
WORKER.on("disconnect", FUNC())                 #
WORKER.isConnected()                            #
WORKER.isDead()                                 #True if exited of thrown exception
WORKER.exitedAfterDisconnect                    #When WORKER exits, will be false if exited because of an exception, and true
                                                #if because of kill() or disconnect()
on("exit", FUNC(WORKER, UINT, 'SIGNAL'|null))   #Fired when a child process exits.
                                                #UINT is the exit code
WORKER.on("exit", FUNC(UINT, 'SIGNAL'|null))    #
WORKER.on("error", FUNC(ERROR))                 #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        WORKER_THREADS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISOMORPHISM ==>                                 #Inspired by DOM workers but with notable differences

--experimental-worker                           #Must be used
                                             11*#Must not be used

MULTI-THREADING ==>                             #Uses threads not processes, i.e.:
                                                #  - uses OS time slicing i.e.:
                                                #     - long microtasks are processed in several steps
                                                #     - load between threads is balanced by OS
                                                #  - for each time slice, uses any available CPU, i.e. scale to all CPUs
                                                #I.e. good for CPU-intensive tasks (not I/O intensive)


new Worker(SCRIPT[, OPTS])                      #SCRIPT is 'PATH'
                                             12*#or URL with file: scheme
                                         14.9.0*#or URL with data: scheme
                                                #OPTS:
                                                #  - eval BOOL (def: false): use inline 'JAVASCRIPT' instead
                                                #  - workerData VAL:
                                                #     - assigned to WORKER_THREADS.workerData VAL
                                                #     - same possible types as postMessage()
                                             12*#  - transferList VAL:
                                             12*#     - with OPTS.workerData, the VAL2_ARR connected to it
                                             12*#       (like postMessage(OPTS.workerData, OPTS.transferList))
                                             12*#  - argv STR_ARR: process.argv
                                             12*#     - same possible types as postMessage()
                                             11*#  - execArgv STR_ARR (def: process.execArgv)
                                             11*#  - env OBJ (def: process.env)
                                             11*#     - copied
                                             11*#     - can be require('worker_threads').SHARE_ENV, to pass process.env by reference instead
                                             12*#  - resourceLimits OBJ:
                                             12*#     - terminates process if reaches those limits
                                             12*#     - does not include ARRBUFFER
                                             12*#     - OBJ:
                                             12*#        - maxOldGenerationSizeMb NUM: main heap max size
                                             12*#        - maxYoungGenerationSizeMb NUM: recently created objects heap max size
                                             12*#        - codeRangeSizeMb NUM: code max size
                                             12*#        - stackSizeMb NUM (def: 4): stack max size
                                             14*#  - trackUnmanagedFds BOOL (def: false): on exit, automatically call any FD_INT if FS.close() was not called

global.*                                        #In worker, like in parent except process.*:
                                                #  - exit() affects current thread not current process
                                                #  - no abort|chdir|initgroups|set*|umask(VAL)|on('SIGNAL')
                                            <11*#     - no execArgv
                                            <12*#     - no report.*
                                                #  - env|title are read-only
                                                #Worker and parent's global|process.* are distinct.
                                                #Unlike DOM, no concept of WORKERGLOBAL nor "self".

process.stdin|stdout|stderr                     #Worker has different standard streams than parent, but they are piped:
                                                #  - from parent if OPTS.stdin true (def: false)
                                                #  - to parent unless OPTS.stdout|stderr true (def: false)
WORKER.stdin|stdout|stderr                      #Worker's standard streams, available to parent

WORKER_THREADS.isMainThread                     #BOOL. True if is top-level parent.

WORKER_THREADS|WORKER.threadId                  #NUM
                                                #Top-level parent is 0. Then increments for each worker

WORKER.resourceLimits                        12*#Like OPTS.resourceLimits

WORKER.on('online', FUNC())                     #When worker is loaded, just before it starts executing

WORKER.terminate()->PROMISE_EXIT_CODE           #Worker current microtask will be interrupted
                                                #EXIT_CODE will be 1
                                             12*#Async and return a PROMISE

WORKER.on('exit', FUNC(EXIT_CODE))              #When worker ends (including because of uncaught exceptions)

WORKER.on('error', FUNC(ERROR))                 #Uncaught exception within worker.

MESSAGEPORT|WORKER.[un]ref()                    #


WORKER|MESSAGEPORT.postMessage                  #Like DOM except:
 (VAL[, VAL2_ARR])                              #  - child can only use MESSAGEPORT, not global "postMessage()"
                                                #  - VAL2:
                                                #     - can be SHARED_ARRBUFFER
                                             14*#     - can be FILE_HANDLE or crypto KEY
                                                #     - when MESSAGEPORT, VAL must be MESSAGEPORT
WORKER|MESSAGEPORT.on('message', FUNC(VAL))     #Like DOM except:
                                                #  - receive VAL directly, not MESSAGEEVENT
                                                #  - MESSAGEPORT will keep process open until MESSAGEPORT.close|unref()
WORKER|MESSAGEPORT.on
 ('messageerror', FUNC(ERROR))               14*#Like DOM
WORKER.receiveMessageOnPort(MESSAGPORT)->VAL 12*#If there is a message VAL in the queue, return it and remove it from queue.
                                             12*#Otherwise return undefined
WORKER.moveMessagePortToContext              11*#Transfer MESSAGEPORT to another global object COBJ (created by VM.createContext())
 (MESSAGEPORT, COBJ)->MESSAGEPORT2           11*#MESSAGEPORT will become unusable
                                             11*#'message' event listeners are kept
WORKER.markAsUntransferable(VAL2)            14*#If VAL2 is passed to postMessage(), ignore it from the VAL2_ARR

new MessageChannel()
MESSAGECHANNEL.port1|2
MESSAGEPORT.start|close()                       #Like DOM
MESSAGEPORT.on('close', FUNC())                 #

WORKER_THREADS.parentPort                       #Default MESSAGEPORT available in every worker.
                                                #null in parent


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              VM               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ALTERNATIVES ==>                                #When running 'Math.random()'
                                                #Execution time:
                                                #  - as is:  0.000006ms
                                                #  - eval(): 0.0001ms
                                                #  - runIn*Context(): 0.001ms
                                                #     - with SCRIPT: same performance, but can divide between loading (new Script)
                                                #       and executing (SCRIPT.runIn*Context())
                                                #  - spawn(): 1.3ms
                                                #  - Worker(): 6ms
                                                #Security:
                                                #  - as is, eval(): access to current process + context
                                                #  - runIn*Context(): access to current process
                                                #  - Worker(): access to none (providing OPTS.stdin|stdout|stderr true)
                                                #  - spawn(): access to none
                                                #Limits:
                                                #  - as is, eval(): defaults (max call stack, max STR|ARR length)
                                                #  - runIn*Context(): defaults, timeout
                                                #  - Worker(): defaults, seems to crash over 1000 threads
                                                #  - spawn(): defaults, timeout, maxBuffer
                                                #Threads/processes:
                                                #  - as is, eval(), runIn*Context(): same thread|process
                                                #  - Worker(): different thread
                                                #  - spawn(): different process

createContext([CONT_OBJ][, CONT_OPTS])->COBJ    #COBJ is an OBJ with some hidden properties.
                                                #CONT_OBJ is merged in.
                                                #CONT_OPTS:
                                                #  - name STR (def: 'VM Context NUM'): for debugging
                                                #  - origin PROTO://HOST[:PORT] (def: ''): for debugging
                                                #  - codeGeneration:
                                                #     - strings BOOL (def: true): if false, throws on eval() or derivatives (new Function(...), etc.)
                                                #     - wasm BOOL (def: true): if false, throws when trying to compile WASM
                                             14*#  - microtaskMode STR (def: nothing): if 'afterEvaluate':
                                             14*#     - wait for current macrotask to complete, i.e. all microtasks done
                                             14*#     - RUN_OPTS.timeout|breakOnSigint will work microtask-wise, not macrotask-wise
isContext(COBJ)->BOOL                           #Returns true if COBJ

runInContext(STR, COBJ[, RUN_OPTS])             #Like eval() but use context COBJ as unique global environment:
                                                #  - passed by reference.
                                                #  - does not have any other access to caller otherwise,
                                                #    including current caller local scope
                                                #Also:
                                                #  - use current process:
                                                #     - same file descriptors
                                                #     - throw exception in current process
                                                #     - should create a new process first if VM used for security reason.
                                                #  - returns synchronous return value from code STR
                                                #     - but can still inspect COBJ passed by reference for async return value,
                                                #       or pass COBJ.FUNC()
                                                #RUN_OPTS:
                                                #  - filename STR, line|columnOffset NUM: for stack trace error message
                                                #  - displayErrors BOOL (def: true): prints to current stderr any stderr
                                                #    from code
                                                #  - timeout NUM: throw error if timeout
                                                #  - breakOnSigint BOOL (def: false): terminate on SIGINT
                                                #  - cachedData BUFFER:
                                                #     - can also be TYPED_ARR|DATAVIEW
                                                #     - copy of script, to improve load performance
                                                #     - created by SCRIPT.createCachedData()->BUFFER
                                             12*#       or SOURCE_TEXT_MODULE.createCachedData()->BUFFER
                                                #     - V8.cachedDataVersionTag()->NUM:
                                                #        - returns a hash of v8 version, CLI flags and CPU features
                                                #        - to use as cache key
                                                #  - importModuleDynamically('SPECIFIER', PARENT_VMMODULE)->[PROMISE_]VMMODULE:
                                                #     - called on import()
                                                #     - def: throw error
runInNewContext(STR[, CONT_OBJ][, RUN_OPTS])    #Same but automatically use createContext(CONT_OBJ, CONT_OPTS)
                                                #Additional RUN_OPTS:
                                                #  - context*: like CONT_OPTS.*
runInThisContext(STR[, RUN_OPTS])               #Same as runInNewContext(STR, global)

compileFunction('CODE'[, 'PARAM_NAME'_ARR]      #Like new Function() but use OPTS.parsingContext COBJ (def: global)
 [, RUN_OPTS|SCRIPT_OPTS])->FUNC                #RUN_OPTS|SCRIPT_OPTS:
                                                #  - filename, line|columnOffset, cachedData
                                                #  - contextExtensions OBJ_ARR (def: []): objects wrapping COBJ

new Script(STR[, RUN_OPTS])                     #Returns a SCRIPT, i.e. a compiled version of STR:
                                                #  - separates compiling from running STR
                                                #  - every run can be bound to different COBJ
                                                #RUN_OPTS:
                                                #  - displayErrors|timeout|breakOnSigint are specified during run*(...)
                                                #  - others are specified during new Script()
SCRIPT.runIn[New|This]Context(...)              #Same as run*(STR, ...)

VMMODULE                                        #Same as SCRIPT but for ES module
                                                #Must use --experimental-vm-modules
                                                #Creates by new SourceTextModule() and new SyntheticModule()
VMMODULE.link                                   #Specifies the function to resolve SPECIFIERs,
 (FUNC('SPECIFIER', PARENT_VMMODULE))           #I.e. when using import { SPECIFIER } from VMMODULE
 ->[PROMISE_]VMMODULE                           #Must be called only once.
                                                #VMMODULE and PARENT_VMMODULE must have same COBJ
VMMODULE.linkingStatus                          #Can be:
                                                #  - 'unlinked': before VMMODULE.link()
                                                #  - 'linking': during VMMODULE.link()
                                                #  - 'linked': after VMMODULE.link() success
                                                #  - 'evaluating': before VMMODULE.evaluate()
                                                #  - 'evaluated': after VMMODULE.evaluate() success
                                                #  - 'errored': after VMMODULE.link() error
VMMODULE.error                                  #If linkingStatus 'errored', contains link() rejected promise value.
                                                #Otherwise, accessing it throws an exception.
VMMODULE.instantiate()                          #Must be called after VMMODULE.link()
                                                #Might throw if problem importing|exporting
                                                #The function is memoized.
VMMODULE.evaluate([RUN_OPTS])->PROMISE(VAL)     #Runs the code.
                                                #Must be called after VMMODULE.instantiate()
                                                #RUN_OPTS: timeout, breakOnSigint
VMMODULE.url                                    #
VMMODULE.namespace                              #
VMMODULE.dependencySpecifiers                   #All 'MODULE'_ARR imported by that module

new SourceTextModule(STR[, OPTS])               #SOURCE_TEXT_MODULE, child of VMMODULE.
                                                #For regular JavaScript text files.
                                                #OPTS:
                                                #  - context COBJ: reused by every MODULE.run*(...), i.e. cannot be changed
                                                #  - identifier STR (def: 'vm:module(NUM)'): for debugging
                                                #  - line|columnOffset NUM: for stack trace error message
                                                #  - importModuleDynamically(...): see above
                                                #  - initalizeImportMeta(import.meta, VMMODULE):
                                                #     - called during VMMODULE.evaluate()
                                                #     - used to initialize import.meta by modifying it
                                             12*#  - cachedData BUFFER: like VM.runInContext()
new SyntheticModule('VAR'_ARR, FUNC()[,OPTS])12*#SYNTHETIC_MODULE, child of VMMODULE.
                                             12*#Define modules programmatically instead of through source text files.
                                             12*#Used for non-JavaScript modules.
                                             12*#'VAR'_ARR are exported variables.
                                             12*#FUNC() is called on evaluate()
                                             12*#  - with SYNTHETIC_MODULE as `this`
                                             12*#OPTS:
                                             12*#  - context, identifier: like SOURCE_TEXT_MODULE
SYNTHETIC_MODULE.setExport('VAR', VAL)       12*#Define exported variable. Should be done inside constructor FUNC()

measureMemory([OPTS])->PROMISE_OBJ           13*#Returns memory taken by a COBJ
                                             13*#Prints experimental warning
                                             13*#OPTS:
                                             13*#  - context COBJ (def: current one)
                                             13*#  - mode 'summary' (def) or 'detailed'
                                             13*#Returns OBJ:
                                             13*#  - total:
                                             13*#     - jsMemoryEstimate NUM (in bytes)
                                             13*#     - jsMemoryRange [MIN_NUM, MAX_NUM]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CRYPTO             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


setEngine(PATH[, NUM])                          #When using custom OpenSSL or alternative crypto library.
                                                #NUM are or'd flags: ENGINE_METHOD_ALL|RSA|DSA|DH|RAND|ECDH|ECDSA|CIPHERS|
                                                #DIGESTS|STORE|PKEY_[ASN1_]METH|NONE
--openssl-config=FILE
OPENSSL_CONF=FILE ENVVAR                        #

createHash(STR[, OPTS])                         #Returns a HASH, i.e. a IOSTREAM generator: write|read to it to get hashes.
                                                #STR is the algo.
                                                #CRYPTO.getHashes() gives list of supported hashes algos, as STR_ARR:
                                                #includes [EC]DSA, DSS1, MD4|5, RIPEMD, RMD, SHA1|224|256|384|512, Whirlpool
                                                #OPTS:
                                                #  - same as STREAM.Transform(OPTS)
                                             12*#  - outputLength NUM (in bytes)
HASH.copy([OPTS])->HASH2                     12*#Clone. Keep state. Doe snot work if HASH already closed.

createHmac(STR, STDBUFFER|KEY)                  #Same as createHash() but for a HMAC. STR is hash algo. Second argument is the key.
createCipheriv(STR, STDBUFFER|KEY,STDBUFFER|null#Same but for a CIPHER (sym. cipher).
 [, OPTS])                                      #Key must be KEY|TDBUFFER or STR with encoding "binary".
                                                #Third argument is IV. Can be null.
                                                #CRYPTO.getCiphers() gives list of supported sym. ciphers (including mode of
                                                #operation), as STR_ARR: includes AES, Blowfish, Camellia, CAST, DES, DES3,
                                                #DES-X, IDEA, RC2, RC4, SEED,
                                             11*#ChaCha
                                                #OPTS:
                                                #  - any of STREAM.Transform()
                                                #  - authTagLength NUM (def: 16): 4-16 (must be even number)
CIPHER.setAutoPadding(BOOL)                     #If false (def: true), disables padding (PKCS padding).
                                                #Use it for personalized padding, i.e. filling with nulls.
CIPHER.getAuthTag()->BUFFER                     #Returns MAC, for sym. ciphers that produce one ("authenticated
                                                #encryption"), i.e. "GCM" only.
CIPHER.setAAD(BUFFER)->BUFFER2                  #Same but for "additional authenticated data" ("GCM" only)
createDecipheriv(...)
DECIPHER.setAutoPadding(BOOL)                   #Same for decryption.
DECIPHER.setAuthTag(TDBUFFER)                   #
DECIPHER.setAAD(BUFFER)                         #

createDiffieHellman(ARGS)                       #Creates a DIFFIEHELLMAN (used for asym. encryption with HL algo).
                                                #ARGS can be:
                                                #  - NUM[, NUM2]: prime length NUM and generator NUM2 (def: 2).
                                                #  - STDBUFFER[, ENCODING][, NUM|STDBUFFER2[, ENCODING2]]: prime STDBUFFER
                                                #    (def ENCODING: "buffer", can also be "binary|base64") and generator
                                                #    NUM|STDBUFFER2 (def: 2)
DIFFIEHELLMAN.getPrime([ENCODING])->SBUFFER     #
DIFFIEHELLMAN.getGenerator([ENCODING])->SBUFFER #
DIFFIEHELLMAN.generateKeys([ENCODING])->SBUFFER #Creates private and public key, and returns public key.
DIFFIEHELLMAN.getPublic|PrivateKey([ENCODING])
 ->SBUFFER                                      #
DIFFIEHELLMAN.setPublic|PrivateKey
 (STDBUFFER, [ENCODING])                        #
DIFFIEHELLMAN.computeSecret(STDBUFFER           #Creates shared secret by using current private key and other part public key
[, ENCODING][, ENCODING2])->SBUFFER             #STDBUFFER (must have used the same prime and generator)
                                                #ENCODING is other part public key encoding, ENCODING2 shared secret returned.
DIFFIEHELLMAN.verifyError                       #Or'd flags showing warning after initialization among:
                                                #  - CRYPTO.DH_CHECK_P_NOT_SAFE_PRIME
                                                #  - CRYPTO.DH_CHECK_NOT_PRIME
                                                #  - CRYPTO.DH_UNABLE_TO_CHECK_GENERATOR
                                                #  - CRYPTO.DH_NOT_SUITABLE_GENERATOR
getDiffieHellman(STR)                           #Returns a DIFFIEHELLMAN but:
                                                #  - without setPublic|PrivateKey()
                                                #  - according to STR "modp1|2|5|14|15|16|17|18", i.e. prime is constant, but
                                                #    it is faster

createECDH(STR)                                 #Returns ECDH, elliptic curve version of Diffie-Hellman.
                                                #Same as DIFFIEHELLMAN but:
                                                #  - last arg FORMAT "[un]compressed|hybrid" (def: "uncompressed") to generateKeys() and getPublicKeys()
                                                #  - no getPrime(), getGenerator(), verifyError, setPublicKey()
                                                #STR is algo, from CRYPTO.getCurves() as STR_ARR: includes Oakley, brainpool,
                                                #c2tnb, prime, secp, sect, wap-wsg-idm-ecid-wtls
ECDH.convertKey(STDBUFFER, 'ALGO'[, ENCODING]
 [, ENCODING2], FORMAT)->SBUFFER                #Converts public key STDBUFFER to FORMAT

public|privateEncrypt|Decrypt                   #Encrypts/decrypts asym. (RSA) TDBUFFER, with private|public key STR|KEY|OBJ:
 (STR|KEY|OBJ, TDBUFFER)                        #  - key, format, type, passphrase: like createPrivate|PublicKey()
                                                #  - padding: CRYPTO.constants.RSA_NO|PKCS1[_OAEP]_PADDING
                                             12*#  - oaepHash STR (def: 'sha1'): algo for OAEP padding
                                             12*#  - oaepLabel TDBUFFER: label for OAEP padding

generateKeyPair[Sync]('TYPE', OPTS              #Create asym key pair, where SBUFFER is publicKey and SBUFFER privateKey
 [, FUNC(ERROR, SBUFFER, SBUFFER2)])            #'TYPE' is 'rsa', 'dsa', 'ec', 'ed25519', 'ed448', 'x25519', 'x448'
 [->{ publicKey|privateKey }]                12*#or 'dh'
                                                #OPTS:
                                                #  - publicKeyEncoding OBJ (def: produces a KEY):
                                                #     - type 'pkcs1' (RSA only) or 'spki' (prefered)
                                                #     - format 'pem' or 'der'
                                                #  - privateKeyEncoding OBJ (def: produces a KEY):
                                                #     - type 'pkcs1' (RSA only), 'sec1' (EC only) or 'pkcs8' (prefered)
                                                #     - format 'pem' or 'der'
                                                #     - cipher 'ALGO', passphrase STR: encrypt using PKCS#5 2.0
                                                #  (RSA, DSA)
                                                #  - modulusLength NUM: key size (in bits)
                                                #  (RSA)
                                                #  - publicExponent NUM (def: 0x10001): public exponent
                                                #  (DSA)
                                                #  - divisorLength NUM: q size (in bits)
                                                #  (EC)
                                                #  - namedCurve STR: curve name

createPrivate|PublicKey(OPTS|SBUFFER)->KEY   11*#Create asym key pair. OPTS:
                                             11*#  - key SBUFFER or (for 'Public') KEY
                                             11*#  - format 'pem' (def) or 'der': of key
                                             11*#  - type 'pkcs1', 'spki' or (privateKey only) 'sec1': ignored if format 'pem'
                                             11*#  - passphrase SBUFFER (privateKey only)
createSecretKey(BUFFER)->KEY                 11*#Create sym key.

diffieHellman(OPTS)->BUFFER                  12*#Compute Diffie-Hellman secret using OPTS:
                                             12*#  - privateKey KEY
                                             12*#  - publicKey KEY
                                             12*#KEY must be of same type 'dh|ec|x448|x25519'

KEY.type                                     11*#'public|private' (if async) or 'secret' (if sync)
KEY.asymmetricKeyType                        11*#'rsa', 'dsa', 'ec', (if sym key) undefined,
                                             12*#'ed25519', 'ed448', 'x25519', 'x448', 'rsa-pss'
                                             12*#'dh'
KEY.symmetricSize                            11*#Byte length NUM. undefined if async
KEY.export([OPTS])->SBUFFER                  11*#OPTS (if async):
                                             11*#  - type, format, passphrase: like createPrivate|PublicKey()
                                             11*#  - cipher STR

createSign(STR)                                 #Same as createDecipher() but for signing algo STR.
                                                #List can be found with openssl list-public-key-algorithms.
                                                #Includes RSA, DH, DSA, HMAC and CMAC.
                                                #Unless createCipher(), is only a OSTREAM. To read from it, use
                                                #SIGN.sign(SBUFFER|KEY|OPTS[, ENCODING]), where SBUFFER|OPTS|KEY is the private key.
                                                #OPTS:
                                                #  - key, format, type, passphrase: like createPrivateKey()
                                                #  - padding CRYPTO.constants.RSA_PKCS1_[PSS_]PADDING
                                                #  - saltLength NUM, can be:
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_DIGEST: digest size
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_MAX_SIGN
                                             12*#  - dsaEncoding 'der' (def) or 'ieee-p1363'
createVerify(STR)                               #Same for verifying algo STR.
                                                #Like createSign(), is only a OSTREAM.
VERIFY.verify                                   #Read from createVerify()
 (SBUFFER|KEY|OBJ, STDBUFFER[,ENCODING])        #SBUFFFER is a certificate or a RSA|DSA public key in PEM format
                                             11*#or a private key
                                                #OBJ:
                                                #  - padding
                                                #  - saltLength
                                             12*#  - dsaEncoding
                                                #STDBUFFER is the signature.
sign(['ALGO, ']STDBUFFER2, SBUFFER|KEY|OPTS)
 ->BUFFER
verify(['ALGO, ']STDBUFFER2, SBUFFER|KEY|OPTS,
 STDBUFFER)->BUFFER                          12*#Shortcut for createSign|Verify()

Certificate()                                   #Returns CERTIFICATE, used for SPKAC, used to send certificates client-side to
                                                #the server with the HTML5 <keygen>.
CERTIFICATE.verifySpkac(TDBUFFER)->BOOL         #
CERTIFICATE.exportChallenge|PublicKey
(STDBUFFER[, ENCODING])->BUFFER                 #

pbkdf2[Sync](STBUFFER, STBUFFER2, NUM, NUM2,    #Generate a random BUFFER using PBKDF2 with HMAC-SHA1, with first arg being
DIGEST[, FUNC(ERROR, BUFFER)])[->BUFFER]        #the input, second the salt (should be min. 64 bits), NUM the number of
                                                #iterations (should be min. 1000) and NUM2 the final string length.

scrypt[Sync](STDBUFFER, STDBUFFER2, NUM         #Generate a derived key BUFFER using Scrypt.
 [, OPTS][, FUNC(ERROR, BUFFER)])[->BUFFER]     #First arg is the password, second is the salt (should be 16 bytes long), NUM is BUFFER length.
                                                #OPTS:
                                                #  - cost|N NUM (def: 16384): CPU/memory cost. Must be power of 2
                                                #  - blockSize|r NUM (def: 8): block size
                                                #  - parallelization|p NUM (def: 1): parallelization
                                                #  - maxmem NUM (def: 32MB): memory bound.
                                            <12*#    Must be > 128*N*r

randomBytes(NUM[, FUNC(ERROR, BUFFER)])         #Generates random BUFFER of length NUM
                                                #Is cryptographically secure (e.g. from /dev/random)
                                                #If no FUNC, synchronous (returns BUFFER)
randomFill[Sync](TDBUFFER[, NUM[, NUM2]]        #Like randomBytes() but by filling in a TDBUFFER instead, from offset NUM
[, FUNC(ERROR, TDBUFFER)])[->BUFFER]            #(def: 0) with length NUM2 (def: TDBUFFER.lBUFFER.length).
randomInt
 ([UINT, ]UINT2[, FUNC(ERROR, UINT3)])  14.10.0*#Generates random UINT3 from UINT (included, def: 0) to UINT2 (excluded)
randomInt([UINT, ]UINT2)->UINT3         14.10.0*#Is cryptographically secure (e.g. from /dev/random)

getFips()->BOOL                                 #True if Node has been:
                                                #   - built to be FIPS-compliant (by def, is not)
                                                #   - run with node --enable-fips or (same but cannot modify CRYPTO.fips) --force-fips
setFips(BOOL)                                   #

timingSafeEqual(TDBUFFER, TDBUFFER2)->BOOL      #Like TDBUFFER.equals(TDBUFFER2), but protected against timing attacks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ASSERT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSERT                                          #Throws ERROR or ASSERTIONERROR with message 'MESSAGE' if fails.
ASSERT.*(..., 'MESSAGE'|ERROR)                  #Can be always passed as last argument (except ifError()). Def:
                                                #  - [not]equal|ok(): 'VAL ==|!= VAL2'
                                                #  - [not]DeepEqual(): 'VAL [not]DeepEqual VAL2'
                                                #  - fail(): 'Failed'
                                                #  - strictEqual(): diff
                                                #  - others: sentence

ASSERTIONERROR.actual|expected                  #VAL
                                                #With *equal|ok|ifError()
                                                #Does a colored diff
                                                #Only actual with *throws|*rejects()
ASSERTIONERROR.operator                         #'==' (equal|ok()) or '!=' (notEqual()), 'fail' (fail()),
                                                #'throw|doesNotThrow|reject|doesNotReject', 'FUNC' (others)

ASSERT.strict.*(...)                            #Same as ASSERT.*(...) except:
                                                #  - use == instead of ===
                                                #  - when arguments are OBJ, prints an OBJ diff instead of showing them in full

ASSERT.fail()                                   #Always fails

ASSERT.[not]equal(VAL, VAL2)                    #VAL == VAL2
                                             14*#or both NaN
ASSERT.[not]strictEqual(VAL, VAL2)              #Object.is(VAL, VAL2)
ASSERT.[not]deepStrictEqual(VAL, VAL2)          #UTIL.isDeepStrictEqual()

ASSERT[.ok](VAL)                                #VAL === true

ASSERT.ifError(VAL)                             #VAL === null

ASSERT.[doesNot]match(STR, REGEXP)           12*#REGEXP.test(STR)

ASSERT.throws|doesNotThrow(FUNC()[, VAL])       #Function throws
                                                #VAL can be:
                                                #  - TYPE|ERROR: instanceof
                                                #  - FUNC(ERROR)->BOOL
                                                #  - REGEXP: against ERROR.message
                                                #  - OBJ: deep ==
ASSERT.rejects|doesNotReject                    #PROMISE rejection
 (PROMISE[()][, VAL])->PROMISE2                 #Fails if FUNC()->PROMISE throws before returning the PROMISE
                                                #Fails if not using a PROMISE[()]
                                                #PROMISE2 is resolved if test passed

new CallTracker()                            14*#Asserts number of times a FUNC was called.
CALLTRACKER.calls([FUNC][, NUM])->FUNC2      14*#FUNC2 is wrapper around FUNC
                                             14*#Def FUNC: noop
                                             14*#Def NUM: 1
CALLTRACKER.report()->ASSERTIONERROR_ARR     14*#Empty array if none
CALLTRACKER.verify()                         14*#Throw all ASSERTIONERROR_ARR aggregated as one


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONSOLE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONSOLE.*                                       #Like DOM utilities except:
                                                #  - uses UTIL.inspect|format()
                                                #     - with OPTS.colors true, unless inside a WORKER
                                                #  - console.dir(VAL, ...) -> console.log(inspect(VAL, ...))
                                                #  - console.assert() can use format strings
                                                #Includes:
                                                #  - console.clear|count[Reset]|debug|group[Collapsed|End]|profile[End]|timeStamp
                                                #  - console.dirxml()
                                                #  - console.table|timeLog()

new Console(OPTS)                               #Returns CONSOLE, same as console but with different stdout|stderr
new Console(OSTREAM[, OSTREAM2][, BOOL])        #OPTS:
                                                #  - stdout OSTREAM, stdout OSTREAM2
                                                #  - ignoreErrors BOOL (def: true): ignore errors on OSTREAM[2]
                                                #  - colorMode BOOL or 'auto' (def: OSTREAM.isTTY && OSTREAM.hasColors())
                                             11*#  - inspectOptions OPTS: passed to UTIL.inspect()
                                             12*#  - groupIndentation NUM (def: 2): when using console.group*()

STDERR ==>                                      #Uses by:
                                                #  - CONSOLE.warn|error() (not other CONSOLE.*)
                                                #  - unhandled exception or promise rejection
                                                #  - process.emitWarning()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PERF_HOOKS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


performance                                     #Like DOM (see doc), except:
PERFORMANCE                                     #  - different entryTypes:
PERFENTRY.*                                     #     - keep 'mark' and 'measure'
PERFOBSERVER                                    #     - 'timing' PERFORMANCETIMING -> 'nodeTiming' PERFNODETIMING
                                                #     - no 'navigation' PERFORMANCENAVIGATION
                                                #     - also has 'gc', 'function',
                                             12*#       'http' or 'http2' (HTTP request started|done)
                                                #  - no PERFORMANCE.clearMeasures|getEntries*() (but PERFLIST.getEntries*() are kept)
                                                #  - PERFOBSERVER.observe OPTS.buffered BOOL:
                                                #     - if false (def), fire listener callbacks sync
                                                #     - if true, use setImmediate()
                                                #  - PERFOBSERVER is an ASYNCRESOURCE

PERFORMANCE.timeOrigin                          #DOMGLOBALTIME base of DOMLOCALTIME, i.e. when process started.
                                                #Use same logic as process.hrtime() (i.e. arbitrary number),
                                                #but as a DOMETIMESTAMP

PERFORMANCE.nodeTiming                          #PERFNODETIMING, which is a PERFENTRY with:
                                                #  - entryType 'node'
                                                #  - name 'node'
                                                #  - startTime: same as PERFORMANCE.timeOrigin
                                                #  - duration: same as PERFORMANCE.now() - PERFORMANCE.timeOrigin
                                                #Is similar to PERFORMANCENAVIGATION, but for Node
PERFNODETIMING.*                                #The following use same same logic as process.hrtime(), but in ns
PERFNODETIMING.nodeStart                        #Node process started
PERFNODETIMING.v8Start                          #v8 process initialized
PERFNODETIMING.environment                      #Environment initialized
PERFNODETIMING.bootstrapComplete                #End of all require()
PERFNODETIMING.loopStart                        #Start of event loop
PERFNODETIMING.loopExit                         #End of event loop. Not sure when it is not 0
PERFNODETIMING.idleTime                 14.10.0*#How long event loop was idle

PERFORMANCE.eventLoopUtilization        14.10.0*#Measure event loops:
 ([OBJ2][, OBJ3])->OBJ                  14.10.0*#  - from OBJ2 (def: process start)
                                        14.10.0*#  - until OBJ3 (def: now)
                                        14.10.0*#  - where OBJ2|OBJ3 are previous eventLoopUtilization() return values
                                        14.10.0*#OBJ:
                                        14.10.0*#  - active DOMDURATION: event loop active
                                        14.10.0*#  - idle DOMDURATION: inverse
                                        14.10.0*#  - utilization: active / (active + idle)

PERFGCTIMING                                    #PERFENTRY for garbage collector, with:
                                                #  - entryType 'gc'
                                                #  - name 'gc'
                                                #  - startTime
                                                #  - duration DOMTIMESTAMP
                                                #  - kind: constants.NODE_PERFORMANCE_GC_MINOR|MAJOR|INCREMENTAL|WEAKCB (1|2|4|8)
                                             12*#  - flags: constants.NODE_PERFORMANCE_GC_FLAGS_NO|CONSTRUCT_RETAINED|FORCED|
                                             12*#    SYNCHRONOUS_PHANTOM_PROCESSING|ALL_AVAILABLE_GARBAGE|ALL_EXTERNAL_MEMORY|
                                             12*#    SCHEDULE_IDLE (0|2|4|8|16|32|64)

PERFORMANCE.timerify(FUNC)->FUNC                #Make FUNC(...) create a PERFENTRY with:
                                                #  - entryType 'function'
                                                #  - duration: how long FUNC() took
                                                #  - name FUNC.name (without 'timerified ')
                                                #  - startTime DOMLOCALTIME
                                                #Prepend 'timerified ' to FUNC.name
                                                #Does not await return value if it is a PROMISE

monitorEventLoopDelay([OPTS])->HISTOGRAM     11*#Even loop benchmarking, i.e. how long each microtask takes (in ns).
                                             11*#OPTS:
                                             11*#  - resolution NUM (in ms) (def: 10) (min: 1)
HISTOGRAM.enable|disable()->BOOL             11*#Start|stop. Returns false is already started|stopped
HISTOGRAM.reset()                            11*#
HISTOGRAM.min|max
HISTOGRAM.mean|stddev                        11*#Duration NUM (in ns)
HISTOGRAM.percentiles                        11*#Same as a MAP where key is percentile NUM (0-100) and value is duration NUM (in ns)
HISTOGRAM.exceeds                            11*#How many microtasks took more than 1 hour


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             I18N              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ICU DATA                                        #I18n dataset used by:
                                                #  - JavaScript-aware functions: STR.normalize|toLowerCase|toUpperCase(),
                                                #    STR|NUM|DATE.toLocale*(), STR.localeCompare(), Intl, URL,
                                                #    TEXTENCODER|TEXTDECODER
                                                #How many languages are included depends on:
                                                #  - compile-time flag --with-intl=STR:
                                                #     - 'full'
                                                #     - 'small-icu':
                                                #        - supports: STR.normalize|toLowerCase|toUpperCase(), STR.toLocale*(),
                                                #          STR.localeCompare(), URL, BUFFER.transcode()
                                                #        - not supported: Intl, NUM|DATE.toLocale*(), TEXTENCODER|TEXTDECODER
                                                #     - 'system-icu':
                                                #        - same as 'small-icu', except link to ICU dataset dynamically instead
                                                #          of statically
                                                #        - i.e. depends whether OS includes ICU databaset, which most Linux do
                                                #     - 'none': no i18n, and STR.normalize(), Intl and BUFFER.transcode() fail
                                            <13*#  - def: 'small-icu'
                                             13*#  - def: 'full'
                                                #  - ENVVAR NODE_ICU_DATA=FILE
                                                #  - node --icu-data-dir=FILE
                                                #Can use package full-icu to down ICU dataset manually.

process.versions.icu                            #'VERSION'|undefined

ENCODING                                        #Either: ascii, utf8 (def), urf16le|ucs2, base64, hex, binary (actually latin-1)
                                                #For TEXTDECODER|TEXTENCODER, it is different (see DOM doc), and depends on ICU:
                                                #  - always: 'utf-8' (def), 'utf-16le'
                                                #  - if 'small|system-icu': 'utf-16be'
                                                #  - if 'full' ICU: many more (see online doc)

UTIL.TextDecoder|TextEncoder                    #See DOM doc.
TextDecoder|TextEncoder                      11*#
                                             12*#Including TEXTENCODER.encodeInto()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             UTIL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


inspect(VAL[, OBJ])                             #Print function used by repl. Returns as STR.
                                                #OBJ members are:
                                                #  - showHidden BOOL: if false (def), doesn't show non-enumerable properties,
                                                #    except SYMs
                                             12*#    and user-defined prototype properties
                                                #  - depth NUM (def: 2): max recursion (null|Infinity for infinite)
                                      11.0-11.3*#    Def: 20
                                                #  - maxArrayLength NUM (def: 100) (null for infinite)
                                             12*#  - maxStringLength NUM (def: Infinity) (Infinity|null for infinite):
                                                #    truncate any STR with ellipsis
                                                #  - breakLength NUM (def: 60) (can be Infinity): maxlength to print OBJ in multiline
                                                #  - compact BOOL|NUM:
                                                #     - if false:
                                                #        - always print OBJ multiline
                                                #        - break strings that are more than breakLength long
                                             11*#     - if NUM: allows fitting NUM properties in one line (if within breakLength)
                                            <12*#     - def: true
                                             12*#     - def: 3
                                                #  - colors BOOL (def: false)
                                                #  - customInspect BOOL (def: true):
                                                #     - call VAL[SYM](UINT[, OBJ])->STR if it exists
                                                #     - SYM is util.inspect.custom or Symbol.for('nodejs.util.inspect.custom')
                                                #  - showProxy BOOL: if true (def: false), dereference PROXY (to their target)
                                                #  - sorted BOOL (def: false) or FUNC('KEY', 'KEY2')->-1|0|1
                                             11*#  - getters BOOL (def: false) or 'get|set' (only getters with|without a set()):
                                             11*#    show getters values
                                                #Circular references are printed correctly.
                                             12*#  - a pointer to the reference is shown
                                                #Can change inspect.defaultOptions
                                                #require("buffer").INSPECT_MAX_BYTES: number of bytes printed for BUFFER
                                                #(def: 50)
                                             11*#Max output 128MB
inspect.colors                                  #OBJ with members defining colors. styles points category (e.g. number) to
inspect.styles                                  #color category, and colors point color category to color codes.

format(STR[, STR2...])                          #Printf-like FUNC, STR can contain:
                                                #  - "%s": STR
                                                #  - "%d", "%i": INT|BIGINT
                                                #  - "%f": FLOAT
                                                #  - "%j": JSON. Returns '[Circular]' (on the whole return value) if any circular references. Handles toJSON()
                                                #  - "%O": OBJ. Uses UTIL.inspect() with default options
                                                #  - "%o": OBJ. Uses UTIL.inspect() with options: showHidden true, depth 4, showProxy true
                                      11.0-11.3*#    depth 20
                                                #  - "%%": escape
formatWithOptions(OBJ, ...)                     #Like format(...) except if can specify inspect() options OBJ

debug[log](STR)->DEBUG_FUNC                     #
                                         12.9.0*#Can be called debug(...)
DEBUG_FUNC(...)                                 #Like console.error(...) except:
                                                #  - appends STR
                                                #  - noop unless DEBUG_FUNC.enabled true
DEBUG_FUNC.enabled                       12.9.0*#BOOL
                                         12.9.0*#Def: if ENVVAR NODE_DEBUG "STR2,..." (can include *) includes STR

promisify(FUNC(..., FUNC2(ERROR, VAL)))->FUNC   #Transform FUNC so FUNC(...)->PROMISE(ERROR|VAL)
                                                #If calling FUNC(..., FUNC2), FUNC2 still gets called, and PROMISE do not get
                                                #resolved|rejected
                                                #If FUNC throws, PROMISE gets rejected.
                                                #For this to work:
                                                #  - FUNC2 does not have to be last argument in FUNC declaration
                                                #  - but caller must specify all arguments up to FUNC2
                                                #If FUNC[util.promisify.custom] FUNC3 is defined, returns FUNC3 instead.
                                                #  - this is defined for setTimeout|setImmediate(), i.e. can be used even
                                                #    though callback is first parameter
                                             12*#  - util.promisify.custom is also Symbol.for('nodejs.util.promisify.custom')
callbackify(FUNC()->PROMISE)
 ->FUNC(..., FUNC2(ERROR, VAL))                 #Inverse. FUNC will not return PROMISE anymore

isDeepStrictEqual(VAL, VAL2)                    #Does a deep equality
                                                #Does not compare inherited nor non-enumerable properties
                                                #Handles NaN, DATE, REGEXP, MAP|SET, ERROR

inherits(TYPE_FUNC, TYPEPARENT_FUNC)            #Makes TYPE inherits from TYPEPARENT, i.e. executes:
                                                #  TYPE.prototype = Object.create(TYPEPARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE
                                                #Also creates a TYPE.super_ that points to TYPEPARENT
                                                #Since it does not use OBJ in Object.create(), needs to create own static
                                                #members with TYPE.prototype.VAR = VAL


types.isRegExp(VAL)->BOOL                       #True if REGEXP
types.isDate(VAL)->BOOL                         #True if DATE
types.isPromise(VAL)->BOOL                      #True if PROMISE
types.is[Weak]Map|Set(VAL)->BOOL                #True if [WEAK]MAP|SET
types.isNativeError(VAL)->BOOL                  #True if instanceof ERROR
types.isProxy(VAL)->BOOL                        #True if PROXY

types.isArgumentsObject(VAL)->BOOL              #True if arguments

types.isAsyncFunction(VAL)->BOOL                #True if async FUNC

types.isGeneratorFunction(VAL)->BOOL            #True if FUNC *
types.isGeneratorObject(VAL)->BOOL              #True if return value of FUNC * (not just any ITERABLETOR)
types.isMap|SetIterator(VAL)->BOOL              #True if MAP|SET.keys|values|entries|Symbol.iterator()

types.is[Shared|Any]ArrayBuffer[View]|DataView|
 TypedArray|[Big]Int|Uint|Float*Array(VAL)
 ->BOOL                                         #True if [SHARED]ARRAYBUFFER|DATAVIEW|TYPED_ARR|UINT|INT|FLOAT*ARRAY

types.isBoolean|Number|StringObject(VAL)
 ->BOOL                                         #True if new Boolean|Number|String(VAL) (not Boolean|Number|String(VAL))
types.isSymbolObject(VAL)->BOOL                 #True if Object(Symbol(VAL)) (not Symbol(VAL))
types.isBoxedPrimitive(VAL)->BOOL               #True if new Boolean|Number|String(VAL) or Object(Symbol|BigInt(VAL))

types.isModuleNamespaceObject(VAL)->BOOL        #True if OBJ from import * as OBJ
types.isExternal(VAL)->BOOL                     #True if external C/C++ value


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REPORT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--experimental-report                        11*#Must be used
                                             12*#Does not need to be used

process.report.getReport([ERROR])->OBJ       11*#Get debugging information.
                                             11*#Def ERROR is new Error()
                                             11*#Returns OBJ:
                                             12*#(Node 11 returns 'JSON' instead)
                                             11*#  - header:
                                             12*#     - reportVersion 1
                                             11*#     - trigger:
                                             11*#        - 'GetReport': manual call to getReport()
                                             11*#        - 'OnUncaughtException': --report-uncaught-exception
                                             11*#        - 'OnFatalError': --report-on-fatalerror
                                             11*#        - 'OnUserSignal': --report-on-signal
                                             11*#     - event STR:
                                             11*#        - 'JavaScript API': manual call to getReport()
                                             11*#        - 'exception': --report-uncaught-exception
                                             11*#        - 'ERROR_MESSAGE': --report-on-fatalerror
                                             11*#        - 'SIGNAL': --report-on-signal
                                             11*#     - filename 'FILENAME'|null: where file was dumped
                                             11*#     - dumpEventTime 'DATE'
                                             11*#     - dumpEventTimeStamp DATE_NUM
                                             11*#     - commandLine STR_ARR: process.argv
                                             11*#     - processId NUM
                                             11*#     - nodejsVersion 'vVERSION'
                                             11*#     - glibcVersionRuntime|Compiler 'VERSION'
                                             11*#     - componentVersions: process.versions
                                             11*#     - arch: process.arch
                                             11*#     - platform: process.platform
                                             11*#     - release: process.release
                                             11*#     - host: os.hostname()
                                             11*#     - cpus: os.cpus()
                                             12*#     - networkInterfaces: os.networkInterfaces() (except as an OBJ_ARR)
                                             11*#     - cwd process.cwd()
                                             11*#     - osName STR (e.g. 'Linux')
                                             11*#     - osRelease STR (e.g. '4.18.0-16-generic')
                                             11*#     - osVersion 'VERSION' (e.g. '#17-Ubuntu SMP Fri Feb 8 00:06:57 UTC 2019')
                                             11*#     - osMachine STR (e.g. 'x86_64')
                                             11*#     - machine STR: osVersion (not Windows) + hostname
                                             11*#     - wordSize 32|64
                                             11*#  - javascriptStack: message STR, stack STR_ARR
                                             11*#  - nativeStack STR_ARR: same but lower-level
                                             11*#  - javascriptHeap:
                                             11*#     - totalMemory 'NUM'
                                             11*#     - totalCommittedMemory 'NUM'
                                             11*#     - usedMemory 'NUM'
                                             11*#     - availableMemory 'NUM'
                                             11*#     - memoryLimit 'NUM': slightly above availableMemory
                                             11*#     - heapSpaces.read_only|new|old|code|map|[new_]large_object_space:
                                             11*#        - memorySize 'NUM'
                                             11*#        - committedMemory 'NUM'
                                             11*#        - used 'NUM'
                                             11*#        - available 'NUM'
                                             11*#        - capacity 'NUM': used + available
                                             11*#  - libuv OBJ_ARR: pending macrotasks
                                             11*#     - type STR
                                             11*#     - is_active '0|1'
                                             11*#     - is_referenced '0|1'
                                             11*#     - address 'NUM'
                                             11*#     - any type-specific properties
                                             11*#  - environmentVariables OBJ: process.env
                                             11*#  - [uvthreads]resourceUsage:
                                             11*#     - user|kernelCpuSeconds 'NUM'
                                             11*#     - cpuConsumptionPercent 'NUM'
                                             11*#     - fsActivity.reads|writes 'NUM'
                                             11*#     (not uvthreads)
                                             11*#     - maxRss 'INT'
                                             11*#     - pageFaults.IO[Not]Required 'INT'
                                             11*#  - userLimits.TYPE.soft|hard 'NUM|unlimited|'
                                             11*#     - TYPE can be [core_]file_size_blocks|data_seg_size_kbytes|max_locked_memory_bytes|
                                             11*#       max_memory_size_kbytes|open_files|stack_size_bytes|cpu_time_seconds|
                                             11*#       max_user_processes|virtual_memory_kbytes
                                             11*#  - sharedObjects 'PATH'_ARR: shared libraries
process.report.writeReport                   11*#Call process.report.getReport() and dump the file
 (['FILENAME'][, ERROR])->'FILENAME'         11*#Print FILENAME on stderr

--diagnostic-report-*                        12*#Former name of --report-*

process.report.directory
--report-directory DIR                       11*#Def: '', i.e. process.cwd()
process.report.filename                      11*#'FILENAME|stdout|stderr'
--report-filename STR                        11*#Def: '', i.e. 'report.YYYYMMDD.HHMMSS.PID.COUNTER.json'
process.report.compact
--report-compact                             12*#Use JSON.stringify(VAL) instead of JSON.stringify(VAL, null, 2)

process.report.reportOnUncaughtException
--report-uncaught-exception                  11*#BOOL (def: false). Call writeReport() on uncaught exception
process.report.reportOnFatalError
--report-on-fatalerror                       11*#BOOL (def: false). Call writeReport() on process crashing (e.g. out of memory)
process.report.reportOnSignal
--report-on-signal                           11*#BOOL (def: false). Call writeReport() on signal.
process.report.signal
--report-signal SIGNAL                       11*#'SIGNAL' (def: 'SIGUSR2') used with process.report.reportOnSignal



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           PROFILING           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FRAME                                        12*#OBJ:
                                             12*#  - url 'STR': FILE URL
                                             12*#  - scriptId 'NUM': FILE ID
                                             12*#  - functionName 'FUNC.name'
                                             12*#  - lineNumber|columnNumber NUM

--cpu-prof                                   12*#Writes a CPU profiling dump on exit.
                                             12*#Can be loaded in Chrome DevTools `Performance` tab.
                                             12*#Use a sampling approach:
                                             12*#  - keep track of all stack frames
                                             12*#  - run periodic samples, checking which stack frames are executing
                                             12*#File is JSON:
                                             12*#  - nodes NODE_ARR (stack frames):
                                             12*#     - id 'NODE_ID'
                                             12*#     - children 'NODE_ID'_ARR
                                             12*#     - callFrame FRAME
                                             12*#     - hitCount NUM: number of samples where this stack frame was on top
                                             12*#     - positionTicks OBJ_ARR (optional):
                                             12*#        - line NUM: line number
                                             12*#        - ticks NUM: number of samples on that line
                                             12*#  - startTime|endTime NUM (in ns): since machine startup
                                             12*#  - samples 'NODE_ID'_ARR: top stack frame for each sample
                                             12*#  - timeDeltas NUM_ARR (in ns):
                                             12*#     - time between each sample
                                             12*#     - should be approximately same as --cpu-prof-interval
--cpu-prof-dir 'DIR'                         12*#Def: --diagnostic-dir
--cpu-prof-name STR                          12*#Def: 'CPU.YYYYMMDD.HHMMSS.PID.TID.COUNTER.cpuprofile'
--cpu-prof-interval NUM                       12*#NUM (in microsecs). Def: 1000

--heap-prof                                  12*#Writes a heap profiling dump on exit.
                                             12*#Can be loaded in Chrome DevTools `Memory` tab.
                                             12*#File is JSON:
                                             12*#  - head NODE:
                                             12*#     - id 'NODE_ID'
                                             12*#     - children NODE_ARR
                                             12*#     - callFrame FRAME
                                             12*#     - selfSize NUM (in bytes)
                                             12*#  - samples OBJ_ARR:
                                             12*#     - nodeId 'NODE_ID'
                                             12*#     - ordinal NUM (index)
                                             12*#     - size NUM (in bytes)
                                             12*#FRAME: functionName STR, scriptId STR
--heap-prof-dir 'DIR'                        12*#Def: --diagnostic-dir
--heap-prof-name STR                         12*#Def: 'Heap.YYYYMMDD.HHMMSS.PID.TID.COUNTER.heapprofile'
--heap-prof-interval NUM                     12*#NUM (in bytes). Def: 512KB

--diagnostic-dir 'DIR'                       14*#Default value of --cpu-prof-dir|heap-prof-dir|redirect-warnings
                                             14*#Def: PWD


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              V8               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getHeapStatistics()->OBJ                        #OBJ:
                                                #  - total|used_heap_size[_executable] NUM
                                                #  - total_physical|available_size NUM
                                                #  - heap_size_limit NUM
                                                #  - [peak_]malloced_memory NUM
                                                #  - does_zap_garbage BOOL
                                             12*#  - number_of_native|detached_contexts NUM
getHeapSpaceStatistics()->OBJ                   #OBJ:
                                                #  - space_name STR
                                                #  - space_[used|available_]size NUM
                                                #  - physical_space_size NUM
getHeapCodeStatistics()->OBJ                 12*#OBJ:
                                             12*#  - code_and_metadata_size NUM
                                             12*#  - bytecode_and_metadata_size NUM
                                             12*#  - external_script_source_size NUM

setFlagsFromString('--OPT ...')                 #Additional v8 CLI options

serialize(VAL)->BUFFER
deserialize(BUFFER)->VAL                        #Serialize|deserialize according to structured clone algorithm (see JavaScript doc)

NODE_V8_COVERAGE=DIR                            #See v8 coverage doc

getHeapSnapshot()->ISTREAM                   11*#Create a V8 heap snapshot. This serializes the current process|worker state.
                                             11*#Parent|child workers are not included.
                                             11*#This can be used to:
                                             11*#  - restart the process later, or speed up startup time (not implemented yet)
                                             11*#  - inspect memory/heap in Chrome devTools
writeHeapSnapshot(['FILENAME'])->'FILENAME'  11*#Write getHeapSnapshot() to a file in process.cwd()
                                             11*#'FILENAME' defaults to 'Heap-${yyyymmdd}-${hhmmss}-${pid}-${threadId}.heapsnapshot'
--heapsnaphot-signal=SIGNAL                  12*#Do writeHeapSnapshot() on SIGNAL

--use-largepages=STR                         12*#Use page size of 2MiB instead of 4KiB.
                                             12*#Good when lots of random access on large amount of memory
                                             12*#STR can be:
                                             12*#  - 'off' (def)
                                             12*#  - 'silent': silent if fail
                                             12*#  - 'on': warning if fail
