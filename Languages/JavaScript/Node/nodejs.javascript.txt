
          
   NODEJS  
          



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         COMMAND LINE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PURPOSE ==>                                     #Execute JavaScript code server-side
                                                #Based on Chrome JavaScript engine V8

VERSION ==>                                     #10.9.0 (current), 8.11.4 (LTS)

ES6 ==>                                         #Support is documented in JavaScript doc

node[js] [--] [FILE] [FILE_ARGS]                #Command-line
node[js] -e|--eval|-p|--print STR [--] [ARGS]   #nodejs is symlink to node (prefer the later as this is what nvm uses).
                                                #FILE is JavaScript file (def: stdin). Can be - too
                                                #With -e, evaluates STR
                                                #With -p, evaluates STR, and prints last return value.
NODE_OPTIONS=--OPT,... ENVVAR                   #Same as using node --OPT ...
--v8-options                                    #Prints available v8 options.
process.allowedNodeEnvironmentFlags             #Read-only SET with all available NODE_OPTIONS

-i
--interactive                                   #Enters REPL even if stdin does not come from a terminal
-c
--check                                         #Run-dry (syntax check)

#!/usr/bin/env node                             #Shabang to execute a Node file directly with ./FILE

npm                                             #Node packet manager (see doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          EVENT QUEUE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


clear|setTimeout|Interval|Immediate(...)        #Like DOM ones (see DOM doc), but extra members
ID.[un]ref()->ID                                #Yield the macrotask (see JavaScript doc)
ID.refresh()->ID                                #Reset the counter

process.nextTick(FUNC()[, ...])                 #Similar to setImmediate(...) but uses microtask queue instead
                                                #of macrotask one (see JavaScript doc)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          ASYNC HOOKS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TASK_ID                                         #Microtask ID
                                                #Is incrementing counter, with top-level microtask having ID 1
                                                #Specifics:
                                                #  - ID 0 means executed from C++, not JavaScript
                                                #  - PROMISE report parent microtask's, not their actual microtask ID, unless
                                                #    an enabled HOOK exists
                                                #  - async|await (but PROMISE) report parent microtask's, not their actual microtask ID
RESOURCE                                        #Any resource, firing 0, 1 or several microtasks (depends on RESOURCE_TYPE)
                                                #RESOURCE properties depend on RESOURCE_TYPE. They might not be populated yet in init()
RESOURCE_TYPE                                   #Can be:
                                                #  - TickObject: process.nextTick()
                                                #     - properties: callback FUNC, [args 'VAL'_ARR]
                                                #  - Immediate: setImmediate()
                                                #     - properties: _onImmediate FUNC, [_argv 'VAL'_ARR]
                                                #  - Timeout: setTimeout|setInterval()
                                                #     - properties:
                                                #        - _onTimeout FUNC
                                                #        - _idleTimeout NUM
                                                #        - _repeat null|NUM: same but null with setTimeout()
                                                #        - [_timerArgs 'VAL'_ARR]
                                                #  - TIMERWRAP: setTimeout|setInterval()
                                                #  - PROMISE:
                                                #     - on:
                                                #        - new Promise(FUNC), Promise.resolve|reject()
                                                #        - PROMISE.then|catch|finally(FUNC), await PROMISE
                                                #        - calling an async FUNC
                                                #     - properties:
                                                #        - promise PROMISE
                                                #        - isChainedPromise BOOL:
                                                #           - true if resolving|rejecting with another PROMISE2
                                                #           - including await PROMISE, resolve|reject(PROMISE) or
                                                #             return PROMISE in then|catch|finally()
                                                #  - TTYWRAP: console.*
                                                #     - properties: callback FUNC, [args 'VAL'_ARR]
                                                #  - SIGNALWRAP: OS signal
                                                #  - FSEVENTWRAP, FSREQWRAP, GETADDRINFOREQWRAP, GETNAMEINFOREQWRAP, HTTPPARSER,
                                                #    JSSTREAM, PIPECONNECTWRAP, PIPEWRAP, PROCESSWRAP, QUERYWRAP, SHUTDOWNWRAP,
                                                #    STATWATCHER, TCPCONNECTWRAP, TCPSERVER, TCPWRAP, UDPSENDWRAP, UDPWRAP,
                                                #    WRITEWRAP, ZLIB, SSLCONNECTION, PBKDF2REQUEST, RANDOMBYTESREQUEST, TLSWRAP: others

executionAsyncId()->TASK_ID                     #Current microtask
triggerAsyncId()->PARENT_TASK_ID                #Parent microtask, i.e. caller

createHook(OPTS)->HOOK                          #Fires callbacks on new microtasks|resources, using OPTS:
                                                #  - init(TASK_ID, RESOURCE_TYPE, PARENT_TASK_ID, RESOURCE):
                                                #     - when RESOURCE is initialized.
                                                #  - before|after(TASK_ID):
                                                #     - before|after each microtask starts|ends
                                                #     - since some RESOURCE create no microtasks, or several,
                                                #       this might not be called, or be called several times
                                                #  - destroy(TASK_ID): when RESOURCE is destroyed
                                                #  - resolve(TASK_ID):
                                                #     - when a PROMISE is resolved|rejected, including to another PROMISE2
                                                #     - only for RESOURCE_TYPE PROMISE
                                                #Exceptions thrown in callbacks are uncaught exceptions, but cannot be handled.
                                                #Doing async operations (i.e. creating microtasks) inside callbacks:
                                                #  - can cause infinite recursion
                                                #  - this includes console.*(), which can be replaced e.g. by
                                                #    fs.writeSync(1, util.format(VAL))
HOOK.enable|disable()->HOOK                     #HOOK callbacks will only be fired in enabled (disabled by def)

new AsyncResource('RESOURCE_TYPE'[, OPTS])      #Custom RESOURCE
                                                #OPTS:
                                                #  - triggerAsyncId PARENT_TASK_Id (def: executionAsyncId())
                                                #  - requireManualDestroy BOOL: if false (def), calls emitDestroy() when object
                                                #    is garbage collected
ASYNCRESOURCE.runInAsyncScope
 (FUNC[, THIS][, ...ARGS])                      #This is automatically create a new TASK_ID and call 'before|after' events
ASYNCRESOURCE.emitDestroy()                     #
ASYNCRESOURCE.asyncId()->TASK_ID                #
ASYNCRESOURCE.triggerId()->PARENT_TASK_ID       #

node --no-force-async-hooks-checks              #Do not do extra runtime checks related to async hooks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         DEBUGGER (V8)         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HOW TO DEBUG ==>                                #There are three ways: v8 (node --inspect), node --debug and Electron
                                                #Prefer node --inspect

node --inspect[-brk][=[HOST:]PORT] ...          #Launches node ... but with debugger server
                                                #Must then:
                                                #  - go to chrome://inspect and click on a link to open devtools
                                                #  - or directly click on the Node symbol in devtools
                                                #Also forwards console messages
                                                #If -brk, will put breakpoint at first line
                                                #Unless -brk, breakpoints are ignored until a client is connected
                                                #HOST: def 127.0.0.1
                                                #PORT: def 9229, 0 for "any available"
                                                #Difference with node --debug:
                                                #  - only for Chrome devtools as client
                                                #  - but optimized for it, with more features (ES6, async stack, profiling, source
                                                #    maps, workspaces, blackboxing, etc.)
                                                #Note that child processes must be started with node --inspect as well
                                                #Prefered way to debug


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        DEBUGGER (OLD)         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


node --debug[-brk][=PORT] ...                   #Same as node --inspect, but for any client, and exposed on localhost:PORT
                                                #Def PORT: 5858
                                                #Can add --debug flag on the fly to existing node process by sending SIGUSR1
                                                #Should prefer node --inspect when Chrome client is available

node debug -p PID                               #Start debugger CLI client.
node debug URL                                  #Commands:
                                                #  - breakpoints are specified by:
                                                #    - putting breakpoint; in FILE
                                                #    - sb([[FILE, ]LINE_NUM]): by def, current line
                                                #    - sb('FUNC()')
                                                #    - cb(...): clear breakpoints
                                                #  - [un]watch(VAL): watch points
                                                #  - watchers: list watch points
                                                #  - c: continue
                                                #  - n: next
                                                #  - s: step in
                                                #  - o: step out
                                                #  - pause: pause running code
                                                #  - run|restart|kill
                                                #  - repl: open console to execute in current context
                                                #  - bt: call stack
                                                #  - list(NUM): list NUM next lines
                                                #  - scripts: list all FILE
node debug ...                                  #Same as node --debug-brk + node debug

node-inspector                                 ##Start Chrome developer tools debugger client proxy
                                               ##How:
                                               ##  - start debugger server, i.e. node --debug[-brk]
                                               ##  - on same machine, start debugger proxy:
                                               ##     - node-inspector
                                               ##     - if /usr/bin/node not available, make a symlink from /usr/bin/node
                                               ##  - on any machine, visit http://HOST:PORT/debug?port=PORT2 (see options)
                                               ##Uses 'rc' module for configuration
                                               ##Node package (0.12.10).
--web-port PORT                                ##Def: 8080. Port to be listened.
--web-host HOST                                ##Def: 0.0.0.0
--debug-port PORT2                             ##Def: 5858. Listening port.
--save-live-edit                               ##Live edit change files directly
--hidden '["REGEXP",...]'                      ##Files to hide
--no-preload                                   ##Faster boot-time
--inject                                       ##When using debugger extensions
--stack-trace-limit                            ##Def: 50
--ssl-key|cert                                 ##FILE

node-debug ...                                 ##Part of node-inspector package.
                                               ##Same as node --debug-brk ..., followed by node-inspector, then open browser.
                                               ##Same arguments with also:
--[no-]debug-brk                               ##Stop on first line
--cli                                          ##Don't open browser
--nodejs "[...]"                               ##Pass options to NodeJS process


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      DEBUGGER (ELECTRON)      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


IRON-NODE ==>                                  ##Another way to debug is to use Electron.
JAM3 DEVTOOL ==>                               ##Those two apps do this
                                               ##There are many problems I encountered with those, so I prefer node --inspect


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ERROR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ERROR                                           #Are v8 errors, i.e. what follows is shared by Chrome
                                                #See JavaScript doc for more information, including on async stack trace

Error.captureStackTrace(OBJ[, FUNC])            #Adds OBJ.stack, unless already exists
                                                #Automatically done by ERROR, i.e. Error.captureStackTrace(ERROR) is useless
                                                #If FUNC, stops stack frame at FUNC
--stack-trace-limit=NUM
Error.stackTraceLimit                           #Def: 10

Error.prepareStackTrace                         #When set with FUNC(ERROR, CALL_ARR)->'STACK', override how OBJ.stack is get
                                                #Default is something along the lines of:
                                                #  ERROR.name: ERROR.message
                                                #    at [new] CALL.getFunctionName() [as methodName] (LOCATION)
                                                #    at <anonymous> (LOCATION)
                                                #    at eval (PARENT_CALL, <LOCATION2>)
                                                #    at native
                                                #    at uknown location
                                                #    ...
                                                #LOCATION is:
                                                #  (CALL.getFileName():CALL.getLineNumber():CALL.getColumnNumber())
CALL.getFileName()->'FILENAME'                  #
CALL.getEvalOrigin()->'FILENAME'                #Same but when using eval() (or related)
CALL.getScriptNameOrSourceURL()->'FILENAME'     #Same but when using eval() (or related) with //# sourceURL comment
CALL.getFunction()->FUNC                        #undefined in 'strict mode'
CALL.getFunctionName()->'[CLASS.]FUNC|null'     #
CALL.getMethodName()->'FUNC'|null               #
CALL.getThis()->THIS                            #undefined in 'strict mode'
CALL.getTypeName()->STR|null                    #THIS's TYPE
CALL.getLine|ColumnNumber()->NUM                #
CALL.isTopLevel()->BOOL                         #
CALL.isEval()->BOOL                             #From eval() (or related)
CALL.isNative()->BOOL                           #From native C++ code
CALL.isConsructor()->BOOL                       #Using new


NERROR                                          #Node internal error, as opposed to standard JavaScript ERROR
                                                #Often filesystem errors, including permissions
NERROR.syscall                                  #STR
NERROR.errno                                    #UINT
                                                #Can use UTIL.getSystemErrorName(NERROR.errno)->STR to get it as STR.
NERROR.code                                     #STR
NERROR.path                                     #STR, for filesystem errors


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            EVENTS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EventEmitter                                    #Base class of all objects receiving events
                                                #'EVENT' can be a SYM
                                                #Events are emitted synchronously
EVENTEMITTER.on('EVENT', FUNC)->EVENTEMITTER    #
EVENTEMITTER.once('EVENT', FUNC)->EVENTEMITTER  #
EVENTEMITTER.prepend[Once]Listener(...)         #Like on[ce](...) but adds to beginning of listeners list, not end
EVENTEMITTER.off|removeListener('EVENT', FUNC)
  ->EVENTEMITTER                                #
EVENTEMITTER.removeAllListeners(['EVENT'])
  ->EVENTEMITTER                                #
EVENTEMITTER.emit('EVENT'[, ...])->BOOL         #True if there were listeners
                                                #If 'EVENT' is 'error' and there are not listeners, throws instead

EVENTEMITTER.listeners(EVENT)->FUNC_ARR         #
EVENTEMITTER.rawListeners(EVENT)->FUNC_ARR      #Same but also with what Node.js adds, e.g. once() wrapper
EVENTEMITTER.listenerCount(EVENT)->NUM          #Slightly faster than EVENTEMITTER.listeners(STR).length
EVENTEMITTER.eventNames()->'EVENT'_ARR          #
EVENTEMITTER.setMaxListeners(NUM)->EVENTEMITTER #0 for unlim. Beyond max, does not stops adding listeners, only print warning.
EVENTEMITTER.getMaxListeners()->NUM             #
EVENTEMITTER.defaultMaxListeners                #10
EVENTEMITTER.on                                 #Event when a new event handler is added or removed.
 ("new|removeListener", FUNC(EVENT, FUNC2))     #Added|removed FUNC2 might still [not] be in EVENTEMITTER.listeners(EVENT)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GLOBAL             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GLOBAL VARIABLES ==>                            #  - global|GLOBAL|root: global scope reference
                                                #  - clear|setImmediate|Interval|Timeout, Object, URL, console, encodeURI, etc.: JavaScript globals
                                                #  - module, require, exports, __filename, __dirname: module-related globals
                                                #  - process, url: core modules
                                                #  - Buffer: core modules property
                                                #  - all core modules (e.g. http): in CLI only


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


MODULE ==>                                      #Can be:
                                                #  - Node JavaScript file: executes it
                                                #  - JSON file: same as module.exports = JSON.parse('JSON')
                                                #  - machine code file:
                                                #     - must be *.node
                                                #     - loaded by dlopen()
                                                #     - exports available in void init(Handle<Object> exports)
                                                #     - must use libraries: V8, libuv, others
                                                #     - use node-gyp for packaging/compilation
                                                #Decides type with file extension
                                                #Done runtime. See JavaScript modules doc for more info
module                                          #Current MODULE, i.e. file being loaded.
                                                #There are builtin modules, which are the chapters of this doc.

node -r STR                                     #Load file STR:
node --require STR                              #  - 'ID': core module
require(STR)                                    #  - 'FILE' (absolute or relative)
                                                #  - 'DIR' (absolute or relative):
                                                #     - DIR/package.json, using main 'PATH' (relative to DIR)
                                                #     - DIR/index.EXT
                                                #  - 'MODULE':
                                                #     - i.e. anything that does not start with / or .
                                                #     - tries require('DIR2/MODULE'), with DIR2 [.../[..]]./node_modules/
                                                #Paths can omit extensions: .mjs, .js, .json, .node
                                                #If not found, throw ERROR with code "MODULE_NOT_FOUND"
require.resolve(STR[, OPTS])->'ID'              #How [MODULE.]require(STR) would resolve
                                                #OPTS:
                                                #  - paths 'DIR'_ARR: alternative directories to look into
                                                #    Their [.../[..]]./node_modules will always be searched
require.resolve.paths(STR)->'DIR'_ARR           #Directories that would be looked into when [MODULE.]require(STR) would resolve
require.cache[ID]                               #[MODULE.]require(STR) cache (i.e. modules are only loaded once).
                                                #ID is require.resolve(STR) result
                                                #Builtins are not cached.
                                                #Can delete it to remove cache, or restart current code.
MODULE.require                                  #Reference to require

CIRCULAR DEPENDENCIES ==>                       #If a module require its parent:
                                                #  - it will receive its parent current module.exports, even though its parent is not finished loading
                                                #  - it will not execute its parent, since its parent is already loading

SCOPE ==>                                       #Variables are local to each file, except for MODULE.exports
exports                                         #Return value (by reference if OBJ) when required. Must be assigned sync.
                                                #Can be any type.
MODULE.exports                                  #Reference to exports.
                                                #Must be used when want to overwrite, i.e. exports = VAL (as opposed to exports.VAR = VAL)
this                                            #Is, according to ENVVAR NODE_MODULE_CONTEXTS:
                                                #  - 0 (def): module.exports
                                                #  - 1: global

require.main                                    #Root file (first to have been loaded), as MODULE
process.mainModule                              #Same but updated if root file changed at runtime
MODULE.parent|children                          #MODULE[_ARR]|null
MODULE.loaded                                   #False for the first time the file is loaded (i.e. sync)
                                                #True for async functions

__filename                                      #Current file absolute path.
MODULE.filename                                 #Reference to __filename
MODULE.id                                       #For core modules, a string like "buffer". For others, module.filename.
__dirname                                       #Current file absolute dirname

require('module').builtinModules                #List of system 'MODULE'_ARR (e.g. 'http') including internal ones

CLI ==>                                         #require.main, process.mainModule: undefined
                                                #MODULE.loaded: false
                                                #__filename, __dirname: undefined (but MODULE.filename is '$PWD/repl')
                                                #MODULE.id: 'repl'
                                                #exports is undefined (but not MODULE.exports)

import|export ...                               #ES modules
                                                #Must:
                                                #  - use node --experimental-modules
                                                #     - --experimental-vm-modules for use in VM
                                                #  - use FILE.mjs instead of FILE.js
                                                #     - .mjs can require .js, .js can require .mjs only with import()
                                                #Loading:
                                                #  - use same algorithm to find module
                                                #  - PATH are URL (only file: supported), i.e. need to be URI encoded
                                                #No CommonJS, i.e. no require|module|exports|__filename|__dirname
                                                #Not supported yet: import(), no import.meta

DIFFERENCES ==>                                 #Difference from require(), import and import()
                                                #Steps:
                                                #  - resolution (all): resolve PATH to absolute PATH
                                                #  - read file
                                                #  - wrapping:
                                                #     - require(): wrap in anonymous function, with global variables as
                                                #       arguments, i.e.
                                                #       (function(exports, require, module, __filename, __dirname){...})(...)
                                                #     - import[()]: no wrapper, is top-level function
                                                #  - parsing:
                                                #     - require(), import(): normal
                                                #     - import: also find symbols from named imports (import { VAR }) and link
                                                #       them
                                                #  - running|evaluating (all)
                                                #  - cache return value (all)
                                                #Parse-time vs runtime:
                                                #  - require(), import(): everything done runtime
                                                #  - import:
                                                #     - everything done parse-time (except running), running then done runtime
                                                #     - i.e.:
                                                #        - cannot do e.g. export { VAL as [DYNAMIC_VAR] }
                                                #        - also better static analysis
                                                #        - VAR are implicitely const
                                                #Sync vs async:
                                                #  - require(): sync
                                                #  - import: async:
                                                #     - same behavior as if it was sync, since it is parse-time
                                                #     - but means that might go over several loops of the event loop
                                                #  - import(): async with PROMISE
                                                #Top-level:
                                                #  - require(), import(): does not have to be top-level
                                                #  - import: must be top-level

node --loader FILE.mjs                          #Customize the behavior of "import"
                                                #FILE must export OBJ.resolve('PATH', 'URL', FUNC2)->{ url, format }:
                                                #  - called instead of normal import behavior
                                                #     - normal import behavior still available as FUNC2
                                                #  - 'PATH' is relative path
                                                #  - 'URL' is absolute base. Is a URL, e.g. file: protocol with filesystem
                                                #  - url is resolved absolute URL
                                                #  - format can be 'esm' (.mjs), 'cjs' (.js), 'json' (.json), 'addon' (.node),
                                                #    'builtin' (core module) or 'dynamic'
                                                #When returning format 'dynamic', the loading process is customized as well,
                                                #and FILE must export async OBJ.dynamicInstantiate(URL)->{exports, execute(EXPORTS)}:
                                                #  - URL is the resolved absolute URL returned by OBJ.resolve()
                                                #  - exports is the 'VAR'_ARR of exported variables
                                                #  - execute() must call EXPORTS.VAR.get()|set(VAL) to set the value of the
                                                #    exported variables


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        STRING_DECODER         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new StringDecoder(['ENCODING'])                 #Returns DECODER. Def: "utf8"
                                                #Does BUFFER -> STR translation
DECODER.write|end(BUFFER)->STR                  #Adds to current string. If:
                                                #  - it still contains incomplete chars, returns ''
                                                #  - otherwise, resets and returns current string
DECODER.end()->STR                              #Returns current string, but does not reset.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BUFFER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Buffer                                          #Child of Uint8Array (including constructors), with extra methods:
                                                #  - mixes in DATAVIEW flexibility (of changing current type)
                                                #  - better serialization: toString(), toJSON()
                                                #  - can decode STR according to different encodings
                                                #  - can swap bytes, compare bytes
                                                #  - some performance improvements, and some convenience functions

[S][T][D][U][A]BUFFER                           #Means BUFFER|[STR]|[TYPED_ARR]|[DATAVIEW]|[UINT8ARR]|[ARRBUFFER]
BVAL                                            #UINT (like Uint8Array), STR, BUFFER or UINT8ARR

Buffer.isEncoding('ENCODING')->BOOL             #
transcode(UBUFFER, "ENCODING", "ENCODING2")
 ->BUFFER2                                      #Returns BUFFER2 with ENCODING2, based on UBUFFER with ENCODING

new TYPED_ARR(BUFFER)                           #Copy, not reference
                                                #Each single BUFFER BVAL -> a single TYPED_ARR VAL
Buffer.allocUnsafe[Slow](NUM)->BUFFER           #Similar to new TYPED_ARR(NUM)
                                                #Max size is require("buffer").kMaxLength (64 bits on 64 bits architecture)
                                                #Unless "Slow", will reuse preallocated buffer from a pool (i.e. faster)
                                                #if NUM <= Buffer.poolSize (def: 8192) / 2
Buffer.alloc(NUM[, NUM2|SBUFFER[, 'ENCODING']]) #Like Buffer.allocUnsafeSlow(NUM).fill(NUM2|SBUFFER, 'ENCODING') (def: \0),
 ->BUFFER                                       #for security reasons
                                                #If node --zero-fill-buffers, will fill with \0 even Buffer.allocUnsafe[Slow]()
Buffer.from(NUM_ARR)->BUFFER                    #Similar to new TYPED_ARR(NUM_ARR)
Buffer.from(ARRBUFFER, ...)->BUFFER             #Similar to new TYPED_ARR(ARRBUFFER, ...)
Buffer.from(STR[, 'ENCODING'])->BUFFER          #
Buffer.from(BUFFER)->BUFFER                     #Copies
Buffer.concat(UBUFFER_ARR[, UINT])->BUFFER      #Similar to Array.prototype.concat.call(null, ...) but with UBUFFER_ARR
                                                #Providing final length UINT can speed up performance.
BUFFER.buffer                                   #Inherited from UINT8ARR. Reference to underlying ARRBUFFER

Buffer.byteLength(STDABUFFER[, 'ENCODING'])->NUM#Similar to TYPED_ARR.byteLength

Buffer.isBuffer(VAL)->BOOL                      #
BUFFER.equals(UBUFFER2)->BOOL                   #
BUFFER.compare(UBUFFER2[, 4 NUM])->-1|0|1       #Sort comparison. NUMs are UBUFFER2 start|end and UBUFFER start|end
Buffer.compare(UBUFFER, UBUFFER2)->-1|0|1       #Same as BUFFER.compare(UBUFFER2)

BUFFER.toString(['ENCODING'[, ...])->STR        #Like:
                                                #  let decoder = new StringDecoder('ENCODING');
                                                #  decoder.write(BUFFER.slice(...));
                                                #  return decoder.end()
BUFFER.toJSON()                                 #Returns as '{"type": "Buffer", "data": [...]}'

BUFFER.slice(...)->BUFFER                       #Like [TYPED_]ARR, but returns a reference
BUFFER.[last]indexOf(..., 'ENCODING')->NUM      #Like [TYPED_]ARR but:
BUFFER.includes(..., 'ENCODING')->BOOL          #  - VAL is BVAL
BUFFER.fill(...[, 'ENCODING'])                  #  - can use 'ENCODING'

BUFFER.write(STR[, UINT[, UINT2[, 'ENCODING']]])#Writes STR on BUFFER
 ->NUM                                          #UINT is offset (def: 0) and UINT2 is length (def: all)
BUFFER.copy(UBUFFER2[, 3 UINT])->UINT4          #Copies bytes from BUFFER at position UINT to UBUFFER2 from position UINT2 to
                                                #UINT3 (def: UBUFFER2.length)

BUFFER.readFloat|Double|[U]Int8|16|32]LE|BE
(UINT[, BOOL])->VAL                             #Similar to DATAVIEW.get|set* but:
BUFFER.writeFloat|Double|[U]Int8|16|32LE|BE     #  - use LE|BE instead of BOOL argument
(VAL, UINT[, BOOL])                             #  - if BOOL true, faster but no validation of UINT buffer overflow
BUFFER.read[U]Int[LE|BE](UINT, UINT2[, BOOL])
BUFFER.write[U]Int[LE|BE](VAL,UINT,UINT2[,BOOL])#Same but specifies [U]Int size UINT2 (up to 48)

BUFFER.swap16|32|64()->BUFFER                   #Swaps every couple of 1|2|4 bytes. Return value is reference


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STREAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SVAL                                            #UBUFFER or (if setEncoding() called) STR, or null if nothing to read
OBJECT MODE ==>                                 #SVAL is any VAL (except null):
                                                #  - encoding is ignored
                                                #  - both ISTREAM and OSTREAM must be in objectMode
                                                #  - ISTREAM.read() NUM argument is ignored (always 1)

ISTREAM ==>                                     #Input stream. Actually called Readable
                                                #Is an ASYNC_ITERABLE
new STREAM.Readable([OBJ])                      #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. uses BUFFER)
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM:
                                                #     - buffer size (def: 16kb)
                                                #     - on ISTREAM: data available for read but not read yet
                                                #     - on OSTREAM: data not flushed yet
                                                #     - if buffer full, waits
ISTREAM.on("readable", FUNC())                  #New chunks available, or just before "end"
ISTREAM.on("data", FUNC(SVAL))                  #Each new chunk available. Firing FUNC() consumes that chunk.
                                                #Not fired if ISTREAM is empty
ISTREAM.read([UINT])->SVAL                      #Like on("data") but:
                                                #  - sync: waits until chunk available (i.e. prefer on("data"))
                                                #  - specify (max) chunk size UINT (def: all)
                                                #  - SVAL is null if ISTREAM empty
ISTREAM.on("end", FUNC())                       #When all chunks have been read
ISTREAM.on("close", FUNC())                     #When underlying fd is closed (not all ISTREAM close)
ISTREAM.on("error", FUNC(ERROR))                #
ISTREAM.pause|resume()                          #Makes it stop|resume emit "data" events.
ISTREAM.isPaused()                              #
ISTREAM.setEncoding('ENCODING')                 #
ISTREAM.readableHighWaterMark                   #NUM
ISTREAM.readableLength                          #NUM. Number of bytes not read yet
ISTREAM.readableFlowing                         #Can be:
                                                #  - null: when all data has been consumed, or stream has not started been read yet
                                                #  - true: when stream is being read, i.e. after on('data')
                                                #  - false: when stream is being paused, i.e. after pause()
ISTREAM.pipe(OSTREAM[, { end: BOOL }])->OSTREAM #Same as ISTREAM.on("data", sval => OSTREAM.write(SVAL))
                                                #If BOOL true (def), call OSTREAM.end() on ISTREAM.on('end|error') (except on stdout|stderr)
ISTREAM.unpipe([OSTREAM])                       #Stops pipe() (def: all)
ISTREAM.unshift(SVAL)                           #Put last SVAL read back in ISTREAM
ISTREAM.destroy([ERROR])                        #

OSTREAM ==>                                     #Output stream. Actually called Writable
STREAM.Writable([OBJ])                          #Constructor for OSTREAM. OBJ members are:
                                                #  - decodeStrings BOOL: if true (def), decodes to BUFFER before
                                                #    calling underlying OSTREAM._write()
                                                #  - objectMode BOOL: see above
                                                #  - highWaterMark NUM: see above
OSTREAM.write(SVAL[, 'ENCODING'[,FUNC()]])->BOOL#Writes chunks.
                                                #FUNC() is fired when buffered + flushed.
                                                #BOOL:
                                                #  - false if data cannot be buffered anymore (i.e. buffer is full)
                                                #  - i.e. should wait for OSTREAM.once('drain') before writing again
OSTREAM.end(SVAL[, 'ENCODING'[, FUNC()]])
 ->OSTREAM                                      #Same but for final chunk. FUNC is the finish event handler
OSTREAM.destroy([ERROR])                        #
OSTREAM.setDefaultEncoding('ENCODING')->OSTREAM #
OSTREAM.writableHighWaterMark                   #NUM
OSTREAM.writableLength                          #NUM. Number of bytes not flushed yet
OSTREAM.[un]cork()                              #cork() forces buffering to disk, uncork() flushes
                                                #To do when writing a lot of small I/O, to make them all flush at once.
OSTREAM.on("close", FUNC())                     #Like ISTREAM
OSTREAM.on("finish", FUNC())                    #Fired when end() done
OSTREAM.on("[un]pipe", FUNC(ISTREAM))           #Fired by ISTREAM.[un]pipe()
OSTREAM.on("error", FUNC(ERROR))                #

finished(ISTREAM|OSTREAM[,FUNC(ERROR)])->PROMISE#Resolved on:
                                                #  - ISTREAM|OSTREAM: 'close', destroy()
                                                #  - ISTREAM: 'end'
                                                #  - OSTREAM: 'finish'
                                                #  - REQ|RES: 'complete', underlying stream 'finish'
                                                #Rejected on:
                                                #  - most: 'error', premature 'close', or destroy(ERROR)
                                                #  - REQ|RES: 'abort'
ON-FINISHED(REQ|RES, FUNC(ERROR, REQ|RES))     ##Fires FUNC() when it ended because of:
ON-FINISHED.isFinished(REQ|RES)->BOOL          ##  - an ERROR, i.e. IOSTREAM events 'error'
                                               ##  - request|response sent, i.e. IOSTREAM events 'end', 'finish', 'close'
                                               ##Does not work well with CONNECT HTTP method nor Upgrade [C]
                                               ##Prefer Stream.finished()
                                               ##on-finished Node module (2.3.0)
pipeline(ISTREAM|OSTREAM[_ARR]...[,FUNC(ERROR)])#Like finished(STREAM.pipe(STREAM2).pipe(...), ...)
 ->PROMISE                                      #Also if one STREAM errors then other STREAM are closed (with STREAM.abort|destroy())

IOSTREAM ==>                                    #Implement both ISTREAM and OSTREAM. Actually called either:
                                                #  - STREAM.Duplex
                                                #  - STREAM.Transform:
                                                #     - same but where there is a correlation between input and output (ex: crypto, but not HTTP)
                                                #     - only semantic

INHERITING STREAMS ==>                          #To create STREAM child classes, just inherit them and reimplement functions
                                                #_read(), _write[v](), _transform() or _flush() (see online doc), without calling them directly.


process.stdout|err|in                           #OSTREAM|ISTREAM with extra member:
                                                #  - isTTY BOOL: if true, will be a READSTREAM|WRITESTREAM
                                                #Unless used as a pipe, are sync (unless other STREAM which are async by def).


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TTY              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


READSTREAM                                      #Child of TCPSOCKET, but without destroy(), connect event nor *address*
                                                #Instantiated by process.stdin if process.stdin.isTTY true
                                                #Will keep process alive until destroyed.
READSTREAM.isRaw                                #BOOL: raw or character device.
READSTREAM.bytesRead                            #So far
READSTREAM.setRawMode(BOOL)                     #

WRITESTREAM                                     #Same but for process.stdout|stderr
WRITESTREAM.columns|rows                        #UINT
WRITESTREAM.getColorDepth([process.env])->NUM   #Number of bits per channel, 1|4|8|24
WRITESTREAM.on("resize", FUNC())                #

isatty(FD_INT)                                  #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           READLINE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


INTERFACE                                       #Read CLI input and pipe it to output
                                                #I.e. when using stdin and stdout on a terminal, will create a CLI
                                                #If Node prompt is already there, will double output on input
createInterface(OBJ)->INTERFACE                 #OBJ:
                                                #  - input ISTREAM
                                                #  - output OSTREAM
                                                #  - terminal BOOL (def: OSTREAM.isTTY): use READSTREAM|WRITESTREAM
                                                #  - completer(STR[, FUNC(ERROR, ARR)])[->ARR]:
                                                #     - used to tab completion
                                                #     - can be sync or async
                                                #     - ARR: [STR2_ARR, STR]
                                                #        - STR is original string
                                                #        - STR2_ARR are possible matches. If only one left, autocompletes
                                                #  - historySize NUM (def: 30) (0 for none)
                                                #  - removeHistoryDuplicates BOOL (def: false): new history lines that are duplicate
                                                #    of a previous one removes that older one
                                                #  - prompt STR (def: '> ')
                                                #  - crlfDelay NUM (def: 100, cannot be lower): if input reads \r and \n
                                                #    successively but more than NUMms apart, treat them as two newlines, not one
INTERFACE.close()                               #Called by ISTREAM.end(), CTRL-C and CTRL-D.
INTERFACE.on("close", FUNC())                   #

INTERFACE.on("line", FUNC(STR))                 #Fired each time a line is read from ISTREAM.
INTERFACE.write(STR[, OBJ])                     #Prints STR on OSTREAM or, if OBJ { ctrl|meta|shift: true, name: STR },
                                                #on CTRL|META|SHIFT-STR
                                                #Be careful as it will be read by ISTREAM, if ISTREAM and OSTREAM point to same thing (e.g. terminal).
INTERFACE.setPrompt(STR)                        #Change OBJ.prompt (see above)
INTERFACE.prompt([BOOL])                        #Write in beginning of current OSTREAM line the OBJ.prompt
                                                #If line was not empty, will place cursor at character number UINT of prompt (def) or, if true, at end of line.
INTERFACE.question(STR, FUNC(STR2))             #Replace current prompt by STR on OSTREAM, and fires FUNC(STR2) on line event instead of normal line event.
INTERFACE.pause|resume()                        #Pause|resume ISTREAM.
                                                #ISTREAM still accept input but buffers it, and reads it once resumed.
                                                #Also fired by SIGCONT or SIGTSTP (CTRL-Z)
                                                #resume() is also called by write(), prompt() and question()
INTERFACE.on("pause|resume", FUNC())            #
INTERFACE.on("SIGNINT|TSTP|CONT", FUNC())       #

clearScreenDown(WRITESTREAM)                    #
clearLine(WRITESTREAM, NUM)                     #Can be 0 (entire line) or -1|1 (to the left|right of cursor)
cursorTo|moveCursor(WRITESTREAM, NUM, NUM2)     #Move cursor absolutely|relatively
emitKeypressEvents(WRITESTREAM[, INTERFACE])    #Enable OSTREAM.on('keypress')


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             REPL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


start([OBJ])->REPLSERVER                        #Creates a REPLSERVER:
                                                #  - INTERFACE made specifically for Node.js command line:
                                                #     - line event handler is eval()
                                                #     - core modules are loaded by default
                                                #  - this is what is used by node with no FILE.
                                                #If NODE_NO_READLINE envvar is defined to 1, readline is not used.
                                                #OBJ members are:
                                                #  - input|output|terminal|prompt:
                                                #     - like createInterface()
                                                #     - but with defaults process.stdin|stdout
                                                #  - eval(STR, OBJ, FILENAME, FUNC(ERROR, STR)):
                                                #     - function to perform after each line
                                                #        - if ERROR is new Recoverable(ERROR), keep prompt ongoing (e.g. for multiline input)
                                                #     - def is async. wrapper of eval():
                                                #        - STR is command
                                                #        - OBJ is current context (global object)
                                                #        - STR2 is current module.filename
                                                #  - useColors BOOL (def: same as terminal)
                                                #     - can also use ENVVAR NODE_DISABLE_COLORS=1
                                                #  - useGlobal BOOL (def: false): use current context, and not local one
                                                #  - ignoreUndefined BOOL (def: false): if true, doesn't print output when it is undefined
                                                #  - writer FUNC(VAL): output printing, def. is util.inspect
                                                #  - replMode:
                                                #     - can be:
                                                #        - REPL_MODE_STRICT: "use strict"
                                                #        - REPL_MODE_SLOPPY: inverse
                                                #     - def is ENVVAR NODE_REPL_MODE 'sloppy|strict' (def: 'sloppy')
                                                #  - breakEvalOnSigint BOOL: if true (def: false), stops on CTRL-C
REPLSERVER.on("reset", FUNC())                  #When ".clear" is called.
REPLSERVER.on("exit", FUNC())                   #
REPLSERVER.context                              #Global environment, as OBJ
                                                #REPL command ".clear" resets it.


REPL COMMANDS ==>                               #
_                                               #Last expression evaluated
_error                                          #Last uncaught exception
.save FILE                                      #Save all input so far to FILE
.load FILE                                      #Input FILE
.exit
CTRL-D                                          #
.break
CTRL-C                                          #
.editor                                         #Start multiline session
.help                                           #
REPLSERVER.defineCommand('STR', OBJ|FUNC(...))  #Custom commands called .STR
                                                #OBJ:
                                                #  - action(...)
                                                #     - can use REPLSERVER.displayPrompt([BOOL]) to reshow the prompt
                                                #       using INTERFACE.prompt(BOOL)
                                                #     - can call REPLSERVER.clearBufferedCommand() to cancel itself
                                                #  - help STR

NODE_REPL_HISTORY ENVVAR                        #Def: ~/.node_repl_history
NODE_REPL_HISTORY_SIZE ENVVAR                   #Def: 1000


node --experimental-repl-await                  #Allow using await top-level


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DGRAM             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createSocket(STR|OPTS[, FUNC(BUFFER, OPTS)])    #OPTS:
 ->UDPSOCKET                                    #  - type "udp4|6"
                                                #  - reuseAddr BOOL (def: false): make UDPSOCKET.bind() reuse an address already bound
                                                #  - lookup FUNC (def: DNS.lookup)
                                                #  - recvBufferSize|sendBufferSize NUM: in|out buffer size
                                                #STR is OPTS.type
                                                #FUNC is 'message' event handler.
UDPSOCKET.address()                             #{ address, port, family }

UDPSOCKET.bind(OBJ[, FUNC()])                   #Start listening. OBJ:
UDPSOCKET.bind(PORT_NUM[, 'ADDR'][, FUNC()])    #  - port PORT_NUM
                                                #  - address 'ADDR' (def: all available)
                                                #FUNC() is 'listening' event handler
                                                #Program will block until UDPSOCKET.close() is called. Can also use UDPSOCKET.[un]ref()
UDPSOCKET.on("listening", FUNC())               #After bind()
UDPSOCKET.on("message", FUNC(BUFFER, OBJ))      #OBJ is like UDPSOCKET.address()
UDPSOCKET.close([FUNC()])                       #FUNC is close event handler
UDPSOCKET.on("close", FUNC())                   #
UDPSOCKET.on("error", FUNC(ERROR))              #

UDPSOCKET.send                                  #Sends to PORT_NUM, address 'ADDR'.
(SUBUFFER[_ARR][, UINT, UINT2],                 #Payload is first arg, from byte UINT, length UINT2
PORT_NUM, 'ADDR'[, FUNC(ERROR, UINT3)])         #If bind() has not been called, UDPSOCKET gets assigned a random port, and an adress "0.0.0.0"
                                                #When done, fires FUNC: UINT3 is the number of bytes sent.
                                                #Max. SUBUFFER size is the MTU, which must be found with PMTUD.

UDPSOCKET.setRecv|SendBufferSize(NUM)           #
UDPSOCKET.getRecv|SendBufferSize()->NUM         #

UDPSOCKET.setBroadcast(BOOL)                    #
UDPSOCKET.setMulticastLoopback(BOOL)            #
UDPSOCKET.setMulticastInterface(STR)            #
UDPSOCKET.add|dropMembership(STR[, STR2])       #Routing options
UDPSOCKET.set[Multicast]TTL(UINT)               #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              NET              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createServer([OBJ, ][FUNC()])->TCPSERVER        #FUNC is 'connection' event handler
                                                #OBJ:
                                                #  - allowHalfOpen BOOL: see below
                                                #  - pauseOnConnect BOOL (def: false): if true, calls TCPSOCKET.pause()
                                                #on 'connection'

TCPSERVER.listen                                #Makes the TCSERVER:
(PORT_NUM|'PORT'[, 'ADDR'][, UINT][, FUNC()])   #  - listen to PORT_NUM|'PORT':
                                                #     - if 0, random port
                                                #     - can fire 'error' event with ERROR.code "EADDRINUSE" if another process
                                                #       already uses this port.
                                                #  - listen to 'ADDR':
                                                #     - def: INADDR_ANY, i.e. any available IP on the machine will work
                                                #  - UINT:
                                                #     - max number of pending connections, i.e. TCP sent SYN packet, but not
                                                #       ACK yet.
                                                #     - refuse connection if above max.
                                                #     - def: 511 (which is pretty ok)
                                                #     - OS limits are determined by sysctl settings like tcp_max_backlog
                                                #       and somaxconn (which is 511 in my system)
                                                #  - FUNC is 'listening' event hander
                                                #Can only be called once.
TCPSERVER.listen('PATH'[, UINT][, FUNC()])      #Same but by explictely creating a socket at 'PATH' (should be in /tmp)
TCPSERVER.listen(OBJ[, UINT][, FUNC()])         #Same but for either:
                                                #  - { fd: UINT }: with file descriptor, not on Windows
                                                #  - TCPSERVER|TCPSOCKET
TCPSERVER.listen(OBJ[, FUNC()])                 #Same with OBJ:
                                                #  - port, host, path, backlog UINT
                                                #  - readableAll|writableAll BOOL (def: false): file permission for the socket
TCPSERVER.on("listening", FUNC())               #Fired when listen() is called.
TCPSERVER.listening                             #BOOL
TCPSERVER.close([FUNC()])                       #Stops the server from accepting new connections:
                                                #  - keeps existing ones
                                                #  - when existing ones have stopped, emits "close" event
                                                #FUNC is 'close' event listener
TCPSERVER.on("close", FUNC())                   #Fired on TCPSERVER.close()
TCPSERVER.address()->OBJ                        #Returns { port: UINT, address STR, family: "IPv4|6" }
                                                #After listen() has been called
TCPSERVER.[un]ref()->TCPSERVER                  #Yield the macrotask (see JavaScript doc)
                                                #listen() call ref(), and stop() or stop event handlers call unref()

TCPSERVER.on("connection", FUNC(TCPSOCKET))     #Fired when a TCP connection is initiated.
TCPSERVER.on("error", FUNC(ERROR))              #Fired when connection problem. Will fire TCPSERVER.close()
TCPSERVER.maxConnections                        #Def: null
                                                #0|null means no limits.
                                                #Above that, will refuse connections.
TCPSERVER.getConnections([FUNC(ERROR, UINT)])   #Number of connections


connect|createConnection(ARGS[, FUNC()])
  ->TCPSOCKET                                   #Same as new Socket(OBJ) followed by TCPSOCKET.connect(...)
TCPSOCKET                                       #IOSTREAM but:
                                                #  - no readable event, read() or unshift() (but still data event)
                                                #  - nothing about piping
                                                #  - close event handler: FUNC(BOOL): true if close because of error
                                                #  - error event handler: FUNC(ERROR)
new Socket([OBJ])                               #OBJ:
                                                #  - fd: UINT
                                                #  - readable|writable BOOL (def: false): only when fd was used
                                                #  - allowHalfOpen BOOL (def: false):
                                                #     - if true, when other socket closes connection, doesn't automatically
                                                #       call end()
                                                #     - which means:
                                                #        - can still write to it (but non-readable)
                                                #        - must manually call end()
TCPSOCKET.connect(ARGS[, FUNC()])               #ARGS:
                                                #  - OBJ:
                                                #     - port PORT_NUM|'PORT'
                                                #     - host 'ADDR'
                                                #     - localAddress|localPort
                                                #     - path 'PATH' (only for UNIX sockets, only option then)
                                                #     (see DNS.lookup())
                                                #     - family 4|6|null
                                                #     - hints
                                                #     - lookup (def: DNS.lookup())
                                                #  - HOST[, PORT]
                                                #  - "PATH"
                                                #FUNC() is 'connect' event handler.
TCPSOCKET.connecting                            #BOOL: true after connect() but before 'connect' event
TCPSOCKET.on                                    #Fired after hostname resoution, but before TCP connection.
("lookup", FUNC(ERROR, 'IP', VAL, 'HOST'))      #VAL is family 4|6|null
TCPSOCKET.on("connect|ready", FUNC())           #
TCPSOCKET.destroy([ERROR])                      #No more read|write. Only necessary when error happened.
                                                #If ERROR, 'error' event is fired
TCPSOCKET.destroyed                             #BOOL
TCPSOCKET.[un]ref()->TCPSOCKET                  #Like TCPSERVER

TCPSOCKET.setTimeout(UINT[, FUNC()])->TCPSOCKET #Emits timeout event after UINTms of idleness.
                                                #Not emitted after TCPSOCKET is destroyed.
                                                #0 (def) disables.
                                                #By def, timeout handler does not do anything, but can end|destroy()
                                                #FUNC is 'timeout' event handler
                                                #Uses setTimeout(), i.e. done at macrotask level, i.e. might take longer than
                                                #UINTms if long macrotasks.
TCPSOCKET.on('timeout', FUNC())                 #

TCPSOCKET.setKeepAlive(BOOL, UINT)->TCPSOCKET   #Def: false and 0.
                                                #TCP keepalive
TCPSOCKET.setNoDelay(BOOL)->TCPSOCKET           #If false (def), use buffers:
                                                #  - to reduce amount of requests i.e. send data in chunks
                                                #  - more efficient when using a lot of small requests, but can delay them
                                                #  - even disabled, underlying IOSTREAM still use buffer to keep up with
                                                #    high demand
TCPSOCKET.bufferSize                            #Currently buffered size.
                                                #If ever growing, should use pause|resume()
TCPSOCKET.bytesRead|Written                     #So far

TCPSOCKET.address()->OBJ                        #Like TCPSERVER
TCPSOCKET.local|remotePort|Address              #
TCPSOCKET.remoteFamily                          #'IPv4|6'
isIp('ADDR')->0|4|6                             #
isIpv4|6('ADDR')->BOOL                          #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              TLS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getCiphers()->STR_ARR                           #All suite of SSL ciphers are [PREFIX-]ALGO[-HASH]
                                                #ALGO: AES128|256, 3DES, DES, Camellia128|256, IDEA, RC4, SEED
                                                #PREFIX:
                                                #  - ECDH[E]-ECDSA|RSA: for AES, DES, RC4
                                                #  - DH[E]-DSS|RSA: for AES, Camellia, SEED
                                                #  - EDH-DSS|RSA: for DES
                                                #  - PSK: for AES, 3DES, RC4
                                                #  - SRP-[DSS|RSA]: for AES, 3DES
                                                #HASH ([-]#ALGO means ALGO with[out] PREFIX SPK|SRP):
                                                #  - sha: -#AES*, Camellia*, RC4, SEED
                                                #  - gcm-sha256: -#AES128
                                                #  - gcm-sha384: -#AES256
                                                #  - sha256: -#AES*
                                                #  - cbc3-sha: -#DES
                                                #  - cbc-sha: IDEA, #AES
                                                #  - md5: RC4 (unless any PREFIX)
                                                #  - ede-cbc-sha: #DES
                                                #Can be changed with node --tls-cipher-list=LIST
TLSSOCKET.getEphemeralKeyInfo()->OBJ            #Gets information about cipher's (only [EC]DH) use of perfect forward secrecy:
                                                #  - type '[EC]DH'
                                                #  - name STR
                                                #  - size NUM

TLS.createSecureContext(OBJ)->SECURECONTEXT     #OBJ:
                                                #  - key STR[_ARR]|BUFFER|OBJ_ARR:
                                                #     - server private key, in PEM format
                                                #     - OBJ is { pem STR|BUFFER[, passphrase STR] }
                                                #  - cert STR[_ARR]|BUFFER[_ARR]: server certificate, in PEM format
                                                #  - pfx STR[_ARR]|BUFFER[_ARR]|OBJ_ARR:
                                                #     - key+cert+ca in PFX or PKCS12 format
                                                #     - OBJ is { buf STR|BUFFER[, passphrase STR] }
                                                #  - ca STR[_ARR]|BUFFER[_ARR]:
                                                #        - list of root certificates, in PEM format
                                                #        - by def., well-known root CAs
                                                #           - can be extended with NODE_EXTRA_CA_CERTS envvar
                                                #           - are known builtin, either:
                                                #              - node --use-bundled-ca (def): Mozilla CA store
                                                #              - node --use-openssl-ca (def):
                                                #                 - OpensSSL CA store, modified by distributions,
                                                #                   can be modified by ENVVARs
                                                #                 - can use ENVVAR SSL_CERT_DIR=DIR and SSL_CERT_FILE=FILE
                                                #           - can also be augmented with ENVVAR NODE_EXTRA_CA_CERTS=FILE
                                                #        - otherwise, can be used to authorize self-signed certificates
                                                #  - passphrase STR: passphrase used to decrypt the server private key (when a private key is encrypted)
                                                #  - crl STR[_ARR]: CRLs, in PEM format
                                                #  - secureProtocol STR:
                                                #     - "SSLv2|3|TLSv1_[client|server_]method": forces SSL version for client and|or server
                                                #        - no client|server means both
                                                #     - def: uses the best one accepted by client
                                                #  - honorCipherOrder BOOL:
                                                #     - if true, server will choose cipher preference, not client
                                                #     - list is designated by ciphers STR
                                                #     - def: false, but true recommended
                                                #  - ciphers STR:
                                                #     - defaults to "*AES*:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
                                                #     - AES are in order: 128 > 256, SHA384 > SHA256, ECDHE > DHE, RSA > ECDSA
                                                #  - sessionIdContext STR:
                                                #     - STR concatened in front of SSL session ID.
                                                #     - if requestCert is true, it is a MD5 nonce. Otherwise, it is "".
                                                #  - ecdhCurve STR (def: "auto"): for ECDH
                                                #  - dhparam STR|BUFFER: for DH
                                                #  - clientCertEngine STR: OpenSSL engine
                                                #  - secureOptions { CRYPTO.SSL_OP_*: VAL }: OpenSSL options

TLSSERVER                                       #Child of TCPSERVER:
                                                #  - since it inherits from TCPSERVER, can accept TCP connections, not only SSL ones.
                                                #  - all TLSSERVER will fire for both SSL and normal TCP connections.
                                                #Authorization:
                                                #  - if rejectUnauthorized is true:
                                                #     - non-authorized SSL are still accepted (and communication is encrypted)
                                                #     - but can be checked as non-authorized
                                                #  - certificate check will follow CA chain until CA roots:
                                                #  - authorization also checks the domain in certificate === host being connected
createServer(OBJ[, FUNC(TLSSOCKET)])->TLSSERVER #OBJ:
                                                #  - any SECURECONTEXT.* property
                                                #  - requestCert BOOL (def: false): request authentication (with certificate) of other end (i.e. client)
                                                #  - rejectUnauthorized BOOL (def: true): throw error to other end if cannot authentify it
                                                #  - handshakeTimeout (def: 120000, in ms): when timing out, emits tlsClientError
                                                #  - ALPNProtocols SUBUFFER[_ARR]: list of application protocols that can be used, ordered by priority.
                                                #  - SNICallback('HOST', FUNC(ERROR, OBJ)):
                                                #     - when client asks for SNI, calls it with requested server 'HOST'
                                                #        - if success, must call FUNC(null, OBJ2), where OBJ2 is TLSSOCKET.secureContext
                                                #     - can also use TLSSERVER.addContext('HOST', SECURECONTEXT)
                                                #  - sessionTimeout (def: 300, in sec): expiration for TLS identifiers and session tickets
                                                #  - ticketKeys BUFFER: 48 bytes divided in three 16 bytes parts: prefix, HMAC, AES key
                                                #     - can use TLSSERVER.getTicketKeys()->BUFFER and TLSSERVER.setTicketKeys(BUFFER)
                                                #FUNC is 'secureConnection' event handler
TLSSERVER.on("secureConnection",FUNC(TLSSOCKET))#Like TCPSERVER.on("connection"), but for SSL.
                                                #Only fired by SSL connections, not normal TCP ones.
TLSSERVER.on
("tlsClientError", FUNC(ERROR, TLSSOCKET))      #See handshakeTimeout
TLSSERVER.on("newSession",FUNC(ID,DATA,FUNC2()))#Fired when client creates new session: ID is the session ID, DATA the shared secret.
                                                #Must fire FUNC2 when done
TLSSERVER.on("resumeSession",                   #Fired when client wants to resume a session. Must call FUNC2() to do so:
FUNC(ID, FUNC2(ERROR, DATA)))                   #  - DATA is the one stored with newSession event
                                                #  - if no new session, ERROR|DATA should be null

connect([PORT_NUM[,'HOST']]OBJ[,FUNC(TLSSOCKT)])#Like TCP.connect(), but for TLS (client connection). OBJ members are:
  ->TLSSOCKET                                   #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - rejectUnauthorized, ALPNProtocols: like createServer()
                                                #     - except rejectUnauthorized is true by def.
                                                #  - session: like new TLSSocket()
                                                #  - host 'HOST', port PORT_NUM, path 'PATH'
                                                #  - socket TCPSOCKET|IOSTREAM: use an existing TCPSOCKET (host+port can be ommitted then)
                                                #  - servername: for SNI, hostname to choose
                                                #  - checkServerIdentity('HOST', CERT_BUFFER): if throw error, refuse connection
                                                #  - minDHSize NUM (def: 1024)
                                                #  - lookup FUNC: DNS lookup, def: DNS.lookup()
                                                #FUNC is 'secureConnect' event handler
                                                #Returns a TLSSOCKET.

TLSSOCKET                                       #Child of TCPSOCKET, but for SSL.
                                                #Contains other end's authentication status and certificate, providing requestCert: true has been used.
new TLSSocket(TCPSOCKET, OBJ)                   #OBJ:
                                                #  - secureContext SECURECONTEXT or SECURECONTEXT.* directly
                                                #  - requestCert, rejectUnauthorized, ALPNProtocols, SNICallback: like createServer()
                                                #  - session BUFFER
                                                #  - requestOCSP BOOL (def: false):
                                                #     - OCSP is alternative protocol to use CRL
                                                #        - ask to Certificate authority instead of using CRL list
                                                #     - TLSSERVER.on('OCSPRequest', FUNC(BUFFER, BUFFER2, FUNC(ERROR, BUFFER3))):
                                                #        - BUFFER[2] are primary|issuer DER-encoded certificates
                                                #        - BUFFER3: see just below
                                                #     - TLSSOCKET.on('OCSPResponse', FUNC(BUFFER3))
                                                #  - isServer BOOL
                                                #  - server TCPSERVER
TLSSOCKET.on("secureConnect", FUNC())           #Like TCPSOCKET.on("connect"), but for SSL.
TLSSOCKET.getPeerCertificate([BOOL])->OBJ       #OBJ: subject, issuer, valid_to, fingerprint[256], pubkey, etc.
                                                #If true, returns full chain, i.e. OBJ.issuer
TLSSOCKET.encrypted                             #Always true. To distinguish from TCPSOCKET.
TLSSOCKET.authorized                            #False if certificate was not signed by CA specified in ca: STR_ARR
                                                #If false, reason might be given in TLSSOCKET.authorizationError STR
TLSSOCKET.getCipher()->OBJ                      #Current SSL cipher used as { name STR, version STR }
TLSSOCKET.getProtocol()->STR                    #Among 'SSLv3|TLSv1[.1|2]|unknown'
TLSSOCKET.alpnProtocol                          #Protocol selected among ALPNProtocols (see above)
TLSSOCKET.servername                            #For SNI, chosen 'HOST'
TLSSOCKET.renegotiate(OBJ[, FUNC(ERROR)])       #OBJ: rejectUnauthorized, requestCert
                                                #Automatically done after session expires:
                                                #  - TLS.CLIENT_RENEG_LIMIT (def: 3) times every TLS.CLIENT_RENEG_WINDOW (def: 600, in sec),
                                                #to avoid DDoS as it takes resources
TLSSOCKET.disableRenegotiation()                #
TLSSOCKET.setMaxSendFragment(NUM)->BOOL         #Def|max: 16384. Min: 512.
                                                #True on success.
                                                #Smaller: smaller latency but slower.
TLSSOCKET.getSession()->OBJ                     #OBJ: ASN.1 encoded
TLSSOCKET.getTLSTicket()->BUFFER                #
TLSSOCKET.get[Peer]Finished()->BUFFER           #Returns the "Finished" message, i.e. a hash of the handshake


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTP              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STATUS_CODES                                    #{ STATUS_NUM: 'STATUS_NAME', ... }
                                                #Misses 419
METHODS                                         #STR_ARR of HTTP methods, including common ones, WEBDEV and more obscure ones

HTTPSERVER                                      #Child of TCPSERVER
createServer([OPTS, ][FUNC()])->HTTPSERVER      #FUNC is 'request' event handler
                                                #OPTS:
                                                #  - IncomingMessage|ServerResponse FUNC: to replace constructors of REQ|RES
HTTPSERVER.on("request", FUNC(REQ, RES))        #Fired on client request
HTTPSERVER.on("checkContinue", FUNC(REQ, RES))  #Fired on client request with Expect: 100-continue [C]
                                                #If request is ok, should use RES.writeContinue() to sends a 100 status code
                                                #to the client.
HTTPSERVER.on                                   #Fired on client request with CONNECT method
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on                                   #Fired on client request with Upgrade [C]
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Client's body is in BUFFER.
HTTPSERVER.on("clientError",FUNC(ERR,TCPSOCKET))#Fired on connection problem.
                                                #Def: TCPSOCKET.destroy()
                                                #ERR has members:
                                                #  - bytesParsed NUM
                                                #  - rawPacket BUFFER

HTTPSERVER.maxHeadersCount                      #Maximum number of headers incoming (def: 1000, 0 for unlim)

RES|CLIENTREQ.setTimeout(UINT[, FUNC()])        #Call underlying TCPSOCKET.*
RES|CLIENTREQ.on("timeout", FUNC())             #Unless 'timeout' event handler overriden, calls RES|CLIENTREQ.socket.destroy()
HTTPSERVER.setTimeout(UINT[, FUNC()])           #Calls RES.setTimeout(...) on each new RES
                                                #Def: 12000, i.e. 2 mins
HTTPSERVER.timeout                              #Same
HTTPSERVER.on("timeout", FUNC(RES))             #Called when any RES 'timeout' event is fired

HTTPSERVER.keepAliveTimeout                     #Keep TCPSOCKET NUMms (def: 5000) after RES.end() was called, so it can be
                                                #reused if a new request from same host arrives.
                                                #0 to disable.
                                                #It is different from REQ|CLIENTREQ|HTTPSERVER.timeout:
                                                #  - HTTPSERVER.timeout is for idleness while request is ongoing
                                                #  - HTTPSERVER.keepAliveTimeout is for idleness between requests
                                                #Is not Keep-Alive: timeout=NUM [S] but behaves like if Keep-Alive: timeout=NUM [C]
                                                #was specified (although that header does not exist).
                                                #As long as TCPSOCKET is opened, TCPSOCKET.unref() won't be called, keeping the
                                                #server open.

CLIENTREQ.NoDelay|SocketKeepAlive(...)          #Call underlying TCPSOCKET.*

REQ                                             #ISTREAM, reading the body
REQ.httpVersion[Major|Minor]                    #
REQ.method                                      #"GET|DELETE|..." (not for CLIENTREQ's REQ)
REQ.url                                         #STR (not for CLIENTREQ's REQ). Does not include origin
REQ.headers                                     #As { VAR: 'VAL'[_ARR] ... }. Normalized:
                                                #  - 'VAR' lowercase
                                                #  - duplicates:
                                                #     - common ones are merged as 'VAL'
                                                #     - Set-Cookie: 'VAL'_ARR
                                                #     - others are joined with ','
REQ.rawHeaders                                  #As [ 'VAR', 'VAL', ... ]. Not normalized
REQ.[raw]trailers                               #Same for trailer headers
REQ.statusCode|Message                          #Only for CLIENTREQ's REQ
REQ.socket                                      #TCPSOCKET
REQ.flush()                                     #Send the headers right away, instead of trying to send in same TCP packet
                                                #as body.
                                                #Useful if headers are given quickly but body retrieval takes time.
REQ.on('aborted', FUNC())                       #Aborted by client
REQ.aborted                                     #BOOL

RES                                             #OSTREAM, writing the body:
                                                #  - headers must be set first
                                                #  - write() sends to client
                                                #  - end() finishes
                                                #Automatically create following headers:
                                                #  - Date [S] (if RES.sendDate true (def))
                                                #  - Connection: keep-alive [S]
                                                #  - Transfer-Encoding: chunked [S]
RES.on("close", FUNC())                         #Fired if closed before end() was called
RES.headersSent                                 #True if headers are sent
RES.finished                                    #True if all sent (i.e. after end())
RES.statusCode|Message                          #If statusMessage not set, use STATUS_CODES[statusCode]
RES.setHeader('VAR', 'VAL'[_ARR])               #'VAL'_ARR: same as doing setHeader() several times.
RES.getHeader('VAR')->'VAL'[_ARR]               #
RES.getHeaderNames()->'VAR'_ARR                 #
RES.getHeaders()->OBJ                           #
RES.hasHeader('VAR')->BOOL                      #
RES.removeHeader('VAR')                         #
RES.writeHead(STATUS_NUM[, 'STATUS_NAME'][,OBJ])#Sets RES.statusCode|Message|headers (must be done only once)
RES.addTrailers(OBJ)                            #Add trailing header fields, i.e. between write() and end() of the body.
                                                #Do not forget Trailer [C] at beginning of response
RES.writeProcessing()                           #Send 102 response

ON-HEADERS(RES, FUNC())                        ##Fires FUNC() (with RES as this) just before RES starts sending headers
                                               ##Node module 'on-headers' (1.0.1)

CLIENTREQ                                       #Outgoing HTTP request (as opposed to incoming)
                                                #OSTREAM (like RES)
                                                #Headers:
                                                #  - Content-length [C]: only compatible with utf8 encoding for write()
                                                #  - Expect: 100-continue [C]:
                                                #     - call end() right away
                                                #     - should set a timeout
                                                #     - and listen to 'continue' event
                                                #  - default:
                                                #     - all:
                                                #         Host: HOST:PORT [C]
                                                #         Connection: keep-alive [C]
                                                #     - not GET|HEAD:
                                                #         Transfer-Encoding: chunked [C]
request(['URI'|URI][, OBJ][, FUNC(REQ)])        #Sends a HTTP request.
 ->CLIENTREQ                                    #OBJ:
                                                #  - protocol STR (def: 'http:')
                                                #  - host[name] STR (def: "localhost")
                                                #     - prefer hostname
                                                #     - will fire exception if non existing
                                                #  - family 4|6 (def: both)
                                                #  - port PORT_NUM (def: 80)
                                                #  - socketPath STR: incompatible with host[name] and port
                                                #  - localAddress STR
                                                #  - method STR (def: "GET")
                                                #  - path STR (def: "/"): including hash and query string
                                                #  - headers OBJ
                                                #  - auth STR: e.g. "auth:password"
                                                #  - agent AGENT|false (def: globalAgent)
                                                #  - keepAlive[Msecs]: see AGENT
                                                #  - createConnection(...): see AGENT
                                                #  - timeout NUM
                                                #FUNC is 'response' event handler.
get(['URI'|URI][, OBJ][, FUNC(REQ)])            #Same but use method "GET" and automatically calls OSTREAM.end()
CLIENTREQ.on("socket", FUNC(TCPSOCKET))         #Fired when socket is created to send the request.
CLIENTREQ.on("response", FUNC(REQ))             #Response of the server.
                                                #REQ must be read, no matter what.
CLIENTREQ.on("continue", FUNC())                #Fired when server responds with Expect: 100-continue [S]
CLIENTREQ.on("checkExpectation",FUNC(REQ, RES)) #Fired when server responds with Expect [S], except Expect: 100-continue [S]
CLIENTREQ.on("information", FUNC(OBJ))          #Fired when server responds with 1** (excluding 101)
                                                #OBJ: statusCode STR
CLIENTREQ.on
("connect", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds to a CONNECT request
CLIENTREQ.on
("upgrade", FUNC(REQ, TCPSOCKET, BUFFER))       #Fired when server responds with Upgrade [S]
CLIENTREQ.abort()                               #
CLIENTREQ.on('abort', FUNC())                   #Aborted by client, i.e. CLIENTREQ.abort()
CLIENTREQ.on('aborted', FUNC())                 #Aborted by server
CLIENTREQ.flushHeaders()                        #Like REQ.flush()

AGENT                                           #Socket pools manager for CLIENTREQ (not REQ|RES)
new AGENT(OBJ)                                  #OBJ is:
                                                #  - maxSockets NUM (def: Infinity):
                                                #     - max busy + free sockets per host.
                                                #     - increasing just affect pooling, i.e. more memory used but faster
                                                #     - but does not affect max. number of sockets per host (unlim.)
                                                #  - maxFreeSockets NUM (def: 256):
                                                #     - max free sockets.
                                                #     - only relevant if keepAlive true
                                                #  - keepAlive BOOL (def: true): keep free sockets opened for use
                                                #  - keepAliveMsecs NUM (def: 1000)
                                                #  - timeout NUM
AGENT.max[Free]Sockets                          #
AGENT.[free]sockets                             #Current TCPSOCKET_ARR
AGENT.requests                                  #Current REQ_ARR, not assigned to sockets yet.
AGENT.destroy()                                 #To do to destroy free sockets if keepAliveMsecs high, to avoid hanging.
AGENT.keepSocketAlive = FUNC(TCPSOCKET)         #Override function fired on new free socket.
                                                #Def: TCPSOCKET.setKeepAlive(true, keepAliveMsecs); TCPSOCKET.unref(); return true;
AGENT.reuseSocket = FUNC(TCPSOCKET, CLIENTREQ)  #Override function fired when free socket is being picked.
                                                #Def: TCPSOCKET.ref();
AGENT.getName(OBJ)                              #Returns OBJ (host, port, localAddress) as unique ID STR
AGENT.createConnection(...)->IOSTREAM           #Same as TCP createConnection(), but can be customized and use any IOSTREAM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             HTTPS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


HTTPS ==>                                       #Has exactly same members as HTTP except:
                                                #  - createServer(OBJ[, FUNC]): OBJ is same as TLS|HTTP.createServer()
                                                #  - all members:
                                                #      - inherit from HTTP, e.g. HTTPSSERVER inherits HTTPSERVER
                                                #      - use TLS* objects instead of TCP*, e.g. TLSSERVER <- TCPSERVER, TLSSOCKET <- TCPSOCKET, etc.
                                                #      - as such, can be used as HTTP server too
                                                #  - to provide TLS OBJ members (same as tls.connect(OBJ), e.g. key, cert, etc.) to connect(...):
                                                #     - use a custom AGENT, and provide AGENT.options


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              URL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NODE_URI                                        #Prefer URI
                                                #OBJ:
                                                #  - protocol STR|null
                                                #  - slashes BOOL: if AUTHORITY starts with //
                                                #  - auth STR|null
                                                #  - host STR|null
                                                #  - port STR|null
                                                #  - hostname STR|null
                                                #  - pathname 'PATH'|null
                                                #  - path 'PATH?QUERY'|null
                                                #  - search '?QUERY'|QUERY_OBJ|null
                                                #  - query 'QUERY'|null
                                                #  - hash '#HASH'|null
                                                #  - href 'URI'
parse('URI'[, BOOL[, BOOL2]])->NODE_URI         #BOOL: if true (def: false), NODE_URI.search is QUERY_OBJ
                                                #BOOL2: if true (def: false), protocol can be omitted

resolve('BASE_URI', 'RELATIVE_URI')->'URI'      #
resolveObject('BAS_URI','RELATIV_URI')->NODE_URI#

URI                                             #As opposed to NODE_URI, is isomorphic, i.e. same as in browser (see DOM doc)
new URL("URI"[, URI2|'URI2'])->URI              #See DOM doc
format(URI[, OPTS])->'URI'                      #OPTS:
                                                #  - auth BOOL: if false (def: true), ignores username|password
                                                #  - fragment BOOL: if false (def: true), ignores hash
                                                #  - search BOOL: if false (def: true), ignores search
                                                #  - unicode BOOL: if false (def), uses Punycode. Otherwise, URI encoding

ORIGIN                                          #OBJ: scheme STR|null, host STR|null, port STR|undefined, domain STR|null
originFor(...)->ORIGIN                          #Like URL constructor, but returning ORIGIN instead


domainToASCII(STR)->STR2
domainToUnicode(STR)->STR2                      #IDN from|to Punycode


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          QUERYSTRING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


stringify(QUERY_OBJ[, STR[, STR2[, OPTS]]])     #'QUERY' is escaped
  ->'QUERY'                                     #STR is separator (def: '&'), STR2 delimiter (def: '=')
                                                #ARR is serialized as several VARs
                                                #OPTS:
                                                #  - encodeURIComponent(...) (def: escape(...)): customize escaping
parse('QUERY'[, STR[, STR2]][, OPTS])->QUERY_OBJ#Inverse.
                                                #OPTS:
                                                #  - maxKeys NUM (def: 1000, 0 for unlim)
                                                #  - decodeURIComponent(...) (def: unescape(...)):
                                                #     - customize escaping
                                                #     - transforms + to spaces (instead of escaping)
                                                #Note: QUERY_OBJ does not inherit from OBJ
[un]escape(STR)                                 #Same as en|decodeURIComponent(), but can be overriden to change stringify|parse() behavior

QS ==>                                         ##See QS module for more features


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              DNS              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DIFFERENCE ==>                                  #DNS.resolve*|reverse() and DNS.lookup*() are similar but:
                                                #  - resolve*|reverse(): use C-Ares, a fast library for DNS resolution, which does DNS query directly.
                                                #  - lookup*():
                                                #     - uses getaddrinfo(), which is slower.
                                                #     - it uses underlying OS, i.e. how DNS resolution would behave on that system (e.g. /etc/hosts)
                                                #     - it is used by http.*, tcp.* and udp.* modules.
                                                #Resolving manually the host can give better performance.

lookup('HOST'[, OBJ], FUNC(ERROR, 'HOST', STR4))#DNS forward lookup.
                                                #STR4 is family: 4 (IPv4), 6 (IPv6) or null (both).
                                                #OBJ:
                                                #  - family 4|6|null
                                                #  - hints NUM: or'd flags among:
                                                #     - DNS.ADDRCONFIG
                                                #     - DNS.V4MAPPED: if look for IPv6 but none found, return IPv4 mapped as IPv6
                                                #  - all BOOL: if true (def: false), return all address as STR4_ARR, not only first one
                                                #  - verbatim BOOL: if false (def), reorder IPv4 before IPv6
                                                #The ERROR.name can correspond to several DNS.*, like DNS.NOTFOUND, DNS.NODATA, DNS.NOMEM, etc. (see online doc)
lookupService
(IP, PORT, FUNC(ERROR, 'HOST', 'SCHEME'))       #

new Resolver()                                  #RESOLVER
                                                #In following methods, if RESOLVER is missing, use builtin RESOLVER
[RESOLVER.]resolve
 ('HOST'[, STR2], FUNC(ERROR, VAL_ARR))         #Same as lookup() but STR2 can any PTR record type: "A" (def), "AAAA", "MX", "TXT", "SRV", "PTR", "NS", "CNAME", "SOA", "NAPTR" or "ANY" (guesses)
[RESOLVER.]resolveSTR2                          #Same. STR2 is camelcase, and "A"|"AAAA"->4|6
 ('HOST', [OBJ, ]FUNC(ERROR, VAL_ARR))          #OBJ (only with records "A"|"AAAA"):
                                                #  - ttl BOOL: if true (def: false), VAL is { address STR, ttl NUM }
[RESOLVER.]reverse('IP', FUNC(ERROR,'HOST'_ARR))#DNS reverse lookup.

[RESOLVER.]setServers('IP[:PORT]'_ARR)          #Sets list of servers IP to use for DNS resolution
[RESOLVER.]getServers()->'IP[:PORT]'_ARR        #List of servers

RESOLVER.cancel()                               #Cancel all current resolve*|reverse() calls, with ERROR with code 'ECANCELLED'

promises.*(...)                                 #Like DNS.*(...) except returns PROMISE and no RESOLVER.cancel()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              OS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


tmpdir()->STR                                   #e.g. "/tmp"
homedir()->STR                                  #e.g. "/home/user"
endianness()->STR                               #"BE" or "LE"
hostname()->STR                                 #e.g. "ether-laptop"
type()->STR                                     #e.g. "Linux"
platform()->STR                                 #e.g. "linux"
release()->STR                                  #e.g. "3.11.0-14-generic"
arch()->STR                                     #e.g. "x64"
uptime()->DOUBLE                                #In seconds
loadavg()->DOUBLE_ARR                           #For last 1, 5 and 15 minutes. Not for Windows.
totalmem|freemem()->NUM                         #RAM
cpus()->OBJ_ARR                                 #OBJ:
                                                #  - model STR
                                                #  - speed UINT (MHz): varies with the load
                                                #  - times OBJ, ms spent by CPU on each member since uptime: user, sys, idle,
                                                #    nice, irq
networkInterfaces()->OBJ_ARR                    #OBJ:
                                                #  - key is interface name ("lo", "wlan0", etc.)
                                                #  - value is OBJ2_ARR, with OBJ2:
                                                #     - address 'IP'
                                                #     - netmask 'MASK'
                                                #     - cidr 'IP/MASK'
                                                #     - family "IPv4|6"
                                                #     - mac STR
                                                #     - internal BOOL (true if boucle local)
                                                #     - scopeid NUM
userInfo([OBJ])->OBJ2                           #OBJ2:
                                                #  - uid|gid NUM (-1 on Windows)
                                                #  - username 'USER'
                                                #  - homedir 'PATH'
                                                #  - shell 'PATH' (null on Windows)
                                                #OBJ: encoding 'utf8' (def) or 'buffer'
EOL                                             #"\n" or "\r\n"
constants                                       #OBJ: errno.ERROR NUM, signals: SIGNAME NUM

setPriority([PID, ]NUM)                         #Sets OS process scheduling priority ("niceness").
                                                #If 0 (def), current process
                                                #NUM is between -20 (high priority) and 19 (low priority) or using constants:
                                                #  - constants.PRIORITY_LOW: 19
                                                #  - constants.PRIORITY_BELOW_NORMAL: 10
                                                #  - constants.PRIORITY_NORMAL: 0
                                                #  - constants.PRIORITY_ABOVE_NORMAL: -7
                                                #  - constants.PRIORITY_HIGH: -14
                                                #  - constants.PRIORITY_HIGHEST: -20
getPriority([PID])->NUM                         #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PATH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PATH ==>                                        #All these functions look at PATH without caring if file exists.
normalize('PATH')->'PATH'                       #Normalize ".", ".." and extra "/"
join('PATH',...)->'PATH2'                       #Concat paths, by adding|removing "/" in-between, and normalize()
resolve('PATH',...)->'PATH2'                    #Like doing several cd 'PATH' from current directory:
                                                #  - can be fictional DIR
                                                #  - 'PATH' can be relative or absolute
                                                #  - 'PATH2' is final DIR, normalized()
relative('PATH', 'PATH2')->'PATH3'              #Show path to go from absolute PATH to absolute PATH2.
isAbsolute('PATH')->BOOL                        #
dirname('PATH')->'DIR'                          #
basename('PATH'[, 'EXT'])->'FILE'               #
extname('PATH')->'EXT'                          #Including '.'

parse('PATH')->PATH_OBJ                         #PATH_OBJ: root STR, dir STR, base STR, ext STR, name STR
format(PATH_OBJ)->'PATH'                        #Inverse

sep                                             #"/" or "\\"
delimiter                                       #":" or ";"
posix|win32.*                                   #Like PATH, but always behave like if on those platforms
toNamespacedPath('PATH')->'PATH'                #Returns Windows-specific namespaced path.
                                                #Does not do anything unless on Windows.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              FS               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


node --trace-sync-io                            #console.trace() when sync I/O is used

FS-EXTRA                                       ##Replacement for FS, with extra methods.
                                               ##Version 0.16.3
                                               ##Works well with BLUEBIRD.promisifyAll(FS-EXTRA)
WRENCH                                         ##Other filesystem module, but not drop-in replacement of FS.
                                               ##Version 1.5.8

PATH|FILENAME|DIR                               #STR, URI or BUFFER (less interoperable)
f*                                              #Variant using file descriptior FD_INT
l*                                              #Doesn't deference symlinks

PWD ==>                                         #All relative to process.cwd()
...Sync(...)                                    #All functions have a synchronous variant, without FUNC, except
                                                #[un]watch[File]() and createRead|WriteStream()
                                                #Will throw exceptions instead of using ERROR.

copyFile(PATH, PATH2[, NUM][, FUNC(ERROR)])     #NUM is an or'd flag:
                                                #  - COPYFILE_EXCL: fail if PATH2 already exists
FS-EXTRA.copy(FILE|DIR, FILE|DIR2, FUNC(ERROR))##
WRENCH.copyDirSync[Recursive]                  ##OBJ:
(FILE|DIR, FILE|DIR2[, OBJ][,FUNC(ERROR)])     ##  - forceDelete BOOL: overwrite destination
                                               ##  - excludeHiddenUnix BOOL: copy dotfiles
                                               ##  - preserveFiles BOOL: keep copy when overwriting
                                               ##  - preserveTimestamps BOOL
                                               ##  - inflateSymlinks BOOL: follow symlinks
                                               ##  - filter REGEXP|FUNC(STR)->BOOL: exclude files to copy
                                               ##  - whitelist BOOL: if true, filter works
                                               ##  - include|exclude REGEXP|FUNC(STR)->BOOL
rename(PATH, PATH2, FUNC(ERROR))                #
FS-EXTRA.move(FILE|DIR, FILE|DIR2[, OBJ],
FUNC(ERROR))                                   ##Can use OBJ.clobber true to overwrite.
GULP-RENAME(VAL)                               ##Rename filenames. VAL can be:
                                               ##  - FILENAME_STR (single file)
                                               ##  - OBJ: dirname STR, basename STR, prefix STR, suffix STR, extname STR
                                               ##    (e.g. ".js")
                                               ##  - FUNC(OBJ)->OBJ, with same OBJ as above
                                               ##Version 1.2.0

[f]truncate(PATH|FD_INT, UINT, FUNC(ERROR))     #

[f|l]chown(PATH|FD_INT, UID, GID, FUNC(ERROR))  #
WRENCH.chownSyncRecursive(DIR, UID, GID)       ##
[f|l]chmod(PATH|FD_INT, UINT, FUNC(ERROR))      #
WRENCH.chmodSyncRecursive(DIR, UINT)           ##

[f]utimes(PATH|FD_INT, ATIME, MTIME, FUNC(ERR)) #Change atime|mtime
access(PATH[, NUM], FUNC(ERROR))                #Checks if has permission, according to NUM or'd flags:
                                                #  - FS.F_OK (def): files exists and its directory list it
                                                #  - FS.R|W|X_OK: can be read|written|executed
[f|l]stat(PATH|FD_INT,[OPTS,]FUNC(ERROR,FSSTAT))#FSSTAT:
                                                #  - isFile|Directory|Block|CharacterDevice|FIFO|Socket(), (only with lstat()) isSymbolicLink()
                                                #  - dev UINT
                                                #  - ino UINT
                                                #  - mode UINT
                                                #  - nlink UINT
                                                #  - uid|gid UINT
                                                #  - rdev UINT
                                                #  - [blk]size UINT
                                                #  - blocks UINT
                                                #  - a|m|ctime[Ms] DATE|NUM
                                                #  - birthtime[Ms] DATE|NUM: creation time (Windows only)
                                                #OPTS:
                                                #  - bigint BOOL (def: false): make FSSTAT.* BIGINT instead of UINT

[sym]link(PATH, PATH2[, STR], FUNC(ERROR))      #STR is 'dir', 'file' (def) or 'junction' (only Windows)
GULP-SYMLINK.relative|absolute                 ##Creates a symlink in DIR (creates it if not existing, overwrite if OBJ.force
(DIR_ARR|FUNC(VINYL)->VINYL[,OBJ])             ##true) with same filename as current file, poiting to that file (with a
                                               ##relative|absolute path). Version 2.0.1
readlink(PATH[, OBJ], FUNC(ERROR, PATH2))       #PATH must be a symlink
                                                #OBJ: encoding 'ENCODING'
realpath[.native]                               #Like normalize(), but also resolve symlinks, and PATH must exist.
 (PATH[, OBJ], FUNC(ERROR, PATH2))              #OBJ: encoding 'ENCODING'
                                                #If "native", does less normalization

unlink(PATH, FUNC(ERROR))                       #
rmdir(PATH, FUNC(ERROR))                        #
FS-EXTRA.remove(FILE|DIR, FUNC(ERROR))         ##Like rm -rf
WRENCH.rmdirSyncRecursive(FILE|DIR[, BOOL])    ##Same. If true, fails silently.
RIMRAF(DIR|FILE[, FUNC()])                     ##Same
                                               ##Version 2.2.8
                                               ##Also GULP-RIMRAF([OBJ]):
                                               ##  - Only makes sense after GULP-IGNORE() in the middle of the pipeline
                                               ##    (otherwise use RIMRAF() directly).
                                               ##  - gulp.src() should use { read: false } if only GULP-IGNORE() then
                                               ##    GULP-RIMRAF() are used, so it is faster.
                                               ##  - Must use OBJ.force true if not in $PWD
                                               ##  - Version 0.1.0

mkdir(PATH[, MODE_INT], FUNC(ERROR))            #MODE_INT is 0777 by def
FS-EXTRA.ensureFile|Dir(FILE|DIR,FUNC(ERROR))  ##Create file|dir, including parent dirs, if not existing.
FS-EXTRA.mkdirs(DIR, FUNC(ERROR))              ##Like ensureDir()
WRENCH.mkdirSyncRecursive(DIR[, MODE_INT])

readdir(DIR, [OPTS, ]                           #ls: 'FILE' excludes . and ..
 FUNC(ERROR, 'FILE'|DIRENT_ARR))                #OPTS:
                                                #  - encoding 'ENCODING'
                                                #  - withFileTypes BOOL (def: false): whether to return DIRENT_ARR or 'FILE'_ARR
WRENCH.readdirSync[Recursive]
(DIR[, OPTS][, FUNC(ERROR, STR2_ARR)])          ##Same but recursive
DIRENT.isFile|Directory|Block|CharacterDevice|
 FIFO|Socket|SymbolicLink()->BOOL               #
DIRENT.name                                     #STR

open(PATH, STR|NUM[, MODE], FUNC(ERROR, FD_INT))#Open a file and return a file descriptor.
                                                #STR are flags: "r|w|a[s|x][+]":
                                                #  - r|w|a: read, write (create if not exist, or truncate),
                                                #    append (create if not exist)
                                                #  - s: synchronous mode (bypasses cache). Bad performance. For "r|a" only
                                                #  - x: don't overwrite file. For "w|a" only
                                                #  - +: open for read and writing.
                                                #NUM are or'd flags:
                                                #  - O_RDONLY|O_WRONLY|O_RDWR: read|write-only or not
                                                #  - O_TRUNC: truncate
                                                #  - O_APPEND: append
                                                #  - O_CREAT: create if not exist
                                                #  - O_CREATE + O_EXCL: fail if exist
                                                #  - O_DIRECTORY: fail if not a directory
                                                #  - O_NOFOLLOW: fail if is a symlink
                                                #  - O_SYMLINK: do not follow symlinks
                                                #  - O_NOATIME: do not update atime
                                                #  - O_DIRECT: try to avoid caching|buffering
                                                #  - O_SYNC: wait for data to be persisted to return calls
                                                #  - O_DSYNC: wait for data+metadata to be persisted to return calls
                                                #  - O_NOCTTY: if file is a terminal device, treat it as a normal file
                                                #  - O_NONBLOCK: use async when opening special files like serial ports
                                                #MODE INT is 0666 by def.
close(FD_INT, FUNC(ERROR))                      #
write(FD_INT, TDBUFFER, INT, INT2, [ INT3,]     #Write INT2 bytes from TDBUFFER at its position INT to file FD_INT at its position INT3 (def: current).
FUNC(ERROR, INT4, TDBUFFER))                    #INT4 is the number of bytes written.
write(FD_INT, STR[, INT3,
['ENCODING', ]] FUNC(ERROR, INT4, STR))         #Similar.
read(FD_INT, TDBUFFER, INT, INT2,
INT3, FUNC(ERROR, INT4, BUFFER))                #
f[data]sync(FD_INT, FUNC(ERROR))                #Flushes to disk
                                                #If 'data', does not flush metadata (e.g. mtime)

readFile                                        #Easier way than using open() and read()
(PATH|FD_INT, [OBJ, ]FUNC(ERROR, BUFFER|STR))   #OBJ:
                                                #  - encoding 'ENCODING' (def: null, i.e. returns BUFFER, otherwise returns STR)
                                                #  - flag STR (def: "r")
                                                #Prefer createReadStream(...).pipe(OSTREAM)
FS-EXTRA.readJson(...)                         ##Same as readFile(), but return as OBJ
write|appendFile(FILENAME|UINT,                 #OBJ has same members but also mode MODE_INT (def: 0666)
[STDBUFFER,] [OBJ, ] FUNC(ERROR))               #Def flag is "w|a"
FS-EXTRA.outputFile(...)                       ##Same as writeFile(), but calls ensureFile() first
FS-EXTRA.writeJson|outputJson(...)             ##Same as writeFile|outputFile(), but with an OBJ (JSON.stringify'd).
createReadStream(PATH[, OBJ])->ISTREAM          #Preferred over readFile().
                                                #Useful with ISTREAM.[.pipe(IOSTREAM)...]pipe(OSTREAM):
                                                #  - transmits to OSTREAM by chunks ("data" events) instead of at once
                                                #    (readFile())
                                                #  - can use IOSTREAM as modular transforms functions (like Unix commands)
                                                #OBJ has members:
                                                #  - flags STR (def: "r")
                                                #  - encoding 'ENCODING' (def: null)
                                                #  - fd FD_INT (def: null)
                                                #  - mode NUM (def: 0666)
                                                #  - autoClose BOOL (def: true): close the file descriptor on error|end event
                                                #  - start|end UINT: only use from bytes UINT to UINT2
                                                #ISTREAM has extra:
                                                #  - same members as OBJ
                                                #  - on('open', FUNC(FD_INT))
                                                #  - on('ready', FUNC())
                                                #  - path PATH
                                                #  - pos UINT
createWriteStream(PATH[, OBJ])->OSTREAM         #OBJ has members flags, defaultEncoding, fd, mode, autoClose, start
                                                #OSTREAM has extra:
                                                #  - same members as OBJ
                                                #  - on('open', FUNC(FD_INT))
                                                #  - on('ready', FUNC())
                                                #  - path PATH
                                                #  - pos UINT
                                                #  - bytesWritten UINT
new WRENCH.LineReader(FILE)                    ##Returns LINEREADER
LINEREADER.hasNextLine()                       ##
LINEREADER.getNextLine()                       ##Returns FILE line by line
LINEREADER.close()                             ##

mkdtemp('PATH', FUNC(ERROR, 'PATH2'))           #Create temp file at 'PATHrandom', with random:
                                                #  - 6 chars [:alnum:] (36 bits of entropy)
                                                #  - can end with '/'
TEMP.open(PREFIX, FUNC(ERROR, OBJ))            ##Creates temp file with permission 0600 under temp directory.
                                               ##OBJ:
                                               ##  - path STR
                                               ##  - fd NUM
                                               ##PREFIX:
                                               ##  - OBJ: prefix STR, suffix STR, dir DIR (def: "", "", OS temp dir)
                                               ##  - STR: only PREFIX_STR
                                               ##  - Path will be TMP_DIR/PREFIX-UUID-AFFIX
                                               ##If TEMP.track() called before, it will erase file on process exit.
                                               ##Version 0.8.1
TEMP.mkdir(PREFIX,FUNC(ERROR,PATH))            ##Same with directory
TEMP.createWriteStream()                       ##Same for file as OSTREAM
TEMP.path(PREFIX)                              ##Same for only the path
TEMP.cleanup(FUNC(ERROR,OBJ))                  ##Remove temp files. TEMP.track() must have been called before.
                                               ##OBJ: files|dirs NUM


watch('DIR'[, OPTS][, FUNC])->FSWATCHER         #FSWATCHER fires events when s file changes name or content.
                                                #OPTS:
                                                #  - persistent BOOL: if true (def), calls ref(), yielding the macrotask
                                                #  - recursive BOOL (def: false)
                                                #  - encoding 'ENCODING' (def: 'utf8')
                                                #FUNC is the FSWATCHER 'change' event handler.
                                                #Unstable. Prefer Chokidar.
FSWATCHER.on
('change', FUNC('change|rename', SBUFFER))      #SBUFFER is the FILENAME and is not always provided (e.g. never on MacOSX, and not always on other OS)
FSWATCHER.close()                               #
FSWATCHER.on('close', FUNC())                   #
FSWATCHER.on('error', FUNC(ERROR))              #

[un]watchFile                                   #Uses polling
(FILE[, OPTS], FUNC(PREV_STAT, NEW_STAT))       #OPTS:
                                                #  - persistent BOOL
                                                #  - interval (def: 5000)

constants                                       #Low-level file-system constants, for the current OS


FS.promises                                     #Like FS but:
                                                #  - return PROMISE instead
                                                #     - no FS.unwatch|watch[File]() nor FS.*Stream()
                                                #  - FD_INT are FILE_HANDLE instead
                                                #     - no FS.close() but FILE_HANDLE.close() is available
                                                #  - FS.constants|Stats|*OK remain on FS.*
                                                #  - is experimental (throws warning)
FILE_HANDLE                                     #Abstraction of a file descriptor, with automatic closing on FS PROMISE rejection
FILE_HANDLE.fd                                  #FD_INT
FILE_HANDLE.FUNC(...)                           #Same as FSP.[f]FUNC(FILE_HANDLE, ...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ZLIB              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


createGzip|Deflate[Raw]([OBJ])->COMPRESS        #COMPRESS is a IOSTREAM, so should do:
                                                #  ISTREAM.pipe(IOSTREAM).pipe(OSTREAM)
                                                #See HTTP for different formats.
                                                #Raw: same but does not append a zlib header.
                                                #OBJ can be:
                                                #  - [finish]flush, among:
                                                #     - constants.Z_NO_FLUSH (def)
                                                #     - constants.Z_PARTIAL_FLUSH
                                                #     - constants.Z_SYNC_FLUSH
                                                #     - constants.Z_FULL_FLUSH
                                                #     - constants.Z_FINISH
                                                #     - constants.Z_BLOCK
                                                #     - constants.Z_TREES
                                                #  - chunkSize (def: 16*1024): higher means faster but more memory
                                                #  - windowBits (def: 15): from 9 to 15, higher means better compression but
                                                #    more memory.
                                                #  - dictionary TDABUFFER (deflate|inflate only) (def: "")
                                                #OBJ (compression only):
                                                #  - level: higher means better compression but slower, among:
                                                #     - constants.Z_DEFAULT_COMPRESSION (def)
                                                #     - constants.Z_BEST_SPEED
                                                #     - constants.Z_BEST_COMPRESSION
                                                #     - constants.Z_NO_COMPRESSION
                                                #  - memLevel (def: 8): from 1 to 9, higher means better compression but more
                                                #    memory.
                                                #  - strategy, make compression better, according to type of data, among:
                                                #     - constants.Z_DEFAULT_STRATEGY: almost random data, and small values
                                                #     - constants.Z_FILTERED: in-between
                                                #     - constants.Z_HUFFMAN_ONLY: less random, and large repeating chunk
                                                #     - constants.Z_RLE: same, but specially for PNG data
                                                #     - constants.Z_FIXED: only specific application
                                                #Memory required (in bytes) is:
                                                #  - for compression:
                                                #     - 2^(windowBits+2) + 2^(memLevel+9) + chunkSize, i.e. 272K by def
                                                #  - for decompression:
                                                #     - 2^windowBits + chunkSize, i.e. 48K by def
createGunzip|Inflate[Raw]|Unzip([OBJ])->UNCOMPRS#UNCOMPRESS is a IOSTREAM.
                                                #Unzip: autodetect whether Gunzip or Deflate (but not DeflateRaw).
[UN]COMPRESS.flush([NUM, ]FUNC(ERROR))          #Compression uses an internal cache. Flush it.
                                                #Don't call unless necessary, because it impacts performance.
                                                #NUM def is ZLIB.Z_FULL_FLUSH. See above for other values.
[UN]COMPRESS.reset()                            #Stop compressing any data going through.
                                                #Only for Deflate|Inflate
[UN]COMPRESS.params(LEVEL, STRATEGY,FUNC(ERROR))#
[UN]COMPRESS.bytesWritten                       #NUM

gzip|deflate[Raw]
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER))         #
gunzip|inflate[Raw]|unzip
(STDABUFFER[, OBJ],FUNC(ERROR, BUFFER2))        #Convenience methods
*Sync(...)                                      #Same without callback, and not async


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           WARNINGS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


WARNINGS ==>                                    #Are similar to console.warn() except:
                                                #  - can be handled similarly to an exception, but does not stop execution
                                                #  - not part of normal JavaScript code flow
                                                #  - used by Node.js internal warnings, e.g. deprecations
                                                #  - should try to emit only once
                                                #By def, printed to console with console.warn()

node --no-warnings
NODE_NO_WARNINGS=1 ENVVAR                       #Does not print to console
node --trace-warnings                           #Use console.trace() instead of console.warn()
node --redirect-warnings=FILE
NODE_REDIRECT_WARNINGS=FILE ENVVAR              #I.e. will not be printed to console

PROCESS.emitWarning(ERROR)
PROCESS.emitWarning('MESSAGE'[, 'TYPE']
[, 'ID'][, FUNC(ERROR)->ERROR])                 #Creates a warning
PROCESS.emitWarning('MESSAGE',                  #Def TYPE: 'Warning'
[{ type, code, ctor, detail }])                 #detail is extra message on next line (e.g. stack trace)

process.on('warning', FUNC(ERROR))              #Fired on warnings.
                                                #ERROR: message 'MESSAGE', name 'TYPE', code 'ID', detail STR
                                                #ERROR.code|detail might be undefined


DEPRECATION ==>                                 #Type of warning with TYPE "DeprecationWarning"

UTIL.deprecate(FUNC, 'MESSAGE'[, 'ID'])->FUNC   #Make FUNC fire PROCESS.emitWarning('MESSAGE', 'DeprecationWarning', 'ID')

node --no-deprecation
node --trace-deprecation                        #Like --no|trace-warnings but for deprecations
node --throw-deprecation                        #throw error on deprecation
node --pending-deprecation
NODE_PENDING_DEPRECATION=1 ENVVAR               #Includes upcoming deprecations


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROCESS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EXIT EVENTS ==>                                 #  - normal exit: beforeExit, exit
                                                #  - uncaught exception: uncaughtException, beforeExit, exit
                                                #  - process.exit(): exit
                                                #  - process.abort(): none
                                                #  - SIGINT|SIGTERM (with no handler): none
                                                #  - SIGINT|SIGTERM (with handler): SIGINT|SIGTERM
                                                #The only handler that will prevent exit from happening (graceful exit)
                                                #are SIGINT|SIGTERM
on("beforeExit", FUNC(INT))                     #
on("exit", FUNC(INT))                           #INT is the exit code. process.exitCode is same,
                                                #providing process.exit() was called

on("uncaughtException", FUNC(ERROR))            #
setUnaughtExceptionCaptureCallback              #Same as on("uncaughtException") except:
 (FUNC(ERROR)|null)                             #  - unsets "uncaughtException" handler
                                                #  - unsets --abort-on-uncaught-exception
hasUnaughtExceptionCaptureCallback()->BOOL      #
node --abort-on-uncaught-exception              #Create a dump file when process exited because of uncaught exception

exit([UINT])                                    #Exit with exit code UINT (def: 0)
abort()                                         #Aborts: exits + produce a core file.

pid                                             #
ppid                                            #Parent's pid
kill(PID_INT[, 'SIGNAL'])                       #Sends a signal (def: "SIGTERM").
                                                #If PID_INT, doesn't exit, throw exception (can use SIGNAL_STR 0 to just
                                                #test process existence).
on('SIGNAL', FUNC('SIGNAL'))                    #Fires when signal emitted on current process. Special cases:
                                                #  - "SIGUSR1" will start debugger
                                                #  - handling SIGINT or SIGTERM will remove default handler.
                                                #  - cannot handle SIGKILL or SIGSTOP
                                                #  - SIGWINCH: when window resized

on('unhandledRejection, FUNC(VAL, PROMISE))     #When PROMISE:
                                                #  - is rejected
                                                #  - and has no handler (PROMISE.catch())
on('rejectionHandled, FUNC(PROMISE))            #When adding PROMISE.catch() on a PROMISE that:
                                                #  - was already rejected
                                                #  - and had no handler when it was rejected (i.e. 'unhandledRejection')
                                                #  - and was rejected in a previous macrotask

argv                                            #Command line args as STR_ARR. Doesn't include node options.
                                                #First is "node", second the absolute path of FILE, then the other arguments.
execArgv                                        #Same but only for node options (exclude all STR of argv)
execPath                                        #Absolute path of node executable used.
env                                             #Environment variables, as OBJ. Values are strings.
title                                           #Process title displayed in ps. Read/write. Usually short max length.

cwd()->'DIR'                                    #Current directory
                                                #Is the one of the main file. Required files do not change it.
chdir('DIR')                                    #

get[e]gid|[e]uid()                              #
set[e]gid|[e]uid(UINT|STR)                      #
getgroups()
setgroups(STR_ARR)                              #Supplementary GIDs.
initgroups(STR, STR2[_ARR])                     #
umask([UINT])                                   #

release.name                                    #'node|io.js'
release.sourceUrl|headersUrl                    #'URL'
release.lts                                     #When LTS
version                                         #
versions                                        #OBJ with members http_parser, node, icu, v8, ares, uv, zlib, modules, openssl
config                                          #Config flags and variables used during compilation, as OBJ
arch                                            #"arm", "ia32" or "x64"
platform                                        #"darwin", "freebsd", "linux", "sunos" or "win32"

memoryUsage()->OBJ                              #OBJ: rss, heapTotal, heapUsed, external
cpuUsage([OBJ])->OBJ                            #OBJ: user|system NUM (time usage, in microseconds)
                                                #If OBJ passed, is difference.
uptime()                                        #
hrtime([VAL])->VAL                              #Current time as [UINT, UINT2], where UINT is seconds and UINT2 nanoseconds.
                                                #Not real time, but arbitrary one just to compare with another time check.
                                                #If VAL passed, is difference.
                                                #Better that using new Date(), notably because ns not ms
hrtime.bigint()->BIGINT                         #Same but using BIGINT nanosecs instead of [UINT, UINT2]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        CHILD_PROCESS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


spawn(STR[, STR2_ARR], OBJ)                     #Creates, runs and return a CHILDPROCESS, from command line STR, with
                                                #args STR2_ARR.
                                                #OBJ (should be at least {}) are options among:
                                                #  - cwd STR
                                                #  - env OBJ (def: process.env)
                                                #  - name STR: PROCESS.title
                                                #  - uid|gid UINT
                                                #  - detached BOOL: if true, becomes leader a new process group, i.e. will
                                                #    not exit when parent does. Must not inherit any file descriptor from
                                                #    parent.
                                                #  - stdio STR_ARR, how parent can access child's file descriptors
                                                #    (at least first three ones, stdin|out|err, but can continue with
                                                #    fd 3, etc.) among:
                                                #      - "pipe": enable CHILDPROCESS.stdio[FD_INT]|stdin|out|err
                                                #      - "ipc": enable CHILDPROCESS.send()
                                                #        Can only do it for one file descriptor.
                                                #      - "ignore": with nothing
                                                #      - STREAM: use the underlying file descriptor (like doing NUM> FILE)
                                                #      - FD_INT: use parent file descriptor FD_INT (like doing NUM&>FD_INT)
                                                #      - null: "pipe" for stdin|out|err, "ignore" for others.
                                                #    Can use the following shortcuts STR instead:
                                                #      - "ignore": [ "ignore", "ignore", "ignore" ]
                                                #      - "pipe": [ "pipe", "pipe", "pipe" ]
                                                #      - "inherit": [ 0, 1, 2 ]
                                                #  - shell STR|BOOL (def: false)
                                                #  - windowsHide BOOL (def: false): hide the subprocess console window
                                                #    usually created on Windows
                                                #Use CHILDPROCESS.ref(), so needs to use unref() if program can exit while
                                                #CHILDPROCESS is running.
spawnSync(...)                                  #Same except:
                                                #  - extra arguments:
                                                #     - input STDBUFFER: overrides stdio[0]
                                                #     - timeout, killSignal, maxBuffer, encoding: see exec()
                                                #  - waits for completion and returns:
                                                #     - pid UINT
                                                #     - output STR_ARR
                                                #     - stdout|err SVAL: same as output[1|2]
                                                #     - status NUM: null if killed by signal
                                                #     - signal STR
                                                #     - error ERROR
fork(STR[, STR2_ARR], OBJ)                      #Same as spawn(), but:
                                                #  - for a file STR. Use:
                                                #     - execPath STR: def is "node", so STR is a JavaScript node.js file,
                                                #       but could use Bash, Python, etc.
                                                #     - execArgv STR_ARR to pass arguments.
                                                #  - OBJ options are cwd, env, encoding, execPath, execArgv, uid|gid, stdio and:
                                                #     - silent BOOL: if true use "pipe" stdio, otherwise "inherit" (def)
                                                #       In all cases, send() is available.
                                                #Sets ENVVAR NODE_CHANNEL_FD, which is a file descriptor that I don't
                                                #understand how to use.
                                                #Can consume quite a lot of resources.
exec(STR, OBJ, FUNC(ERROR, SVAL, SVAL2))        #Same as spawn() but current process becomes CHILDPROCESS (which is returned) and:
                                                #  - STR is command line, including arguments
                                                #  - when terminated, fires FUNC where SVAL[2] is stdout|err
                                                #  - OBJ have members:
                                                #     - cwd STR
                                                #     - env OBJ
                                                #     - uid|gid UINT
                                                #     - encoding 'ENCODING' (def: "utf8")
                                                #     - timeout UINT (def: 0): if > 0, will send killSignal after UINT ms
                                                #     - killSignal STR (def: "SIGTERM")
                                                #     - maxBuffer UINT (def: 200KB): killSignal if more is used
                                                #     - shell STR (def: "/bin/sh")
                                                #     - windowsHide BOOL
execSync(STR[, OBJ])                            #Same but:
                                                #  - extra argument: input STDBUFFER (overrides stdio[0])
                                                #  - returns SVAL (result stdout)
execFile('FILE'[, STR2_ARR], OBJ, FUNC(...))    #Same but specifies a 'FILE', and arguments STR2_ARR.
execFileSync(STR[, STR2_ARR][, OBJ])            #
execSync(STR[, OBJ])                           ##Same as native execSync() (module sync-exec 0.5.0) but:
                                               ##  - works on Node 0.10
                                               ##  - returns OBJ2.stdout|stderr|status
execSync.exec|run(STR)                         ##Same as native execSync() (module execSync, 1.0.4) but:
                                               ##  - not maintained, does not work on Node 0.12
                                               ##  - exec()->EXIT_NUM, run()->OBJ.code|stdout

CHILDPROCESS.stdio[FD_INT]                      #I|OSTREAM for file descriptor FD_INT
CHILDPROCESS.stdin|out|err                      #Same for 0|1|2
CHILDPROCESS.pid                                #

PROCESS|CHILDPROCESS.send                       #Communication:
(VAL[, TCPSOCKET|TCPSERVER][, OPTS]             #  - parent use CHILDPROCESS.on("message") and CHILDPROCESS.send(...)
[, FUNC([ERROR])])                              #  - child use PROCESS.on("message") and PROCESS.send(...)
                                                #Child process must have been created using "ipc" (see above)
                                                #When sending a TCPSOCKET|TCPSERVER, it will be shared between parent and child:
                                                #  - packets will arrive randomly at both
                                                #  - only one needs to listen
                                                #  - for TCPSERVER, both can listen to 'connection' event
                                                #FUNC is fired after sending, before target received.
                                                #If FUNC specified, no 'error' event emitted.
                                                #OPTS:
                                                #  - keepOpen BOOL (def: false): see TCPSOCKET
CHILDPROCESS.on("message",
FUNC(OBJ[, TCPSOCKET|TCPSERVER]))               #CHILDPROCESS will not exit until disconnect() is called or parent exits.
CHILDPROCESS.disconnect()                       #Flush all communication, then becomes impossible to do send()
                                                #Do it before exiting.
CHILDPROCESS.connected                          #
CHILDPROCESS.on("disconnect", FUNC())           #
CHILDPROCESS.on("error", FUNC(ERROR))           #When CHILDPROCESS could not send(), be kill() or be spawn()
                                                #The exit event might be fired or not after error event.
CHILDPROCESS.on("exit|close", FUNC(UINT,STR))   #UINT is the exit code, STR the terminating signal (or null).
                                                #exit is when process exits, close is when its file descriptors are closed.
                                                #file descriptors don't close if shared by other processes.
CHILDPROCESS.kill([STR])                        #Def: "SIGTERM"
CHILDPROCESS.channel                            #Underlying IOSTREAM for send()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CLUSTER            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GOAL ==>                                        #A single process will only use only one CPU core.
                                                #Using CHILDPROCESS.fork() on the same code to create one child for each CPU
                                                #core.
                                                #Can manage the workers: kill some, manage a pool, etc.
                                                #Work should be done by child processes, master should only manage them.
                                                #Child processes cannot fork() to grandchild processes.
                                                #One common task is to make CHILDPROCESS TCPSERVER.listen(), in which case:
                                                #  - connections will arrive randomly at the child processes listening to
                                                #    the same port.
                                                #    The randomness uses CLUSTER.schedulingPolicy:
                                                #      - CLUSTER.SCHED_RR (def): improved round-robin
                                                #      - CLUSTER.SCHED_NONE: previous version
                                                #    or use ENVVAR NODE_CLUSTER_SCHED_POLICY "rr|none"
                                                #  - be careful:
                                                #     - listen(TCPSERVER|TCPSOCKET): TCPSERVER|TCPSOCKET must have been sent by master
                                                #       to child, or will create problems
                                                #     - listen({ fd: INT }): looks at parent file descriptor
                                                #  - if UDPSOCKET.bind() or TCPSERVER.listen() OBJ.exclusive true (def: false), socket is not shared
fork([OBJ])                                     #Like CHILD_PROCESS.fork(), but returns a WORKER, which gives extra functions.
                                                #Can fork a separate file for children, but if forking the same file, should
                                                #use if ( CLUSTER.isMaster|Worker ) in beginning of code.
                                                #OBJ is env (def: process.env).
                                                #Options are controlled by CLUSTER.settings, that is available for read once
                                                #CLUSTER.setupMaster(OBJ) has been called to change it (only once):
                                                #  - exec STR: the file the child is forked with (def: process.argv[1])
                                                #  - args STR (def: process.argv.slice(2)): to worker
                                                #  - execArgv STR_ARR (def: process.execArgv): to node
                                                #  - silent BOOL: like CHILDPROCESS.fork() (def: false)
                                                #  - cwd, uid|gid UINT, stdio, windowsHide
                                                #setupMaster() fire 'setup'(OBJ) event
on("fork|online", FUNC(WORKER))                 #Fired when a child process is created|ready to respond.
WORKER.on("online", FUNC())                     #
on("listening", FUNC(WORKER, OBJ))              #Fired when a child process use TCPSERVER.listen().
                                                #OBJ has members { address, port, addressType: "[udp]4|6|-1(Unix socket)" }
WORKER.on("listening", FUNC(OBJ))               #

workers                                         #All WORKER in an OBJ, where the key is the WORKER.id
                                                #Only available in parent process.
worker                                          #Current WORKER. Only available in child processes.
WORKER.id                                       #
WORKER.process                                  #The underlying CHILDPROCESS.
                                                #In a WORKER, can use process.* directly

WORKER.send(VAL[,TCPSOCKET|TCPSERVER][, FUNC()])#
WORKER.on
("message", FUNC(OBJ[, TCPSOCKET|TCPSERVER]))   #
on('message', FUNC(WORKER TCPSOCKET|TCPSERVER,
OBJ))                                           #
WORKER.kill([STR])                              #Calls WORKER.disconnect(), then in:
                                                #  - the parent, sends signal (def: "SIGTERM")
                                                #  - the child processes, exit with error code 0

WORKER.disconnect()->WORKER                     #If listen() was called, don't accept new connections and emit TCPSERVER.close()
                                                #when no more connections (only server connections, not CLIENTREQ, that
                                                #are closed directly).
                                                #Might be useful to use a timeout to kill the WORKER if connections keep on
                                                #living.
disconnect(FUNC())                              #Call disconnect() on all child processes (must be done from parent).
on("disconnect", FUNC(WORKER))                  #Fired when a child process use disconnect()
WORKER.on("disconnect", FUNC())                 #
WORKER.isConnected()                            #
WORKER.isDead()                                 #True if exited of thrown exception
WORKER.exitedAfterDisconnect                    #When WORKER exits, will be false if exited because of an exception, and true
                                                #if because of kill() or disconnect()
on("exit", FUNC(WORKER, UINT, STR))             #Fired when a child process exits.
                                                #UINT is the exit code, STR the signal (null if none).
WORKER.on("exit", FUNC(UINT, STR))              #
WORKER.on("error", FUNC(ERROR))                 #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        WORKER_THREADS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ISOMORPHISM ==>                                 #Inspired by DOM workers but with notable differences

node --experimental-worker                      #Must be used

MULTI-THREADING ==>                             #Uses threads not processes, i.e.:
                                                #  - uses OS time slicing i.e.:
                                                #     - long microtasks are processed in several steps
                                                #     - load between threads is balanced by OS
                                                #  - for each time slice, uses any available CPU, i.e. scale to all CPUs
                                                #I.e. good for CPU-intensive tasks (not I/O intensive)


new Worker('SCRIPT_PATH'[, OPTS])               #OPTS:
                                                #  - eval BOOL (def: false): use inline 'JAVASCRIPT' instead
                                                #  - workerData VAL:
                                                #     - assigned to WORKER_THREADS.workerData VAL
                                                #     - same possible types as postMessage()

global.*                                        #In worker, like in parent except process.*:
                                                #  - exit() affects current thread not current process
                                                #  - no abort|chdir|initgroups|set*|umask() nor on('SIGNAL')
                                                #  - env|title are read-only
                                                #Worker and parent's global|process.* are distinct.
                                                #Unlike DOM, no concept of WORKERGLOBAL nor "self".

process.stdin|stdout|stderr                     #Worker has different standard streams than parent, but they are piped from|to
                                                #parent unless OPTS.stdin|stdout|stderr true (def: false)
WORKER.stdin|stdout|stderr                      #Worker's standard streams, available to parent

WORKER_THREADS.isMainThread                     #BOOL. True if is top-level parent.

WORKER_THREADS|WORKER.threadId                  #NUM
                                                #Top-level parent is 0. Then increments for each worker

WORKER.on('online', FUNC())                     #When worker is loaded, just before it starts executing

WORKER.terminate([FUNC(ERROR, EXIT_CODE)])      #Worker current microtask will be interrupted
                                                #I.e. should not be done when WORKER might be in the middle of executing a Node.js core function
                                                #EXIT_CODE will be 1

WORKER.on('exit', FUNC(EXIT_CODE))              #When worker ends (including because of uncaught exceptions)

WORKER.on('error', FUNC(ERROR))                 #Uncaught exception within worker.

MESSAGEPORT|WORKER.[un]ref()                    #


WORKER|MESSAGEPORT.postMessage(VAL[, VAL2_ARR]) #Like DOM except:
                                                #  - child can only use MESSAGEPORT, not global "postMessage()"
                                                #  - VAL2:
                                                #     - can be SHARED_ARRBUFFER
                                                #     - when MESSAGEPORT, VAL must be MESSAGEPORT
WORKER|MESSAGEPORT.on('message', FUNC(VAL))     #Like DOM except:
                                                #  - receive VAL directly, not MESSAGEEVENT
                                                #  - MESSAGEPORT will keep process open until MESSAGEPORT.close|unref()

new MessageChannel()
MESSAGECHANNEL.port1|2
MESSAGEPORT.start|close()                       #Like DOM
MESSAGEPORT.on('close', FUNC())                 #

WORKER_THREADS.parentPort                       #Default MESSAGEPORT available in every worker.
                                                #null in parent


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              VM               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ALTERNATIVES ==>                                #When running 'Math.random()'
                                                #Execution time:
                                                #  - as is:  0.000006ms
                                                #  - eval(): 0.0001ms
                                                #  - runIn*Context(): 0.001ms
                                                #     - with SCRIPT: same performance, with 50% time spent for loading (new Script),
                                                #       50% for execution (SCRIPT.runIn*Context())
                                                #  - spawn|exec(): 1.3ms
                                                #  - Worker(): 6ms
                                                #Security:
                                                #  - as is, eval(): access to current process + context
                                                #  - runIn*Context(): access to current process
                                                #  - Worker(): access to none (providing OPTS.stdin|stdout|stderr true)
                                                #  - spawn|exec(): access to none
                                                #Limits:
                                                #  - as is, eval(): defaults (max call stack, max STR|ARR length)
                                                #  - runIn*Context(): defaults, timeout
                                                #  - worker(): defaults, seems to crash over 1000 threads
                                                #  - spawn|exec(): defaults, timeout, maxBuffer
                                                #Threads/processes:
                                                #  - as is, eval(), runIn*Context(): same thread|process
                                                #  - Worker(): different thread
                                                #  - spawn|exec(): different thread

createContext([CONT_OBJ][, CONT_OPTS])->COBJ    #COBJ is an OBJ with some hidden properties.
                                                #CONT_OBJ is merged in.
                                                #CONT_OPTS:
                                                #  - name STR (def: 'VM Context NUM'): for debugging
                                                #  - origin PROTO://HOST[:PORT] (def: ''): for debugging
                                                #  - codeGeneration:
                                                #     - strings BOOL (def: true): if false, throws on eval() or derivatives (new Function(...), etc.)
                                                #     - wasm BOOL (def: true): if false, throws when trying to compile WASM
isContext(COBJ)->BOOL                           #Returns true if COBJ

runInContext(STR, COBJ[, RUN_OPTS])             #Like eval() but use context COBJ as unique global environment:
                                                #  - passed by reference.
                                                #  - does not have any other access to caller otherwise,
                                                #    including current caller local scope
                                                #Also:
                                                #  - use current process:
                                                #     - same file descriptors
                                                #     - throw exception in current process
                                                #     - should create a new process first if VM used for security reason.
                                                #  - returns synchronous return value from code STR
                                                #     - but can still inspect COBJ passed by reference for async return value,
                                                #       or pass COBJ.FUNC()
                                                #RUN_OPTS:
                                                #  - filename STR, line|columnOffset NUM: for stack trace error message
                                                #  - displayErrors BOOL (def: true): prints to current stderr any stderr
                                                #    from code
                                                #  - timeout NUM: throw error if timeout
runInNewContext(STR[, CONT_OBJ]
 [, RUN_OPTS|CONT_OPTS])                        #Same but automatically use createContext(CONT_OBJ, CONT_OPTS)
runInThisContext(STR[, RUN_OPTS])               #Same as runInNewContext(STR, global)

compileFunction('CODE'[, 'PARAM_NAME'_ARR]      #Like new Function() but use OPTS.parsingContext COBJ (def: global)
 [, RUN_OPTS|SCRIPT_OPTS])->FUNC                #RUN_OPTS|SCRIPT_OPTS:
                                                #  - filename, line|columnOffset, cachedData
                                                #  - contextExtensions OBJ_ARR (def: []): objects wrapping COBJ

new Script(STR[, RUN_OPTS|SCRIPT_OPTS])         #Returns a SCRIPT, i.e. a compiled version of STR:
                                                #  - separates compiling from running STR
                                                #  - every run can be bound to different COBJ
                                                #SCRIPT_OPTS:
                                                #  - cachedData BUFFER:
                                                #     - copy of script, to improve load performance
                                                #     - created by SCRIPT.createCachedData()->BUFFER
                                                #     - V8.cachedDataVersionTag()->NUM returns a hash of v8
                                                #       version, CLI flags and CPU features
SCRIPT.runIn[New|This]Context(...)              #Same as run*(STR, ...)
                                                #RUN_OPTS also has:
                                                #  - breakOnSigint BOOL

new SourceTextModule(STR[, MODULE_OPTS])        #Same as Script but for ES module
                                                #Must use --experimental-vm-modules
                                                #MODULE_OPTS:
                                                #  - context COBJ: reused by every MODULE.run*(...), i.e. cannot be changed
                                                #  - url STR (def: 'vm:module(NUM)'): for debugging
                                                #  - filename STR, line|columnOffset NUM: for stack trace error message
VMMODULE.link(FUNC('SPECIFIER',PARENT_MODULE))  #Specifies the function to resolve SPECIFIERs,
 ->[PROMISE_]VMMODULE                           #I.e. same as using import { SPECIFIER } from VMMODULE
                                                #Must be called only once.
                                                #MODULE and PARENT_MODULE must have same COBJ
VMMODULE.linkingStatus                          #Can be:
                                                #  - 'unlinked': before VMMODULE.link()
                                                #  - 'linking': during VMMODULE.link()
                                                #  - 'linked': after VMMODULE.link() success
                                                #  - 'errored': after VMMODULE.link() error
VMMODULE.error                                  #If linkingStatus 'errored', contains link() rejected promise value.
                                                #Otherwise, accessing it throws an exception.
VMMODULE.instantiate()                          #Might throw if problem importing|exporting
                                                #The function is memoized.
                                                #Must be called after VMMODULE.link()
VMMODULE.evaluate([RUN_OPTS])->PROMISE(VAL)     #Runs the code.
                                                #Must be called after VMMODULE.instantiate()
                                                #RUN_OPTS: timeout, breakOnSigint
VMMODULE.url                                    #
VMMODULE.namespace                              #
VMMODULE.dependencySpecifiers                   #All 'MODULE'_ARR imported by that module


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CRYPTO             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


setEngine(PATH[, NUM])                          #When using custom OpenSSL or alternative crypto library.
                                                #NUM are or'd flags: ENGINE_METHOD_ALL|RSA|DSA|DH|RAND|ECDH|ECDSA|CIPHERS|
                                                #DIGESTS|STORE|PKEY_[ASN1_]METH|NONE
node --openssl-config=FILE
OPENSSL_CONF=FILE ENVVAR                        #

createHash(STR)                                 #Returns a HASH, i.e. a IOSTREAM generator: write|read to it to get hashes.
                                                #STR is the algo.
                                                #CRYPTO.getHashes() gives list of supported hashes algos, as STR_ARR:
                                                #includes [EC]DSA, DSS1, MD4|5, RIPEMD, RMD, SHA1|224|256|384|512, Whirlpool
createHmac(STR, STDBUFFER)                      #Same but for a HMAC. STR is hash algo. Second argument is the key.
createCipheriv(STR, STDBUFFER, STDBUFFER|null   #Same but for a CIPHER (sym. cipher).
 [, OPTS])                                      #Key must be TDBUFFER or STR with encoding "binary".
                                                #Third argument is IV.
                                                #CRYPTO.getCiphers() gives list of supported sym. ciphers (including mode of
                                                #operation), as STR_ARR: includes AES, Blowfish, Camellia, CAST, DES, DES3,
                                                #DES-X, IDEA, RC2, RC4, SEED.
                                                #OPTS:
                                                #  - any of STREAM.Transform()
                                                #  - authTagLength NUM (def: 16): 4-16 (must be even number)
CIPHER.setAutoPadding(BOOL)                     #If false (def: true), disables padding (PKCS padding).
                                                #Use it for personalized padding, i.e. filling with nulls.
CIPHER.getAuthTag()->BUFFER                     #Returns MAC, for sym. ciphers that produce one ("authenticated
                                                #encryption"), i.e. "GCM" only.
CIPHER.setAAD(BUFFER)->BUFFER2                  #Same but for "additional authenticated data" ("GCM" only)
createDecipheriv(...)
DECIPHER.setAutoPadding(BOOL)                   #Same for decryption.
DECIPHER.setAuthTag(TDBUFFER)->DECIPHER         #
DECIPHER.setAAD(BUFFER)->DECIPHER               #

createDiffieHellman(ARGS)                       #Creates a DIFFIEHELLMAN (used for asym. encryption with HL algo).
                                                #ARGS can be:
                                                #  - NUM[, NUM2]: prime length NUM and generator NUM2 (def: 2).
                                                #  - STDBUFFER[, ENCODING][, NUM|STDBUFFER2[, ENCODING2]]: prime STDBUFFER
                                                #    (def ENCODING: "buffer", can also be "binary|base64") and generator
                                                #    NUM|STDBUFFER2 (def: 2)
DIFFIEHELLMAN.getPrime([ENCODING])->SBUFFER     #
DIFFIEHELLMAN.getGenerator([ENCODING])->SBUFFER #
DIFFIEHELLMAN.generateKeys([ENCODING])->SBUFFER #Creates private and public key, and returns public key.
DIFFIEHELLMAN.getPublic|PrivateKey([ENCODING])
 ->SBUFFER                                      #
DIFFIEHELLMAN.setPublic|PrivateKey
 (STDBUFFER, [ENCODING])                        #
DIFFIEHELLMAN.computeSecret(STDBUFFER           #Creates shared secret by using current private key and other part public key
[, ENCODING][, ENCODING2])->SBUFFER             #STDBUFFER (must have used the same prime and generator)
                                                #ENCODING is other part public key encoding, ENCODING2 shared secret returned.
DIFFIEHELLMAN.verifyError                       #Or'd flags showing warning after initialization among:
                                                #  - CRYPTO.DH_CHECK_P_NOT_SAFE_PRIME
                                                #  - CRYPTO.DH_CHECK_NOT_PRIME
                                                #  - CRYPTO.DH_UNABLE_TO_CHECK_GENERATOR
                                                #  - CRYPTO.DH_NOT_SUITABLE_GENERATOR
getDiffieHellman(STR)                           #Returns a DIFFIEHELLMAN but:
                                                #  - without setPublic|PrivateKey()
                                                #  - according to STR "modp1|2|5|14|15|16|17|18", i.e. prime is constant, but
                                                #    it is faster

createECDH(STR)                                 #Returns ECDH, elliptic curve version of Diffie-Hellman.
                                                #Same as DIFFIEHELLMAN but:
                                                #  - last arg FORMAT "[un]compressed|hybrid" (def: "uncompressed") to generateKeys() and getPublicKeys()
                                                #  - no getPrime(), getGenerator(), verifyError, setPublicKey()
                                                #STR is algo, from CRYPTO.getCurves() as STR_ARR: includes Oakley, brainpool,
                                                #c2tnb, prime, secp, sect, wap-wsg-idm-ecid-wtls
ECDH.convertKey(STDBUFFER, 'ALGO'[, ENCODING]
 [, ENCODING2], FORMAT)->SBUFFER                #Converts public key STDBUFFER to FORMAT

public|privateEncrypt|Decrypt(STR|OBJ, TDBUFFER)#Encrypts/decrypts asym. (RSA) TDBUFFER, with private|public key STR|OBJ:
                                                #  - key STR: PEM format
                                                #  - passphrase STR (decoding only)
                                                #  - padding: CRYPTO.constants.RSA_NO|PKCS1[_OAEP]_PADDING

createSign(STR)                                 #Same as createDecipher() but for signing algo STR.
                                                #List can be found with openssl list-public-key-algorithms.
                                                #Includes RSA, DH, DSA, HMAC and CMAC.
                                                #Unless createCipher(), is only a OSTREAM. To read from it, use
                                                #SIGN.sign(STR|OBJ[, ENCODING]), where STR|OBJ is the private key.
                                                #OBJ:
                                                #  - key STR
                                                #  - passphrase STR
                                                #  - padding CRYPTO.constants.RSA_PKCS1_[PSS_]PADDING
                                                #  - saltLength NUM, can be:
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_DIGEST: digest size
                                                #     - CRYPTO.constants.RSA_PSS_SALTEN_MAX_SIGN
createVerify(STR)                               #Same for verifying algo STR.
                                                #Like createSign(), is only a OSTREAM. To read from it, use
                                                #VERIFY.verify(STR|OBJ, STDBUFFER[, ENCODING]), where STR is a certificate or
                                                #a RSA|DSA public key in PEM format, and STDBUFFER the signature.

Certificate()                                   #Returns CERTIFICATE, used for SPKAC, used to send certificates client-side to
                                                #the server with the HTML5 <keygen>.
CERTIFICATE.verifySpkac(TDBUFFER)->BOOL         #
CERTIFICATE.exportChallenge|PublicKey
(STDBUFFER[, ENCODING])->BUFFER                 #

pbkdf2[Sync](STBUFFER, STBUFFER2, NUM, NUM2,    #Generate a random BUFFER using PBKDF2 with HMAC-SHA1, with first arg being
DIGEST[, FUNC(ERROR, BUFFER)])[->BUFFER]        #the input, second the salt (should be min. 64 bits), NUM the number of
                                                #iterations (should be min. 1000) and NUM2 the final string length.

scrypt[Sync](STDBUFFER, STDBUFFER2, NUM[, OPTS] #Generate a derived key BUFFER using Scrypt.
 [, FUNC(ERROR, BUFFER)])[->BUFFER]             #First arg is the password, second is the salt (should be 16 bytes long), NUM is BUFFER length.
                                                #OPTS:
                                                #  - N NUM (def: 16384): CPU/memory cost. Must be power of 2
                                                #  - r NUM (def: 8): block size
                                                #  - p NUM (def: 1): parallelization
                                                #  - maxmem NUM (def: 32MB): memory bound. Must be > 128*N*r

randomBytes(NUM[, FUNC(ERROR, BUFFER)])         #Generates random BUFFER of length NUM
                                                #Is cryptographically secure (e.g. from /dev/random)
                                                #If no FUNC, synchronous (returns BUFFER)
randomFill[Sync](TDBUFFER[, NUM[, NUM2]]        #Like randomBytes() but by filling in a TDBUFFER instead, from offset NUM
[, FUNC(ERROR, TDBUFFER)])[->BUFFER]            #(def: 0) with length NUM2 (def: TDBUFFER.lBUFFER.length).

getFips()->BOOL                                 #True if Node has been:
                                                #   - built to be FIPS-compliant (by def, is not)
                                                #   - run with node --enable-fips or (same but cannot modify CRYPTO.fips) --force-fips
setFips(BOOL)                                   #

timingSafeEqual(TDBUFFER, TDBUFFER2)->BOOL      #Like TDBUFFER.equals(TDBUFFER2), but protected against timing attacks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ASSERT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ASSERT                                          #Throws ASSERTIONERROR with message 'ASSERT_TITLE' if fails.
ASSERT.*(..., 'ASSERT_TITLE')                   #Can be always passed as last argument (except ifError()). Def:
                                                #  - [not]equal|ok(): 'VAL ==|!= VAL2'
                                                #  - [not]DeepEqual(): 'VAL [not]DeepEqual VAL2'
                                                #  - fail(): 'Failed'
                                                #  - strictEqual(): diff
                                                #  - others: sentence

ASSERTIONERROR.actual|expected                  #VAL
                                                #With *equal|ok|ifError()
                                                #Does a colored diff
ASSERTIONERROR.operator                         #'==' (equal|ok()) or '!=' (notEqual()), undefined (fail()), 'FUNC' (others)

ASSERT.fail()                                   #Always fails

ASSERT.[not]equal(VAL, VAL2)                    #VAL == VAL2
ASSERT.[not]strictEqual(VAL, VAL2)              #Object.is(VAL, VAL2)
ASSERT.[not]deepEqual(VAL, VAL2)                #UTIL.isDeepStrictEqual()

ASSERT[.ok](VAL)                                #VAL == true

ASSERT.ifError(VAL)                             #VAL == null

ASSERT.throws|doesNotThrow(FUNC()[, VAL])       #Function throws
                                                #VAL can be:
                                                #  - TYPE|ERROR: instanceof
                                                #  - FUNC(ERROR)->BOOL
                                                #  - REGEXP: against ERROR.message
                                                #  - OBJ: deep ==
ASSERT.rejects|doesNotReject(PROMISE[()][, VAL])#PROMISE rejection
 ->PROMISE2                                     #Fails if FUNC()->PROMISE throws before returning the PROMISE
                                                #Fails if not using a PROMISE[()]


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONSOLE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONSOLE.*                                       #Like DOM utilities except:
                                                #  - uses UTIL.inspect|format()
                                                #     - with OPTS.colors true, unless inside a WORKER
                                                #  - console.dir(VAL, ...) -> console.log(inspect(VAL, ...))
                                                #  - console.assert() can use format strings

new Console(OPTS)                               #Returns CONSOLE, same as console but with different stdout|stderr
new Console(OSTREAM[, OSTREAM2])                #OPTS:
                                                #  - stdout OSTREAM, stdout OSTREAM2
                                                #  - ignoreErrors BOOL (def: true): ignore errors on OSTREAM[2]
                                                #  - colorMode BOOL or 'auto' (def, depends on OSTREAM.isTTY|getColorDepth())

STDERR ==>                                      #Uses by:
                                                #  - CONSOLE.warn|error() (not other CONSOLE.*)
                                                #  - unhandled exception or promise rejection
                                                #  - process.emitWarning()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PERF_HOOKS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


performance                                     #Like DOM (see doc), except:
PERFORMANCE                                     #  - different entryTypes:
PERFENTRY.*                                     #     - keep 'mark' and 'measure'
PERFOBSERVER                                    #     - 'timing' PERFORMANCETIMING -> 'nodeTiming' PERFNODETIMING
                                                #     - no 'navigation' PERFORMANCENAVIGATION
                                                #     - also has 'gc' and 'function'
                                                #  - no PERFORMANCE.clearMeasures|getEntries*() (but PERFLIST.getEntries*() are kept)
                                                #  - PERFOBSERVER.observe OPTS.buffered BOOL:
                                                #     - if false (def), fire listener callbacks sync
                                                #     - if true, use setImmediate()
                                                #  - PERFOBSERVER is an ASYNCRESOURCE
                                                #  - DOMTIMESTAMP is nanoseconds-precise

PERFORMANCE.timeOrigin                          #DOMGLOBALTIME base of DOMLOCALTIME, i.e. when process started.
                                                #Use same logic as process.hrtime() (i.e. arbitrary number),
                                                #but as a DOMETIMESTAMP

PERFORMANCE.nodeTiming                          #PERFNODETIMING, which is a PERFENTRY with:
                                                #  - entryType 'node'
                                                #  - name 'node'
                                                #  - startTime: same as PERFORMANCE.timeOrigin
                                                #  - duration: same as PERFORMANCE.now() - PERFORMANCE.timeOrigin
                                                #Is similar to PERFORMANCENAVIGATION, but for Node
PERFNODETIMING.*                                #The following use same same logic as process.hrtime(), but in ns
PERFNODETIMING.nodeStart                        #Node process started
PERFNODETIMING.v8Start                          #v8 process initialized
PERFNODETIMING.environment                      #Environment initialized
PERFNODETIMING.bootstrapComplete                #End of all require()
PERFNODETIMING.loopStart                        #Start of event loop
PERFNODETIMING.loopExit                         #End of event loop. Not sure when it is not 0

PERFGCTIMING                                    #PERFENTRY for garbage collector, with:
                                                #  - entryType 'gc'
                                                #  - name 'gc'
                                                #  - startTime
                                                #  - duration DOMTIMESTAMP
                                                #  - kind: constants.NODE_PERFORMANCE_GC_MINOR|MAJOR|INCREMENTAL|WEAKCB (1|2|4|8)

PERFORMANCE.timerify(FUNC)->FUNC                #Make FUNC(...) create a PERFENTRY with:
                                                #  - entryType 'function'
                                                #  - duration: how long FUNC() took
                                                #  - name FUNC.name (without 'timerified ')
                                                #  - startTime DOMLOCALTIME
                                                #Prepend 'timerified ' to FUNC.name
                                                #Does not await return value if it is a PROMISE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             I18N              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ICU DATA                                        #I18n dataset used by:
                                                #  - JavaScript-aware functions: STR.normalize|toLowerCase|toUpperCase(),
                                                #    STR|NUM|DATE.toLocale*(), STR.localeCompare(), Intl, URL,
                                                #    TEXTENCODER|TEXTDECODER
                                                #  - BUFFER.transcode()
                                                #How many languages are included depends on:
                                                #  - compile-time flag --with-intl=STR:
                                                #     - 'full'
                                                #     - 'small-icu' (def):
                                                #        - supports: STR.normalize|toLowerCase|toUpperCase(), STR.toLocale*(),
                                                #          STR.localeCompare(), URL, BUFFER.transcode()
                                                #        - not supported: Intl, NUM|DATE.toLocale*(), TEXTENCODER|TEXTDECODER
                                                #     - 'system-icu':
                                                #        - same as 'small-icu', except link to ICU dataset dynamically instead
                                                #          of statically
                                                #        - i.e. depends whether OS includes ICU databaset, which most Linux do
                                                #     - 'none': no i18n, and STR.normalize(), Intl and BUFFER.transcode() fail
                                                #  - ENVVAR NODE_ICU_DATA=FILE
                                                #  - node --icu-data-dir=FILE
                                                #Can use package full-icu to down ICU dataset manually.

process.versions.icu                            #'VERSION'|undefined

ENCODING                                        #Either: ascii, utf8 (def), urf16le|ucs2, base64, hex, binary (actually latin-1)
                                                #For TEXTDECODER|TEXTENCODER, it is different (see DOM doc), and depends on ICU:
                                                #  - always: 'utf-8' (def), 'utf-16le'
                                                #  - if 'small|system-icu': 'utf-16be'
                                                #  - if 'full' ICU: many more (see online doc)

UTIL.TextDecoder|TextEncoder                    #Supported. See DOM doc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             UTIL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


inspect(VAL[, OBJ])                             #Print function used by repl. Returns as STR.
                                                #OBJ members are:
                                                #  - showHidden BOOL: if false (def), doesn't show non-enumerable properties,
                                                #    except SYMs
                                                #  - depth NUM (def: 2): max recursion (null|Infinity for infinite)
                                                #  - maxArrayLength NUM (def: 0) (null for infinite)
                                                #  - breakLength NUM (def: 60) (null for infinite):
                                                #    maxlength to print OBJ in multiline
                                                #  - compact BOOL (def: true): if false, adds more newlines and break long lines
                                                #  - colors BOOL (def: false)
                                                #  - customInspect BOOL: if true (def), will call
                                                #    VAL[util.inspect.custom](UINT[, OBJ])->STR if it exists
                                                #  - showProxy BOOL: if true (def: false), dereference PROXY (to their target)
                                                #Can change inspect.defaultOptions
                                                #require("buffer").INSPECT_MAX_BYTES: number of bytes printed for BUFFER
                                                #(def: 50)
inspect.colors                                  #OBJ with members defining colors. styles points category (e.g. number) to
inspect.styles                                  #color category, and colors point color category to color codes.

format(STR[, STR2...])                          #Printf-like FUNC, STR can contain:
                                                #  - "%s": STR
                                                #  - "%d", "%i": INT
                                                #  - "%f": FLOAT
                                                #  - "%j": JSON. Prints '[Circular]' on circular references. Handles toJSON()
                                                #  - "%O": OBJ. Uses UTIL.inspect() with default options
                                                #  - "%o": OBJ. Uses UTIL.inspect() with options: showHidden true, depth 4,
                                                #    showProxy true
formatWithOptions(OBJ, ...)                     #Like format(...) except if can specify inspect() options OBJ

debuglog(STR)                                   #Returns FUNC() that works like console.error() except:
                                                #  - appends STR
                                                #  - noop unless envvar NODE_DEBUG "STR2,..." (can include *) includes STR

promisify(FUNC(..., FUNC2(ERROR, VAL)))->FUNC   #Transform FUNC so FUNC(...)->PROMISE(ERROR|VAL)
                                                #If calling FUNC(..., FUNC2), FUNC2 still gets called, and PROMISE do not get
                                                #resolved|rejected
                                                #If FUNC throws, PROMISE gets rejected.
                                                #For this to work:
                                                #  - FUNC2 does not have to be last argument in FUNC declaration
                                                #  - but caller must specify all arguments up to FUNC2
                                                #If FUNC[util.promisify.custom] FUNC3 is defined, returns FUNC3 instead.
                                                #  - this is defined for setTimeout|setImmediate(), i.e. can be used even
                                                #    though callback is first parameter
callbackify(FUNC()->PROMISE)
 ->FUNC(..., FUNC2(ERROR, VAL))                 #Inverse. FUNC will not return PROMISE anymore

isDeepStrictEqual(VAL, VAL2)                    #Does a deep Object.is()
                                                #Does not compare non-enumerable properties

inherits(TYPE_FUNC, TYPEPARENT_FUNC)            #Makes TYPE inherits from TYPEPARENT, i.e. executes:
                                                #  TYPE.prototype = Object.create(TYPEPARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE
                                                #Also creates a TYPE.super_ that points to TYPEPARENT
                                                #Since it does not use OBJ in Object.create(), needs to create own static
                                                #members with TYPE.prototype.VAR = VAL


types.isRegExp(VAL)->BOOL                       #True if REGEXP
types.isDate(VAL)->BOOL                         #True if DATE
types.isPromise(VAL)->BOOL                      #True if PROMISE
types.is[Weak]Map|Set(VAL)->BOOL                #True if [WEAK]MAP|SET
types.isNativeError(VAL)->BOOL                  #True if instanceof ERROR
types.isProxy(VAL)->BOOL                        #True if PROXY

types.isArgumentsObject(VAL)->BOOL              #True if arguments

types.isAsyncFunction(VAL)->BOOL                #True if async FUNC

types.isGeneratorFunction(VAL)->BOOL            #True if FUNC *
types.isGeneratorObject(VAL)->BOOL              #True if return value of FUNC * (not just any ITERABLETOR)
types.isMap|SetIterator(VAL)->BOOL              #True if MAP|SET.keys|values|entries|Symbol.iterator()

types.is[Shared|Any]ArrayBuffer|DataView|
 TypedArray|[Big]Int|Uint|Float*Array(VAL)->BOOL#True if [SHARED]ARRAYBUFFER|DATAVIEW|TYPED_ARR|UINT|INT|FLOAT*ARRAY

types.isBoolean|Number|StringObject(VAL)->BOOL  #True if new Boolean|Number|String(VAL) (not Boolean|Number|String(VAL))
types.isSymbolObject(VAL)->BOOL                 #True if Object(Symbol(VAL)) (not Symbol(VAL))

types.isModuleNamespaceObject(VAL)->BOOL        #True if OBJ from import * as OBJ
types.isWebAssemblyCompiledModule(VAL)->BOOL    #True if compiled WASM
types.isExternal(VAL)->BOOL                     #True if external C/C++ value


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           COVERAGE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NODE_V8_COVEREAGE=DIR                           #ENVVAR
                                                #Uses V8 "startPreciseCoverage" to record coverage information and save to DIR/coverage-PID-TIMESTAMP.json
                                                #Has performance impact.
                                                #Includes internal Node.js code.
                                                #Includes branches that were not hit.
                                                #Does not include worker threads, but includes child processes.
                                               ##See Istanbul on how to convert it to Istanbul format

COVERAGE                                        #Content of the coverage file
COVERAGE.result                                 #FILECOV_ARR, ordered by load start

FILECOV                                         #Coverage of a special file
FILECOV.scriptId                                #Unique ID, incrementing 'INT'
FILECOV.url                                     #'PATH'
FILECOV.functions                               #FUNCCOV_ARR

FUNCCOV                                         #Coverage of a specific function
FUNCCOV.functionName                            #FUNC.name
                                                #Can be '', including for top-level scope
FUNCCOV.ranges                                  #LINECOV_ARR
FUNCCOV.isBlockCoverage                         #BOOL. If false, branch covers the whole function, i.e. FUNCCOV.ranges === 1
                                                #Note that on the other hand, sometimes FUNCCOV.ranges === 1 but FUNCCOV.isBlockCoverage === true

BRANCHCOV                                       #Coverage of a specific branch
BRANCHCOV.startOffset|endOffset                 #Bytes offset inside the file
BRANCHCOV.count                                 #NUM of times it was hit. Can be 0


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              V8               :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


getHeapStatistics()->OBJ                        #OBJ:
                                                #  - total|used_heap_size[_executable] NUM
                                                #  - total_physical|available_size NUM
                                                #  - heap_size_limit NUM
                                                #  - [peak_]malloced_memory NUM
                                                #  - does_zap_garbage BOOL
getHeapSpaceStatistics()->OBJ                   #OBJ:
                                                #  - space_name STR
                                                #  - space_[used|available_]size NUM
                                                #  - physical_space_size NUM
setFlagsFromString('--OPT ...')                 #Additional v8 CLI options
