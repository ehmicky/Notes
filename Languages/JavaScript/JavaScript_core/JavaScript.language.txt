
              
   JAVASCRIPT  
              



VERSION ==>                                     #Standard is called ECMAScript. JavaScript and ActionScript are dialects.
                                                #This doc shows strict mode only

SUPPORT ==>                                     #Use this notation for new features:
                                               ~#  - stage 3 proposal
                                            NUM*#  - introduced by Node NUM.*.* (starting at Node 14.0.0)
                                               *#  - not Node 18.2.0
                                               -#  - not all supported web browsers
                                               |#  - a core Babel plugin exists (only documented if lacks Node/browser support)
                                              ||#  - a non-core Babel plugin exists
                                             |||#  - a polyfill/ponyfill exists
                                                #Only document|use features in stage >= 3
                                                #Can look at support with:
                                                #  - EcmaScript kangax compat-table
                                                #  - http://node.green/

MAIN PRINCIPLES ==>                             #Case-sensitive. Whitespaces are ignored.
                                                #Type: weak, dynamic, generic, late/duck.
                                                #Lexical-scope
                                                #Functional (first-class functions)
                                                #Object-oriented (prototype-based)
                                                #Imperative (structures close to C)
                                                #Need a host environnement (e.g. browser) for I/O
                                                #Memory management: garbage collection.

EXECUTION ==>                                   #Each browser has own JavaScript engine, which was in the past interpreted,
                                                #but now is byte-compiled or compiled:
                                                #  - V8 (Chrome, Opera 15+, Edge >=2020, Node.js, Deno)
                                                #  - SpiderMonkey (Firefox, MongoDB >=3.2)
                                                #  - JavaScriptCore/SquirrelFish/Nitro (Safari) part of WebKit
                                                #  - Chakra (IE9+, Edge <2019), opensourced at ChakraCore


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ASYNC             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EVENT LOOP ==>                                  #Loops:
                                                #  - each event loop loops through [macro]tasks
                                                #  - each macrotask loops through microtasks|tick
                                                #  - each microtask is run synchronously

NEW TASKS ==>                                   #Each thread has a single event loop
                                                #  - creates a new thread: process, WebWorker, cross-origin <iframe>
                                                #Macrotasks are created by I/O code, which includes:
                                                #  - setTimeout|Interval|Immediate()
                                                #  - filesystem, network or OS calls
                                                #     - not streams on their own
                                                #  - event handlers triggered by browser interaction.
                                                #     - events triggered directly through JavaScript, which include Node.js EVENTEMITTER, are sync.
                                                #Microtasks are created by:
                                                #  - process.nextTick()
                                                #  - queueMicrotask()
                                                #  - PROMISE.then|catch() callbacks
                                                #  - priority:
                                                #     - first-in first-out
                                                #     - process.nextTick() before other types of microtasks
                                                #        - e.g. if a process.nextTick() create a new process.nextTick(),
                                                #          it will be fired before pending PROMISE microtasks

PERFORMANCE ==>                                 #For Node.js:
                                                #  - minimal time of a macrotask is 1ms.
                                                #    I.e. a macrotask that only does setTimeout(..., 0) will last 1ms
                                                #  - there is no minimal time for a microtask

SINGLE-THREADED ==>                             #Each event loop is single-threaded:
                                                #  - i.e. only one microtask and one macrotask runs at any time
                                                #Resources:
                                                #  - I/O-intensive tasks:
                                                #     - are the slowest
                                                #     - should yield the thread and be woken up on a new macrotask
                                                #     - this is what most I/O functions do by default, i.e. I/O calls are
                                                #       optimally handled
                                                #     - i.e. developer just need to use async I/O functions
                                                #  - CPU-intensive tasks:
                                                #     - will hold the whole thread
                                                #     - if too slow, should spawn a new thread instead
                                                #  - memory consumption:
                                                #     - is very low, because thread and processes is what makes memory go high

ASYNC EXPECTATION ==>                           #Libraries exposing callbacks should trigger them in a new microtask,
                                                #because this what consumers usually expect.
                                                #  - e.g. this would otherwise be problematic:
                                                #     let VAR = FUNC(CALLBACK); VAR.on('start', ...)

THREAD EXIT ==>                                 #Thread exits when the event loop has no more macrotasks
                                                #In a browser, this never happens, as there are always DOM event listeners.
                                                #In Node.js:
                                                #  - this means any of the following will keep the thread running:
                                                #     - process.nextTick(), queueMicrotask(), setTimeout|setInterval()
                                                #     - PROMISE.then|catch() FUNC, await PROMISE
                                                #     - TCPSERVER.ref(), CHILDPROCESS.ref(), and anything higher
                                                #  - some I/O objects expose unref() methods to yield the macrotask

ASYNC STACK TRACE ==>                           #Also called "long stack trace"
                                                #When using async, the callback function does not include stack trace from parent function
                                                #  - because it is processed on a different microtask
                                                #This is missing in:
                                                #  - setTimeout|Interval|Immediate(FUNC), process.nextTick(FUNC), queueMicrotask()
                                                #  - filesystem, network, OS or browser interaction event handlers
                                                #  - new Promise()
                                                #This is not missing when using async|await:
                                                #  - including whn using Promise.*()
                                                #  - supported:
                                                #     - code during|before an await statement: always
                                                #     - code after an await statement: most browsers and Node


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SCOPE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GENERAL ==>                                     #  - variable scope is:
                                                #     - "var": FUNC {...}
                                              -|#     - "let|const": any {...}
                                                #  - any function inherits scope of the function in which it is declared (not called)
                                                #     - inherits by reference, not by value
globalThis                                    -|#Global scope reference
                                              -|#Otherwise can be in many places (self in WORKER, window in DOM, global in Node.js, this otherwise)

DECLARATION ==>                                 #  - using undeclared VAR throws ReferenceError (except with typeof)
                                                #  - using VAR (even if declared in parent scope) declared later in
                                                #    current scope with:
                                              -|#     - "let|const": throws ReferenceError ("Temporal Dead Zone")
                                                #     - "var": adds an implicit empty declaration before, i.e. will be
                                                #       undefined (variable hoisting)
                                                #     - function FUNC(){}: adds an implicit declaration+assignment before

DECLARING FUNCTIONS ==>                         #  - FUNC = function [FUNC2](){}
                                                #     - declared+assigned at runtime (like other variables)
                                                #     - this also covers anonymous function, and void function [FUNC2](){}
                                                #     - Using "FUNC2":
                                                #        - equivalent of doing let FUNC2 = function(){} at the beginning of
                                                #          the same function
                                                #        - allow recursion to reference themselves without risk of parent
                                                #          scope to reassign FUNC2
                                                #  - function FUNC2(){}:
                                                #     - declared+assigned at parsetime
                                                #        - i.e. equivalent of doing let FUNC2 = function () {} at {...} scope
                                                #          beginning
                                                #  - new Function(...): child of global scope

MEMORY MANAGEMENT ==>                           #Garbage collection:
                                                #  - use tracing, i.e. no problem with reference cycles
                                                #  - root objects are global variables
                                                #  - closures carry references to their parent scope, but only of the
                                                #    references they use
                                                #     - this might be problematic when closures are returned, i.e. go up the
                                                #       stack, extending their parent scope lifetime
                                                #Memory leak happens with combination of variables being:
                                                #  - big, e.g.:
                                                #     - functions carrying parent SCOPEs
                                                #     - big objects
                                                #     - raw data returned from server
                                                #  - long-lived, e.g.:
                                                #     - attached to top/long-lived SCOPEs, e.g. global variables, e.g.:
                                                #        - long-lived DOM elements
                                                #        - global functions (e.g. global event handlers, setInterval(), ...)
                                                #Avoiding:
                                                #  - unset variables just after being used if they are big or attached to
                                                #    long-lived objects
                                                #     - "unset": prefer setting empty value than using "delete"
                                                #  - only use closures as argument or return value when needed

new WeakRef(OBJ)                        14.6.0*-#Keep a reference to OBJ, without preventing OBJ from being GC'd
                                        14.6.0*-#Should not rely:
                                        14.6.0*-#  - on when|whether GC happens, since this is very variable
                                        14.6.0*-#  - on it to guess when|whether GC happens
                                        14.6.0*-#For example, should not be used for resource cleanup.
                                        14.6.0*-#Should only be used as a way to prevent increasing memory usage.
                                        14.6.0*-#  - e.g. caches or weak maps
                                        14.6.0*-#  - consider using WeakMap|WeakSet if possible
WEAKREF.deref()->OBJ|undefined          14.6.0*-#Returns OBJ. undefined if OBJ was GC'd

new FinalizationRegistry(FUNC(OBJ, VAL))14.6.0*-#Same improper use warnings as WeakRef
FINALIZATION_REGISTRY.register          14.6.0*-#Calls FUNC(OBJ, VAL) when OBJ is GC'd
 (OBJ[, VAL][, VAL2])                   14.6.0*-#Keeps weak reference to OBJ|VAL2 (does not prevent it from being GC'd)
                                        14.6.0*-#Keep strong reference to VAL (i.e. should not be OBJ)
                                        14.6.0*-#VAL2 is the one to use with unregister() (can be same as OBJ)
FINALIZATION_REGISTRY.unregister
 (VAL2)->BOOL                           14.6.0*-#BOOL is whether it was registered

new Realm()                                 *-|~#Global environment
REALM.importValue('MDL', 'VAR')             *-|~#Like (await import('MDL')).VAR but bound to a REALM
 ->PROMISE_VAL                              *-|~#VAL must be simple type or FUNC
REALM.evaluate('CODE')->PROMISE_VAL         *-|~#Like eval('CODE') but bound to a REALM
                                            *-|~#VAL must be simple type or FUNC


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       BASIC STATEMENTS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RESERVED WORDS ==>                              #enum, await, implements, package, protected, public, private, interface,
                                                #static

STATEMENT;                                      #; optional, but recommended in case could be interpreted as multiline

STATEMENT\                                      #Only required for multiline statements:
                                                #  - within a STR
                                                #  - if first line could be interpreted as standalone statement.

// COMMENT
/* COMMENT */                                   #
#!...                                           #Ignored if first non-blank line

"use strict";                                   #Start strict mode:
                                                #  - i.e. strict ES6|ES7 conformance
                                                #  - allows faster optimization by browsers
                                                #  - not compatible until IE10
                                                #Applies to current and child scopes:
                                                #  - child scopes: including nested functions, anonymous functions, eval(),
                                                #    new Function(), etc.
                                                #  - but not functions declared in different scopes and called in current|child scopes
                                                #  - warning: concatenating with other scripts might put them in same scope,
                                                #    making them strict too.
                                                #  - must be before any statement (otherwise noop)
                                                #Implicit in any ES6 module (i.e. useless), but not in Node.js modules or
                                                #global scripts
                                                #In the web console, can use an anonymous function in order to use strict mode.

QUAL VAR[ = VAL]                                #Declaration. Default value is undefined.
  [, VAR2[ = VAL2]]...                          #VAR:
                                                #  - cannot be a reserved keyword
                                                #  - can contain:
                                                #     - any Unicode char with property "ID_Continue"
                                                #       (letters-like, numbers-like, diacretics)
                                                #     - $ or _
                                                #     - U+200C U+200D (zero-width space)
                                                #  - can be included as is, or using \u.... or \u{....}
                                                #  - first character must be Unicode char with property "ID_Start",
                                                #    (i.e. only letters-like) or $ or _
VAR = VAL;                                      #Assignation.
                                                #Returns VAL, so chain possible: VAR = VAR2 = VAL, but means VAR2 is global

[QUAL] [ VAR[ = VAL], ...[, ...ITERBL] ] = ARR-|#[QUAL ]VAR = ARR[NUM], ...
                                              -|#VAL is default value
                                              -|#Final ITERABLE is for variadic assignment
[QUAL] { KEY: VAR[ = VAL] } = OBJ             -|#[QUAL ]VAR = OBJ[KEY], ...
                                              -|#Without 'QUAL', must wrap with ({...} = OBJ)
                                              -|#VAL is default value
                                              -|#Can be { KEY: { KEY2: ... } }
                                              -|#KEY can appear several times with different VAR,
                                              -|#including { KEY: { KEY2 }, KEY: KEY }
[QUAL] { KEY[ = VAL] } = OBJ                  -|#Same as QUAL { KEY: KEY[ = VAL] } = OBJ

QUAL                                            #var|let|const
let VAR                                       -|#Like var VAR, but {} block scoped.
const VAR                                     -|#Like let VAR but read-only, i.e. throws error on assignments beyond
                                              -|#declaration
                                              -|#Is shallow: if OBJ, only OBJ is read-only, not OBJ.VAR
                                              -|#Is only for current block scope since:
                                              -|#  - function arguments imply new assignment
                                              -|#  - function return value must be assigned to be used as reference

delete OBJ.VAR                                  #Like assigning undefined except:
                                                #  - remove key as well
                                                #  - cannot be performed if non-configurable
                                                #  - can be performed if non-writable
                                                #Note: for ARR[NUM], does not modify length (like assigning undefined)
                                                #Returns true if OBJ (not OBJ.VAR) exists.

void STATEMENT                                  #Same as STATEMENT, but returns undefined
                                                #void 0 is sometimes used to return undefined without risk for shadowing
                                                #  - But not needed since shadowing can be caught by linting

eval("STATEMENT...")                            #Fire STATEMENT... in current scope. Return last STATEMENT return value.
                                                #To avoid.
                                                #If argument non STR, renvoie VAL.
                                                #"VAR = VAL" does not declare anything.
                                                #Can throw SyntaxError or EvalError.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          STRUCTURES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SINGLE LINE ==>                                 #Block braces can be skipped if only on single next line (to avoid)

VAL                                             #Anything that returns a VAL
EXPR                                            #Anything that could go on a single line of code ending with ;
...                                             #Several EXPR


TEST ? VAL1 : VAL2                              #Returns VAL1 or VAL2

VAL && VAL2                                     #Same as VAL ? VAL : VAL2
VAL || VAL2                                     #Same as VAL ? VAL2 : VAL
VAL ?? VAL2                            14.0.0*-|#Same as VAL == null ? VAL : VAL2

VAR &&= VAL2                           15.0.0*-|#Same as VAR = VAR && VAL2
VAR ||= VAL2                           15.0.0*-|#Same as VAR = VAR || VAL2
VAR ??= VAL2                           15.0.0*-|#Same as VAR = VAR ?? VAL2

VAL1, VAL2                                      #Evaluates both, but returns VAL2.
                                                #Use case: in for or while loops.


{ ... }                                         #Creates a scope

(VAL)                                           #To increase precedence.

if ( TEST ) { ... }
[else if ( TEST ) { ... }]...
[else { ... }]

switch (VAL) {                                  #Use VAL === VAL2
  case VAL2: ...  [break;] ...                  #If no break, execute next case (including "default")
  case VAL3: case VAL4: ...  [break;] ...       #Case can be empty, meaning several "case" match when any matches.
  [default: ...  [break;]]                      #... can be wrapped in { ... }, which creates a scope
}

for ( [EXPR1] ; [TEST] ; [EXPR2] ) { ... }      #Same as:
                                                #  EXPR1; while ( TEST ) { ...; EXPR2; }
while ( TEST ) { ... }
do { ... } while ( TEST )

for ( [QUAL] VAR in OBJ ) { ... }               #Iterate over keys that are enumerable, excluding SYMs
                                                #OBJ can be ITERATOR.

break [LABEL]                                   #Stop current for|while|switch iteration or (only with LABEL)
                                                #if_else|anonymous block
                                                #Can target a specific for|while|switch iteration by specifying LABEL: before
                                                #it (to avoid), e.g. LABEL: for ... or LABEL: if ...
continue [LABEL]                                #Same but only current loop, and only for|while


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TYPES             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPING SYSTEM ==>                               #  - weak: no type specified at Declaration
                                                #  - generic: native operators accepts any type, since each native type
                                                #    transtype to any (except OBJ->undefined|null)
                                                #  - dynamic: type is not checked at compile-time nor (since generic) run-time

AVAILABLE TYPES ==>                             #  - simple: number|boolean|string|bigint|symbol|undefined|null
                                                #  - object (TYPE): Object and its children
                                                #    - native: Object|Array|Number|Boolean|String|Error|...
                                                #    - user-defined:
                                                #       - host objects: defined by browser (e.g. DOM elements)

typeof VAR                                      #Returns "boolean|string|number|bigint|symbol|undefined|object|function"
                                                #"object": includes null, excludes FUNC
Object.prototype.toString.call(VAL)->STR        #Returns '[object NAME]' where NAME is (in priority order):
                                              -|#  - '[object OBJ[Symbol.toStringTag]]'
                                                #  - builtin:
                                                #     - 'Null|Undefined|Number|String|Boolean|BigInt|Symbol'
                                                #     - 'Object'
                                                #     - 'Array|[Shared]ArrayBuffer|DataView|[Big][U]Int|FloatNUMArray'
                                                #     - '[Async][Generator]Function'
                                                #     - 'Arguments'
                                                #     - 'RegExp|Date|Error|[Weak]Map|[Weak]Set|WeakRef|Realm'
                                                #     - 'Generator'
                                                #     - 'Promise'
                                                #     - 'Module'
                                                #     - 'Intl.*'
                                                #     - 'Math|JSON|Intl|Atomics|Reflect': the namespace itself
                                                #     - 'global'
                                                #     - not: Proxy
                                                #  - 'Object'
                                                #  (DOM only)
                                                #  - 'DOMError' (deprecated), 'DOMException'


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           EQUALITY            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/

VAL == VAL2
VAL != VAL2                                     #Implicit transtype
VAL === VAL2
VAL !== VAL2                                    #No implicit transtype

OBJ == OBJ2
OBJ != OBJ2
OBJ === OBJ2
OBJ !== OBJ2                                    #Same reference

Object.is(VAL, VAL2)                          -|#Same as ===, except !Object.is(+0,-0) and Object.is(NaN, NaN)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TRANSTYPING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


IMPLICIT TRANSTYPING ==>                        #Uses String|Boolean|Number|BigInt|Object(VAL)
EXPLICIT TRANSTYPING ==>                        #Prefer using String|Boolean|Number|BigInt|Object(VAL).
                                                #Sometimes used (avoid):
                                                # - BOOL: !!VAL
                                                # - NUM: +VAL, VAL*1, VAL/1, ~~VAL, VAL|0, VAL-0
                                                # - STR: VAL + ''

OBJ[Symbol.toPrimitive]('default')              #Called when implicit type ambiguous, e.g. VAL + STR or VAL == VAL2


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           UNDEFINED           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


undefined                                       #Value of:
                                                #  - non-declared VAR: throw ReferenceError when used, except with typeof
                                                #  - declared but non-assigned VAR (including arguments and return value)
                                                #Global variable, not keyword
                                                #  - non-configurable|writable
                                                #  - but can be shadowed by local VAR named "undefined"

typeof VAR === 'undefined'                      #Like VAR === undefined, except no ReferenceError if VAR undeclared
                                                #Should never be necessary:
                                                #  - useless in local scopes
                                                #  - in global scope, use globalThis.VAR === undefined


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             NULL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


null                                            #Special keyword indicating emptiness

VAL == null                                     #Implicitly transtype to null|undefined, i.e. returns true for both
VAL === null|undefined                          #No implicit transtype


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BOOLEAN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


true|false                                      #BOOL

!BOOL
BOOL && BOOL2
BOOL || BOOL2

Boolean(VAL)->NUM                               #Used for explicit|implicit transtyping.
                                                #  - STR: '' false, '...' true
                                                #  - NUM|BIGINT: 1 true, 0 false
                                                #  - undefined|null: false
                                                #  - OBJ|SYM: true


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            NUMBER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NUM                                             #Always double-precision float (binary64)
                                                #Can use TYPED_ARR for single-precision floats or 8|16|32-bits [u]ints
0xNUM
0XNUM                                           #16 radix
0oNUM
0ONUM                                           #8 radix
0bNUM
0BNUM                                           #2 radix
NUM_...                                       -|#Underscores can be added:
                                              -|#  - they are ignored and meant as separators
                                              -|#  - works with any radix except octals

NUM + - * / % NUM2                              #
-NUM                                            #
NUM++ ++NUM NUM-- --NUM                         #
NUM ** NUM2                                     #
NUM ~ & ^ | >> << >>> NUM2                      #
NUM OP= NUM2                                    #E.g. NUM += NUM2
NUM < <= > >= NUM2                              #

Number(VAL)->NUM                                #Used for explicit|implicit transtyping:
                                                #  - STR:
                                                #     - '': 0
                                                #     - 'NUM': NUM
                                                #        - trims whitespaces
                                                #     - others: NaN
                                                #  - BOOL: true 1, false 0
                                            -|||#  - BIGINT: TypeError
                                            -|||#     - can be explicitely converted though
                                            -|||#     - in which case, transtyped to [-]Infinity if out-of-bound
                                                #  - undefined: NaN
                                                #  - null: 0
                                              -|#  - SYM: TypeError
                                                #  - OBJ (in priority):
                                              -|#     - OBJ[Symbol.toPrimitive]('number')
                                                #     - OBJ.valueOf()
                                                #     - NaN
[Number.]parseFloat(VAL)->NUM                   #Like Number(VAL) but:
                                                #  - returns NaN for non-NUM|STR and ''
                                                #  - removes trailing non-numerical chars in STR
                                                #  - only understands decimal form
[Number.]parseInt(VAL[, NUM])->NUM              #Same as [Number.]parseFloat() but:
                                                #  - removes decimals
                                                #  - understands decimal or hexadecimal form by default.
                                                #     - if NUM, forces radix

NUM.toFixed([NUM])->STR                         #Number of decimal digits.
                                                #Might have exponential notation or not.
                                                #Def|min NUM: 0. Max NUM: 100.
NUM.toExponential([NUM])->STR                   #Number of decimal digits.
                                                #Always use exponential notation.
                                                #Def|min NUM: 0. Max NUM: 100.
NUM.toPrecision([NUM])->STR                     #Number of integer+decimal digits, excluding leading decimals zeros if integer is 0
                                                #Might have exponential notation or not.
                                                #Min NUM: 1. Max NUM: 100.
                                                #If no NUM, behaves like NUM.toString()
NUM.toString(RADIX)->STR                        #

Number.isInteger(NUM)                         -|#Does not coerce to NUM

[Number.]NaN                                    #Returned e.g. by √-1, 0/0 or wrong NUM conversion
                                                #Test:
                                                #  - NaN !== NaN but Object.is(NaN, NaN)
                                              -|#  - Number.isNaN(VAL): same as Object.is(VAL, NaN)
                                                #  - isNaN(VAL): same as Number.isNaN(Number(VAL))
[-]Infinity                                     #Returned e.g. by overflow like 1e400, or 1/0
Number.POSITIVE_INFINITY|NEGATIVE_INFINITY      #Test:
                                                #  - [-]Infinity === [-]Infinity
                                              -|#  - Number.isFinite(VAL): typeof VAL === 'number' && VAL !== [-]Infinity && !Number.isNaN(VAL)
                                                #  - isFinite(VAL): same as Number.isFinite(Number(VAL))

Number.MIN_VALUE                                #Closest to 0 (underflow) (about 5e-324)
Number.MAX_VALUE                                #After it is Infinity (overflow) (about 2e+308)
Number.MIN|MAX_SAFE_INTEGER                   -|#Smallest|highest integer that can be represented as a float precisely
                                              -|#(about +|-1e16)
Number.isSafeInteger(NUM)->BOOL               -|#Number.isInteger(NUM) && NUM >= Number.MIN_SAFE_INTEGER && NUM <= Number.MAX_SAFE_INTEGER
                                              -|#Does not coerce to NUM
Number.EPSILON                                -|#NUM +|- NUM2 can create small discrepancies, e.g. 0.3 - 0.1 within a
                                              -|#EPSILON range:
                                              -|#  - When comparing non-integer NUMs, should check NUM-NUM2 < +|-EPSILON
                                              -|#  - about 2e-16


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BIGINT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NUMn                                        -|||#BIGINT. Infinite precision integer
                                            -|||#Behaves like NUM:
                                            -|||#  - including octal, hex, binary notations
                                            -|||#  - including toString(RADIX)
                                            -|||#Exceptions:
                                            -|||#  - integer not double:
                                            -|||#     - / % round towards 0
                                            -|||#  - cannot use >>> nor +NUMn
                                            -|||#  - throw on JSON.stringify()
                                            -|||#  - has its own typeof, constructor
                                            -|||#  - no BIGINT.toFixed|toPrecision|toExponential() (since it is integer)

BigInt(VAL)->NUM                                #Used for explicit|implicit transtyping.
                                                #  - STR|BOOL|OBJ|undefined: like NUM except SyntaxError instead of NaN
                                                #  - null|SYM: SyntaxError
                                                #  - NUM:
                                                #     - implicit: TypeError
                                                #        - exception: == === != !== < <= > >=
                                                #     - explicit: possible
                                                #        - transtyped to [-]Infinity if out-of-bound

BigInt.asUintN|asIntN(NUM, NUM2n)->NUM2n    -|||#Enforce max size NUM bits on NUM2n
                                            -|||#On overall, rotate to min|max value (according to NUM)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


"..."                                           #Escapes everything but " newline and \ (including trailing)
'...'                                           #Escapes everything but ' newline and \ (including trailing)
`...${EXPR}...`                               -|#"..." + EXPR + "..."
                                              -|#Escapes everything (including " ' or newline) but ` ${ or \
\CHAR                                           #Any backslash escape can be used except \a, \c et \e
NEWLINE ==>                                     #OS-independent: '\n' is LF, '\r' is CR
                                                #OS-dependent (CR+LF on Windows, LF others): terminal|file I/O
MAX LENGTH ==>                                  #Standard: at most 2**53 - 1, i.e. ~9e15
                                                #Engine-dependent:
                                                #  - v8: 2**29 - 24, i.e. ~5e8
                                                #  - SpiderMonkey: 2**30 - 2, i.e. ~1e9
                                                #  - SquirrelFish: 2**31 - 1, i.e. ~2e9

STR + STR2                                      #
STR += STR2                                     #
STR.concat(STR2...)                             #

STR < <= > >=                                   #Char by char, code unit-wise

String(VAL)->STR                                #Used for explicit|implicit transtyping:
                                                #  - BOOL|NUM|undefined|null: 'BOOL|...'
                                                #  - BIGINT: 'NUM' (not 'NUMn')
                                              -|#  - SYM: 'Symbol(VAR)'
                                              -|#     - only with explicit String(SYM) or SYM.toString()
                                                #  - OBJ (in priority order):
                                              -|#     - OBJ[Symbol.toPrimitive]('string')
                                                #     - OBJ.toString()
                                                #        - FUNC|ARR|REGEXP|DATE|ERROR: see own doc
                                                #     - OBJ.valueOf()
                                                #     - Object.prototype.toString.call(VAL) (see its doc)

FUNC`...`                                     -|#FUNC(STR_ARR, VAL...)->VAL:
FUNC `...`                                    -|#  - VAL... are each ${EXPR}
                                              -|#  - STR_ARR[.raw][NUM]:
                                              -|#     - each `...` in-between
                                              -|#        - including empty "" at beginning|end if starts|ends with ${EXPR}
                                              -|#     - if "raw", escape backslashes
                                              -|#  - special case for backslash sequences (only if FUNC specified):
                                              -|#     - STR is undefined
                                              -|#     - escaped in STR.raw, e.g. '\\n'
                                              -|#FUNC can be String.raw(), which concatenates all like normal template,
                                              -|#except it escape backslashes


STR[NUM]                                        #Read-only. undefined if out of range.
STR.charAt(NUM)                                 #Same except "" if out of range
STR.at(NUM)->'CHAR'                   16.6.0*-|~#Like STR[NUM] except -NUM is from end, and is not writable

STR.length                                      #Number of characters

STR.match(REGEXP)                               #Like REGEXP.exec(STR), except that if g flag, returns all matches as ARR
                                                #(or null)
STR.matchAll(REGEXP)                          -|#Returns ITERABLE that returns successive REGEXP.exec(STR)
                                              -|#I.e. as opposed to STR.match(), when using a g flag, parenthesis groups and
                                              -|#indices will be returned too
STR.search(REGEXP)                              #Like STR.indexOf() but with a REGEXP
STR.starts|endsWith|includes(STR2[, NUM])     -|#

STR.replace(REGEXP|STR2, STR3)                  #Returns STR, replacing REGEXP with STR3, which can contain:
                                                #  - $1, etc.: parenthesis group matches
                                                #  - $&: full match
                                                #  - $`: what's before full match
                                                #  - $': what's after full match
                                                #  - $$: $ literal
STR.replace(REGEXP|STR2,
 FUNC($&, $1..., INDEX, STR))                   #Returns STR, replacing REGEXP with FUNC(...)
STR.replaceAll(REGEXP|STR2, STR3)
STR.replaceAll(REGEXP|STR2,            15.0.0*-|#Same as STR.replace(...) but STR2 implies a 'g' flag.
 FUNC($&, $1..., INDEX, STR))          15.0.0*-|#If REGEXP, must have a 'g' flag.
STR.split(REGEXP|STR2[, UINT])                  #Returns an ARR, with REGEXP|STR2 being split delimiter.
                                                #If STR2 is '', means between each characters.
                                                #If REGEXP contains parenthesis groups, each is included in ARR between
                                                #each element.
                                                #If UINT, does ARR.slice(0, UINT)
STR.repeat(NUM)                               -|#

OBJ[Symbol.match](...)                        -|#Methods to implement to be able to use STR.match(OBJ)
                                              -|#or STR.startsWith|endsWith|includes(OBJ)
                                              -|#Implemented by REGEXP
OBJ[Symbol.replace|split](...)                -|#Methods to implement to be able to use STR.replace|split(OBJ).
                                              -|#Implemented by REGEXP
OBJ[Symbol.search](...)                       -|#Methods to implement to be able to use STR.search(OBJ).
                                              -|#Implemented by REGEXP

STR.toUpper|LowerCase()                         #
STR.trim()                                      #
STR.trimLeft|Right()                            #Remove whitespaces (same as /\s/) on left and|or right.
STR.trimStart|End()                            |#Aliases for trimLeft|Right()
STR.padStart|End(NUM[, STR2])                 -|#If STR.length < NUM, prepends|appends STR2 (def: ' ') until STR.length === NUM

STR.[lastI/i]ndexOf(STR[, NUM])
STR.slice([NUM[, NUM2]])                        #Like ARR
STR.substring(NUM[, NUM2])                      #Like .slice() except:
                                                #  - negative NUM2 -> 0
                                                #  - If NUM2 < NUM, swap
STR.substr(NUM[, NUM2])                         #Like .slice() except:
                                                #  - NUM can be negative (index from end)
                                                #  - NUM2 is length, not index

en|decodeURI(STR)                               #Percent-encode any character not permitted in URIs, i.e. anything but:
                                                #  [:alnum:] - . _ ~ ! ' ( ) * # : ? & = + $ ; , / @
                                                #Should be used for full URIs
                                                #Uses UTF-8
                                                #decodeURI() can throw URIError
en|decodeURIComponent(STR)                      #Same but also percent-encode characters that might have semantics in
                                                #URIs parts:
                                                #                              # : ? & = + $ ; , / @
                                                #I.e. does not percent-encode the following (should escape if it has semantics
                                                #for specific case):
                                                #  [:alnum:] - . _ ~ ! ' ( ) *
                                                #Should be used for URI parts
[un]escape(STR)                                 #Like en|decodeURIComponent() but using a different set of what's considered URI part:
                                                #                  ~ ! ' ( )   # : ? & =   $ ; ,
                                                #I.e. does not percent-encode the following:
                                                #  [:alnum:] - . _           *           +       / @
                                                #Also, uses UTF-16, with Unicode chars percent encoded as %uUUUU, not a series of %XX
                                                #Deprecated


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            UNICODE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ENCODING ==>                                    #UTF-16:
                                                #  - S_CODEPOINT: 1 character === 1 codepoint
                                                #  - CODEPOINT:   1 character === 1 codepoint (<U+10000) or 2 surrogate codepoints (>=U+10000)
                                                #  - isolated|inverted surrogate pairs are not invalid: they are considered their own character|codepoint instead
                                                #Exceptions:
                                                #  - encode|decodeURI[Component]() uses UTF-8
                                                #  - the platform (Node.js, Web APIs) provides with encoding-specific operations. often with UTF-8

S_CODEPOINT                                     #Single Unicode character STR. Any, even U+10FFFF
CODEPOINT                                       #Like S_CODEPOINT except > U+FFFF treats each surrogate as own character.
                                                #All STR operations use CODEPOINTs:
                                                #  - including STR.length, STR[NUM], STR.*(), comparison, max length
                                                #  - except:
                                                #     - STR iteration
                                                #     - STR.to[Locale]Lower|UpperCase(), STR.trim*()
                                                #     - \u{}, String.fromCodePoint(), STR.codePointAt(), /REGEXP/u
[S_]CODEPOINT[_NUM]                             #Same as NUM

\uCODEPOINT_HEXA                                #CODEPOINT in a STR
\u{S_CODEPOINT_HEXA}                          -|#S_CODEPOINT in a STR

String.fromCharCode(CODEPOINT_NUM...)->STR      #
String.fromCodePoint(S_CODEPOINT_NUM...)->STR -|#Returns STR

STR.charCodeAt(NUM)->CODEPOINT                  #NUM is CODEPOINT-wise
                                                #For > U+FFFF, if NUM is on:
                                                #  - the first|second surrogate pair: CODEPOINT is returned
                                                #If NUM out-of-range, returns NaN.
STR.codePointAt(NUM)->S_CODEPOINT             -|#NUM is CODEPOINT-wise
                                              -|#For > U+FFFF, if NUM is on:
                                              -|#  - the first surrogate pair: S_CODEPOINT is returned
                                              -|#  - the second surrogate pair: CODEPOINT is returned
                                              -|#If NUM out-of-range, returns undefined.

/REGEXP/u                                     -|#  - operate with S_CODEPOINT instead of CODEPOINT
                                              -|#     - for example for . [] {NUM,NUM2} etc.
                                              -|#  - stricter REGEXP syntax enforcement, e.g. /{/ throws
                                              -|#  - allow using \p or \P

STR.normalize([STR2])                          -#Some codepoint sequences are equivalent, e.g. with diacretics
                                               -#Equivalence types:
                                               -#  - canonical: same abstract character, including visual appearance and behavior
                                               -#     - example: '\u00e9' (é) (composed) and '\u0065\u0301' (e  ́) (decomposed)
                                               -#  - compatibility: looser superset, i.e. enough if can be treated alike
                                               -#     - examples:
                                               -#        - '\ufb00' (ﬀ ) (composed) and '\u0066' (ff) (decomposed)
                                               -#        - '\u24b9' (Ⓓ ) (composed) and '\u0044' (D) (decomposed)
                                               -#Can be:
                                               -#  - "NFC" (def): decomposes then compose (canonical)
                                               -#  - "NFD": decompose (canonical)
                                               -#  - "NFKC": decompose then compose (compatibility)
                                               -#  - "NFKD": decompose (compatibility)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            SYMBOLS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Symbol([STR])                                 -|#SYM
SYM.description                               -|#STR

SYM == != === !== SYM                         -|#Symbols are compared by identify, regardless of SYM.description

SYM.toString()->'Symbol(STR)'                 -|#STR is SYM.description

OBJ[SYM]                                      -|#Same as OBJ["RANDOM"], semantically for private members.
                                              -|#Different methods to enumerate (see above)
                                              -|#SYM properties ignored by JSON.stringify()

Symbol.for(STR)                               -|#Like Symbol(STR), except "register" it to a global store using STR as a key,
                                              -|#so that Symbol.for(STR) === Symbol.for(STR)
Symbol.keyFor(SYM)                            -|#Returns STR if SYM was created as Symbol.for(STR), undefined otherwise.

WELL-KNOWN SYMBOLS ==>                        -|#SYM that can be used to override native behavior.
                                              -|#E.g. Symbol.iterator
                                              -|#When printed, sometimes abbreviated to @@VAR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OBJECTS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[new] Object(VAL)                               #Used for implicit|explicit conversion.
                                                #For any type:
                                                #  - new type is OBJ, i.e. different type
                                                #  - but behavior is same thanks to implicit transtyping
                                                #For Number|BigInt|String|Boolean:
                                                #  - can also use new TYPE(VAL)
                                                #For undefined|null:
                                                #  - prototype is null
                                                #  - no implicit transtyping
                                                #All OBJs inherit from Object except Object.create(null)

OBJ.VAR                                         #Access property (can be any type)
OBJ['VAR']                                      #OBJ.VAR has same naming restrictions as QUAL VAR, except can be a reserved word
                                                #OBJ['VAR'] can use any valid STR
                                                #Throws with undefined|null

OBJ?.VAR                               14.0.0*-|#Like OBJ == null ? undefined : OBJ.VAR
OBJ?.['VAR']                           14.0.0*-|#Like OBJ == null ? undefined : OBJ['VAR']

{ VAR[: VAL] ... }                              #Literal OBJ.
                                                #If could be interpreted as a { ... } structure (e.g. beginning of line),
                                                #wrap with ()
                                                #VAR can either:
                                                #  - be "VAR" or 'VAR': any valid STR
                                                #  - be unquoted, with same naming restrictions as QUAL VAR except:
                                                #     - can be reserved keywords
                                                #     - can be any NUM, which will be converted to STR
                                              -|#Def VAL is VAR
                                              -|#VAR can be [STR], for dynamic property name
                                              -|#If duplicate key, the last one will overwrite the ones before.
{ FUNC() {...} ... }                          -|#Same as { FUNC: function FUNC() {...} ... }

PROPERTIES ORDER ==>                            #Guaranteed to be in that order:
                                                #  - 'NUM', sorted numerically
                                                #  - STR, sorted by creation time
                                                #  - SYM, sorted by creation time

OWN / ENUMERABLE ==>                            #              +-------------------------------------------------------+-------------------------------+
                                                #              | Own                                                   | Own+inherited                 |
                                                # +------------+-------------------------------------------------------+-------------------------------+
                                                # | enum       | OBJ.propertyIsEnumerable('VAR'|SYM)->BOOL             | for (QUAL NOT_SYM_VAR in OBJ) |
                                                # |            | Object.keys(OBJ)->'VAR'_ARR                           |                               |
                                                # |            | Object.values|entries|fromEntries(...)                |                               |
                                                # |            | Object.assign(...), { ...OBJ }                        |                               |
                                                # +------------+-------------------------------------------------------+-------------------------------+
                                                # | [non-]enum | OBJ.hasOwnProperty('VAR'|SYM)->BOOL                   | 'VAR'|SYM|#PROP in OBJ        |
                                                # |            | Object.hasOwn(OBJ, 'VAR'|SYM)->BOOL                   |                               |
                                                # |            | Reflect.ownKeys(OBJ)=>'VAR'|SYM_ARR                   |                               |
                                                # |            | Object.getOwnPropertyNames(OBJ)->'VAR'_ARR            |                               |
                                                # |            | Object.getOwnPropertySymbols(OBJ)->SYM_ARR            |                               |
                                                # |            | Object.getOwnPropertyDescriptor(OBJ, 'VAR'|SYM)->OBJ2 |                               |
                                                # |            | Object.getOwnPropertyDescriptors(OBJ)->OBJ3           |                               |
                                                # +------------+-------------------------------------------------------+-------------------------------+

'VAR'|SYM in OBJ                                #Returns true if OBJ['VAR'|SYM] is member
                                                #Negation: !('VAR' in OBJ)
#PROP in OBJ                           16.5.0*-|#Same for private #PROP
OBJ.hasOwnProperty('VAR'|SYM)->BOOL             #Returns true if OBJ['VAR'|SYM] is own
Object.hasOwn(OBJ, 'VAR'|SYM)->BOOL    16.9.0*-|#Same
OBJ.propertyIsEnumerable('VAR'|SYM)->BOOL       #Returns true if OBJ['VAR'|SYM] is own + enumerable

Object.keys(OBJ)->'VAR'_ARR                     #Returns keys that are own + enumerable + not SYMs
Reflect.ownKeys(OBJ)->'VAR'|SYM_ARR             #Returns keys that are own
Object.getOwnPropertyNames(OBJ)->'VAR'_ARR      #Returns keys that are own + not SYMs
Object.getOwnPropertySymbols(OBJ)->SYM_ARR      #Returns keys that are own + SYMs

Object.values(OBJ)                            -|#Same as Object.keys() but for values
Object.entries(OBJ)                           -|#Same as Object.keys() but for [KEY, VALUE]
Object.fromEntries(ITERABLE)                  -|#Inverse Object.entries(), i.e. from ITERABLE of [KEY, VALUE] to OBJ
                                              -|#As opposed to Object.entries(), KEY that SYM are not skipped

Object.assign(OBJ[, OBJ2...])                 -|#Shallow copy of own enumerable OBJ2 members (including SYMs) to OBJ, which is returned.
                                              -|#Properties copied in OBJ are:
                                              -|#  - always configurable|writable, even if OBJ2 members were not
                                              -|#  - resolved, if OBJ2 members were getters
{ [...] ...OBJ2 [...] }                       -|#Same as Object.assign({}, OBJ2, ...)

[QUAL] { [...] ...OBJ } = OBJ2                -|#Does Object.assign(OBJ, OBJ2), except the parts mentioned in ...


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      OBJECT DESCRIPTORS       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


{ get|set VAR(...) {...} }                      #Like { VAR(...) {...} } followed by Object.defineProperty() with configurable|enumerable true

Object.defineProperty(OBJ, 'VAR'|SYM, OBJ2)     #Assign OBJ['VAR'|SYM] = VAL, where VAL depends on OBJ2 ('descriptors'):
                                                #  - either (def: value undefined):
                                                #     - value VAL
                                                #     - get and|or set:
                                                #        - get()->VAL
                                                #           - called at OBJ.VAR
                                                #           - def: returns undefined
                                                #        - set(VAL)
                                                #           - called at OBJ.VAR = VAL
                                                #           - `this` is OBJ
                                                #              - no return value, i.e. must be modified
                                                #           - must not set this.VAR to avoid infinite recursion
                                                #           - def: TypeError on set
                                                #  - enumerable BOOL (def: false):
                                                #     - if false, not listed by Object.keys|...(), OBJ.propertyIsEnumerable() and for (QUAL STR in OBJ)
                                                #  - writable BOOL (def: false):
                                                #     - if false, throws TypeError if OBJ.VAR = VAL
                                                #        - even if VAL did not change
                                                #        - even if VAR is inherited through the __proto__ chain
                                                #        - but can still Object.defineProperty() if configurable
                                                #     - not possible with get|set():
                                                #        - always undefined
                                                #        - setting it throws
                                                #  - configurable BOOL (def: false):
                                                #     - if false, throws TypeError:
                                                #        - if:
                                                #           - delete OBJ.VAR
                                                #           - set configurable|writable|enumerable
                                                #              - except if same value
                                                #        - not if:
                                                #           - OBJ.VAR = VAL
                                                #           - VAR is inherited through the __proto__ chain
                                                #When fired several times, each call only overwrite the specified descriptors.
Object.getOwnPropertyDescriptor(OBJ, 'VAR'|SYM) #Returns OBJ.VAR descriptor OBJ2
 ->OBJ2                                         #Even if not declared through Object.defineProperty()
                                                #Returns undefined if does not exists or is not own.
                                                #Including SYMs
Object.defineProperties(OBJ, OBJ3)
Object.getOwnPropertyDescriptors(OBJ)->OBJ3     #Same but using OBJ3 { 'VAR': OBJ2 ... } instead.

Object.preventExtensions(OBJ)                   #Make OBJ non-extensible, i.e. TypeError if:
                                                #  - adding new property
                                                #  - setting __proto__
                                                #Not recursive.
Object.isExtensible(OBJ)                        #

Object.seal(OBJ)                                #Make OBJ non-extensible, non-configurable
                                                #Not recursive.
Object.isSealed(OBJ)                            #

Object.freeze(OBJ)                              #Make OBJ non-extensible, non-configurable, non-writable (except get|set())
                                                #Not recursive.
Object.isFrozen(OBJ)                            #

                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          PROTOTYPES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OBJ.__proto__                                   #When OBJ.VAR is not defined, OBJ.__proto__.VAR is tried
                                                #  - recursively (prototype chain)
                                                #  - the last __proto__ is null
                                                #Setting OBJ.__proto__[...].VAR creates OBJ.VAR instead
                                                #  - including with Object.defineProperty() and delete
                                                #  - even if value did not change
                                                #I.e. inheritance is prototype-based.
                                                #__proto__ itself is considered an inherited, non-enumerable, writable, configurable property
Object.getPrototypeOf(OBJ)->VAL                 #Same but less standard and:
                                                #  - returns `null` instead of `undefined` for null prototype
                                                #  - does not return `undefined` if no prototype in the chain is Object.prototype
Object.setPrototypeOf(OBJ, VAL)->OBJ          -|#Same as OBJ.__proto__ = VAL (to avoid because performance issues)
OBJ.isPrototypeOf(OBJ2)                         #Returns true if OBJ2.__proto__[...] === OBJ
                                                #I.e. if isPrototypeOf TYPE, also true for TYPE_PARENT
                                                #Always false for non-OBJs, but does not throw.

super.*                                       -|#Same as this.__proto__.*
super[EXPR]                                   -|#Can be used in any OBJ method using shortcut notation

MULTIPLE INHERITANCE ==>                        #Not supported, but be approximated using composition|mixins, including:
                                                #  - own members: call several TYPE_PARENT(...) in constructor
                                                #  - inherited members: merge TYPE_PARENT.prototype to TYPE.prototype
                                                #     - con: copied, not referenced (except deep properties)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CONSTRUCTORS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE                                            #Constructor FUNC
                                                #Cannot be an arrow FUNC
                                                #By convention TYPE starts with uppercase

TYPE.prototype                                  #Properties that all TYPE instances should inherit
                                                #Set to empty OBJ when any FUNC is instantiated
                                                #  - not set for arrow nor bound FUNCs
Object.create(TYPE.prototype[, OBJ])->OBJ2      #Returns { __proto__: TYPE.prototype }
                                                #Then calls Object.defineProperties(OBJ2, OBJ)
Object.create(null)                             #OBJ where __proto__ is null instead of Object.prototype
PROTOTYPE POLLUTION ==>                         #Setting core OBJ.* property to override core behavior.
                                                #For: OBJ.hasOwnProperty|propertyIsEnumerable|isPrototypeOf|to[Locale]String|valueOf()
                                                #Can be prevented with:
                                                #  - call-time: Object.prototype.FUNC.call(OBJ, ...) instead of OBJ.FUNC(...)
                                                #  - declaration-time: Object.create(null)

OBJ instanceof TYPE                             #Returns true if OBJ.__proto__[...] === TYPE.prototype
                                                #If TYPE is bound, unbound it first.
OBJ[Symbol.hasInstance](VAR)->BOOL            -|#Define to override VAR instanceof OBJ
REALMS ==>                                      #TYPEs might be coming from another environment with a different global scope
                                                #  - e.g. when using Node.js 'vm', or iframes in browser
                                                #This makes TYPE check fail (including instanceof)
                                                #  - except for native types, including undefined|null and Symbol.for()
                                                #But typeof and Object.prototype.toString.call() work

TYPE.prototype.constructor                      #TYPE itself.
                                                #Set when any non-arrow|bound FUNC is instantiated
                                                #Meant for type checking on instances.
                                                #Not used by new TYPE

TYPE.*                                          #Static members, i.e. properties of TYPE, not instances
                                                #Can be inherited by using TYPE.__proto__ = TYPE_PARENT

EXAMPLE ==>                                     #  function TYPE(...) {
                                                #    TYPE_PARENT.apply(this[, ...])
                                                #    this.VAR = ...; ...
                                                #  }
                                                #  TYPE.prototype = Object.create(TYPE_PARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE
                                                #  TYPE.__proto__ = TYPE_PARENT

new TYPE[(...)]                                 #Create OBJ with Object.create(TYPE.prototype)
                                                #  - if TYPE is bound, unbound it first.
                                                #Then call TYPE.call(OBJ, ...)
                                                #Returns:
                                                #  - TYPE.call(...) return value if object
                                                #     - Should avoid because return value's __proto__ might not be TYPE.prototype
                                                #        - This is unexpected by most users
                                                #        - This prevents inheritance and type checking
                                                #  - Otherwise: OBJ
super(...)                                    -|#Inside class constructor, same as TYPE_PARENT.call(this, ...)
                                              -|#  - including return value
                                              -|#If class has TYPE_PARENT, in constructor (if any):
                                              -|#  - must be called
                                              -|#     - and before accessing `this`
                                              -|#  - if TYPE_PARENT() returns an object, it becomes `this`
                                              -|#     - including for grandchildren types
new.target                                    -|#When called with new FUNC(): FUNC itself
                                              -|#When called without "new": undefined
                                              -|#If FUNC is bound: unbound it first
                                              -|#SyntaxError if arrow FUNC.
                                              -|#new.target is inherited like `this`:
                                              -|#  - not inherited in:
                                              -|#     - non-arrow FUNC declaration
                                              -|#     - FUNC calls
                                              -|#  - but inherited in:
                                              -|#     - arrow FUNC declarations
                                              -|#     - super(), even if returns a value
                                              -|#Must be inside TYPE function itself, not through FUNC calls


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:   NATIVE TYPES INHERITANCE    :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NATIVE TYPE CONSTRUCTORS ==>                    #Some native type constructors can be called without "new":
                                                #  - String|Boolean|Number|BigInt|Symbol: transtype
                                                #  - Object|Array|Function|RegExp|Error: same as with "new" (but should avoid)
                                                #  - Date: same as new Date().toString()
                                                #  - all others: forbidden
NATIVE TYPES INHERITANCE ==>                    #Native types constructors return a value instead of assigning to this.
                                                #When:
                                                #  - Inheriting manually with TYPE.__proto__|prototype|constructor:
                                                #    This creates the issues mentioned above, i.e. does not work
                                                #  - Uses class ... extends: this works
TYPE[Symbol.species]                          -|#TYPE2 to override TYPE constructor used to create empty new objects.
                                              -|#E.g. used by:
                                              -|#  - ARR.concat|filter|map|slice|splice()
                                              -|#  - STR.split(REGEXP)
                                              -|#  - PROMISE.then()
                                              -|#Should be set to TYPE_PARENT when extending native types
                                              -|#  - unless want to keep child type, e.g. with Error
                                              -|#E.g. if TYPE deriving from Array, TYPE.map() will return TYPE not ARR, unless this is used


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             CLASS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


class [TYPE] [extends TYPE_PARENT] {          -|#Similar to:
                                              -|#  TYPE.prototype = Object.create(TYPE_PARENT.prototype) (non-writable|enumerable|configurable)
                                              -|#    - if no TYPE_PARENT: Object.create(Object.create(null))
                                              -|#  TYPE.prototype.constructor = TYPE (non-enumerable)
                                              -|#  TYPE.__proto__ = TYPE_PARENT
                                              -|#    - if no TYPE_PARENT: Function.prototype
                                              -|#TYPE_PARENT can be a VAL, not only a VAR
                                              -|#Throw error if not called with new.
                                              -|#No comma between definition members.
                                              -|#Returns TYPE
  constructor(...) { ... }                    -|#Constructor TYPE(...)
                                              -|#Def: calls super(...)
  FUNC(...) { ... }                           -|#TYPE.prototype.FUNC = FUNC (non-enumerable)
  static FUNC(...) { ... }                    -|#TYPE.FUNC = FUNC (non-enumerable)
  VAR|[STR] [= EXPR][, ...];                  -|#Calls this.VAR = EXPR in constructor. (enumerable)
                                              -|#Called after super()
                                              -|#  - If no super(), in beginning instead
  static VAR|[STR] [= EXPR][, ...];           -|#Calls TYPE.VAR = EXPR right-away (enumerable)
                                              -|#In EXPR, `this` is TYPE
  [static] #VAR [= EXPR][, ...];       14.6.0*-|#Like VAR = EXPR and FUNC(...), except can only be refered to inside class,
  #FUNC(...) { ... }                   14.6.0*-|#i.e. using this.#VAR and this.#FUNC(...). Not inherited.
  static { ... }                       17.0.0*-|#Calls ... right away (`this` is TYPE)
  [static] accessor VAR [= EXPR][, ...];    *-|~#Like #VAR with an automatic getter|setter
                                              -|#Can only be declared during class declaration.
}                                             -|#


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FUNC                                            #Is OBJ, so can be assigned.
Function                                        #FUNC TYPE
function [FUNC]([...]) { ... [return VAL;] ... }#Declare and returns FUNC.
                                                #See "Scope" above.
[new ]Function(['...',]'...')                   #Same as function(...) { ... } but:
                                                #  - scope will be child of global scope.
                                                #  - body is STR can be dynamically created. Can create injection risk.
                                                #Use only if really necessary.

(...) => {...}                                -|#Same as (function(...) {...}).bind(this), except:
                                              -|#  - arguments|super|new.target refer to current function's
                                              -|#  - no FUNC.prototype, i.e. cannot be inherited or used as constructor
(...) => VAL                                  -|#Same as (...) => { return VAL; }
                                              -|#To return an OBJ, wrap in ({...})
ARG => {...}                                  -|#Same as (ARG) => {...}

PARAMETERS ==>                                  #  - positional
                                                #  - extra parameters do not fire exceptions
                                                #  - non-OBJ are passed by value, but OBJ always by reference:
                                                #     - including in assignment
                                                #     - left-hand value keeps reference to right-hand value, but not inverse
                                                #        - i.e. assigning to an OBJ argument removes precedent reference:
                                                #            function(OBJ){ OBJ = OBJ2 }     // Removes OBJ reference
                                                #            function(OBJ){ OBJ.VAR = VAL }  // Keep OBJ reference
                                                #  - maximum length is implementation-specific
                                                #     - 118044 with V8
                                                #     - including with FUNC.bind|call|apply() or array spread
                                              -|#  - can use trailing commas
                                              -|#  - VAR = VAL: default value:
                                              -|#     - can refer to previous parameter of same function.
                                              -|#     - VAL is evaluated at each function call, not at declaration,
                                              -|#       in its own child scope.
                                              -|#     - explicitely passing undefined gets the default value
                                              -|#     - does not have to be last parameters, but makes more sense
                                              -|#  - ...ARR: variadic args
                                              -|#  - {...}: assigns {...} = OBJ
                                              -|#     - including { [...] ...OBJ [...] } = OBJ2
                                              -|#  - [VAR...]: assigns ARR = [VAL...]
arguments                                       #Readonly ARRAYLIKE containing currently passed arguments.

FUNC([VAL]...)                                  #Fire FUNC and returns its return value
                                              -|#Can be ...ITERABLE, replaced by NEXT...
                                              -|#Can use trailing commas

FUNC?.(...)                            14.0.0*-|#Like FUNC == null ? undefined : FUNC(...)
                                       14.0.0*-|#Does not work with new FUNC?.(...)
OBJ?.FUNC(...)                         14.0.0*-|#Like OBJ == null ? undefined : OBJ.FUNC(...)

FUNC.length                                     #Number of required arguments

FUNC.name                                     -|#Is:
                                              -|#  - function NAME (...) {...} -> 'NAME'
                                              -|#  - { NAME() {...} } -> 'NAME'
                                              -|#  - (...) => {...} -> ''
                                              -|#  - function (...) {...} -> ''
                                              -|#  - NAME = FUNC -> FUNC.name || NAME
                                              -|#  - { NAME: FUNC } -> FUNC.name || NAME
                                              -|#  - OBJ.VAR = FUNC -> FUNC.name
                                              -|#Prepends:
                                              -|#  - "bound " if FUNC.bind()
                                              -|#  - "get|set " if getter|setter
                                              -|#If NAME is SYM -> '[STR]' with STR from Symbol(STR)
                                              -|#Might be changed by minifiers (e.g. done by default by Uglify, although there
                                              -|#is an option)
                                              -|#Used in stack trace of ERROR or debuggers
                                              -|#Read-only, but configurable (so can Object.defineProperty() the value).
FUNC.toString()                                 #Function declaration, can be eval'd()
                                               -#I.e. either:
                                               -#  - 'function[*] [NAME] (...) {...}'
                                               -#  - '(...) => {...}' or ARG => VAL (or mixed of both) if arrow function
                                               -#  - '[get|set] [*]NAME(...) {...}' if member function
                                               -#  - 'class [CLASS] {...}' if CLASS
                                               -#  - 'function anonymous(ARG...\n) {...} if new Function()
                                                #If native function, will contain "[native code]"

this                                            #OBJ if current function fired as OBJ.FUNC(), otherwise null|undefined
                                                #Read-only
                                                #Notes:
                                                #  - FUNC2 = OBJ.FUNC or FUNC3(OBJ.FUNC)
                                                #     - must OBJ.FUNC.bind(OBJ) to keep "this"
                                                #  - OBJ = new FUNC(); calls FUNC.call(OBJ)
FUNC.bind(VAL[, ...])                           #Returns FUNC, but binds "this" to VAL (except if called with 'new'),
                                                #and first arguments to ...
                                                #Cannot rebind.
FUNC.call(VAL[, ...])                           #Same as FUNC.bind(VAL[, ...])()
FUNC.apply(VAL[, ARR])                          #Same but using an ARR instead of comma-separated arguments.
                                                #Often used to forward to another function: FUNC.apply(this, arguments)

VAR = FUNC([...]); return VAR;              *||-#Two examples of a tail call optimization:
return FUNC([...]);                         *||-#  - the last FUNC() performed before "return" (besides assignments)
                                            *||-#    (includes FUNC like native operators)
                                            *||-#This will optimize FUNC() call:
                                            *||-#  - faster, because optimizer can replace call stack current frame instead
                                            *||-#    of adding to it
                                            *||-#  - allow infinite recursion


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          DECORATORS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@DFUNCs                                     *-|~#@DFUNCs can be several whitespace-separated @DFUNC
class ... {                                 *-|~#DFUNC can be VARR or FUNC(...)->DFUNC, without wrapping with (...)
  @DFUNCs [get|set] [#]FUNC(...) {...}      *-|~#DFUNC(VAL, DCONTEXT)[->VAL] that modifies the value after it.
  @DFUNCs [static] [accessor] [#]VAR = EXPR *-|~#  - def return value: VAL
}                                           *-|~#VAL is, for:
                                            *-|~#  - 'class|method|getter|setter': FUNC
                                            *-|~#  - 'field': undefined as argument, but available by returning FUNC2(VAL)->VAL
                                            *-|~#     - i.e. meant to wrap value initialization
                                            *-|~#  - 'accessor': OBJ with same shape as DCONTEXT.access
                                            *-|~#     - i.e. meant to wrap value get|set
                                            *-|~#     - return VAL can also have property initialize(VAL)->VAL (behaves like 'field' return value)
                                            *-|~#Called:
                                            *-|~#  - once on prototype: DFUNC()
                                            *-|~#  - on new CLASS instances initialization, with `this` being CLASS:
                                            *-|~#     - FUNC2() returned by 'field'
                                            *-|~#     - OBJ.initialize() returned by 'accessor'
                                            *-|~#     - DCONTEXT.addInitializer()'s FUNC2()
                                            *-|~#  - on value get|set: OBJ.get|set returned by 'accessor'
                                            *-|~#DCONTEXT:
                                            *-|~#  - kind 'class', 'method|getter|setter' or 'field|accessor'
                                            *-|~#  - name 'VAR'|SYM
                                            *-|~#  (not 'class')
                                            *-|~#  - private BOOL: if #FUNC2|VAR
                                            *-|~#  - static BOOL: if "static"
                                            *-|~#  - access OBJ: unlike the VAL being passed to DFUNC, if get|set() are used later, they retrieve the current value then
                                            *-|~#  (not 'class|setter')
                                            *-|~#     - get()->VAL
                                            *-|~#  (not 'class|method|getter')
                                            *-|~#     - set(VAL)
                                            *-|~#  (not 'field')
                                            *-|~#  - addInitializer(FUNC2())


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ERRORS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


throw VAL                                       #Throw exception VAL, i.e. interrupt each function in the call stack until
                                                #inside try { ... } followed by catch ( VAR ) { ... }
                                                #Thrown errors will reject parent PROMISEs and be propagated in async|await stacks
                                                #However they will stop at other top-level functions creating async context
                                                #  - e.g. setTimeout()
                                                #  - i.e. should be promisified
try { ...  }
[catch [(VAR)] { ... }]                       -|#(VAR) can be omitted
[finally { ... }]                               #finally { ... } is always fired
                                                #  - return|exception have higher priority than try|catch's return|exception
                                                #  - if no `return` statement, default to try|catch's return

[new ]Error([STR[, OPTS]])                      #OBJ usually used when throw VAL, because more info.
                                                #Prefer with "new"
                                                #STR is ERROR.message (def: "")
                                       16.9.0*-|#OPTS:
                                       16.9.0*-|#  - cause: sets ERROR.cause
                                                #Some builtin ERROR thrown:
                                                #  - ReferenceError: console.log(notdeclared)
                                                #  - TypeError: null.FUNC()
                                                #  - SyntaxError: 5 *** 7
                                                #  - RangeError: new Array(Infinity)
                                                #  - URIError: decodeURIComponent('%')
                                                #  - EvalError: with eval()
ERROR.name                                      #ERROR type (def: "Error"), redefined by children.
                                                #Usually set on prototype and non-enumerable.
ERROR.message                                   #STR
                                                #Non-enumerable
                                                #Set as own property, but also set on prototype as empty STR.
ERROR.stack                                     #Stack trace STR
                                                #Represent position at `new Error()`
                                                #Non-enumerable
                                                #Format is not standardized and very engine-specific
                                                #  - in V8:
                                                #     - includes ERROR.name|message but not on SpiderMonkey|JavaScriptCore
                                                #     - done lazily, i.e. only evaluates when ERROR.stack retrieved the first time, including:
                                                #        - ERROR.name|message header
                                                #        - calling Error.prepareStackTrace()
                                                #  - in V8, it is created lazily
                                                #     - i.e. represent
                                                #  - in SpiderMonkey:
                                                #     - set on prototype
                                                #     - is a getter
                                                #     - when retrieved on the prototype, returns empty STR, but not when retrieved through prototype chain
                                                #     - includes constructor
                                                #        - not for native errors
                                                #        - prefixed by constructor ERROR_FUNC.name (not ERROR.name)
                                                #           - at ERROR_FUNC creation time: modifying ERROR_FUNC.name does not change it
                                                #See "async" above for async stack trace
                                                #See stack trace documentation for more information on: parsing, normalizing,
                                                #beautifying, visualizing, etc.
                                                #Printed by UTIL.inspect(ERROR)
ERROR.cause                            16.9.0*-|#Inner ERROR2
                                       16.9.0*-|#Optional. Can be any type.
                                       16.9.0*-|#Not used by ERROR.stack nor toString()
                                       16.9.0*-|#But used by UTIL.inspect(ERROR) and console.log() on most browsers
ERROR.toString()                                #'NAME: MESSAGE'

new AggregateError
 (VAL_ARR[, 'MESSAGE'][, OPTS])          15.0.0*#ERROR include several children VAL_ARR
AGGREGATE_ERROR.errors                   15.0.0*#VAL_ARR
                                         18.6.0*#Printed BY UTIL.inspect(ERROR)

debugger                                        #Sets a breakpoint

Error.*stack*                                   #V8 specific
                                                #Are global, i.e. ignored on Error.* subclasses
Error.captureStackTrace(OBJ[, FUNC])            #Adds OBJ.stack, unless already exists
                                                #Automatically done by ERROR, i.e. Error.captureStackTrace(ERROR) is useless
                                                #If FUNC, stops stack frame at FUNC

Error.stackTraceLimit                           #Def: 10

Error.prepareStackTrace                         #When set with FUNC(ERROR, CALL_ARR)->'STACK', override how OBJ.stack is get
                                                #Default is something along the lines of:
                                                #  ERROR.name: ERROR.message
                                                #    at [new] CALL.getFunctionName() [as methodName] (LOCATION)
                                                #    at <anonymous> (LOCATION)
                                                #    at eval (PARENT_CALL, <LOCATION2>)
                                                #    at native
                                                #    at unknown location
                                                #    ...
                                                #LOCATION is:
                                                #  (CALL.getFileName():CALL.getLineNumber():CALL.getColumnNumber())
CALL.getFileName()->'FILENAME'                  #undefined if eval
CALL.getEvalOrigin()->'FILENAME'                #Same but when using eval() (or related)
CALL.getScriptNameOrSourceURL()->'FILENAME'     #Same but when using eval() (or related) with //# sourceURL comment
CALL.getFunction()->FUNC                        #undefined in 'strict mode'
CALL.getFunctionName()->'[CLASS.]FUNC|null'     #
CALL.getMethodName()->'FUNC'|null               #
CALL.getThis()->THIS                            #undefined in 'strict mode'
CALL.getTypeName()->STR|null                    #THIS's TYPE
CALL.getLine|ColumnNumber()->NUM                #
CALL.getPosition()->NUM                         #Byte index
                                                #Does not includes CommonJS wrapper anymore
CALL.isToplevel()->BOOL                         #
CALL.isEval()->BOOL                             #From eval() (or related)
CALL.isNative()->BOOL                           #From native C++ code
CALL.isConstructor()->BOOL                      #Using new
CALL.isAsync()->BOOL                            #True if async stack trace
                                                #Only for the CALL that triggered an async operation, e.g. `await`.
CALL.isPromiseAll()->BOOL                       #True if Promise.all()
CALL.getPromiseIndex()->NUM                     #PROMISE index inside Promise.all()

ERROR.lineNumber|columnNumber                   #NUM
                                                #SpiderMonkey-specific
                                                #Non-enumerable
ERROR.fileName                                  #STR
                                                #SpiderMonkey-specific
                                                #Non-enumerable

ERROR.line|column                               #NUM
                                                #JavaScriptCore-specific
                                                #Enumerable


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             INTL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OBJ.toLocaleString()                            #Same as OBJ.toString(), but can be reimplemented by children
                                                #(like OBJ.toString())
ARR.toLocaleString()                            #Same as ARR.toString() with locale commas
STR.toLocaleUpper|LowerCase()                   #Using current locale

new Intl.Locale(LOCALE, LOCALE_ARGS)           -#LOCALE_OBJ
                                               -#LOCALE_ARGS is an OBJ:
                                               -#  - are Unicode "Language tags"
                                               -#  - list: see its doc
                                               -#  - supports: ca|calendar, co|collation, hc|hourCycle, kf|caseFirst,
                                               -#    kn|numeric, nu|numberingSystem
                                               -#Def: current locale
                                               -#For Node, support must be done during building
LOCALE_OBJ.*                                   -#Anything from LOCALE_ARGS (using long name)
LOCALE_OBJ.language                            -#STR
LOCALE_OBJ.script                              -#STR
LOCALE_OBJ.region                              -#STR
LOCALE_OBJ.basename                            -#STR
LOCALE_OBJ.calendar                            -#STR
LOCALE_OBJ.caseFirst                           -#BOOL
LOCALE_OBJ.collation                           -#STR
LOCALE_OBJ.hourCycle                           -#STR
LOCALE_OBJ.numeric                             -#STR
LOCALE_OBJ.numberingSystem                     -#STR
LOCALE_OBJ.textInfo                     18.0.0*-#STR
LOCALE_OBJ.weekInfo                     18.0.0*-#STR
LOCALE_OBJ.toString()->LOCALE                  -#
LOCALE_OBJ.locale                              -#Like LOCALE, but only the first part
LOCALE                                      -|||#STR serialization of LOCALE_OBJ:
                                            -|||#  - e.g. 'fr-FR'
                                            -|||#  - LOCALE_ARGS is serialized as final -u-SHORTEN_ARG-VAL
                                            -|||#  - true for current locale
                                            -|||#Polyfill|ponyfill 'intl.js'
Intl.getCanonicalLocales                    -|||#Normalize LOCALE, e.g. its case and remove duplicates
 (LOCALE[_ARR])->LOCALE_ARR                 -|||#Throws if invalid

LOCALEOPTS ==>                              -|||#Is LOCALE[_ARR][, OPTS]
                                               -#Or LOCALE_OBJ[_ARR][, OPTS]
                                            -|||#OPTS:
                                            -|||#  - depends on the method
                                            -|||#  - defaults to using CLDR with the provided LOCALE
                                            -|||#  - always has members:
                                            -|||#     - locale LOCALE
                                            -|||#     - localeMatcher 'best fit' (def) or 'lookup' (poorer algorithm)
                                            -|||#  - some members might be read-only
Intl.*.supportedLocalesOf([LOCALEOPTS])     -|||#Returns LOCALE_ARR matching LOCALEOPTS and being installed on client.

new Intl.*([LOCALOPTS])                     -|||#Returns new instance of a specific intl operation
                                            -|||#Is expensive, so should be cached
                                            -|||#Returned member always has members:
                                            -|||#  - resolvedOptions()->OPTS

Intl.supportedValuesOf(STR)->STR_ARR  18.0.0*-|~#Returns all possible values for a specific Intl.* method|option
                                      18.0.0*-|~#STR can be: 'currency|calendar|collation|numberingSystem|timeZone|unit'
LOCAL_OBJ.calendars|collations|
 hourCycles|numberingSystems|
 timeZones|textInfo|weekInfo          18.0.0*-|~#STR_ARR

new Intl.Collator([LOCALEOPTS])                -#Locale-specific collation.
                                               -#OPTS:
                                               -#  - usage 'sort' (def) or 'search': like co "search" LOCALE_ARGS
                                               -#  - sensitivity 'base|accent|case|variant' (def: 'variant'):
                                               -#     - case-sensitive: 'case|variant'
                                               -#     - accent-sensitive: 'accent|variant'
                                               -#  - ignorePunctuation BOOL (def: false)
                                               -#  - numeric BOOL (def: false): like kn LOCALE_ARGS
                                               -#  - caseFirst 'upper|lower' or 'false' (def, i.e. locale's): like
                                               -#    kf LOCALE_ARGS
                                               -#Relevant LOCALE_ARGS: co, kn, kf
COLLATOR.compare(STR, STR2)->NUM               -#Like STR < <= >= > STR2, except:
STR.localCompare(STR2[, LOCALEOPTS])->NUM      -#  - returns as -1|0|1
                                               -#  - real sorting, not just codepoint-wise
                                               -#  - takes locales into account

new Intl.DisplayNames([LOCALEOPTS])        14*-|#Language string translation
                                           14*-|#OPTS:
                                           14*-|#  - type STR among:
                                           14*-|#     - 'region': countries (ISO-3166, e.g. 'US' to 'United States') or world regions (UN M49 code, e.g. '419' to 'Latin America')
                                           14*-|#     - 'language' (e.g. 'fr' or 'fr-CA' to 'French' or 'Canadian French')
                                           14*-|#     - 'script' (ISO-15924, e.g. 'Latn' or 'Arab' to 'Latin' or 'Arabic')
                                           14*-|#     - 'currency' (ISO-4217, e.g. 'USD' to 'US Dollar')
                                       17.0.0*-|#     - 'calendar' (calendar name, e.g. 'gregory' to 'Gregorian Calendar')
                                       17.0.0*-|#     - 'dateTimeField' ('era|year|month|quarter|weekOfYear|weekday|dayPeriod|day|hour|minute|second'
                                       17.0.0*-|#  - languageDisplay STR:
                                       17.0.0*-|#     - when using type 'language'
                                       17.0.0*-|#     - either 'dialect' (def, 'British English') or 'standard' ('English (United Kingdom)')
DISPLAYNAMES.of(STR)->STR2                 14*-|#

new Intl.NumberFormat([LOCALEOPTS])         -|||#Number locale formatting.
                                            -|||#OPTS:
                                            -|||#  - style 'decimal|currency|percent|unit' (def: 'decimal')
                                            -|||#  - useGrouping BOOL (def: auto): throusands separators
                                          *-|||~#    Can also be:
                                          *-|||~#      - 'never|always' (like false|true)
                                          *-|||~#      - 'auto' (def): depends on locale
                                          *-|||~#      - 'min2': if at least two digits in each group
                                            -|||#  - minimum|maximumInteger|Fraction|SignificantDigits NUM
                                          *-|||~#  - roundingPriority STR:
                                          *-|||~#     - when *FractionDigits and *SignificantDigits are both specified and they
                                          *-|||~#       lead to different number of digits, decides which one has priority:
                                          *-|||~#        - 'auto' (def): *SignificantDigits
                                          *-|||~#        - 'morePrecision': one with most digits
                                          *-|||~#        - 'lessPrecision': one with least digits
                                          *-|||~#  - trailingZeroDisplay STR:
                                          *-|||~#     - whether to show fraction digits if all 0s
                                          *-|||~#     - can be 'auto' (yes, def) or 'stripIfInteger' (no)
                                          *-|||~#  - roundingMode STR:
                                          *-|||~#     - 'ceil|floor': towards +|-Infinity
                                          *-|||~#     - 'expand|trunc': away|towards 0
                                          *-|||~#     - 'halfExpand' (def) or 'halfTrunc|Ceil|Floor': closest. If half, expand|trunc|ceil|floor
                                          *-|||~#     - 'halfEven'
                                          *-|||~#  - roundingIncrement NUM
                                          *-|||~#     - among 1|2[5]|5[0[0[0]]]
                                            -|||#  - signDisplay 'auto' (def) (-1|-0|0|1), 'always' (-1|-0|+0|+1),
                                            -|||#    'never' (1|0|0|1), 'exceptZero' (-1|-0|0|+1),
                                          *-|||~#    'negative' (-1|0|0|1)
                                            -|||#  (for style 'decimal')
                                            -|||#  - notation 'standard' (def) ('987654321'), 'compact' ('988M'),
                                            -|||#    'engineering' ('987.654E6'), 'scientific' ('9.877E8')
                                            -|||#  (for style 'decimal', notation 'compact')
                                            -|||#  - compactDisplay 'short' (def) ('988M'), 'long' ('988 million')
                                            -|||#  (for style 'currency')
                                            -|||#  - currency STR (no def)
                                            -|||#  - currencyDisplay 'symbol|code|name' (def: 'symbol')
                                            -|||#  - currencySign 'standard' (def) or 'accounting' (show negative as '(NUM)')
                                            -|||#  (for style 'unit')
                                            -|||#  - unit STR among:
                                            -|||#     - acceleration-g-force|meter-per-second-squared
                                            -|||#     - angle-arc-minute|second|degree|radian|revolution
                                            -|||#     - area-acre|hectare|square-centimeter|foot|inch|kilometer|meter|mile|yard
                                            -|||#     - concentr-karat|milligram-per-deciliter|millimole-per-liter|part-per-million
                                            -|||#     - consumption-liter-per-100kilometers|kilometer|mile-per-gallon[-imperial]
                                            -|||#     - digital-[giga|kilo|mega|tera]bit|byte
                                            -|||#     - duration-century|day[-person]|hour|[micro|nano]second|millisecond|minute|month[-person]|week[-person]|year[-person]
                                            -|||#     - electric-ampere|milliampere|ohm|volt
                                            -|||#     - energy-calorie|foodcalorie|joule|kilocalorie|kilojoule|kilowatt-hour
                                            -|||#     - frequency-[kilo|mega|giga]hertz
                                            -|||#     - length-astronomical-unit|centimeter|decimeter|fathom|foot|furlong|inch|kilometer|light-year|meter|micrometer|mile|
                                            -|||#       mile-scandinavian|millimeter|nanometer|nautical-mile|parsec|picometer|yard
                                            -|||#     - light-lux
                                            -|||#     - mass-carat|[micro|milli|kilo]gram|[metric-]ton|ounce|ounce-troy|pound|stone
                                            -|||#     - power-[milli|kilo|mega|giga]watt|horsepower
                                            -|||#     - pressure-hectopascal|inch-hg|millibar|millimeter-of-mercury|pound-per-square-inch
                                            -|||#     - speed-kilometer-per-hour|knot|meter-per-second|mile-per-hour
                                            -|||#     - temperature-celsius|fahrenheit|generic|kelvin
                                            -|||#     - volume-acre-foot|bushel|cubic-centimeter|cubic-foot|cubic-inch|cubic-kilometer|cubic-meter|cubic-mile|cubic-yard|cup[-metric]|fluid-ounce|
                                            -|||#       gallon[-imperial]|[milli|centi|deci|hecto|mega]liter|pint[-metric]|quart|tablespoon|teaspoon
                                            -|||#  - unitDisplay 'narrow', 'short' or 'long'
                                            -|||#Relevant LOCALE_ARGS: nu
NUMBERFORMAT.format(ARG)->STR               -|||#ARG is NUM|BIGINT|STR
NUM|BIGINT.toLocaleString([LOCALEOPTS])->STR-|||#
NUMBERFORMAT.formatToParts(NUM|BIGINT)      -|||#OBJ_ARR:
 ->OBJ_ARR                                  -|||#  - type STR:
                                            -|||#     - 'integer|fraction': integer|fraction part of the number
                                            -|||#     - 'decimal': decimal separator
                                            -|||#     - 'group': thousands separator
                                            -|||#     - 'currency': currency string
                                            -|||#     - 'percentSign': %
                                            -|||#     - 'plusSign|minusSign': + or -
                                            -|||#     - 'infinity|nan': ∞ or NaN
                                            -|||#     - 'literal': anything else, e.g. spaces
                                            -|||#  - value STR
NUMBERFORMAT.formatRange
 (NUM|BIGINT, NUM|BIGINT2)->STR           *-|||~#Like format() but for range between two NUMs ('USD3-5')
NUMBERFORMAT.formatRangeToParts
 (NUM|BIGINT, NUM|BIGINT2)->OBJ_ARR       *-|||~#Like formatToParts() but for range. OBJ has extra member source 'startRange|endRange|shared'
NUMBERFORMAT.format[Range][ToParts]Select *-|||~#Like format[Range][ToParts](...) but returns an OBJ: string (singular), pluralForm
 (...)                                    *-|||~#similar to Intl.PluralRules

new Intl.DateTimeFormat([LOCALEOPTS])       -|||#Date|Time|Date+Time locale formatting.
                                            -|||#OPTS:
                                            -|||#  - timeZone STR (def: locale's)
                                            -|||#  - hour12 BOOL (def: locale's)
                                            -|||#  - formatMatcher 'basic' or 'best fit' (def): like localeMatcher, but for
                                            -|||#    OPTS.weekday|etc.
                                            -|||#  - weekday|era 'narrow|short|long' (no def)
                                            -|||#  - month 'numeric|2-digit|narrow|short|long' (no def)
                                            -|||#  - year|day|hour|minute|second 'numeric|2-digit' (no def)
                                            -|||#  - timeZoneName (no def) among:
                                            -|||#     - 'short'
                                     17.0.0*-|||#       or 'shortOffset': 'GMT-8'
                                     17.0.0*-|||#     - 'longOffset': 'GMT-08:00'
                                     17.0.0*-|||#     - 'shortGeneric': 'PT'
                                            -|||#     - 'long'
                                     17.0.0*-|||#       or 'longGeneric': 'Pacific Time'
                                            -|||#  - timeStyle 'short' (HH:MM), 'medium' (HH:MM:SS), 'long' (HH:MM:SS Z), 'full' (HH:MM:SS ZZZZ)
                                            -|||#  - dateStyle 'short' (D/M/YY), 'medium' (MMM D, YYYY), 'long' (MMMM D, Y), 'full' (Tuesday, MMMM D, Y)
                                            -|||#Relevant LOCALE_ARGS: nu, ca
DATETIMEFORMAT.format(DATE)->STR            -|||#
DATE.toLocale[Date|Time]String([LOCALOPTS])
 ->STR                                      -|||#
DATETIMEFORMAT.formatToParts(DATE)->OBJ_ARR -|||#Same but returned as OBJ_ARR:
                                            -|||#  - type 'era|year|month|weekday|day|hour|minute|second|timeZoneName|separator'
                                            -|||#  - value STR
DATETIMEFORMAT.formatRange
 (DATE, DATE2)->STR                         -|||#Like format() but for range between two DATEs ('1/10/07, 10:00 AM – 1/20/07, 10:00 AM')
DATETIMEFORMAT.formatRangeToParts
 (DATE, DATE2)->OBJ_ARR                     -|||#Like formatToParts() but for range. OBJ has extra member source 'startRange|endRange|shared'

new Intl.RelativeTimeFormat([LOCALEOPTS])   -|||#Date|Time|Date+Time locale formatting, for relative time ("time ago")
                                            -|||#OPTS:
                                            -|||#  - style STR:
                                            -|||#     - 'long' (def) ("in 1 month")
                                            -|||#     - 'short' ("in 1 mo.")
                                            -|||#     - 'narrow' ("in 1 mo.")
                                            -|||#Ponyfill yahoo 'intl-relativeformat'
RELATIVETIMEFORMAT.format
 (NUM, STR)->STR2                           -|||#STR: 'year|quarter|month|week|day|hour|minute|second'
RELATIVETIMEFORMAT.formatToParts            -|||#OBJ_ARR:
 (NUM, STR)->OBJ_ARR                        -|||#  - type STR: like unit (e.g. "year") or "literal" (anything else)
                                            -|||#  - value STR

new Intl.DurationFormat([LOCALEOPTS])         *-#Duration formatting ("2 hr 46 min 40 sec")
                                              *-#OPTS:
                                              *-#  - numberingSystem STR (like LOCAL_OBJ.numberingSystem)
                                              *-#  - fractionalDigits NUM: when rounding (def: no rounding, except for trailing zeroes)
                                              *-#  - style STR:
                                              *-#     - 'long'
                                              *-#     - 'short' (def)
                                              *-#     - 'narrow'
                                              *-#     - 'digital': like 'narrow' for years-days and 'numeric' for hours-*seconds
                                              *-#  - years|months|weeks|days|hours|minutes|[milli|micro|nano]seconds STR: same for specific parts
                                              *-#     - 'long' (e.g. '3 seconds')
                                              *-#     - 'short' (e.g. '3 secs')
                                              *-#     - 'narrow' (e.g. '3s')
                                              *-#     - 'numeric':
                                              *-#        - e.g. '23'
                                              *-#        - only with hours|minutes|[*]seconds
                                              *-#        - handled like '2-digit' if followed by another 'numeric'
                                              *-#     - '2-digit': only with hours|minutes|seconds
                                              *-#        - e.g. '23:'
                                              *-#  - years|...|*secondsDisplay:
                                              *-#     - 'always' (def if style specified)
                                              *-#     - 'auto' (def if default style): hide if zero
DURATIONFORMAT.format
 (T_DURATION|STR|OBJ)->STR2                   *-#STR|OBJ is passed to Temporal.Duration.from()
DURATIONFORMAT.formatToParts
 (T_DURATION|STR|OBJ)->OBJ_ARR                *-#OBJ_ARR: type STR (e.g. 'years'), value STR

new Intl.PluralRules([LOCALEOPTS])             -#Locale-specific plural group of a NUM
                                               -#OPTS:
                                               -#  - type 'cardinal' (def) or 'ordinal'.
                                               -#    It's because some languages have different rules for either.
                                               -#  (read-only)
                                               -#  - minimum|maximumFraction|SignificantDigits NUM
                                               -#  - pluralCategories STR_ARR
PLURALRULES.select(NUM)->STR                   -#Returns plurality of NUM according to locale, among 'zero', 'one', 'two',
                                               -#'few', 'many', 'other'
PLURALRULES.selectRange(NUM, NUM2)->STR     *-|~#STR

new Intl.ListFormat([LOCALEOPTS])              -#Format list of items with natural language.
                                               -#OPTS:
                                               -#  - type:
                                               -#     - 'regular' (def) ("and")
                                               -#     - 'disjunction' ("or")
                                               -#     - 'unit' (only commas|spaces)
                                               -#  - style STR:
                                               -#     - 'long' (def)
                                               -#     - 'short' (use abbreviations|punctuations, no words) (only type 'unit')
                                               -#     - 'narrow' (use only spaces)
LISTFORMAT.format(STR_ARR)->STR                -#
LISTFORMAT.formatToParts(STR_ARR)->OBJ_ARR     -#OBJ_ARR:
                                               -#  - type 'element' (STR) or 'literal' (separators)
                                               -#  - value STR

new Intl.Segmenter([LOCALEOPTS])        16.0.0*-#Break down strings into smaller parts, locale-specific.
                                        16.0.0*-#OPTS:
                                        16.0.0*-#  - granularity STR:
                                        16.0.0*-#     - 'grapheme' (def): might include several chars, since accents are chars
                                        16.0.0*-#     - 'word'
                                        16.0.0*-#     - 'sentence'
SEGMENTER.segment(STR)->SEGMENTS        16.0.0*-#SEGMENTS is SEGMENT_ITERABLE:
                                        16.0.0*-#  - segment STR2
                                        16.0.0*-#  - input STR: full input
                                        16.0.0*-#  - index NUM: STR2 inside STR, in Unicode codepoint
                                        16.0.0*-#  - isWordLike BOOL:
                                        16.0.0*-#     - undefined if granularity not 'word'
                                        16.0.0*-#     - otherwise, whether word-like (letters|numbers) or punctuation|space-like
SEGMENTS.containing(NUM)
 ->SEGMENT|undefined                   16.0.0*-~#Retrieve SEGMENT at index NUM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REGEXP             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


/PATTERN/[FLAGS]                                #Def STR: '(?:)'
[new ]RegExp(['PATTERN'[, 'FLAGS']])            #Backslashes must be escaped in the second form
                                                #Perl RegExp except:
                                                #  - no [[:CLASS:]]
                                                #  - no \< \>
                                                #  - no ...+-greediness (but ...?-non-greediness allowed)
                                                #  - no additional flags
                                                #  - no \A \Z but ^ $ behave like \A \Z unless m flag
                                                #Also has:
                                              -|#  - \p \P: requires u flag
                                            *-|~#     - including \p{*Emoji*}
                                               -#  - (?<=) (?<!)
                                              -|#  - (?<GROUP>) \k<GROUP>:
                                              -|#     - REGEXP.exec() return value ARR also defines ARR.groups.GROUP to access those
                                              -|#     - STR.replace() accesses those using:
                                              -|#        - ${GROUP} if using a string (with normal quotes)
                                              -|#        - extra parameter groups OBJ if using a FUNC
                                            *-|~#     - duplicate GROUPs are allowed, if in different alternatives
                                            *-|~#  - [...&&|--...]: requires v flag
                                                #Flags:
                                                #  - possible:
                                                #     - i: case insensitive
                                                #     - g:
                                                #        - use REGEXP.lastIndex:
                                                #           - initially 0, set to last match index (or 0 if no match)
                                                #           - next REGEXP.exec|test() will start from there
                                                #        - if using ^, if no match, returns null but set REGEXP.lastIndex
                                                #          to next match
                                                #        - function taking REGEXP as argument should iterate using
                                                #          REGEXP.lastIndex
                                                #           - this is what do standard JavaScript methods,
                                                #             e.g. STR.match|replace()
                                                #     - m: ^ $ newline-wise (otherwise whole-string-wise)
                                              -|#     - s: . whole-string-wise (otherwise newline-wise),
                                              -|#       i.e. match any character including: LF CR U+2028 U+2029
                                              -|#     - y: same as g, with ^ in beginning of PATTERN
                                              -|#     - u: see above
                                       *16.0.0-|#     - d: enable ARR.indices with REGEXP.exec()
                                            *-|~#     - v: enable [...&&|--...]
                                                #  - available at REGEXP.ignoreCase|global|multiline|sticky BOOL
REGEXP.source                                   #'PATTERN' (read-only)
REGEXP.flags                                  -|#'FLAGS' (read-only)
REGEXP.toString()                               #'/PATTERN/FLAGS'

REGEXP.exec(STR)                                #Search REGEXP in STR and returns ARR (or null):
                                                #  - ARR[0]: whole match
                                                #  - ARR[NUM]: parenthesis matches
                                                #  - ARR.index: first match index
                                                #  - ARR.input: STR
                                              -|#  - ARR.groups.GROUP: STR (see (?<GROUP>))
                                       *16.0.0-|#  - ARR.indices[0|NUM], ARR.indices.groups.GROUP: like ARR[0|NUM], ARR.groups.GROUP
                                       *16.0.0-|#    but as start|end indices [NUM2, NUM3] instead of STR
REGEXP.test(STR)                                #Returns BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ARRAY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Array                                           #Are actually OBJ with numeric property names, so can do ARR[NUM]
                                                #Can contain different types.
                                                #Multidimensional ARR: use ARR of ARRs
[new ]Array(NUM)                                #Returns ARR with NUM undefined values.
                                                #Throw RangeError if non-positive or decimal.
[new ]Array(VAL...)                             #Like [ VAL... ]
Array.of(VAL...)                              -|#Same as new Array(VAL...) except not interpreted as new Array(NUM) if
                                              -|#only VAL is NUM
[ [VAL...] ]                                    #Literal form.
                                                #Can use trailing commas

MAX LENGTH ==>                                  #2**32 - 1, i.e. ~4e9. Not engine-dependent.

Array.isArray(VAR)->BOOL                        #Same as VAR instanceof Array, except works across REALMs

ARR[NUM]                                        #
ARR?.[NUM]                             14.0.0*-|#Like ARR == null ? undefined : ARR[NUM]
ARR.at(NUM)->VAL                      16.6.0*-|~#Like STR[NUM] except -NUM is from end, and is not writable
ARR.with(NUM, VAL)->ARR2                    *-|~#Like ARR.at(NUM) = VAL, but does not modify ARR

ARRAYLIKE                                       #Any OBJ which understand OBJ[NUM] and OBJ.length
                                                #Can use all ARR methods, except concat() using:
                                                #  Array.prototype.FUNC.call(ARRAYLIKE, ...) is like ARR.FUNC(...)
                                                #If expected to return ARR, returns ARR not ARRAYLIKE.
Array.from(ARRAYLIKE|ITERABLE[, ...])         -|#Returns as ARR
                                              -|#If ..., also calls ARR.map(...)
                                              -|#Can do Array.from({ length }, (_, i) => i) to get [0, 1, ...]

ARR.length                                      #Can be modified (will truncate or extend with undefined values)
                                                #Max 4 billions (32-bits).

ARR.concat(VAL...)                              #Pushes each VAL (does not modify)
                                                #If VAL is ARR2, pushes ARR2 elements, not ARR2 itself,
                                              -|#unless ARR[Symbol.isConcatSpreadable] false
ARR.slice([NUM[, NUM2]])                        #Returns ARR copy from index NUM (def: 0) to NUM2 (def: ARR.length).
                                                #NUM|NUM2 can be negative, i.e. from ARR end.
ARR.splice(NUM[, NUM2[, VAL...]])               #Erase and return NUM2 elements (def: all) from index NUM, and replace them with VAL... (def: nothing)
ARR.toSpliced(...)->ARR2                    *-|~#Same as ARR.splice(...) but does not modify
ARR.fill(VAL[, NUM[, NUM2]])                  -|#Same as ARR.splice(NUM, NUM2, VAL...) with VAL being repeated NUM2-NUM times.
ARR.copyWithin(NUM, NUM2[, NUM3])             -|#Copies ARR.slice(NUM2[, NUM3]) to ARR.slice(NUM, ...)
                                              -|#Returns ARR.
ARR.join([STR])                                 #Returns as STR2, with STR delimiter (def: ',')
ARR.toString()                                  #ARR.join(',')

ARR.push|unshift(VAL,...)                       #Adds VAL to end|beginning (modifies). Returns ARR.length
ARR.pop|shift()                                 #Remove and returns last|first element (modifies).

ARR.reverse()                                   #Modifies and returns ARR.
ARR.toReversed()->ARR2                      *-|~#Same as ARR.reverse() but does not modify
ARR.sort([FUNC(VAL, VAL2)->-1|0|1])             #Modifies and returns ARR.
                                                #Default FUNC does STR comparison.
                                                #Implementation algorithm detail:
                                                #  - v8 uses insertion sort if ARR.length <= 10, quick sort otherwise
ARR.toSorted([FUNC])->ARR2                  *-|~#Same as ARR.sort(FUNC) but does not modify

ARR.indexOf(VAL[, NUM])                         #Returns VAL index, or -1. Uses ===
                                                #If NUM, skip first NUM elements (but still returns index from beginning)
                                                #Using ~VAL is shortcut for VAL !== -1, e.g. ~ARR.indexOf(VAL) is
                                                #like ARR.includes(VAL)
ARR.lastIndexOf(VAL[, NUM])                     #Same but from end.
ARR.find[Index]
 (FUNC(VAL, KEY, ARR)->BOOL[, THIS])          -|#Returns first VAL|KEY that returns true. Otherwise does not return.
ARR.findLast[Index](...)               18.0.0*-|#Same but from end.
ARR.includes(VAL[, NUM])                      -|#Same as ARR.indexOf(...) !== -1
                                              -|#Except NaN === NaN

ARR.forEach(FUNC(VAL, KEY, ARR)[, THIS])        #
ARR.map(FUNC(VAL, KEY, ARR)->VAL[, THIS])       #Returns [VAL...]

ARR.reduce[Right]                               #MEMO is:
(FUNC(MEMO, VAL, KEY, ARR)[, MEMO])             #  - first: argument passed (def: first value, which is then not iterated)
                                                #  - then: previous FUNC() return value
                                                #  - final return value
                                                #reduceRight iterates from end to beginning
ARR.filter(FUNC(VAL, KEY, ARR)->BOOL[, THIS])   #Excludes if false
ARR.every|some(FUNC(VAL, KEY, ARR)->BOOL[,THIS])#Returns true if all|any true.
ARR.flat([INT])                               -|#Flattens INT levels of depth (def: 1)
ARR.flatMap(...)                              -|#Same as ARR.map(...).flatten(1)
ARR.groupBy(FUNC(VAL, KEY, ARR)->STR)->OBJ   -|~#Returns OBJ where keys are STR are values are VAL_ARR2
ARR.groupByToMap(FUNC(VAL, KEY, ARR)->VAL2)
 ->MAP                                       -|~#Same with MAP

ARR.keys()                                    -|#Returns all INDEX as ITERABLETOR
ARR.values()                                  -|#Returns all VAL as ITERABLETOR (i.e. same as ARR[Symbol.iterator])
ARR.entries()                                 -|#Returns all [INDEX, VAL] as ITERABLETOR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         TYPED ARRAYS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new ArrayBuffer(UINT[, OPTS])                   #Raw data chunk. Useful for:
                                                #  - binary data
                                                #  - memory allocation performance optimization
                                                #UINT is byteLength. Filled with \0
                                                #Needs a view to be manipulated, which gives:
                                                #  - start|end indices
                                                #  - a specific type to read it
                                                #Available:
                                                #  - DATAVIEW: can change type
                                                #  - TYPED_ARR: more convenient because manipulated as an ARR
                                                #Several DATAVIEW|TYPED_ARR can be applied to a single ARRBUFFER.
                                                #OPTS:
                                            *-|~#  - maximumByteLength NUM (def: UINT)
ARRBUFFER.byteLength                            #Readonly.
ARRBUFFER.maximumByteLength                 *-|~#Readonly. Set by OPTS.maximumByteLength
                                            *-|~#Maximum size to resize() to (def: UINT)
                                            *-|~#Allocates memory right away, i.e. more efficient
                                            *-|~#Set to byteLength (not resizable) in return values of slice|transfer()
ARRBUFFER.resize(UINT)                      *-|~#Must be < maximumByteLength
ARRBUFFER.resizable                         *-|~#Readonly. BOOL. True if OPTS.maximumByteLength > UINT specified
ARRBUFFER.transfer([UINT])->ARRBUFFER2      *-|~#Returns new ARRBUFFER2 with same underlying data chunk, but potentially
                                            *-|~#different byteLength UINT (def: same, cannot be higher).
                                            *-|~#ARRBUFFER is reset (byteLength|maximumByteLength 0)
ARRBUFFER.slice(...)                            #Like ARR.slice(...)

ArrayBuffer.isView(OBJ)                         #True if DATAVIEW|TYPED_ARR

new DataView(ARRBUFFER[, UINT[, UINT2]])        #UINT is offset (def: 0), UINT2 length (def: ARRBUFFER.byteLength)
DATAVIEW.buffer|byteLength|byteOffset           #Readonly

DATAVIEW.get[Ui|I]nt8|16|32([UINT[, BOOL]])
DATAVIEW.getFloat32|64(UINT[, BOOL])            #UINT is byte offset, BOOL endianness (def: true, i.e. little endian)
DATAVIEW.getBig[Ui|I]nt64(UINT[, BOOL])       -|#
DATAVIEW.set*(UINT, UINT2[, BOOL])              #UINT2 is the value to set


TypedArray                                      #Base prototype of [Ui|I]nt8|16|32Array or Float32|64Array
                                              -|#and Big[Ui|i]nt64Array
                                                #Each have a given associated type
                                                #Not accessible globally but through prototype chain.
                                              -|#Mixes in all ARR methods:
                                              -|#  - including TYPED_ARR[NUM], TypedArray.of|from()
                                              -|#  - excluding concat(), splice(), push|pop|shift|unshift(), flat[Map]()
                                              -|#There is also a special Uint8ClampedArray, which do not 'roll' too low|high
                                              -|#values, e.g.:
                                              -|#  - UINT8_ARR[0] = -10 (246) vs UINT8_CLAMPED_ARR[0] = -1 (0)
                                              -|#  - UINT8_ARR[0] = 260 (4) vs UINT8_CLAMPED_ARR[0] = 260 (255)
new TypedArray(NUM)                             #Same as new TypedArray(new ArrayBuffer(NUM))
new TypedArray(ARRBUFFER[, UINT[, UINT2]])      #Same args as DataView
new TypedArray(TYPED_ARR2)                      #Copy
new TypedArray(ARRAYLIKE|ITERABLE)              #Uses TYPED_ARR.from(...)
                                                #Elements must be integers

TypedArray|TYPED_ARR.BYTES_PER_ELEMENT          #
TYPED_ARR.buffer|byteLength|byteOffset          #Readonly
TYPED_ARR.length                                #

TYPED_ARR.subarray(...)                         #Like slice(...) except it shares same ARRBUFFER
TYPED_ARR.set(ARR|TYPED_ARR2[, UINT])           #Sets all ARR|TYPED_ARR2 values into TYPED_ARR, starting at index UINT (def: 0)
                                                #If ARR|TYPED_ARR2 too big, RangeError thrown
TYPED_ARR.toString()                            #Is like ARR, not OBJ

REFERENCES ==>                                  #Different ARRBUFFERs always point to different data
                                                #But 2 DATAVIEW|TYPED_ARR might point to same ARRBUFFER|data
                                                #  - with: new DataView|TypedArray(ARRBUFFER), TYPED_ARR.subarray()
                                                #  - but not with: new TypedArray(NUM|TYPED_ARR2|ARRAYLIKE|ITERABLE), TypedArray.from(), TYPED_ARR.slice()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        SHARED BUFFERS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new SharedArrayBuffer(UINT)                    -#Can be used like an ARRBUFFER including:
                                               -#  - new TypedArray(...)
                                               -#  - postMessage(...)
                                               -#Except:
                                               -#  - shared between contexts|WINDOWs, e.g. when passed via postMessage()
                                               -#     - postMessage() should not use VAL2
                                               -#  - must be manipulated using Atomics.*() to ensure thread-safety:
                                               -#     - provide correct atomicity and order, underlyingly using a lock
                                               -#  - cannot be used with DataView, and no SharedArrayBuffer.isView()
                                               -#  - resize|resizable -> grow|growable (cannot shrink)

Atomics.load(S_ARRBUFFER, NUM)->VAL            -#Like S_ARRBUFFER[NUM]
Atomics.store(S_ARRBUFFER, NUM, VAL)->VAL      -#Like S_ARRBUFFER[NUM] = VAL
Atomics.exchange(S_ARRBUFFER, NUM, VAL)->VAL2  -#Like S_ARRBUFFER[NUM] = VAL, returning previous value
Atomics.compareExchange                        -#Like if (S_ARRBUFFER[NUM] == VAL3) S_ARRBUFFER[NUM] = VAL,
 (S_ARRBUFFER, NUM, VAL3, VAL)->VAL2           -#returning previous value

Atomics.add|sub|and|or|xor
 (S_ARRBUFFER, NUM, VAL)->VAL2                 -#Like S_ARRBUFFER[NUM] += -= &= |= ^= VAL, returning previous value

Atomics.wait                                   -#Wait until Atomics.notify(), providing test passes.
 (S_INT32_ARR, NUM, VAL[, NUM2])->STR          -#I.e.:
                                               -#  - if S_INT32_ARR[NUM] != VAL, does nothing (STR is "not-equal")
                                               -#  - otherwise:
                                               -#     - wait until Atomics.notify() (STR is "ok")
                                               -#     - or until timeout NUM2ms (STR is "timed-out")
Atomics.waitAsync
 (S_INT32_ARR, NUM, VAL[, NUM2])
 ->PROMISE_STR                         *16.0.0-~#Same but async
Atomics.notify(S_INT32_ARR, NUM, NUM2)         -#Wake up NUM2 workers Atomics.waiting, with same first two arguments

Atomics.isLockFree(S_ARRBUFFER, NUM)->BOOL     -#True if underlying hardware can avoid locks for S_ARRBUFFER in a typed array
                                               -#of size NUM
                                               -#Always true for NUM 4, often true for 1|2, usually false otherwise
                                               -#Used for optimization, i.e. not relying on shared buffers if underlying
                                               -#hardware is going to be slow


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           ITERATORS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ITERATOR                                      -|#OBJ with:
                                              -|#  - next([ARG]):
                                              -|#     - iterates over next value -> { done: false, value: NEXT }
                                              -|#     - if iteration finished -> { done: true, value: RETURN }
                                              -|#        - RETURN is the optional return value of the whole iteration
                                              -|#           - it is not the iteration's last value
                                              -|#           - undefined if already returned by previous next|return()
                                              -|#  - return([ARG])->{ done: true, value: RETURN }
                                              -|#     - finish iteration successfully
                                              -|#     - if iteration finished, noop and RETURN is undefined
                                              -|#     - optional
                                              -|#  - throw([ARG]):
                                              -|#     - finish iteration due to error
                                              -|#     - if iteration finished, fails
                                              -|#     - ARG is usually ERROR
                                              -|#     - optional
ITERABLE                                      -|#OBJ where OBJ[Symbol.iterator]()->ITERATOR
                                              -|#Each call returns a new ITERATOR
                                              -|#STR|[TYPED_]ARR|MAP|SET are ITERABLE (only next() is defined)
ITERABLETOR                                   -|#ITERATOR where OBJ[Symbol.iterator]()->ITERABLETOR (itself)
                                              -|#I.e. used as an ITERABLE, but always with the same ITERATOR
ASYNC_ITERATOR|ITERABLE|ITERABLETOR           -|#Same except:
                                              -|#  - next|return|throw() can return a PROMISE
                                              -|#  - Symbol.iterator -> Symbol.asyncIterator
                                              -|#Can be used as ITERATOR|ITERABLE|ITERABLETOR, but not vice-versa
                                              -|#PROMISE_ARR are ASYNC_ITERABLE

[async] function* [FUNC](){...}               -|#Generator. FUNC returns an ITERABLETOR with ITERATOR:
[class ...] { [async] * FUNC(...) {...} ... } -|#  - next([VAL]):
                                              -|#     - continue execution of function until any of:
                                              -|#        - yield NEXT -> { done: false, value: NEXT }
                                              -|#        - return RETURN -> { done: true, value: RETURN }
                                              -|#        - execution finished -> { done: true, value: undefined }
                                              -|#        - throw VAL -> propagate exception
                                              -|#     - VAL is previous "yield" return value
                                              -|#     - initially stopped at the beginning
                                              -|#        - i.e. VAL is ignored since no "yield" yet
                                              -|#  - return([RETURN])
                                              -|#     - "return RETURN" from current execution position, i.e. finish execution
                                              -|#     - if execution finished, noop and RETURN ignored
                                              -|#     - returns { done: true, value: RETURN }
                                              -|#  - throw(VAL):
                                              -|#     - "throw VAL" from current execution position
                                              -|#     - if execution finished, throw VAL from caller position
yield* ITERABLE                               -|#Like: for (const NEXT of ITERABLE) { yield NEXT }
                                              -|#Return value is ITERABLE's RETURN
yield* ASYNC_ITERABLE                         -|#Same for: for await (const NEXT of ASYNC_ITERABLE) { yield NEXT }
new [Async]GeneratorFunction(...)             -|#Like new Function(...) but for [async] function*(){}
                                              -|#[Async]GeneratorFunction not available globally, but with:
                                              -|#  Object.getPrototypeOf([async] function*(){}).constructor

for ( [QUAL] NEXT of ITERABLE ) {...}         -|#Iterates with NEXT = ITERATOR.next().value until done true
                                              -|#break|return|throw calls ITERATOR.return()
                                              -|#Does not call ITERATOR.throw()
for await (QUAL NEXT of [ASYNC_]ITERABLE)
 {...}                                        -|#Same but using await [ASYNC_]ITERATOR.next().value

[...ITERABLE]                                 -|#In ARR literal form
                                              -|#Iterates with ITERATOR.next().value until done true, then returns aggregated values as ARR
                                              -|#Does not call ITERATOR.return|throw()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          MAPS & SETS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Map([ITERABLE])                           -|#ITERABLE must iterate over [KEY, VAL] elements (e.g. Object.entries(OBJ))
                                              -|#Is an ITERABLE itself, iterating over [KEY, VAL] in insertion order.
                                              -|#To use instead of OBJ, when:
                                              -|#  - KEY must be other than STR
                                              -|#  - VALs are conceptually similar to each other

MAP.get(KEY)->VAL                             -|#Like OBJ[KEY] and OBJ[KEY] = VAL, except KEY can be any type.
MAP.set(KEY, VAL)->MAP                        -|#KEY equality uses Object.is() not ===
MAP.has(KEY)->BOOL                            -|#
MAP.delete(KEY)->BOOL                         -|#
MAP.clear()                                   -|#

MAP.size                                      -|#

MAP.keys|values|entries()                     -|#Like ARR
MAP.forEach(...)                              -|#Like ARR


WeakMap                                       -|#Like Map, except WEAKMAP does not own its children:
                                              -|#  - VAL will be garbage collected when its KEY is, whether WEAKMAP is still
                                              -|#    around or not
                                              -|#  - while MAP.set(KEY, VAL) is conceptually like MAP.KEY = VAL,
                                              -|#    WEAKMAP.set(KEY, VAL) is like KEY.__value = VAL
                                              -|#  - as such, cannot use clear|size|keys|values|entries|forEach()
                                              -|#    and is not ITERABLE
                                              -|#  - KEY must be OBJ
                                            *-|~#    or SYM, except Symbol.for() that are not well-known
                                              -|#To use when passive relation to children (proxying, listening, etc.) not
                                              -|#ownership (children existing mainly as MAP properties).

Set                                           -|#Like a Map where KEY === VAL (i.e. keep unique values):
                                              -|#  - ITERABLE iterates over VAL elements, not [KEY, VAL]
                                              -|#  - entries() iterates over [VAL, VAL], keys|values() are same
                                              -|#  - no SET.get()
                                              -|#  - SET.set() -> SET.add(VAL)

WeakSet                                       -|#Like WeakMap, but for Set.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DATE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Date                                            #Milliseconds-precise. Is internally:
                                                #  - only an Epoch NUM.
                                                #  - NaN for InvalidDate
                                                #UTC vs local:
                                                #  - input:
                                                #     - local: new Date(...)
                                                #     - does not matter: new Date()
                                                #     - UTC: new Date(Date.UTC(...))
                                                #  - output:
                                                #     - local: get|set*()
                                                #     - UTC: get|setUTC*(), getTime()
new Date([YEAR,MONTH,DAY,HOUR,MIN,SEC,MILLISEC])#Each final arguments are optional. Def: now.
new Date(STR)                                   #InvalidDate if cannot parse.
Date()                                          #Same as (new Date()).toString()

DATE.toString()                                 #"Day Mon DD YYYY HH:MM:SS TZ" (local timezone)
DATE.toISOString()                              #"YYYY-MM-DDTHH:MM:SS.SSSZ" (UTC)
DATE.toUTCString()                              #"Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
DATE.toDateString()                             #"Day Mon DD YYYY" (local timezone)
DATE.toTimeString()                             #"HH:MM:SS TZ" (local timezone)

DATE.valueOf()->NUM                             #DATE.getTime()

DATE.*et[UTC][Time/FullYear/Month/Date/Day/     #Date is month day, Day week day (0 for Sunday)
Hours/Minutes/Seconds/Milliseconds/             #Time is Epoch in seconds
TimezoneOffset]()                               #TimezoneOffset is in minutes
                                                #set* returns DATE.getTime()

Date.now()                                      #Like new DATE().getTime()
Date.parse(STR)                                 #Like new DATE(STR).getTime()
Date.UTC(...)                                   #Like new DATE(...).getTime() but new Date(...) uses UTC


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MATH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Math.min|max(NUM...)                            #NaN if one NUM not a number. [-]Infinity if no arguments.

Math.abs(NUM)                                   #
Math.sign(NUM)                                -|#Returns -|+ 0|1 or NaN

Math.ceil|floor(NUM)                            #Ceiling|flooring
Math.trunc(NUM)                               -|#Truncation
Math.round(NUM)                                 #Nearest round. Tie-breaking towards Infinity
Math.fround(NUM)                              -|#Converts to single-precision float (binary32)

Math.PI                                         #
Math.E                                          #
Math.LN2                                        #ln(2)
Math.LN10                                       #ln(10)
Math.LOG2E                                      #log2(e)
Math.LOG10E                                     #log10(e)
Math.SQRT2                                      #
Math.SQRT1_2                                    #

Math.pow(NUM1, NUM2)                            #
Math.sqrt(NUM)                                  #NaN if negative
Math.cbrt(NUM)                                -|#
Math.exp(NUM)                                   #
Math.expm1(NUM)                               -|#Same as Math.exp(NUM)-1
Math.log(NUM)                                   #Base e. NaN if negative
Math.log2|10(NUM)                             -|#Base 2|10
Math.log1p(NUM)                               -|#Same as Math.log(NUM+1)

Math.imul(NUM, NUM2)                          -|#Like NUM*NUM2, except only for 32-bits signed integers, where the sign is the
                                              -|#first bit, e.g. 4e9 is negative.
                                              -|#Used to emulate x86 ASM imul.
Math.clz32(NUM)                               -|#Number of leading zeros in a 32-bits signed binary format.

Math.[a]sin|cos|tan[2](NUM)                     #In radian
Math.[a]sin|cos|tan[2]h(NUM)                  -|#Hyperbolic version
Math.hypot(NUM...)                            -|#sqrt(NUM**2 + NUM2**2 ...)

Math.random()                                   #Float in [0,1). Seeded from current time.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             JSON              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JSON ==>                                        #See JSON-js doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       STRUCTURED CLONE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STRUCTURED CLONE ALGORITHM ==>                  #Serialization of almost any JavaScript VAL:
                                                #  - can be:
                                                #     - any JSON value
                                                #     - undefined|NaN|Infinity|MAP|SET|DATE|REGEXP|BIGINT
                                                #     - BLOB|FILE[LIST]|[ARR]BUFFER[VIEW]|DATAVIEW|TYPED_ARR|IMAGEDATA|ABORT_SIGNAL
                                                #     - circular references
                                                #  - OBJ keep their constructors
                                                #  - cannot be:
                                                #     - FUNC|SYM|PROMISE
                                                #     - ERROR (works on Chrome|Node.js, but not some browsers)
                                                #     - PROXY|INTL.*
                                                #     - DOM ELEM
                                                #  - does not keep:
                                                #     - inherited properties
                                                #     - non-enumerated properties
                                                #     - REGEXP.lastIndex
                                                #     - setters, getters, property descriptors
                                                #  - can transfer memory of some types: ARRBUFFER[VIEW]|MESSAGEPORT
                                                #Used in:
                                                #  - WINDOW|WORKER.postMessage()
                                                #  - structuredClone() (global in DOM or Node.js)
                                                #  - IndexedDB
                                                #  - Node.js v8.[de]serialize()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROMISE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PROMISE                                       -|#Represents an async function call.
                                              -|#Has two non-accessible members:
                                              -|#  - state 'pending|resolved|rejected': whether call is ongoing or done
                                              -|#  - value VAL: async function call return value or exception thrown
PROMISABLE                                    -|#Any OBJ with OBJ.then(FUNC, FUNC2)

TASKS ==>                                     -|#new Promise() FUNC is fired right away, i.e. in current microtask, sync,
                                              -|#before next statement.
                                              -|#But PROMISE.then|catch() FUNC is fired in next microtask, even if PROMISE is
                                              -|#already resolved|rejected.
                                              -|#This means await PROMISE, but also await VAL, will wait at least one microtask

new Promise                                   -|#Returns PROMISE:
(FUNC(RESOLVE(VAL|PROMISABLE), REJECT(VAL)))  -|#  - RESOLVE(VAL): state 'resolved', value VAL
                                              -|#  - REJECT(VAL): state 'rejected', value VAL
                                              -|#  - RESOLVE(PROMISABLE):
                                              -|#     - does PROMISABLE.then(RESOLVE, REJECT)
                                              -|#     - so PROMISE will have same state|value as PROMISABLE
                                              -|#RESOLVE|REJECT() defer state change
Promise.resolve|reject(...)                   -|#Same as new Promise(function(resolve, reject) { resolve|reject(...) })

PROMISE.then([FUNC(VAL)[, FUNC2(VAL)]])       -|#Fire FUNC|FUNC2 with PROMISE value if|when PROMISE.state 'resolved|rejected'
                                              -|#Returns new PROMISE2, which fires (according to what happens in
                                              -|#either FUNC|FUNC2):
                                              -|#  - if return VAL|PROMISABLE (including undefined): RESOLVE(VAL|PROMISABLE)
                                              -|#  - if throw VAL: REJECT(VAL)
                                              -|#Def FUNC|FUNC2:
                                              -|#  - return|throw VAL
                                              -|#  - if not a function, use def
PROMISE.catch(...)                            -|#Same as PROMISE.then(null, ...)
PROMISE.finally(FUNC())                       -|#Like PROMISE.then(FUNC(), FUNC())
                                              -|#Difference:
                                              -|#  - returning does not change PROMISE value
                                              -|#  - but throwing does
                                              -|#  - i.e. unlike `finally` in sync or async function: return statements
                                              -|#    (but not exceptions) have lower priority than try|catch's return|exception

Promise.all(VAL|PROMISABLE_ITERABLE)          -|#Returns PROMISE:
                                              -|#  - if all PROMISABLE resolved -> resolved with VAL2_ARR
                                              -|#  - if any PROMISABLE rejected with VAL2 -> rejected with VAL2
                                              -|#VAL is converted to PROMISE2 using Promise.resolve(VAL)
Promise.race(VAL|PROMISABLE_ITERABLE)         -|#Same but instead:
                                              -|#  - if any PROMISABLE resolved|rejected with VAL2 -> resolved|rejected with VAL2
Promise.allSettled(VAL|PROMISABLE_ITERABL)    -|#Same but instead:
                                              -|#  - after all PROMISABLE resolved|rejected with VAL2 -> resolved with OBJ_ARR:
                                              -|#     - status 'fulfilled|rejected'
                                              -|#     - value VAL2 (if resolved)
                                              -|#     - reason VAL2 (if rejected)
Promise.any(VAL|PROMISABLE_ITERABLE)   15.0.0*-|#Same but instead:
                                       15.0.0*-|#  - if any PROMISABLE resolved with VAL2 -> resolved with VAL2
                                       15.0.0*-|#  - if all PROMISABLE rejected -> rejected with AGGREGATE_ERROR: errors VAL2_ARR

async function [*] [FUNC](...) {...}          -|#Returns FUNC2(...)->PROMISE, where FUNC can:
[class ...] { async [*] FUNC() {...} ... }    -|#  - return VAL -> resolve PROMISE with VAL
async (...) => ...                            -|#  - throw VAL -> reject PROMISE with VAL
                                              -|#  - return PROMISE2 -> reject|resolve PROMISE with PROMISE2 value
await PROMISABLE|VAL                          -|#Inside async FUNC:
                                              -|#  - waits for PROMISABLE to resolve|reject
                                              -|#     - if PROMISABLE value returns PROMISABLE2, use PROMISABLE2 value instead
                                              -|#     - VAL is like Promise.resolve(VAL)
                                              -|#  - then returns|throws PROMISABLE value
                                       14.8.0*-|#Can be in top-level scope too


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PROXY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Proxy(OBJ, OBJ2)                        -|||#Returns PROXY:
                                            -|||#  - live deep mirror of OBJ: OBJ and PROXY are always deep equal
                                            -|||#     - including prototype and inherited properties
                                            -|||#     - but Object.prototype.toString.call(PROXY) is always '[object Object]'
                                            -|||#  - can override some basic object operations with OBJ2:
                                            -|||#     - providing they are performed on PROXY (not on OBJ)
                                            -|||#     - they usually have same arguments, plus a first argument being PROXY
                                            -|||#     - can call themselves without creating infinite recursion,
                                            -|||#        - but set|get() OBJ3 can't, i.e. OBJ3.VAR = VAL as opposed to
                                            -|||#          PROXY.VAR = VAL
                                            -|||#     - there are some special rules ('invariants') to handle
                                            -|||#       non-extensible|configurable|writable properties (see online doc)
                                            -|||#       Should not worry unless writing a library.
                                            -|||#     - return value:
                                            -|||#        - mutating methods must return BOOL:
                                            -|||#           - if falsy, throws TypeError
                                            -|||#        - non-mutating methods must return the same return value as the underlying method
                                            -|||#        - should return the corresponding Reflect.*(...) to get the original behavior
                                            -|||#  - 'VAR' can be SYM
                                            -|||#OBJ2 members follow.
                                            -|||#Limited polyfill|ponyfill GoogleChrome 'proxy-polyfill'
Proxy.revocable(OBJ, OBJ2)                  -|||#Like new Proxy(OBJ, OBJ2) but returns OBJ3:
                                            -|||#  - proxy PROXY
                                            -|||#  - revoke(): make accessing OBJ3.proxy throw a TypeError

OBJ2.set(PROXY, 'VAR', VAL, OBJ3)->BOOL     -|||#PROXY.VAR = VAL
                                            -|||#OBJ3 === PROXY, unless PROXY is in prototype chain, in which case OBJ3 is the target child
OBJ2.get(PROXY, 'VAR', OBJ3)->VAL           -|||#PROXY.VAR
                                            -|||#OBJ3: like set(...)
OBJ2.deleteProperty(PROXY, 'VAR')->BOOL     -|||#delete PROXY.VAR

OBJ2.has(PROXY, 'VAR')->BOOL                -|||#'VAR' in PROXY
OBJ2.ownKeys(PROXY)->STR_ARR                -|||#Object.getOwnPropertyNames(PROXY) + Object.getOwnPropertySymbols(PROXY)
                                            -|||#Must at least contain same keys as original call

OBJ2.defineProperty(PROXY, 'VAR', OBJ3)
 ->BOOL                                     -|||#Object.defineProperty(PROXY, 'VAR', OBJ3)
OBJ2.getOwnPropertyDescriptor(PROXY, 'VAR')
 [->OBJ]                                    -|||#Object.getOwnPropertyDescriptor(PROXY, 'VAR')
OBJ2.isExtensible(PROXY)->BOOL              -|||#Object.isExtensible(PROXY)
                                            -|||#Must return same value
OBJ2.preventExtensions(PROXY)->BOOL         -|||#Object.preventExtensions(PROXY)
                                            -|||#Must return Object.isExtensible(PROXY)

OBJ2.getPrototypeOf(PROXY)->OBJ|null        -|||#PROXY.__proto__ or Object.getPrototypeOf(PROXY)
                                            -|||#Internally used by isPrototypeOf() and instanceof
OBJ2.setPrototypeOf(PROXY, OBJ3)->BOOL      -|||#PROXY.__proto__ = OBJ3 or Object.setPrototypeOf(PROXY, OBJ3)

OBJ2.apply(PROXY, THIS, ARGS_ARR)->VAL      -|||#PROXY(ARGS...)
OBJ2.construct(PROXY, ARGS_ARR)->OBJ        -|||#new PROXY(ARGS...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REFLECT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Reflect.*(OBJ, ...)                           -|#Does same thing as what Proxy OBJ2.*(PROXY, ...) proxies.
                                              -|#E.g. Reflect.set(OBJ, 'VAR', VAL, OBJ3) will:
                                              -|#  - OBJ.VAR = VAL
                                              -|#  - must return BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ES MODULES DIFFERENCES ==>                    -|#Implies 'use strict'
                                              -|#Variables are file-scoped
                                              -|#Because of those differences, must use export {} if nothing is exported, since
                                              -|#without import|export keyword, cannot distinguish.

export QUAL VAR = VAL[, ...]                  -|#
export function VAR(...){...}                 -|#
export class CLASS { ... }                    -|#
export { VAR[ as VAR2], ... }                 -|#Specific VAR ("named export")
export { VAR as default, ... }
export default VAL                            -|#Default VAR ("default export"). Is just a named export called "default".
export {}                                     -|#Do not export anything (i.e. not an empty object)
export {} from "MDL"
export {...} from "MDL"
export ... from "MDL"                         -|#Same as import ... from "MDL", then multiple export

import { VAR[ as VAR2], ... } from "MDL"      -|#Specific VAR
import * as VAR2 from "MDL"                   -|#All VARs, including "default"
import { default as VAR2, ... } from "MDL"
import VAR[, ...] from "MDL"                  -|#"default" VAR. Can be combined, e.g. import VAR, {...} from "MDL"
import {} from "MDL"
import "MDL"                                  -|#Do not import the variable, just execute the file

import("MDL")->PROMISE(OBJ)                   -|#As opposed to above, not static (dynamic), i.e. does not have to be top-level
                                              -|#If default export, defined in OBJ.default

import ... "MDL"
 assert { VAR: "VAL", ... }
import("MDL",                        16.14.0*-|~#Adds information about import using VAR: VAL
 { assert: { VAR: "VAL", ...}})      16.14.0*-|~#Most VAR is host-specific, but the following are standard:
 ->PROMISE(VAL)                      16.14.0*-|~#  - type 'json': file format is JSON

import { "VAR" as VAR2, ... } from "MDL"
export { VAR2 as "VAR", ... } ...           *-|~#Arbitrary export names. Only useful when importing|exporting from non-JavaScript, e.g. WASM

CIRCULAR DEPENDENCIES ==>                     -|#Accessing circular properties during file loading throws an error.
                                              -|#But accessing them later works.

import.meta.url                             -|||#Current file absolute path, as file:// URL
                                            -|||#Polyfill babel-plugin-bundled-import-meta

<script>
  type="module"                              *-|#Must be specified in browser to use modules.
                                             *-|#Each import creates an async request
                                             *-|#  - to avoid long loading time, should preload each file with
                                             *-|#    <link rel="modulepreload" href="FILE">

module { ... }                               *-|#Declare a module inline.
                                             *-|#Return its 'MDL' which must be passed to import()
                                             *-|#Behave like declaring module in a separate file in terms of scope
                                             *-|#   - except import.meta.url is same
