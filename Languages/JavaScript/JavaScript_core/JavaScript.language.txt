
                                  ┏━━━━━━━━━━━━━━━━┓
                                  ┃   JAVASCRIPT   ┃
                                  ┗━━━━━━━━━━━━━━━━┛

VERSION ==>                       #Standard is called ECMAScript. JavaScript and ActionScript are dialects.
                                  #This doc shows strict mode only

SUPPORT ==>                       #Use this notation for new features:
                                 ~#  - stage 3 proposal
                               NUM#  - introduced by Node NUM.*.*
                                 *#  - not latest Node
                                  #Only document|use features in stage >= 3
                                  #Can look at support with:
                                  #  - EcmaScript kangax compat-table
                                  #  - http://node.green/

MAIN PRINCIPLES ==>               #Case-sensitive. Whitespaces are ignored.
                                  #Type: weak, dynamic, generic, late/duck.
                                  #Lexical-scope
                                  #Functional (first-class functions)
                                  #Object-oriented (prototype-based)
                                  #Imperative (structures close to C)
                                  #Need a host environnement (e.g. browser) for I/O
                                  #Memory management: garbage collection.

EXECUTION ==>                     #Each browser has own JavaScript engine, which was in the past interpreted,
                                  #but now is byte-compiled or compiled:
                                  #  - V8 (Chrome, Opera 15+, Edge >=2020, Node.js, Deno)
                                  #  - SpiderMonkey (Firefox, MongoDB >=3.2)
                                  #  - JavaScriptCore/SquirrelFish/Nitro (Safari) part of WebKit
                                  #  - Chakra (IE9+, Edge <2019), opensourced at ChakraCore

                                  ┌───────────┐
                                  │   ASYNC   │
                                  └───────────┘

EVENT LOOP ==>                    #Loops:
                                  #  - each event loop loops through [macro]tasks
                                  #  - each macrotask loops through microtasks|tick
                                  #  - each microtask is run synchronously

NEW TASKS ==>                     #Each thread has a single event loop
                                  #  - creates a new thread: process, WebWorker, cross-origin <iframe>
                                  #Macrotasks are created by I/O code, which includes:
                                  #  - setTimeout|Interval|Immediate()
                                  #  - filesystem, network or OS calls
                                  #     - not streams on their own
                                  #  - event handlers triggered by browser interaction.
                                  #     - events triggered directly through JavaScript, which include Node.js EVENTEMITTER, are sync.
                                  #Microtasks are created by:
                                  #  - process.nextTick()
                                  #  - queueMicrotask()
                                  #  - PROMISE.then|catch() callbacks
                                  #  - priority:
                                  #     - first-in first-out
                                  #     - process.nextTick() before other types of microtasks
                                  #        - e.g. if a process.nextTick() create a new process.nextTick(),
                                  #          it will be fired before pending PROMISE microtasks

PERFORMANCE ==>                   #For Node.js:
                                  #  - minimal time of a macrotask is 1ms.
                                  #    I.e. a macrotask that only does setTimeout(..., 0) will last 1ms
                                  #  - there is no minimal time for a microtask

SINGLE-THREADED ==>               #Each event loop is single-threaded:
                                  #  - i.e. only one microtask and one macrotask runs at any time
                                  #Resources:
                                  #  - I/O-intensive tasks:
                                  #     - are the slowest
                                  #     - should yield the thread and be woken up on a new macrotask
                                  #     - this is what most I/O functions do by default, i.e. I/O calls are
                                  #       optimally handled
                                  #     - i.e. developer just need to use async I/O functions
                                  #  - CPU-intensive tasks:
                                  #     - will hold the whole thread
                                  #     - if too slow, should spawn a new thread instead
                                  #  - memory consumption:
                                  #     - is very low, because thread and processes is what makes memory go high

ASYNC EXPECTATION ==>             #Libraries exposing callbacks should trigger them in a new microtask,
                                  #because this what consumers usually expect.
                                  #  - e.g. this would otherwise be problematic:
                                  #     let VAR = FUNC(CALLBACK); VAR.on('start', ...)

THREAD EXIT ==>                   #Thread exits when the event loop has no more macrotasks
                                  #In a browser, this never happens, as there are always DOM event listeners.
                                  #In Node.js:
                                  #  - timers methods keep the thread alive
                                  #     - i.e. automatically ref'd
                                  #     - process.nextTick(), queueMicrotask(), setTimeout|setInterval()
                                  #  - PROMISEs do not keep the thread alive by themselves
                                  #     - PROMISE.then|catch() FUNC, await PROMISE
                                  #     - but they do when the PROMISE relies on ref'd logic
                                  #  - any external input is ref'd by Node.js
                                  #     - I/O, processes, network
                                  #  - sometimes ref|unref() methods are exposed to manually control this

ASYNC STACK TRACE ==>             #Also called "long stack trace"
                                  #When using async, the callback function does not include stack trace from parent function
                                  #  - because it is processed on a different microtask
                                  #This is missing in:
                                  #  - setTimeout|Interval|Immediate(FUNC), process.nextTick(FUNC), queueMicrotask()
                                  #  - filesystem, network, OS or browser interaction event handlers
                                  #  - new Promise()
                                  #This is not missing when using async|await:
                                  #  - including whn using Promise.*()
                                  #  - supported:
                                  #     - code during|before an await statement: always
                                  #     - code after an await statement: most browsers and Node

                                  ┌───────────┐
                                  │   SCOPE   │
                                  └───────────┘

GENERAL ==>                       #  - variable scope is:
                                  #     - "var": FUNC {...}
                                  #     - "let|const": any {...}
                                  #  - any function inherits scope of the function in which it is declared (not called)
                                  #     - inherits by reference, not by value
globalThis                        #Global scope reference
                                  #Otherwise can be in many places (self in WORKER, window in DOM, global in Node.js, this otherwise)

DECLARATION ==>                   #  - using undeclared VAR throws ReferenceError (except with typeof)
                                  #  - using VAR (even if declared in parent scope) declared later in
                                  #    current scope with:
                                  #     - "let|const": throws ReferenceError ("Temporal Dead Zone")
                                  #     - "var": adds an implicit empty declaration before, i.e. will be
                                  #       undefined (variable hoisting)
                                  #     - function FUNC(){}: adds an implicit declaration+assignment before

DECLARING FUNCTIONS ==>           #  - FUNC = function [FUNC2](){}
                                  #     - declared+assigned at runtime (like other variables)
                                  #     - this also covers anonymous function, and void function [FUNC2](){}
                                  #     - Using "FUNC2":
                                  #        - equivalent of doing let FUNC2 = function(){} at the beginning of
                                  #          the same function
                                  #        - allow recursion to reference themselves without risk of parent
                                  #          scope to reassign FUNC2
                                  #  - function FUNC2(){}:
                                  #     - declared+assigned at parsetime
                                  #        - i.e. equivalent of doing let FUNC2 = function () {} at {...} scope
                                  #          beginning
                                  #  - new Function(...): child of global scope

MEMORY MANAGEMENT ==>             #Garbage collection:
                                  #  - use tracing, i.e. no problem with reference cycles
                                  #  - root objects are global variables
                                  #  - closures carry references to their parent scope, but only of the
                                  #    references they use
                                  #     - this might be problematic when closures are returned, i.e. go up the
                                  #       stack, extending their parent scope lifetime
                                  #Memory leak happens with combination of variables being:
                                  #  - big, e.g.:
                                  #     - functions carrying parent SCOPEs
                                  #     - big objects
                                  #     - raw data returned from server
                                  #  - long-lived, e.g.:
                                  #     - attached to top/long-lived SCOPEs, e.g. global variables, e.g.:
                                  #        - long-lived DOM elements
                                  #        - global functions (e.g. global event handlers, setInterval(), ...)
                                  #Avoiding:
                                  #  - unset variables just after being used if they are big or attached to
                                  #    long-lived objects
                                  #     - "unset": prefer setting empty value than using "delete"
                                  #  - only use closures as argument or return value when needed

new WeakRef(OBJ)                  #Keep a reference to OBJ, without preventing OBJ from being GC'd
                                  #Should not rely:
                                  #  - on when|whether GC happens, since this is very variable
                                  #  - on it to guess when|whether GC happens
                                  #For example, should not be used for resource cleanup.
                                  #Should only be used as a way to prevent increasing memory usage.
                                  #  - e.g. caches or weak maps
                                  #  - consider using WeakMap|WeakSet if possible
WEAKREF.deref()->OBJ|undefined    #Returns OBJ. undefined if OBJ was GC'd

new FinalizationRegistry
 (FUNC(OBJ, VAL))                 #Same improper use warnings as WeakRef
FINALIZATION_REGISTRY.register    #Calls FUNC(OBJ, VAL) when OBJ is GC'd
 (OBJ[, VAL][, VAL2])             #Keeps weak reference to OBJ|VAL2 (does not prevent it from being GC'd)
                                  #Keep strong reference to VAL (i.e. should not be OBJ)
                                  #VAL2 is the one to use with unregister() (can be same as OBJ)
FINALIZATION_REGISTRY.unregister
 (VAL2)->BOOL                     #BOOL is whether it was registered

new ShadowRealm()         18.13.0~#Global environment
--experimental
 -shadow-realm           <18.13.0~#
SVAL                      18.13.0~#Cannot be an OBJ, except for a FUNC providing it does not use OBJ as argument or return value
REALM.importValue
 ('MDL', 'VAR')->>SVAL    18.13.0~#Like (await import('MDL')).VAR but bound to a REALM
REALM.evaluate            18.13.0~#Like eval('CODE') but bound to a REALM
 ('CODE')->SVAL           18.13.0~#Each call has its own scope, but share the same global scope

                                  ┌──────────────────────┐
                                  │   BASIC STATEMENTS   │
                                  └──────────────────────┘

RESERVED WORDS ==>                #enum, await, implements, package, protected, public, private, interface,
                                  #static

STATEMENT;                        #; optional, but recommended in case could be interpreted as multiline

STATEMENT\                        #Only required for multiline statements:
                                  #  - within a STR
                                  #  - if first line could be interpreted as standalone statement.

// COMMENT
/* COMMENT */                     #
#!...                             #Ignored if first non-blank line

"use strict";                     #Start strict mode:
                                  #  - i.e. strict ES6|ES7 conformance
                                  #  - allows faster optimization by browsers
                                  #  - not compatible until IE10
                                  #Applies to current and child scopes:
                                  #  - child scopes: including nested functions, anonymous functions, eval(),
                                  #    new Function(), etc.
                                  #  - but not functions declared in different scopes and called in current|child scopes
                                  #  - warning: concatenating with other scripts might put them in same scope,
                                  #    making them strict too.
                                  #  - must be before any statement (otherwise noop)
                                  #Implicit in any ES6 module (i.e. useless), but not in Node.js modules or
                                  #global scripts
                                  #In the web console, can use an anonymous function in order to use strict mode.

QUAL VAR[ = VAL]                  #Declaration. Default value is undefined.
  [, VAR2[ = VAL2]]...            #VAR:
                                  #  - cannot be a reserved keyword
                                  #  - can contain:
                                  #     - $
                                  #     - any Unicode char with property "ID_Continue":
                                  #        - letters-like
                                  #        - numbers-like
                                  #        - diacretics
                                  #        - _
                                  #        - U+200C U+200D (zero-width space)
                                  #  - can be included as is, or using \u.... or \u{....}
                                  #  - first character must be Unicode char with property "ID_Start",
                                  #    (i.e. only letters-like) or $ or _
VAR = VAL;                        #Assignation.
                                  #Returns VAL, so chain possible: VAR = VAR2 = VAL, but means VAR2 is global

[QUAL] [
  VAR [= VAL],
  ...                             #[QUAL ]VAR = ITERABLE[NUM], ...
  [, ...ITERABLE2]                #VAL is default value
] = ITERABLE                      #ITERABLE2 is variadic assignment
[QUAL] { KEY: VAR[ = VAL] } = OBJ #[QUAL ]VAR = OBJ[KEY], ...
                                  #Without 'QUAL', must wrap with ({...} = OBJ)
                                  #VAL is default value
                                  #Can be { KEY: { KEY2: ... } }
                                  #KEY can appear several times with different VAR,
                                  #including { KEY: { KEY2 }, KEY: KEY }
[QUAL] { KEY[ = VAL] } = OBJ      #Same as QUAL { KEY: KEY[ = VAL] } = OBJ

QUAL                              #var|let|const|using
let VAR                           #Like var VAR, but {} block scoped.
const VAR                         #Like let VAR but read-only, i.e. throws error on assignments beyond
                                  #declaration
                                  #Is shallow: if OBJ, only OBJ is read-only, not OBJ.VAR
                                  #Is only for current block scope since:
                                  #  - function arguments imply new assignment
                                  #  - function return value must be assigned to be used as reference

delete OBJ.VAR                    #Like assigning undefined except:
                                  #  - remove key as well
                                  #  - cannot be performed if non-configurable
                                  #  - can be performed if non-writable
                                  #Note: for ARR[NUM], does not modify length (like assigning undefined)
                                  #Returns true if OBJ (not OBJ.VAR) exists.

void STATEMENT                    #Same as STATEMENT, but returns undefined
                                  #void 0 is sometimes used to return undefined without risk for shadowing
                                  #  - But not needed since shadowing can be caught by linting

eval("STATEMENT...")              #Fire STATEMENT... in current scope. Return last STATEMENT return value.
                                  #To avoid.
                                  #If argument non STR, renvoie VAL.
                                  #"VAR = VAL" does not declare anything.
                                  #Can throw SyntaxError or EvalError.

                                  ┌────────────────┐
                                  │   STRUCTURES   │
                                  └────────────────┘

SINGLE LINE ==>                   #Block braces can be skipped if only on single next line (to avoid)

VAL                               #Anything that returns a VAL
EXPR                              #Anything that could go on a single line of code ending with ;
...                               #Several EXPR


TEST ? VAL1 : VAL2                #Returns VAL1 or VAL2

VAL && VAL2                       #Same as VAL ? VAL : VAL2
VAL || VAL2                       #Same as VAL ? VAL2 : VAL
VAL ?? VAL2                       #Same as VAL == null ? VAL : VAL2

VAR &&= VAL2                      #Same as VAR = VAR && VAL2
VAR ||= VAL2                      #Same as VAR = VAR || VAL2
VAR ??= VAL2                      #Same as VAR = VAR ?? VAL2

VAL1, VAL2                        #Evaluates both, but returns VAL2.
                                  #Use case: in for or while loops.


{ ... }                           #Creates a scope

(VAL)                             #To increase precedence.

if (TEST) { ... }
[else if (TEST) { ... }]...
[else { ... }]                    #

switch (VAL) {
  case VAL2: ...  [break;] ...
  case VAL3:                      #Use VAL === VAL2
  case VAL4: ...  [break;] ...    #If no break, execute next case (including "default")
  [default: ...  [break;]]        #Case can be empty, meaning several "case" match when any matches.
}                                 #... can be wrapped in { ... }, which creates a scope

for ([EXPR1] ; [TEST] ; [EXPR2])
 { ... }                          #Same as: EXPR1; while ( TEST ) { ...; EXPR2; }

while (TEST) { ... }              #

do { ... } while (TEST)           #

for ([QUAL] VAR in OBJ) { ... }   #Iterate over keys that are enumerable, excluding SYMs
                                  #OBJ can be ITERATOR.

break [LABEL]                     #Stop current for|while|switch iteration or (only with LABEL)
                                  #if_else|anonymous block
                                  #Can target a specific for|while|switch iteration by specifying LABEL: before
                                  #it (to avoid), e.g. LABEL: for ... or LABEL: if ...
continue [LABEL]                  #Same but only current loop, and only for|while

                                  ┌───────────┐
                                  │   TYPES   │
                                  └───────────┘

TYPING SYSTEM ==>                 #  - weak: no type specified at Declaration
                                  #  - generic: native operators accepts any type, since each native type
                                  #    transtype to any (except OBJ->undefined|null)
                                  #  - dynamic: type is not checked at compile-time nor (since generic) run-time

AVAILABLE TYPES ==>               #  - simple: number|boolean|string|bigint|symbol|undefined|null
                                  #  - object (TYPE): Object and its children
                                  #    - native: Object|Array|Number|Boolean|String|Error|...
                                  #    - user-defined:
                                  #       - host objects: defined by browser (e.g. DOM elements)

typeof VAR                        #Returns "boolean|string|number|bigint|symbol|undefined|object|function"
                                  #"object": includes null, excludes FUNC
Object.prototype.toString.call    #Returns '[object NAME]' where NAME is (in priority order):
 (VAL)->STR                       #  - '[object OBJ[Symbol.toStringTag]]'
                                  #  - builtin:
                                  #     - 'Null|Undefined|Number|String|Boolean|BigInt|Symbol'
                                  #     - 'Object'
                                  #     - 'Array|[Shared]ArrayBuffer|DataView|[Big][U]Int|FloatNUMArray'
                                  #     - '[Async][Generator]Function'
                                  #     - 'Arguments'
                                  #     - 'RegExp|Date|Error|[Weak]Map|[Weak]Set|WeakRef|Realm'
                                  #     - 'Generator'
                                  #     - 'Promise'
                                  #     - 'Module'
                                  #     - 'Intl.*'
                                  #     - 'Math|JSON|Intl|Atomics|Reflect': the namespace itself
                                  #     - 'global'
                                  #     - not: Proxy
                                  #  - 'Object'
                                  #  (DOM only)
                                  #  - 'DOMError' (deprecated), 'DOMException'

                                  ┌──────────────┐
                                  │   EQUALITY   │
                                  └──────────────┘

VAL == VAL2
VAL != VAL2                       #Implicit transtype
VAL === VAL2
VAL !== VAL2                      #No implicit transtype

OBJ == OBJ2
OBJ != OBJ2
OBJ === OBJ2
OBJ !== OBJ2                      #Same reference

Object.is(VAL, VAL2)              #Same as ===, except !Object.is(+0,-0) and Object.is(NaN, NaN)

                                  ┌─────────────────┐
                                  │   TRANSTYPING   │
                                  └─────────────────┘

IMPLICIT TRANSTYPING ==>          #Uses String|Boolean|Number|BigInt|Object(VAL)
EXPLICIT TRANSTYPING ==>          #Prefer using String|Boolean|Number|BigInt|Object(VAL).
                                  #Sometimes used (avoid):
                                  # - BOOL: !!VAL
                                  # - NUM: +VAL, VAL*1, VAL/1, ~~VAL, VAL|0, VAL-0
                                  # - STR: VAL + ''

OBJ[Symbol.toPrimitive]('default')#Called when implicit type ambiguous, e.g. VAL + STR or VAL == VAL2

                                  ┌───────────────┐
                                  │   UNDEFINED   │
                                  └───────────────┘

undefined                         #Value of:
                                  #  - non-declared VAR: throw ReferenceError when used, except with typeof
                                  #  - declared but non-assigned VAR (including arguments and return value)
                                  #Global variable, not keyword
                                  #  - non-configurable|writable
                                  #  - but can be shadowed by local VAR named "undefined"

typeof VAR === 'undefined'        #Like VAR === undefined, except no ReferenceError if VAR undeclared
                                  #Should never be necessary:
                                  #  - useless in local scopes
                                  #  - in global scope, use globalThis.VAR === undefined

                                  ┌──────────┐
                                  │   NULL   │
                                  └──────────┘

null                              #Special keyword indicating emptiness

VAL == null                       #Implicitly transtype to null|undefined, i.e. returns true for both
VAL === null|undefined            #No implicit transtype

                                  ┌─────────────┐
                                  │   BOOLEAN   │
                                  └─────────────┘

true|false                        #BOOL

!BOOL
BOOL && BOOL2
BOOL || BOOL2

Boolean(VAL)->NUM                 #Used for explicit|implicit transtyping.
                                  #  - STR: '' false, '...' true
                                  #  - NUM|BIGINT: 1 true, 0 false
                                  #  - undefined|null: false
                                  #  - OBJ|SYM: true

                                  ┌────────────┐
                                  │   NUMBER   │
                                  └────────────┘

NUM                               #Always double-precision float (binary64)
                                  #Can use TYPED_ARR for single-precision floats or 8|16|32-bits [u]ints
0xNUM
0XNUM                             #16 radix
0oNUM
0ONUM                             #8 radix
0bNUM
0BNUM                             #2 radix
NUM_...                           #Underscores can be added:
                                  #  - they are ignored and meant as separators
                                  #  - works with any radix except octals

NUM + - * / % NUM2                #
-NUM                              #
NUM++ ++NUM NUM-- --NUM           #
NUM ** NUM2                       #
NUM ~ & ^ | >> << >>> NUM2        #
NUM OP= NUM2                      #E.g. NUM += NUM2
NUM < <= > >= NUM2                #

Number(VAL)->NUM                  #Used for explicit|implicit transtyping:
                                  #  - STR:
                                  #     - '': 0
                                  #     - 'NUM': NUM
                                  #        - trims whitespaces
                                  #     - others: NaN
                                  #  - BOOL: true 1, false 0
                                  #  - BIGINT: TypeError
                                  #     - can be explicitely converted though
                                  #     - in which case, transtyped to [-]Infinity if out-of-bound
                                  #  - undefined: NaN
                                  #  - null: 0
                                  #  - SYM: TypeError
                                  #  - OBJ (in priority):
                                  #     - OBJ[Symbol.toPrimitive]('number')
                                  #     - OBJ.valueOf()
                                  #     - NaN
[Number.]parseFloat(VAL)->NUM     #Like Number(VAL) but:
                                  #  - returns NaN for non-NUM|STR and ''
                                  #  - removes trailing non-numerical chars in STR
                                  #  - only understands decimal form
[Number.]parseInt(VAL[, NUM])->NUM#Same as [Number.]parseFloat() but:
                                  #  - removes decimals
                                  #  - understands decimal or hexadecimal form by default.
                                  #     - if NUM, forces radix

NUM.toFixed([NUM])->STR           #Number of decimal digits.
                                  #Might have exponential notation or not.
                                  #Def|min NUM: 0. Max NUM: 100.
NUM.toExponential([NUM])->STR     #Number of decimal digits.
                                  #Always use exponential notation.
                                  #Def|min NUM: 0. Max NUM: 100.
NUM.toPrecision([NUM])->STR       #Number of integer+decimal digits, excluding leading decimals zeros if integer is 0
                                  #Might have exponential notation or not.
                                  #Min NUM: 1. Max NUM: 100.
                                  #If no NUM, behaves like NUM.toString()
NUM.toString(RADIX)->STR          #

Number.isInteger(NUM)             #Does not coerce to NUM

[Number.]NaN                      #Returned e.g. by √-1, 0/0 or wrong NUM conversion
                                  #Test:
                                  #  - NaN !== NaN but Object.is(NaN, NaN)
                                  #  - Number.isNaN(VAL): same as Object.is(VAL, NaN)
                                  #  - isNaN(VAL): same as Number.isNaN(Number(VAL))
[-]Infinity                       #Returned e.g. by overflow like 1e400, or 1/0
Number.POSITIVE_INFINITY          #Test:
Number.NEGATIVE_INFINITY          #  - [-]Infinity === [-]Infinity
                                  #  - Number.isFinite(VAL): typeof VAL === 'number' && VAL !== [-]Infinity && !Number.isNaN(VAL)
                                  #  - isFinite(VAL): same as Number.isFinite(Number(VAL))

Number.MIN_VALUE                  #Closest to 0 (underflow) (about 5e-324)
Number.MAX_VALUE                  #After it is Infinity (overflow) (about 2e+308)
Number.MIN|MAX_SAFE_INTEGER       #Smallest|highest integer that can be represented as a float precisely
                                  #(about +|-1e16)
Number.isSafeInteger(NUM)->BOOL   #Number.isInteger(NUM) && NUM >= Number.MIN_SAFE_INTEGER && NUM <= Number.MAX_SAFE_INTEGER
                                  #Does not coerce to NUM
Number.EPSILON                    #NUM +|- NUM2 can create small discrepancies, e.g. 0.3 - 0.1 within a
                                  #EPSILON range:
                                  #  - When comparing non-integer NUMs, should check NUM-NUM2 < +|-EPSILON
                                  #  - about 2e-16

                                  ┌────────────┐
                                  │   BIGINT   │
                                  └────────────┘

NUMn                              #BIGINT. Infinite precision integer
                                  #Behaves like NUM:
                                  #  - including octal, hex, binary notations
                                  #  - including toString(RADIX)
                                  #Exceptions:
                                  #  - integer not double:
                                  #     - / % round towards 0
                                  #  - cannot use >>> nor +NUMn
                                  #  - throw on JSON.stringify()
                                  #  - has its own typeof, constructor
                                  #  - no BIGINT.toFixed|toPrecision|toExponential() (since it is integer)

BigInt(VAL)->NUM                  #Used for explicit|implicit transtyping.
                                  #  - STR|BOOL|OBJ|undefined: like NUM except SyntaxError instead of NaN
                                  #  - null|SYM: SyntaxError
                                  #  - NUM:
                                  #     - implicit: TypeError
                                  #        - exception: == === != !== < <= > >=
                                  #     - explicit: possible
                                  #        - transtyped to [-]Infinity if out-of-bound

BigInt.asUintN|asIntN             #Enforce max size NUM bits on NUM2n
 (NUM, NUM2n)->NUM2n              #On overall, rotate to min|max value (according to NUM)

                                  ┌────────────┐
                                  │   STRING   │
                                  └────────────┘

"..."                             #Escapes everything but " newline and \ (including trailing)
'...'                             #Escapes everything but ' newline and \ (including trailing)
`...${EXPR}...`                   #"..." + EXPR + "..."
                                  #Escapes everything (including " ' or newline) but ` ${ or \
\CHAR                             #Any backslash escape can be used except \a, \c et \e
NEWLINE ==>                       #OS-independent: '\n' is LF, '\r' is CR
                                  #OS-dependent (CR+LF on Windows, LF others): terminal|file I/O
MAX LENGTH ==>                    #Standard: at most 2**53 - 1, i.e. ~9e15
                                  #Engine-dependent:
                                  #  - v8: 2**29 - 24, i.e. ~5e8
                                  #  - SpiderMonkey: 2**30 - 2, i.e. ~1e9
                                  #  - SquirrelFish: 2**31 - 1, i.e. ~2e9

STR + STR2                        #
STR += STR2                       #
STR.concat(STR2...)               #

STR < <= > >=                     #Char by char, code unit-wise

String(VAL)->STR                  #Used for explicit|implicit transtyping:
                                  #  - BOOL|NUM|undefined|null: 'BOOL|...'
                                  #  - BIGINT: 'NUM' (not 'NUMn')
                                  #  - SYM: 'Symbol(VAR)'
                                  #     - only with explicit String(SYM) or SYM.toString()
                                  #  - OBJ (in priority order):
                                  #     - OBJ[Symbol.toPrimitive]('string')
                                  #     - OBJ.toString()
                                  #        - FUNC|ARR|REGEXP|DATE|ERROR: see own doc
                                  #     - OBJ.valueOf()
                                  #     - Object.prototype.toString.call(VAL) (see its doc)

FUNC`...`                         #FUNC(STR_ARR, VAL...)->VAL:
FUNC `...`                        #  - VAL... are each ${EXPR}
                                  #  - STR_ARR[.raw][NUM]:
                                  #     - each `...` in-between
                                  #        - including empty "" at beginning|end if starts|ends with ${EXPR}
                                  #     - if "raw", escape backslashes
                                  #     - STR_ARR.length === VAL.length + 1
                                  #  - special case for invalid backslash sequences (only if FUNC specified):
                                  #     - STR is undefined
                                  #     - escaped in STR_ARR.raw, e.g. '\\n'
                                  #FUNC can be String.raw(), which concatenates all like normal template,
                                  #except it escape backslashes


STR[NUM]                          #Read-only. undefined if out of range.
STR.charAt(NUM)                   #Same except "" if out of range
STR.at(NUM)->'CHAR'               #Like STR[NUM] except -NUM is from end, and is not writable

STR.length                        #Number of characters

STR.match(REGEXP)                 #Like REGEXP.exec(STR), except that if g flag, returns all matches as ARR
                                  #(or null)
STR.matchAll(REGEXP)              #Returns ITERABLETOR that returns successive REGEXP.exec(STR)
                                  #I.e. as opposed to STR.match(), when using a g flag, parenthesis groups and
                                  #indices will be returned too
STR.search(REGEXP)                #Like STR.indexOf() but with a REGEXP
STR.starts|endsWith|includes
 (STR2[, NUM])                    #

STR.replace(REGEXP|STR2, STR3)    #Returns STR, replacing REGEXP with STR3, which can contain:
                                  #  - $1, etc.: parenthesis group matches
                                  #  - $&: full match
                                  #  - $`: what's before full match
                                  #  - $': what's after full match
                                  #  - $$: $ literal
STR.replace(REGEXP|STR2,
 FUNC($&, $1..., INDEX, STR))     #Returns STR, replacing REGEXP with FUNC(...)
STR.replaceAll(REGEXP|STR2, STR3)
STR.replaceAll(REGEXP|STR2,       #Same as STR.replace(...) but STR2 implies a 'g' flag.
 FUNC($&, $1..., INDEX, STR))     #If REGEXP, must have a 'g' flag.
STR.split(REGEXP|STR2[, UINT])    #Returns an ARR, with REGEXP|STR2 being split delimiter.
                                  #If STR2 is '', means between each characters.
                                  #If REGEXP contains parenthesis groups, each is included in ARR between each element.
                                  #If UINT, does ARR.slice(0, UINT)
STR.repeat(NUM)                   #

OBJ[Symbol.match](...)            #Methods to implement to be able to use STR.match(OBJ)
                                  #or STR.startsWith|endsWith|includes(OBJ)
                                  #Implemented by REGEXP
OBJ[Symbol.replace|split](...)    #Methods to implement to be able to use STR.replace|split(OBJ).
                                  #Implemented by REGEXP
OBJ[Symbol.search](...)           #Methods to implement to be able to use STR.search(OBJ).
                                  #Implemented by REGEXP

STR.toUpper|LowerCase()           #
STR.trim()                        #
STR.trimLeft|Right()              #Remove whitespaces (same as /\s/) on left and|or right.
STR.trimStart|End()               #Aliases for trimLeft|Right()
STR.padStart|End(NUM[, STR2])     #If STR.length < NUM, prepends|appends STR2 (def: ' ') until STR.length === NUM

STR.[last]indexOf(STR[, NUM])
STR.slice([NUM[, NUM2]])          #Like ARR
STR.substring(NUM[, NUM2])        #Like .slice() except:
                                  #  - negative NUM2 -> 0
                                  #  - If NUM2 < NUM, swap
STR.substr(NUM[, NUM2])           #Like .slice() except:
                                  #  - NUM can be negative (index from end)
                                  #  - NUM2 is length, not index

en|decodeURI(STR)                 #Percent-encode any character not permitted in URIs, i.e. anything but:
                                  #  [:alnum:] - . _ ~ ! ' ( ) * # : ? & = + $ ; , / @
                                  #Should be used for full URIs
                                  #Uses UTF-8
                                  #decodeURI() can throw URIError
en|decodeURIComponent(STR)        #Same but also percent-encode characters that might have semantics in
                                  #URIs parts:
                                  #                              # : ? & = + $ ; , / @
                                  #I.e. does not percent-encode the following (should escape if it has semantics
                                  #for specific case):
                                  #  [:alnum:] - . _ ~ ! ' ( ) *
                                  #Should be used for URI parts
[un]escape(STR)                   #Like en|decodeURIComponent() but using a different set of what's considered URI part:
                                  #                  ~ ! ' ( )   # : ? & =   $ ; ,
                                  #I.e. does not percent-encode the following:
                                  #  [:alnum:] - . _           *           +       / @
                                  #Also, uses UTF-16, with Unicode chars percent encoded as %uUUUU, not a series of %XX
                                  #Deprecated

                                  ┌─────────────┐
                                  │   UNICODE   │
                                  └─────────────┘

ENCODING ==>                      #UTF-16:
                                  #  - S_CODEPOINT: 1 character === 1 codepoint
                                  #  - CODEPOINT:   1 character === 1 codepoint (<U+10000) or 2 surrogate codepoints (>=U+10000)
                                  #  - isolated|inverted surrogate pairs are not invalid: they are considered their own character|codepoint instead
                                  #Exceptions:
                                  #  - encode|decodeURI[Component]() uses UTF-8
                                  #  - the platform (Node.js, Web APIs) provides with encoding-specific operations. often with UTF-8

S_CODEPOINT                       #Single Unicode character STR. Any, even U+10FFFF
CODEPOINT                         #Like S_CODEPOINT except > U+FFFF treats each surrogate as own character.
                                  #All STR operations use CODEPOINTs:
                                  #  - including STR.length, STR[NUM], STR.*(), comparison, max length
                                  #  - except:
                                  #     - STR iteration
                                  #     - STR.to[Locale]Lower|UpperCase(), STR.trim*()
                                  #     - \u{}, String.fromCodePoint(), STR.codePointAt(), /REGEXP/u
[S_]CODEPOINT[_NUM]               #Same as NUM

\uCODEPOINT_HEXA                  #CODEPOINT in a STR
\u{S_CODEPOINT_HEXA}              #S_CODEPOINT in a STR

String.fromCharCode
 (CODEPOINT_NUM...)->STR          #
String.fromCodePoint
 (S_CODEPOINT_NUM...)->STR        #Returns STR

STR.charCodeAt(NUM)->CODEPOINT    #NUM is CODEPOINT-wise
                                  #For > U+FFFF, if NUM is on:
                                  #  - the first|second surrogate pair: CODEPOINT is returned
                                  #If NUM out-of-range, returns NaN.
STR.codePointAt(NUM)->S_CODEPOINT #NUM is CODEPOINT-wise
                                  #For > U+FFFF, if NUM is on:
                                  #  - the first surrogate pair: S_CODEPOINT is returned
                                  #  - the second surrogate pair: CODEPOINT is returned
                                  #If NUM out-of-range, returns undefined.

/REGEXP/u                         #  - operate with S_CODEPOINT instead of CODEPOINT
                                  #     - for example for . [] {NUM,NUM2} etc.
                                  #  - stricter REGEXP syntax enforcement, e.g. /{/ throws
                                  #  - allow using \p or \P

STR.normalize([STR2])             #Some codepoint sequences are equivalent, e.g. with diacretics
                                  #Equivalence types:
                                  #  - canonical: same abstract character, including visual appearance and behavior
                                  #     - example: '\u00e9' (é) (composed) and '\u0065\u0301' (e  ́) (decomposed)
                                  #  - compatibility: looser superset, i.e. enough if can be treated alike
                                  #     - examples:
                                  #        - '\ufb00' (ﬀ ) (composed) and '\u0066' (ff) (decomposed)
                                  #        - '\u24b9' (Ⓓ ) (composed) and '\u0044' (D) (decomposed)
                                  #Can be:
                                  #  - "NFC" (def): decomposes then compose (canonical)
                                  #  - "NFD": decompose (canonical)
                                  #  - "NFKC": decompose then compose (compatibility)
                                  #  - "NFKD": decompose (compatibility)

STR.isWellFormed()->BOOL    20.0.0#False if contains isolated|inverted surrogate pairs
STR.toWellFormed()->STR     20.0.0#Replaces isolated|inverted surrogate pairs by U+FFFD

                                  ┌─────────────┐
                                  │   SYMBOLS   │
                                  └─────────────┘

Symbol([STR])                     #SYM
SYM.description                   #STR

SYM == != === !== SYM             #Symbols are compared by identify, regardless of SYM.description

SYM.toString()->'Symbol(STR)'     #STR is SYM.description

OBJ[SYM]                          #Same as OBJ["RANDOM"], semantically for private members.
                                  #Different methods to enumerate (see above)
                                  #SYM properties ignored by JSON.stringify()

Symbol.for(STR)                   #Like Symbol(STR), except "register" it to a global store using STR as a key,
                                  #so that Symbol.for(STR) === Symbol.for(STR)
Symbol.keyFor(SYM)                #Returns STR if SYM was created as Symbol.for(STR), undefined otherwise.

WELL-KNOWN SYMBOLS ==>            #SYM that can be used to override native behavior.
                                  #E.g. Symbol.iterator
                                  #When printed, sometimes abbreviated to @@VAR

                                  ┌─────────────┐
                                  │   OBJECTS   │
                                  └─────────────┘

[new] Object(VAL)                 #Used for implicit|explicit conversion.
                                  #For any type:
                                  #  - new type is OBJ, i.e. different type
                                  #  - but behavior is same thanks to implicit transtyping
                                  #For Number|BigInt|String|Boolean:
                                  #  - can also use new TYPE(VAL)
                                  #For undefined|null:
                                  #  - prototype is null
                                  #  - no implicit transtyping
                                  #All OBJs inherit from Object except Object.create(null)

OBJ.VAR                           #Access property (can be any type)
OBJ['VAR']                        #OBJ.VAR has same naming restrictions as QUAL VAR, except can be a reserved word
                                  #OBJ['VAR'] can use any valid STR
                                  #Throws with undefined|null

OBJ?.VAR                          #Like OBJ == null ? undefined : OBJ.VAR
OBJ?.['VAR']                      #Like OBJ == null ? undefined : OBJ['VAR']

{ VAR[: VAL] ... }                #Literal OBJ.
                                  #If could be interpreted as a { ... } structure (e.g. beginning of line),
                                  #wrap with ()
                                  #VAR can either:
                                  #  - be "VAR" or 'VAR': any valid STR
                                  #  - be unquoted, with same naming restrictions as QUAL VAR except:
                                  #     - can be reserved keywords
                                  #     - can be any NUM, which will be converted to STR
                                  #Def VAL is VAR
                                  #VAR can be [STR], for dynamic property name
                                  #If duplicate key, the last one will overwrite the ones before.
{ FUNC() {...} ... }              #Same as { FUNC: function FUNC() {...} ... }

PROPERTIES ORDER ==>              #Guaranteed to be in that order:
                                  #  - 'NUM', sorted numerically
                                  #  - STR, sorted by creation time
                                  #  - SYM, sorted by creation time

OWN / ENUMERABLE ==>              #              +-------------------------------------------------------+-------------------------------+
                                  #              | Own                                                   | Own+inherited                 |
                                  # +------------+-------------------------------------------------------+-------------------------------+
                                  # | enum       | OBJ.propertyIsEnumerable('VAR'|SYM)->BOOL             | for (QUAL NOT_SYM_VAR in OBJ) |
                                  # |            | Object.keys(OBJ)->'VAR'_ARR                           |                               |
                                  # |            | Object.values|entries|fromEntries(...)                |                               |
                                  # |            | Object.assign(...), { ...OBJ }                        |                               |
                                  # +------------+-------------------------------------------------------+-------------------------------+
                                  # | [non-]enum | OBJ.hasOwnProperty('VAR'|SYM)->BOOL                   | 'VAR'|SYM|#PROP in OBJ        |
                                  # |            | Object.hasOwn(OBJ, 'VAR'|SYM)->BOOL                   |                               |
                                  # |            | Reflect.ownKeys(OBJ)=>'VAR'|SYM_ARR                   |                               |
                                  # |            | Object.getOwnPropertyNames(OBJ)->'VAR'_ARR            |                               |
                                  # |            | Object.getOwnPropertySymbols(OBJ)->SYM_ARR            |                               |
                                  # |            | Object.getOwnPropertyDescriptor(OBJ, 'VAR'|SYM)->OBJ2 |                               |
                                  # |            | Object.getOwnPropertyDescriptors(OBJ)->OBJ3           |                               |
                                  # +------------+-------------------------------------------------------+-------------------------------+

'VAR'|SYM in OBJ                  #Returns true if OBJ['VAR'|SYM] is member
                                  #Negation: !('VAR' in OBJ)
#PROP in OBJ                      #Same for private #PROP
OBJ.hasOwnProperty('VAR'|SYM)
 ->BOOL                           #Returns true if OBJ['VAR'|SYM] is own
Object.hasOwn(OBJ, 'VAR'|SYM)
 ->BOOL                           #Same
OBJ.propertyIsEnumerable
 ('VAR'|SYM)->BOOL                #Returns true if OBJ['VAR'|SYM] is own + enumerable

Object.keys(OBJ)->'VAR'_ARR       #Returns keys that are own + enumerable + not SYMs
Reflect.ownKeys(OBJ)
 ->'VAR'|SYM_ARR                  #Returns keys that are own
Object.getOwnPropertyNames(OBJ)
 ->'VAR'_ARR                      #Returns keys that are own + not SYMs
Object.getOwnPropertySymbols(OBJ)
 ->SYM_ARR                        #Returns keys that are own + SYMs

Object.values(OBJ)                #Same as Object.keys() but for values
Object.entries(OBJ)               #Same as Object.keys() but for [KEY, VALUE]
Object.fromEntries(ITERABLE)      #Inverse Object.entries(), i.e. from ITERABLE of [KEY, VALUE] to OBJ
                                  #As opposed to Object.entries(), KEY that SYM are not skipped

Object.assign(OBJ[, OBJ2...])     #Shallow copy of own enumerable OBJ2 members (including SYMs) to OBJ, which is returned.
                                  #Properties copied in OBJ are:
                                  #  - always configurable|writable, even if OBJ2 members were not
                                  #  - resolved, if OBJ2 members were getters
{ [...] ...OBJ2 [...] }           #Same as Object.assign({}, OBJ2, ...)

[QUAL] { [...] ...OBJ } = OBJ2    #Does Object.assign(OBJ, OBJ2), except the parts mentioned in ...

                                  ┌────────────────────────┐
                                  │   OBJECT DESCRIPTORS   │
                                  └────────────────────────┘

{ get|set VAR(...) {...} }        #Like { VAR(...) {...} } followed by Object.defineProperty() with configurable|enumerable true

Object.defineProperty             #Assign OBJ['VAR'|SYM] = VAL, where VAL depends on OBJ2 ('descriptors'):
 (OBJ, 'VAR'|SYM, OBJ2)           #  - either (def: value undefined):
                                  #     - value VAL
                                  #     - get and|or set:
                                  #        - get()->VAL
                                  #           - called at OBJ.VAR
                                  #           - def: returns undefined
                                  #        - set(VAL)
                                  #           - called at OBJ.VAR = VAL
                                  #           - `this` is OBJ
                                  #              - no return value, i.e. must be modified
                                  #           - must not set this.VAR to avoid infinite recursion
                                  #           - def: TypeError on set
                                  #        - `delete` removes get|set
                                  #           - i.e. value is not defined, and no more get|set
                                  #  - enumerable BOOL (def: false):
                                  #     - if false, not listed by Object.keys|...(), OBJ.propertyIsEnumerable() and for (QUAL STR in OBJ)
                                  #  - writable BOOL (def: false):
                                  #     - if false, throws TypeError if OBJ.VAR = VAL
                                  #        - even if VAL did not change
                                  #        - even if VAR is inherited through the __proto__ chain
                                  #        - but can still Object.defineProperty() if configurable
                                  #     - not possible with get|set():
                                  #        - always undefined
                                  #        - setting it throws
                                  #  - configurable BOOL (def: false):
                                  #     - if false, throws TypeError:
                                  #        - if:
                                  #           - delete OBJ.VAR
                                  #           - set configurable|writable false -> true
                                  #           - set enumerable|get|set -> !== value
                                  #           - go from get|set <-> value
                                  #        - not if:
                                  #           - set value, or OBJ.VAR = VAL
                                  #              - except if current writable false
                                  #           - set writable true -> false
                                  #           - VAR is inherited through the __proto__ chain
                                  #If own property already exists, default values are current descriptors instead.
Object.getOwnPropertyDescriptor   #Returns OBJ.VAR descriptor OBJ2
 (OBJ, 'VAR'|SYM)->OBJ2           #Even if not declared through Object.defineProperty()
                                  #Returns undefined if does not exists or is not own.
                                  #Including SYMs
Object.defineProperties(OBJ, OBJ3)
Object.getOwnPropertyDescriptors
 (OBJ)->OBJ3                      #Same but using OBJ3 { 'VAR': OBJ2 ... } instead.

Object.preventExtensions(OBJ)     #Make OBJ non-extensible, i.e. TypeError if:
                                  #  - adding new property
                                  #  - setting __proto__
                                  #Not recursive.
Object.isExtensible(OBJ)          #

Object.seal(OBJ)                  #Make OBJ non-extensible, non-configurable
                                  #Not recursive.
Object.isSealed(OBJ)              #

Object.freeze(OBJ)                #Make OBJ non-extensible, non-configurable, non-writable (except get|set())
                                  #Not recursive.
Object.isFrozen(OBJ)              #

                                  ┌────────────────┐
                                  │   PROTOTYPES   │
                                  └────────────────┘

OBJ.__proto__                     #When OBJ.VAR is not defined, OBJ.__proto__.VAR is tried
                                  #  - recursively (prototype chain)
                                  #  - the last __proto__ is null
                                  #Setting OBJ.__proto__[...].VAR creates OBJ.VAR instead
                                  #  - including with Object.defineProperty() and delete
                                  #  - even if value did not change
                                  #I.e. inheritance is prototype-based.
                                  #__proto__ itself is considered an inherited, non-enumerable, writable, configurable property
Object.getPrototypeOf(OBJ)->VAL   #Same but less standard and:
                                  #  - returns `null` instead of `undefined` for null prototype
                                  #  - does not return `undefined` if no prototype in the chain is Object.prototype
                                  #Like OBJ.__proto__, throws if OBJ is undefined|null
Object.setPrototypeOf
 (OBJ, VAL)->OBJ                  #Same as OBJ.__proto__ = VAL (to avoid because performance issues)
OBJ.isPrototypeOf(OBJ2)           #Returns true if OBJ2.__proto__[...] === OBJ
                                  #I.e. if isPrototypeOf TYPE, also true for TYPE_PARENT
                                  #Always false for non-OBJs, but does not throw.

super.*                           #Same as this.__proto__.*
super[EXPR]                       #Can be used in any OBJ method using shortcut notation

MULTIPLE INHERITANCE ==>          #Not supported, but be approximated using composition|mixins, including:
                                  #  - own members: call several TYPE_PARENT(...) in constructor
                                  #  - inherited members: merge TYPE_PARENT.prototype to TYPE.prototype
                                  #     - con: copied, not referenced (except deep properties)

                                  ┌──────────────────┐
                                  │   CONSTRUCTORS   │
                                  └──────────────────┘

TYPE                              #Constructor FUNC
                                  #Cannot be an arrow FUNC
                                  #By convention TYPE starts with uppercase

TYPE.prototype                    #Properties that all TYPE instances should inherit
                                  #Set to empty OBJ when any FUNC is instantiated
                                  #  - not set for arrow nor bound FUNCs
Object.create                     #Returns { __proto__: TYPE.prototype }
 (TYPE.prototype[, OBJ])->OBJ2    #Then calls Object.defineProperties(OBJ2, OBJ)
Object.create(null)               #OBJ where __proto__ is null instead of Object.prototype
PROTOTYPE POLLUTION ==>           #Setting core OBJ.* property to override core behavior.
                                  #For: OBJ.hasOwnProperty|propertyIsEnumerable|isPrototypeOf|to[Locale]String|valueOf()
                                  #Can be prevented with:
                                  #  - call-time: Object.prototype.FUNC.call(OBJ, ...) instead of OBJ.FUNC(...)
                                  #  - declaration-time: Object.create(null)

OBJ instanceof TYPE               #Returns true if OBJ.__proto__[...] === TYPE.prototype
                                  #If TYPE is bound, unbound it first.
OBJ[Symbol.hasInstance](VAR)
 ->BOOL                           #Define to override VAR instanceof OBJ
REALMS ==>                        #TYPEs might be coming from another environment with a different global scope
                                  #  - e.g. when using Node.js 'vm', or iframes in browser
                                  #This makes TYPE check fail (including instanceof)
                                  #  - except for native types, including undefined|null and Symbol.for()
                                  #But typeof and Object.prototype.toString.call() work

TYPE.prototype.constructor        #TYPE itself.
                                  #Set when any non-arrow|bound FUNC is instantiated
                                  #Meant for type checking on instances.
                                  #Not used by new TYPE

TYPE.*                            #Static members, i.e. properties of TYPE, not instances
                                  #Can be inherited by using TYPE.__proto__ = TYPE_PARENT

EXAMPLE ==>                       #  function TYPE(...) {
                                  #    TYPE_PARENT.apply(this[, ...])
                                  #    this.VAR = ...; ...
                                  #  }
                                  #  TYPE.prototype = Object.create(TYPE_PARENT.prototype)
                                  #  TYPE.prototype.constructor = TYPE
                                  #  TYPE.__proto__ = TYPE_PARENT

new TYPE[(...)]                   #Create OBJ with Object.create(TYPE.prototype)
                                  #  - if TYPE is bound, unbound it first.
                                  #Then call TYPE.call(OBJ, ...)
                                  #Returns:
                                  #  - TYPE.call(...) return value if object
                                  #     - Should avoid because return value's __proto__ might not be TYPE.prototype
                                  #        - This is unexpected by most users
                                  #        - This prevents inheritance and type checking
                                  #  - Otherwise: OBJ
super(...)                        #Inside class constructor, same as TYPE_PARENT.call(this, ...)
                                  #  - including return value
                                  #If class has TYPE_PARENT, in constructor (if any):
                                  #  - must be called
                                  #     - and before accessing `this`
                                  #  - if TYPE_PARENT() returns an object, it becomes `this`
                                  #     - including for grandchildren types
new.target                        #When called with new FUNC(): FUNC itself
                                  #When called without "new": undefined
                                  #If FUNC is bound: unbound it first
                                  #SyntaxError if arrow FUNC.
                                  #new.target is inherited like `this`:
                                  #  - not inherited in:
                                  #     - non-arrow FUNC declaration
                                  #     - FUNC calls
                                  #  - but inherited in:
                                  #     - arrow FUNC declarations
                                  #     - super(), even if returns a value
                                  #Must be inside TYPE function itself, not through FUNC calls

                                  ┌──────────────────────────────┐
                                  │   NATIVE TYPES INHERITANCE   │
                                  └──────────────────────────────┘

NATIVE TYPE CONSTRUCTORS ==>      #Some native type constructors can be called without "new":
                                  #  - String|Boolean|Number|BigInt|Symbol: transtype
                                  #  - Object|Array|Function|RegExp|Error: same as with "new" (but should avoid)
                                  #  - Date: same as new Date().toString()
                                  #  - all others: forbidden
NATIVE TYPES INHERITANCE ==>      #Native types constructors return a value instead of assigning to this.
                                  #When:
                                  #  - Inheriting manually with TYPE.__proto__|prototype|constructor:
                                  #    This creates the issues mentioned above, i.e. does not work
                                  #  - Uses class ... extends: this works
TYPE[Symbol.species]              #TYPE2 to override TYPE constructor used to create empty new objects.
                                  #E.g. used by:
                                  #  - ARR.concat|filter|map|slice|splice()
                                  #  - STR.split(REGEXP)
                                  #  - PROMISE.then()
                                  #Not by others, including SET.union|intersection|...()
                                  #Should be set to TYPE_PARENT when extending native types
                                  #  - unless want to keep child type, e.g. with Error
                                  #E.g. if TYPE deriving from Array, TYPE.map() will return TYPE not ARR, unless this is used

                                  ┌───────────┐
                                  │   CLASS   │
                                  └───────────┘

class [TYPE] [extends TYPE_PARENT]#Similar to:
{                                 #  TYPE.prototype = Object.create(TYPE_PARENT.prototype) (non-writable|enumerable|configurable)
                                  #    - if no TYPE_PARENT: Object.create(Object.create(null))
                                  #  TYPE.prototype.constructor = TYPE (non-enumerable)
                                  #  TYPE.__proto__ = TYPE_PARENT
                                  #    - if no TYPE_PARENT: Function.prototype
                                  #TYPE_PARENT can be a VAL, not only a VAR
                                  #Throw error if not called with new.
                                  #No comma between definition members.
                                  #Returns TYPE
  constructor(...) { ... }        #Constructor TYPE(...)
                                  #Def: calls super(...)
  FUNC(...) { ... }               #TYPE.prototype.FUNC = FUNC (non-enumerable)
  static FUNC(...) { ... }        #TYPE.FUNC = FUNC (non-enumerable)
  VAR|[STR] [= EXPR][, ...];      #Calls this.VAR = EXPR in constructor. (enumerable)
                                  #Called after super()
                                  #  - If no super(), in beginning instead
  static VAR|[STR] [= EXPR][,...];#Calls TYPE.VAR = EXPR right-away (enumerable)
                                  #In EXPR, `this` is TYPE
  [static] #VAR [= EXPR][, ...];  #Like VAR = EXPR and FUNC(...), except can only be refered to inside class,
  #FUNC(...) { ... }              #i.e. using this.#VAR and this.#FUNC(...). Not inherited.
  static { ... }                  #Calls ... right away (`this` is TYPE)
  [static] accessor VAR         *~#Like #VAR with an automatic getter|setter
   [= EXPR][, ...];               #Can only be declared during class declaration.
}                                 #

                                  ┌───────────────┐
                                  │   FUNCTIONS   │
                                  └───────────────┘

FUNC                              #Is OBJ, so can be assigned.
Function                          #FUNC TYPE
function [FUNC]([...]) {
  ...
  [return VAL;]
  ...                             #Declare and returns FUNC.
}                                 #See "Scope" above.
[new ]Function(['...',]'...')     #Same as function(...) { ... } but:
                                  #  - scope will be child of global scope.
                                  #  - body is STR can be dynamically created. Can create injection risk.
                                  #Use only if really necessary.

(...) => {...}                    #Same as (function(...) {...}).bind(this), except:
                                  #  - arguments|super|new.target refer to current function's
                                  #  - no FUNC.prototype, i.e. cannot be inherited or used as constructor
(...) => VAL                      #Same as (...) => { return VAL; }
                                  #To return an OBJ, wrap in ({...})
ARG => {...}                      #Same as (ARG) => {...}

PARAMETERS ==>                    #  - positional
                                  #  - extra parameters do not fire exceptions
                                  #  - non-OBJ are passed by value, but OBJ always by reference:
                                  #     - including in assignment
                                  #     - left-hand value keeps reference to right-hand value, but not inverse
                                  #        - i.e. assigning to an OBJ argument removes precedent reference:
                                  #            function(OBJ){ OBJ = OBJ2 }     // Removes OBJ reference
                                  #            function(OBJ){ OBJ.VAR = VAL }  // Keep OBJ reference
                                  #  - maximum length is implementation-specific
                                  #     - ~1.2e5 with V8
                                  #     - including with FUNC.bind|call|apply() or array spread
                                  #  - can use trailing commas
                                  #  - VAR = VAL: default value:
                                  #     - can refer to previous parameter of same function.
                                  #     - VAL is evaluated at each function call, not at declaration,
                                  #       in its own child scope.
                                  #     - explicitely passing undefined gets the default value
                                  #     - does not have to be last parameters, but makes more sense
                                  #  - ...ARR: variadic args
                                  #  - {...}: assigns {...} = OBJ
                                  #     - including { [...] ...OBJ [...] } = OBJ2
                                  #  - [VAR...]: assigns ARR = [VAL...]
arguments                         #Readonly ARRAYLIKE containing currently passed arguments.

FUNC([VAL]...)                    #Fire FUNC and returns its return value
                                  #Can be ...ITERABLE, replaced by NEXT...
                                  #Can use trailing commas

FUNC?.(...)                       #Like FUNC == null ? undefined : FUNC(...)
                                  #Does not work with new FUNC?.(...)
OBJ?.FUNC(...)                    #Like OBJ == null ? undefined : OBJ.FUNC(...)

FUNC.length                       #Number of required arguments

FUNC.name                         #Is:
                                  #  - function NAME (...) {...} -> 'NAME'
                                  #  - { NAME() {...} } -> 'NAME'
                                  #  - (...) => {...} -> ''
                                  #  - function (...) {...} -> ''
                                  #  - NAME = FUNC -> FUNC.name || NAME
                                  #  - { NAME: FUNC } -> FUNC.name || NAME
                                  #  - OBJ.VAR = FUNC -> FUNC.name
                                  #Prepends:
                                  #  - "bound " if FUNC.bind()
                                  #  - "get|set " if getter|setter
                                  #If NAME is SYM -> '[STR]' with STR from Symbol(STR)
                                  #Might be changed by minifiers (e.g. done by default by Uglify, although there
                                  #is an option)
                                  #Used in stack trace of ERROR or debuggers
                                  #Read-only, but configurable (so can Object.defineProperty() the value).
FUNC.toString()                   #Function declaration, can be eval'd()
                                  #I.e. either:
                                  #  - 'function[*] [NAME] (...) {...}'
                                  #  - '(...) => {...}' or ARG => VAL (or mixed of both) if arrow function
                                  #  - '[get|set] [*]NAME(...) {...}' if member function
                                  #  - 'class [CLASS] {...}' if CLASS
                                  #  - 'function anonymous(ARG...\n) {...} if new Function()
                                  #If native function, will contain "[native code]"

this                              #OBJ if current function fired as OBJ.FUNC(), otherwise null|undefined
                                  #Read-only
                                  #Notes:
                                  #  - FUNC2 = OBJ.FUNC or FUNC3(OBJ.FUNC)
                                  #     - must OBJ.FUNC.bind(OBJ) to keep "this"
                                  #  - OBJ = new FUNC(); calls FUNC.call(OBJ)
FUNC.bind(VAL[, ...])             #Returns FUNC, but binds "this" to VAL (except if called with 'new'),
                                  #and first arguments to ...
                                  #Cannot rebind.
FUNC.call(VAL[, ...])             #Same as FUNC.bind(VAL[, ...])()
FUNC.apply(VAL[, ARR])            #Same but using an ARR instead of comma-separated arguments.
                                  #Often used to forward to another function: FUNC.apply(this, arguments)

VAR = FUNC([...]); return VAR;   *#Two examples of a tail call optimization:
return FUNC([...]);              *#  - the last FUNC() performed before "return" (besides assignments)
                                 *#    (includes FUNC like native operators)
                                 *#This will optimize FUNC() call:
                                 *#  - faster, because optimizer can replace call stack current frame instead
                                 *#    of adding to it
                                 *#  - allow infinite recursion

                                  ┌────────────────┐
                                  │   DECORATORS   │
                                  └────────────────┘

@DFUNCs                         *~#@DFUNCs can be several whitespace-separated @DFUNC
class ... {                     *~#DFUNC can be VARR or FUNC(...)->DFUNC, without wrapping with (...)
  @DFUNCs                       *~#DFUNC(VAL, DCONTEXT)[->VAL] that modifies the value after it.
  [get|set] [#]FUNC(...) {...}  *~#  - def return value: VAL
  @DFUNCs [static]              *~#VAL is, for:
  [accessor] [#]VAR = EXPR      *~#  - 'class|method|getter|setter': FUNC
}                               *~#  - 'field': undefined as argument, but available by returning FUNC2(VAL)->VAL
                                *~#     - i.e. meant to wrap value initialization
                                *~#  - 'accessor': OBJ with same shape as DCONTEXT.access
                                *~#     - i.e. meant to wrap value get|set
                                *~#     - return VAL can also have property initialize(VAL)->VAL (behaves like 'field' return value)
                                *~#Called:
                                *~#  - once on prototype: DFUNC()
                                *~#  - on new CLASS instances initialization, with `this` being CLASS:
                                *~#     - FUNC2() returned by 'field'
                                *~#     - OBJ.initialize() returned by 'accessor'
                                *~#     - DCONTEXT.addInitializer()'s FUNC2()
                                *~#  - on value get|set: OBJ.get|set returned by 'accessor'
                                *~#DCONTEXT:
                                *~#  - kind 'class', 'method|getter|setter' or 'field|accessor'
                                *~#  - name 'VAR'|SYM
                                *~#  - metadata OBJ:
                                *~#     - available as CLASS[Symbol.metadata]
                                *~#     - meant to communicate information with caller
                                *~#  (not 'class')
                                *~#  - private BOOL: if #FUNC2|VAR
                                *~#  - static BOOL: if "static"
                                *~#  - access OBJ: unlike the VAL being passed to DFUNC, if get|set() are used later, they retrieve the current value then
                                *~#  (not 'class|setter')
                                *~#     - get()->VAL
                                *~#  (not 'class|method|getter')
                                *~#     - set(VAL)
                                *~#  (not 'field')
                                *~#  - addInitializer(FUNC2())

                                  ┌────────────┐
                                  │   ERRORS   │
                                  └────────────┘

throw VAL                         #Throw exception VAL, i.e. interrupt each function in the call stack until
                                  #inside try { ... } followed by catch ( VAR ) { ... }
                                  #Thrown errors will reject parent PROMISEs and be propagated in async|await stacks
                                  #However they will stop at other top-level functions creating async context
                                  #  - e.g. setTimeout()
                                  #  - i.e. should be promisified
try { ...  }
[catch [(VAR)] { ... }]           #(VAR) can be omitted
[finally { ... }]                 #finally { ... } is always fired
                                  #  - return|exception have higher priority than try|catch's return|exception
                                  #  - if no `return` statement, default to try|catch's return

[new ]Error([STR[, OPTS]])        #OBJ usually used when throw VAL, because more info.
                                  #Prefer with "new"
                                  #STR is ERROR.message (def: "")
                                  #OPTS:
                                  #  - cause: sets ERROR.cause
                                  #Some builtin ERROR thrown:
                                  #  - ReferenceError: console.log(notdeclared)
                                  #  - TypeError: null.FUNC()
                                  #  - SyntaxError: 5 *** 7
                                  #  - RangeError: new Array(Infinity)
                                  #  - URIError: decodeURIComponent('%')
                                  #  - EvalError: with eval()
ERROR.name                        #ERROR type (def: "Error"), redefined by children.
                                  #Usually set on prototype and non-enumerable.
ERROR.message                     #STR
                                  #Non-enumerable
                                  #Set as own property, but also set on prototype as empty STR.
ERROR.stack                       #Stack trace STR
                                  #Represent position at `new Error()`
                                  #Non-enumerable
                                  #Format is not standardized and very engine-specific
                                  #  - in V8:
                                  #     - includes ERROR.name|message but not on SpiderMonkey|JavaScriptCore
                                  #     - done lazily, i.e. only evaluates when ERROR.stack retrieved the first time, including:
                                  #        - ERROR.name|message header
                                  #        - calling Error.prepareStackTrace()
                                  #  - in V8, it is created lazily
                                  #     - i.e. represent
                                  #  - in SpiderMonkey:
                                  #     - set on prototype
                                  #     - is a getter
                                  #     - when retrieved on the prototype, returns empty STR, but not when retrieved through prototype chain
                                  #     - includes constructor
                                  #        - not for native errors
                                  #        - prefixed by constructor ERROR_FUNC.name (not ERROR.name)
                                  #           - at ERROR_FUNC creation time: modifying ERROR_FUNC.name does not change it
                                  #See "async" above for async stack trace
                                  #See stack trace documentation for more information on: parsing, normalizing,
                                  #beautifying, visualizing, etc.
                                  #Printed by UTIL.inspect(ERROR)
ERROR.cause                       #Inner ERROR2
                                  #Optional. Can be any type.
                                  #Not used by ERROR.stack nor toString()
                                  #But used by UTIL.inspect(ERROR) and console.log() on most browsers
ERROR.toString()                  #'NAME: MESSAGE'

new AggregateError
 (VAL_ARR[, 'MESSAGE'][, OPTS])   #ERROR include several children VAL_ARR
AGGREGATE_ERROR.errors            #VAL_ARR
                            18.6.0#Printed BY UTIL.inspect(ERROR)

debugger                          #Sets a breakpoint

Error.isError(VAL)->BOOL         ~#Works cross-realm

Error.*stack*                     #V8 specific
                                  #Are global, i.e. ignored on Error.* subclasses
Error.captureStackTrace           #Adds OBJ.stack, unless already exists
 (OBJ[, FUNC])                    #Automatically done by ERROR, i.e. Error.captureStackTrace(ERROR) is useless
                                  #If FUNC, stops stack frame at FUNC

Error.stackTraceLimit             #Def: 10

Error.prepareStackTrace           #When set with FUNC(ERROR, CALL_ARR)->'STACK', override how OBJ.stack is get
                                  #Default is something along the lines of:
                                  #  ERROR.name: ERROR.message
                                  #    at [new] CALL.getFunctionName() [as methodName] (LOCATION)
                                  #    at <anonymous> (LOCATION)
                                  #    at eval (PARENT_CALL, <LOCATION2>)
                                  #    at native
                                  #    at unknown location
                                  #    ...
                                  #LOCATION is:
                                  #  (CALL.getFileName():CALL.getLineNumber():CALL.getColumnNumber())
CALL.getFileName()->'FILENAME'    #undefined if eval
CALL.getEvalOrigin()->'FILENAME'  #Same but when using eval() (or related)
CALL.getScriptNameOrSourceURL()
 ->'FILENAME'                     #Same but when using eval() (or related) with //# sourceURL comment
CALL.getFunction()->FUNC          #undefined in 'strict mode'
CALL.getFunctionName()
 ->'[CLASS.]FUNC|null'            #
CALL.getMethodName()->'FUNC'|null #
CALL.getThis()->THIS              #undefined in 'strict mode'
CALL.getTypeName()->STR|null      #THIS's TYPE
CALL.getLine|ColumnNumber()->NUM  #
CALL.getPosition()->NUM           #Byte index
                                  #Does not includes CommonJS wrapper anymore
CALL.isToplevel()->BOOL           #
CALL.isEval()->BOOL               #From eval() (or related)
CALL.isNative()->BOOL             #From native C++ code
CALL.isConstructor()->BOOL        #Using new
CALL.isAsync()->BOOL              #True if async stack trace
                                  #Only for the CALL that triggered an async operation, e.g. `await`.
CALL.isPromiseAll()->BOOL         #True if Promise.all()
CALL.getPromiseIndex()->NUM       #PROMISE index inside Promise.all()

ERROR.lineNumber|columnNumber     #NUM
                                  #SpiderMonkey-specific
                                  #Non-enumerable
ERROR.fileName                    #STR
                                  #SpiderMonkey-specific
                                  #Non-enumerable

ERROR.line|column                 #NUM
                                  #JavaScriptCore-specific
                                  #Enumerable

                                  ┌─────────────┐
                                  │   DISPOSE   │
                                  └─────────────┘

using VAR = OBJ[, ...]           ~#Call OBJ[SYMBOL.dispose]() at end of current {...} block, including if exception, similar to finally {...}
OBJ[Symbol.dispose]()            ~#If it throws an ERROR, wrapped as new SuppressedError(ERROR[, ORIGINAL_ERROR])

new DisposableStack()           *~#DSTACK. Allows using multiple OBJ[Symbol.dispose]() at once.
                                *~#If multiple OBJ[Symbol.dispose]() throw, they are wrapped in a recursive SuppressedError
DSTACK[Symbol.dispose]()        *~#
DSTACK.dispose()                *~#Calls DSTACK[Symbol.dispose]()
DSTACK.disposed                 *~#BOOL
DSTACK.use(OBJ)->OBJ            *~#Call OBJ[Symbol.dispose]() on DSTACK[Symbol.dispose]()
DSTACK.defer(FUNC())            *~#Call FUNC() on DSTACK[Symbol.dispose]()
DSTACK.adopt(VAL, FUNC(VAL))
 ->VAL                          *~#Same as defer(FUNC.bind(undefined, VAL))
DSTACK.move()->DSTACK2          *~#Clone. If DSTACK was declared with `using`, DSTACK2 is not bound by it.

await using VAR = VAL
await using { ... }
OBJ[Symbol.asyncDispose]()->>

new AsyncDisposableStack()
ADSTACK[Symbol.asyncDispose]()->>
ADSTACK.disposeAsync()->>
ADSTACK.disposed
ADSTACK.use(OBJ)->OBJ
ADSTACK.defer(FUNC()->>)
ADSTACK.adopt(VAL, FUNC()->>)->VAL
ADSTACK.move()->ADSTACK2        *~#Same but async

new SuppressedError
 (ERROR[, ORIGINAL_ERROR]
 [, 'MESSAGE'][, OPTS])         *~#Error class when an ERROR was thrown while handling an ORIGINAL_ERROR
SUPPRESSED_ERROR.error          *~#ERROR
SUPPRESSED_ERROR.suppressed     *~#ORIGINAL_ERROR

                                  ┌──────────┐
                                  │   INTL   │
                                  └──────────┘

OBJ.toLocaleString()              #Same as OBJ.toString(), but can be reimplemented by children
                                  #(like OBJ.toString())
ARR.toLocaleString()              #Same as ARR.toString() with locale commas
STR.toLocaleUpper|LowerCase()     #Using current locale

new Intl.Locale                   #LOCALE_OBJ
 (LOCALE, LOCALE_ARGS)            #LOCALE_ARGS is an OBJ:
                                  #  - are Unicode "Language tags"
                                  #  - list: see its doc
                                  #  - supports: ca|calendar, co|collation, hc|hourCycle, kf|caseFirst,
                                  #    kn|numeric, nu|numberingSystem
                                  #Def: current locale
                                  #For Node, support must be done during building
LOCALE_OBJ.*                      #Anything from LOCALE_ARGS (using long name)
LOCALE_OBJ.language               #STR
LOCALE_OBJ.script                 #STR
LOCALE_OBJ.region                 #STR
LOCALE_OBJ.basename               #STR
LOCALE_OBJ.calendar               #STR
LOCALE_OBJ.caseFirst              #BOOL
LOCALE_OBJ.collation              #STR
LOCALE_OBJ.hourCycle              #STR
LOCALE_OBJ.numeric                #STR
LOCALE_OBJ.numberingSystem        #STR
LOCALE_OBJ.textInfo         18.0.0#STR
LOCALE_OBJ.weekInfo         18.0.0#STR
LOCALE_OBJ.toString()->LOCALE     #
LOCALE_OBJ.locale                 #Like LOCALE, but only the first part
LOCALE                            #STR serialization of LOCALE_OBJ:
                                  #  - e.g. 'fr-FR'
                                  #  - LOCALE_ARGS is serialized as final -u-SHORTEN_ARG-VAL
                                  #  - true for current locale
                                  #Polyfill|ponyfill 'intl.js'
Intl.getCanonicalLocales          #Normalize LOCALE, e.g. its case and remove duplicates
 (LOCALE[_ARR])->LOCALE_ARR       #Throws if invalid

LOCALEOPTS ==>                    #Is LOCALE[_ARR][, OPTS]
                                  #Or LOCALE_OBJ[_ARR][, OPTS]
                                  #OPTS:
                                  #  - depends on the method
                                  #  - defaults to using CLDR with the provided LOCALE
                                  #  - always has members:
                                  #     - locale LOCALE
                                  #     - localeMatcher 'best fit' (def) or 'lookup' (poorer algorithm)
                                  #  - some members might be read-only
Intl.*.supportedLocalesOf
 ([LOCALEOPTS])                   #Returns LOCALE_ARR matching LOCALEOPTS and being installed on client.

new Intl.*([LOCALOPTS])           #Returns new instance of a specific intl operation
                                  #Is expensive, so should be cached
                                  #Returned member always has members:
                                  #  - resolvedOptions()->OPTS

Intl.supportedValuesOf(STR) 18.0.0#Returns all possible values for a specific Intl.* method|option
 ->STR_ARR                  18.0.0#STR can be: 'currency|calendar|collation|numberingSystem|timeZone|unit'
LOCAL_OBJ.calendars
 |collations|hourCycles
 |numberingSystems|timeZones
 |textInfo|weekInfo         18.0.0#STR_ARR

new Intl.Collator([LOCALEOPTS])   #Locale-specific collation.
                                  #OPTS:
                                  #  - usage 'sort' (def) or 'search': like co "search" LOCALE_ARGS
                                  #  - sensitivity 'base|accent|case|variant' (def: 'variant'):
                                  #     - case-sensitive: 'case|variant'
                                  #     - accent-sensitive: 'accent|variant'
                                  #  - ignorePunctuation BOOL (def: false)
                                  #  - numeric BOOL (def: false): like kn LOCALE_ARGS
                                  #  - caseFirst 'upper|lower' or 'false' (def, i.e. locale's): like
                                  #    kf LOCALE_ARGS
                                  #Relevant LOCALE_ARGS: co, kn, kf
COLLATOR.compare(STR, STR2)->NUM  #Like STR < <= >= > STR2, except:
STR.localCompare                  #  - returns as -1|0|1
 (STR2[, LOCALEOPTS])->NUM        #  - real sorting, not just codepoint-wise
                                  #  - takes locales into account

new Intl.DisplayNames             #Language string translation
 ([LOCALEOPTS])                   #OPTS:
                                  #  - type STR among:
                                  #     - 'region': countries (ISO-3166, e.g. 'US' to 'United States') or world regions (UN M49 code, e.g. '419' to 'Latin America')
                                  #     - 'language' (e.g. 'fr' or 'fr-CA' to 'French' or 'Canadian French')
                                  #     - 'script' (ISO-15924, e.g. 'Latn' or 'Arab' to 'Latin' or 'Arabic')
                                  #     - 'currency' (ISO-4217, e.g. 'USD' to 'US Dollar')
                                  #     - 'calendar' (calendar name, e.g. 'gregory' to 'Gregorian Calendar')
                                  #     - 'dateTimeField' ('era|year|month|quarter|weekOfYear|weekday|dayPeriod|day|hour|minute|second'
                                  #  - languageDisplay STR:
                                  #     - when using type 'language'
                                  #     - either 'dialect' (def, 'British English') or 'standard' ('English (United Kingdom)')
DISPLAYNAMES.of(STR)->STR2        #

new Intl.NumberFormat             #Number locale formatting
 ([LOCALEOPTS])                   #OPTS:
                                  #  - style 'decimal|currency|percent|unit' (def: 'decimal')
                                  #  - useGrouping BOOL (def: auto): throusands separators
                            19.0.0#    Can also be:
                            19.0.0#      - 'never|always' (like false|true)
                            19.0.0#      - 'auto' (def): depends on locale
                            19.0.0#      - 'min2': if at least two digits in each group
                                  #  - minimum|maximumInteger|Fraction|SignificantDigits NUM
                            19.0.0#  - roundingPriority STR:
                            19.0.0#     - when *FractionDigits and *SignificantDigits are both specified and they
                            19.0.0#       lead to different number of digits, decides which one has priority:
                            19.0.0#        - 'auto' (def): *SignificantDigits
                            19.0.0#        - 'morePrecision': one with most digits
                            19.0.0#        - 'lessPrecision': one with least digits
                            19.0.0#  - trailingZeroDisplay STR:
                            19.0.0#     - whether to show fraction digits if all 0s
                            19.0.0#     - can be 'auto' (yes, def) or 'stripIfInteger' (no)
                            19.0.0#  - roundingMode STR:
                            19.0.0#     - 'ceil|floor': towards +|-Infinity
                            19.0.0#     - 'expand|trunc': away|towards 0
                            19.0.0#     - 'halfExpand' (def) or 'halfTrunc|Ceil|Floor': closest. If half, expand|trunc|ceil|floor
                            19.0.0#     - 'halfEven'
                            19.0.0#  - roundingIncrement NUM
                            19.0.0#     - among 1|2[5]|5[0[0[0]]]
                                  #  - signDisplay 'auto' (def) (-1|-0|0|1), 'always' (-1|-0|+0|+1),
                                  #    'never' (1|0|0|1), 'exceptZero' (-1|-0|0|+1),
                            19.0.0#    'negative' (-1|0|0|1)
                                  #  (for style 'decimal')
                                  #  - notation 'standard' (def) ('987654321'), 'compact' ('988M'),
                                  #    'engineering' ('987.654E6'), 'scientific' ('9.877E8')
                                  #  (for style 'decimal', notation 'compact')
                                  #  - compactDisplay 'short' (def) ('988M'), 'long' ('988 million')
                                  #  (for style 'currency')
                                  #  - currency STR (no def)
                                  #  - currencyDisplay 'symbol|code|name' (def: 'symbol')
                                  #  - currencySign 'standard' (def) or 'accounting' (show negative as '(NUM)')
                                  #  (for style 'unit')
                                  #  - unit STR among:
                                  #     - acceleration-g-force|meter-per-second-squared
                                  #     - angle-arc-minute|second|degree|radian|revolution
                                  #     - area-acre|hectare|square-centimeter|foot|inch|kilometer|meter|mile|yard
                                  #     - concentr-karat|milligram-per-deciliter|millimole-per-liter|part-per-million
                                  #     - consumption-liter-per-100kilometers|kilometer|mile-per-gallon[-imperial]
                                  #     - digital-[giga|kilo|mega|tera]bit|byte
                                  #     - duration-century|day[-person]|hour|[micro|nano]second|millisecond|minute|month[-person]|week[-person]|year[-person]
                                  #     - electric-ampere|milliampere|ohm|volt
                                  #     - energy-calorie|foodcalorie|joule|kilocalorie|kilojoule|kilowatt-hour
                                  #     - frequency-[kilo|mega|giga]hertz
                                  #     - length-astronomical-unit|centimeter|decimeter|fathom|foot|furlong|inch|kilometer|light-year|meter|micrometer|mile|
                                  #       mile-scandinavian|millimeter|nanometer|nautical-mile|parsec|picometer|yard
                                  #     - light-lux
                                  #     - mass-carat|[micro|milli|kilo]gram|[metric-]ton|ounce|ounce-troy|pound|stone
                                  #     - power-[milli|kilo|mega|giga]watt|horsepower
                                  #     - pressure-hectopascal|inch-hg|millibar|millimeter-of-mercury|pound-per-square-inch
                                  #     - speed-kilometer-per-hour|knot|meter-per-second|mile-per-hour
                                  #     - temperature-celsius|fahrenheit|generic|kelvin
                                  #     - volume-acre-foot|bushel|cubic-centimeter|cubic-foot|cubic-inch|cubic-kilometer|cubic-meter|cubic-mile|cubic-yard|cup[-metric]|fluid-ounce|
                                  #       gallon[-imperial]|[milli|centi|deci|hecto|mega]liter|pint[-metric]|quart|tablespoon|teaspoon
                                  #  - unitDisplay 'narrow', 'short' or 'long'
                                  #Relevant LOCALE_ARGS: nu
NUMBERFORMAT.format(ARG)->STR     #ARG is NUM|BIGINT|STR
NUM|BIGINT.toLocaleString
 ([LOCALEOPTS])->STR              #
NUMBERFORMAT.formatToParts        #OBJ_ARR:
 (NUM|BIGINT)->OBJ_ARR            #  - type STR:
                                  #     - 'integer|fraction': integer|fraction part of the number
                                  #     - 'decimal': decimal separator
                                  #     - 'group': thousands separator
                                  #     - 'currency': currency string
                                  #     - 'percentSign': %
                                  #     - 'plusSign|minusSign': + or -
                                  #     - 'infinity|nan': ∞ or NaN
                                  #     - 'literal': anything else, e.g. spaces
                                  #  - value STR
NUMBERFORMAT.formatRange
 (NUM|BIGINT, NUM|BIGINT2)
 ->STR                      19.0.0#Like format() but for range between two NUMs ('USD3-5')
NUMBERFORMAT
 .formatRangeToParts
 (NUM|BIGINT, NUM|BIGINT2)
 ->OBJ_ARR                  19.0.0#Like formatToParts() but for range. OBJ has extra member source 'startRange|endRange|shared'
NUMBERFORMAT.format[Range]  19.0.0#Like format[Range][ToParts](...) but returns an OBJ: string (singular), pluralForm
 [ToParts]Select(...)       19.0.0#similar to Intl.PluralRules

new Intl.DateTimeFormat           #Date|Time|Date+Time locale formatting
 ([LOCALEOPTS])                   #OPTS:
                                  #  - timeZone STR (def: locale's)
                                  #  - hour12 BOOL (def: locale's)
                                  #  - formatMatcher 'basic' or 'best fit' (def): like localeMatcher, but for
                                  #    OPTS.weekday|etc.
                                  #  - weekday|era 'narrow|short|long' (no def)
                                  #  - month 'numeric|2-digit|narrow|short|long' (no def)
                                  #  - year|day|hour|minute|second 'numeric|2-digit' (no def)
                                  #  - timeZoneName (no def) among:
                                  #     - 'short'
                                  #       or 'shortOffset': 'GMT-8'
                                  #     - 'longOffset': 'GMT-08:00'
                                  #     - 'shortGeneric': 'PT'
                                  #     - 'long'
                                  #       or 'longGeneric': 'Pacific Time'
                                  #  - timeStyle 'short' (HH:MM), 'medium' (HH:MM:SS), 'long' (HH:MM:SS Z), 'full' (HH:MM:SS ZZZZ)
                                  #  - dateStyle 'short' (D/M/YY), 'medium' (MMM D, YYYY), 'long' (MMMM D, Y), 'full' (Tuesday, MMMM D, Y)
                                  #Relevant LOCALE_ARGS: nu, ca
DATETIMEFORMAT.format(DATE)->STR  #
DATE.toLocale[Date|Time]String
 ([LOCALOPTS])->STR               #
DATETIMEFORMAT.formatToParts      #Same but returned as OBJ_ARR:
 (DATE)->OBJ_ARR                  #  - type 'era|year|month|weekday|day|hour|minute|second|timeZoneName|separator'
                                  #  - value STR
DATETIMEFORMAT.formatRange
 (DATE, DATE2)->STR               #Like format() but for range between two DATEs ('1/10/07, 10:00 AM – 1/20/07, 10:00 AM')
DATETIMEFORMAT.formatRangeToParts
 (DATE, DATE2)->OBJ_ARR           #Like formatToParts() but for range. OBJ has extra member source 'startRange|endRange|shared'

new Intl.RelativeTimeFormat       #Date|Time|Date+Time locale formatting, for relative time ("time ago")
 ([LOCALEOPTS])                   #OPTS:
                                  #  - style STR:
                                  #     - 'long' (def) ("in 1 month")
                                  #     - 'short' ("in 1 mo.")
                                  #     - 'narrow' ("in 1 mo.")
RELATIVETIMEFORMAT.format
 (NUM, STR)->STR2                 #STR: 'year|quarter|month|week|day|hour|minute|second'
RELATIVETIMEFORMAT.formatToParts  #OBJ_ARR:
 (NUM, STR)->OBJ_ARR              #  - type STR: like unit (e.g. "year") or "literal" (anything else)
                                  #  - value STR

new Intl.DurationFormat           #Duration formatting ("2 hr 46 min 40 sec")
 ([LOCALEOPTS])                   #OPTS:
                                  #  - numberingSystem STR (like LOCAL_OBJ.numberingSystem)
                                  #  - fractionalDigits NUM: when rounding (def: no rounding, except for trailing zeroes)
                                  #  - style STR:
                                  #     - 'long'
                                  #     - 'short' (def)
                                  #     - 'narrow'
                                  #     - 'digital': like 'narrow' for years-days and 'numeric' for hours-*seconds
                                  #  - years|months|weeks|days|hours|minutes|[milli|micro|nano]seconds STR: same for specific parts
                                  #     - 'long' (e.g. '3 seconds')
                                  #     - 'short' (e.g. '3 secs')
                                  #     - 'narrow' (e.g. '3s')
                                  #     - 'numeric':
                                  #        - e.g. '23'
                                  #        - only with hours|minutes|[*]seconds
                                  #        - handled like '2-digit' if followed by another 'numeric'
                                  #     - '2-digit': only with hours|minutes|seconds
                                  #        - e.g. '23:'
                                  #  - years|...|*secondsDisplay:
                                  #     - 'always' (def if style specified)
                                  #     - 'auto' (def if default style): hide if zero
DURATIONFORMAT.format
 (T_DURATION|STR|OBJ)->STR2       #STR|OBJ is passed to Temporal.Duration.from()
DURATIONFORMAT.formatToParts
 (T_DURATION|STR|OBJ)->OBJ_ARR    #OBJ_ARR: type STR (e.g. 'years'), value STR

new Intl.PluralRules([LOCALEOPTS])#Locale-specific plural group of a NUM
                                  #OPTS:
                                  #  - type 'cardinal' (def) or 'ordinal'.
                                  #    It's because some languages have different rules for either.
                                  #  (read-only)
                                  #  - minimum|maximumFraction|SignificantDigits NUM
                                  #  - pluralCategories STR_ARR
PLURALRULES.select(NUM)->STR      #Returns plurality of NUM according to locale, among 'zero', 'one', 'two',
                                  #'few', 'many', 'other'
PLURALRULES.selectRange
 (NUM, NUM2)->STR           19.0.0#STR

new Intl.ListFormat([LOCALEOPTS]) #Format list of items with natural language.
                                  #OPTS:
                                  #  - type:
                                  #     - 'regular' (def) ("and")
                                  #     - 'disjunction' ("or")
                                  #     - 'unit' (only commas|spaces)
                                  #  - style STR:
                                  #     - 'long' (def)
                                  #     - 'short' (use abbreviations|punctuations, no words) (only type 'unit')
                                  #     - 'narrow' (use only spaces)
LISTFORMAT.format(STR_ARR)->STR   #
LISTFORMAT.formatToParts          #OBJ_ARR:
 (STR_ARR)->OBJ_ARR               #  - type 'element' (STR) or 'literal' (separators)
                                  #  - value STR

new Intl.Segmenter([LOCALEOPTS])  #Break down strings into smaller parts, locale-specific.
                                  #OPTS:
                                  #  - granularity STR:
                                  #     - 'grapheme' (def): might include several chars, since accents are chars
                                  #     - 'word'
                                  #     - 'sentence'
SEGMENTER.segment(STR)->SEGMENTS  #SEGMENTS is SEGMENT_ITERABLE:
                                  #  - segment STR2
                                  #  - input STR: full input
                                  #  - index NUM: STR2 inside STR, in Unicode codepoint
                                  #  - isWordLike BOOL:
                                  #     - undefined if granularity not 'word'
                                  #     - otherwise, whether word-like (letters|numbers) or punctuation|space-like
SEGMENTS.containing(NUM)
 ->SEGMENT|undefined              #Retrieve SEGMENT at index NUM

                                  ┌────────────┐
                                  │   REGEXP   │
                                  └────────────┘

/PATTERN/[FLAGS]                  #Def STR: '(?:)'
[new ]RegExp                      #Backslashes must be escaped in the second form
 (['PATTERN'[, 'FLAGS']])         #Perl RegExp except:
                                  #  - no [[:CLASS:]]
                                  #  - no \< \>
                                  #  - no ...+-greediness (but ...?-non-greediness allowed)
                                  #  - no additional flags
                                  #  - no \A \Z but ^ $ behave like \A \Z unless m flag
                                  #Also has:
                                  #  - \p \P: requires u flag
                            20.0.0#     - works with multi-codepoints characters like \p{*Emoji*}: requires v flag
                                  #  - (?<=) (?<!)
                                  #  - (?<GROUP>) \k<GROUP>:
                                  #     - REGEXP.exec() return value ARR also defines ARR.groups.GROUP to access those
                                  #     - STR.replace() accesses those using:
                                  #        - ${GROUP} if using a string (with normal quotes)
                                  #        - extra parameter groups OBJ if using a FUNC
                            23.0.0#     - duplicate GROUPs are allowed, if in different alternatives (with |)
                            20.0.0#  - [...&&|--...]: requires v flag
                            23.0.0#  - (?[FLAG...][-FLAG2...]:...): only for ims FLAGs
                                  #Flags:
                                  #  - possible:
                                  #     - i: case insensitive
                                  #     - g:
                                  #        - use REGEXP.lastIndex:
                                  #           - initially 0, set to last match index (or 0 if no match)
                                  #           - next REGEXP.exec|test() will start from there
                                  #        - if using ^, if no match, returns null but set REGEXP.lastIndex
                                  #          to next match
                                  #        - function taking REGEXP as argument should iterate using
                                  #          REGEXP.lastIndex
                                  #           - this is what do standard JavaScript methods,
                                  #             e.g. STR.match|replace()
                                  #     - m: ^ $ newline-wise (otherwise whole-string-wise)
                                  #     - s: . whole-string-wise (otherwise newline-wise),
                                  #       i.e. match any character including: LF CR U+2028 U+2029
                                  #     - y: same as g, with ^ in beginning of PATTERN
                                  #     - u: see above
                                  #     - d: enable ARR.indices with REGEXP.exec()
                            20.0.0#     - v: enable [...&&|--...] and multi-codepoints \p
                            20.0.0#        - include behavior of u, but incompatible with it
                                  #  - available at REGEXP.ignoreCase|global|multiline|sticky BOOL
REGEXP.source                     #'PATTERN' (read-only)
REGEXP.flags                      #'FLAGS' (read-only)
REGEXP.toString()                 #'/PATTERN/FLAGS'

REGEXP.exec(STR)                  #Search REGEXP in STR and returns ARR (or null):
                                  #  - ARR[0]: whole match
                                  #  - ARR[NUM]: parenthesis matches
                                  #  - ARR.index: first match index
                                  #  - ARR.input: STR
                                  #  - ARR.groups.GROUP: STR (see (?<GROUP>))
                                  #  - ARR.indices[0|NUM], ARR.indices.groups.GROUP: like ARR[0|NUM], ARR.groups.GROUP
                                  #    but as start|end indices [NUM2, NUM3] instead of STR
REGEXP.test(STR)                  #Returns BOOL

RegExp.escape(STR)->STR          *#\-escapes any REGEXP-specific character, so it can be passed to new RegExp(STR) without injection

                                  ┌───────────┐
                                  │   ARRAY   │
                                  └───────────┘

Array                             #Are actually OBJ with numeric property names, so can do ARR[NUM]
                                  #Can contain different types.
                                  #Multidimensional ARR: use ARR of ARRs
[new ]Array(NUM)                  #Returns ARR with NUM undefined values.
                                  #Throw RangeError if non-positive or decimal.
[new ]Array(VAL...)               #Like [ VAL... ]
Array.of(VAL...)                  #Same as new Array(VAL...) except not interpreted as new Array(VAL...) if
                                  #only VAL is NUM
[ [VAL...] ]                      #Literal form.
                                  #Can use trailing commas

MAX LENGTH ==>                    #2**32 - 1, i.e. ~4e9. Not engine-dependent.

Array.isArray(VAR)->BOOL          #Same as VAR instanceof Array, except works across REALMs

ARR[NUM]                          #
ARR?.[NUM]                        #Like ARR == null ? undefined : ARR[NUM]
ARR.at(NUM)->VAL                  #Like STR[NUM] except -NUM is from end, and is not writable
ARR.with(NUM, VAL)->ARR2    20.0.0#Like ARR.at(NUM) = VAL, but does not modify ARR

ARRAYLIKE                         #Any OBJ which understand OBJ[NUM] and OBJ.length
                                  #Can use all ARR methods, except concat() using:
                                  #  Array.prototype.FUNC.call(ARRAYLIKE, ...) is like ARR.FUNC(...)
                                  #If expected to return ARR, returns ARR not ARRAYLIKE.
Array.from                        #Returns as ARR
 (ARRAYLIKE|ITERABLE[, ...])      #If ..., also calls ARR.map(...)
                                  #Can do Array.from({ length }, (_, i) => i) to get [0, 1, ...]
Array.fromAsync            22.0.0~#Same but using ASYNC_ITERABLE
 (ASYNC_ITERABLE[, ...])   22.0.0~#Can do Array.fromAsync({ length }, ...)

ARR.length                        #Can be modified (will truncate or extend with undefined values)
                                  #Max 4 billions (32-bits).

ARR.concat(VAL...)                #Pushes each VAL (does not modify)
                                  #If VAL is ARR2, pushes ARR2 elements, not ARR2 itself,
                                  #unless ARR[Symbol.isConcatSpreadable] false
ARR.slice([NUM[, NUM2]])          #Returns ARR copy from index NUM (def: 0) to NUM2 (def: ARR.length).
                                  #NUM|NUM2 can be negative, i.e. from ARR end.
ARR.splice(NUM[, NUM2[, VAL...]]) #Erase and return NUM2 elements (def: all) from index NUM, and replace them with VAL... (def: nothing)
ARR.toSpliced(...)->ARR2    20.0.0#Same as ARR.splice(...) but does not modify
ARR.fill(VAL[, NUM[, NUM2]])      #Same as ARR.splice(NUM, NUM2, VAL...) with VAL being repeated NUM2-NUM times.
ARR.copyWithin(NUM, NUM2[, NUM3]) #Copies ARR.slice(NUM2[, NUM3]) to ARR.slice(NUM, ...)
                                  #Returns ARR.
ARR.join([STR])                   #Returns as STR2, with STR delimiter (def: ',')
ARR.toString()                    #ARR.join(',')

ARR.push|unshift(VAL,...)         #Adds VAL to end|beginning (modifies). Returns ARR.length
                                  #Has limit due to max FUNC args length, i.e. ~1.2e5 on V8
ARR.pop|shift()                   #Remove and returns last|first element (modifies).

ARR.reverse()->ARR2               #Modifies and returns ARR.
ARR.toReversed()->ARR2      20.0.0#Same as ARR.reverse() but does not modify
ARR.sort                          #Modifies and returns ARR.
 ([FUNC(VAL, VAL2)->-1|0|1])      #Default FUNC does STR comparison.
                                  #Implementation algorithm detail:
                                  #  - v8:
                                  #     - previously, insertion sort if ARR.length <= 10, quicksort otherwise
                                  #     - now, timsort
ARR.toSorted([FUNC])->ARR2  20.0.0#Same as ARR.sort(FUNC) but does not modify

ARR.indexOf(VAL[, NUM])           #Returns VAL index, or -1. Uses ===
                                  #If NUM, skip first NUM elements (but still returns index from beginning)
                                  #Using ~VAL is shortcut for VAL !== -1, e.g. ~ARR.indexOf(VAL) is
                                  #like ARR.includes(VAL)
ARR.lastIndexOf(VAL[, NUM])       #Same but from end.
ARR.find[Index]
 (FUNC(VAL,KEY,ARR)->BOOL[, THIS])#Returns first VAL|KEY that returns true. Otherwise does not return.
ARR.findLast[Index](...)    18.0.0#Same but from end.
ARR.includes(VAL[, NUM])          #Same as ARR.indexOf(...) !== -1
                                  #Except NaN === NaN

ARR.forEach
 (FUNC(VAL, KEY, ARR)[, THIS])    #
ARR.map
 (FUNC(VAL, KEY, ARR)->VAL[,THIS])#Returns [VAL...]

ARR.reduce[Right]                 #MEMO is:
 (FUNC(MEMO,VAL,KEY,ARR)[, MEMO]) #  - first: argument passed (def: first value, which is then not iterated)
                                  #  - then: previous FUNC() return value
                                  #  - final return value
                                  #reduceRight iterates from end to beginning
ARR.filter
 (FUNC(VAL,KEY,ARR)->BOOL[, THIS])#Excludes if false
ARR.every|some
 (FUNC(VAL,KEY,ARR)->BOOL[, THIS])#Returns true if all|any true.
ARR.flat([INT])                   #Flattens INT levels of depth (def: 1)
ARR.flatMap(...)                  #Same as ARR.map(...).flatten(1)
Object.groupBy
 (ARR, FUNC(VAL, NUM)->STR|SYM)
 ->OBJ                      21.0.0#Returns OBJ where keys are STR|SYM and values are VAL_ARR2
Map.groupBy
 (ARR, FUNC(VAL, NUM)->VAL2)
 ->MAP                      21.0.0#Same with MAP

ARR.keys()                        #Returns all INDEX as ITERABLETOR
ARR.values()                      #Returns all VAL as ITERABLETOR (i.e. same as ARR[Symbol.iterator])
ARR.entries()                     #Returns all [INDEX, VAL] as ITERABLETOR

                                  ┌──────────────────┐
                                  │   TYPED ARRAYS   │
                                  └──────────────────┘

new ArrayBuffer(UINT[, OPTS])     #Raw data chunk. Useful for:
                                  #  - binary data
                                  #  - memory allocation performance optimization
                                  #UINT is byteLength. Filled with \0
                                  #Needs a view to be manipulated, which gives:
                                  #  - start|end indices
                                  #  - a specific type to read it
                                  #Available:
                                  #  - DATAVIEW: dynamic type
                                  #  - TYPED_ARR:
                                  #     - single type
                                  #     - can be manipulated as an ARR
                                  #Several DATAVIEW|TYPED_ARR can be applied to a single ARRBUFFER.
ARRBUFFER.byteLength              #Readonly
ARRBUFFER|OPTS              20.0.0#Maximum UINT for ARRBUFFER.byteLength. Readonly
 .maxByteLength             20.0.0#Allocates memory right away, i.e. more efficient
                            20.0.0#If not resizable, same as ARRBUFFER.byteLength
ARRBUFFER.resizable         20.0.0#BOOL. Whether can resize(). Readonly.
                            20.0.0#true if OPTS.maxByteLength specified
ARRBUFFER.resize(UINT)      20.0.0#Sets ARRBUFFER.byteLength. Can either grow|shrink
ARRBUFFER                   21.0.0#Clone with same underlying data chunk, resizable and maxByteLength
 .transfer[ToFixedLength]   21.0.0#UINT is byteLength (def: same)
 ([UINT])->ARRBUFFER2       21.0.0#  - can shrink|grow, within maxByteLength
                            21.0.0#If ToFixedLength():
                            21.0.0#  - ARRBUFFER2.resizable false
                            21.0.0#  - can grow beyond maxByteLength
                            21.0.0#     - filling with \0
ARRBUFFER.detached          21.0.0#BOOL. Set to true by transfer*(), which also sets byteLength|maxByteLength 0
ARRBUFFER.slice(...)              #Like ARR.slice(...)
                            20.0.0#Not resizable

ArrayBuffer.isView(VAL)->BOOL     #True if DATAVIEW|TYPED_ARR

new DataView
 (ARRBUFFER[, UINT[, UINT2]])     #UINT is offset (def: 0), UINT2 length (def: ARRBUFFER.byteLength)
DATAVIEW
 .buffer|byteLength|byteOffset    #Readonly

DATAVIEW.get[Ui|I]nt8|16|32
 ([UINT[, BOOL]])
DATAVIEW.getFloat32|64
 (UINT[, BOOL])                   #UINT is byte offset, BOOL endianness (def: true, i.e. little endian)
DATAVIEW.getFloat16
 (UINT[, BOOL])                  *#
DATAVIEW.getBig[Ui|I]nt64
 (UINT[, BOOL])                   #
DATAVIEW.set*(UINT, UINT2[, BOOL])#UINT2 is the value to set

TypedArray                        #Base prototype of [Ui|I]nt8|16|32Array or Float16|32|64Array
                                  #and Big[Ui|i]nt64Array
                                  #Each have a given associated type
                                  #Not accessible globally but through prototype chain.
                                  #Mixes in all ARR methods:
                                  #  - including TYPED_ARR[NUM], TypedArray.of|from()
                                  #  - excluding concat(), splice(), push|pop|shift|unshift(), flat[Map]()
                                  #There is also a special Uint8ClampedArray, which do not 'roll' too low|high
                                  #values, e.g.:
                                  #  - UINT8_ARR[0] = -10 (246) vs UINT8_CLAMPED_ARR[0] = -1 (0)
                                  #  - UINT8_ARR[0] = 260 (4) vs UINT8_CLAMPED_ARR[0] = 260 (255)
new TypedArray(NUM)               #Same as new TypedArray(new ArrayBuffer(NUM))
new TypedArray
 (ARRBUFFER[, UINT[, UINT2]])     #Same args as DataView. Does not copy.
new TypedArray(TYPED_ARR2)        #Copy. New underlying ARRBUFFER is only the needed size.
new TypedArray
 (INT_ARRAYLIKE|ITERABLE)         #Uses TYPED_ARR.from(...)

TypedArray|TYPED_ARR
 .BYTES_PER_ELEMENT               #
TYPED_ARR
 .buffer|byteLength|byteOffset    #Readonly
TYPED_ARR.length                  #

TYPED_ARR.subarray(...)           #Like slice(...) except it shares same ARRBUFFER
TYPED_ARR.set
 (ARR|TYPED_ARR2[, UINT])         #Sets all ARR|TYPED_ARR2 values into TYPED_ARR, starting at index UINT (def: 0)
                                  #If ARR|TYPED_ARR2 too big, RangeError thrown
TYPED_ARR.toString()              #Is like ARR, not OBJ

UINT8ARR.toBase64([OPTS])->STR  *~#OPTS:
                                *~#  - alphabet 'base64' (def) or 'base64url'
                                *~#  - omitPadding BOOL: if false (def), use = padding
Uint8Array.fromBase64           *~#OPTS:
 (STR[, OPTS])->UINT8ARR        *~#  - alphabet: same as above
                                *~#  - lastChunkHandling STR: how to handle last 4 chars chunk that misses padding:
                                *~#     - 'loose' (def): include chunk
                                *~#     - 'stop-before-partial': ignore chunk
                                *~#     - 'strict': throw
                                *~#Allows ASCII whitespaces
UINT8ARR.setFromBase64          *~#Set bytes from byte 0 (can use a subarray to write at different byte)
 (STR[, OPTS])->OBJ             *~#OPTS: same as fromBase64()
                                *~#OBJ:
                                *~#  - read NUM (in base64 chars)
                                *~#  - written NUM2 (in bytes)

UINT8ARR.toHex()->STR           *~#Lowercase
Uint8Array.fromHex(STR)         *~#Allows uppercase|lowercase
 ->UINT8ARR                     *~#Does not allow ASCII whitespaces
UINT8ARR.setFromHex(STR)->OBJ   *~#Similar to UINT8ARR.setFromBase64()

REFERENCES ==>                    #Different ARRBUFFERs always point to different data
                                  #But 2 DATAVIEW|TYPED_ARR might point to same ARRBUFFER|data
                                  #  - with: new DataView|TypedArray(ARRBUFFER), TYPED_ARR.subarray()
                                  #  - but not with: new TypedArray(NUM|TYPED_ARR2|ARRAYLIKE|ITERABLE), TypedArray.from(), TYPED_ARR.slice()

                                  ┌────────────────────┐
                                  │   SHARED BUFFERS   │
                                  └────────────────────┘

new SharedArrayBuffer(UINT)       #Can be used like an ARRBUFFER including:
                                  #  - new TypedArray(...)
                                  #  - postMessage(...)
                                  #Except:
                                  #  - shared between contexts|WINDOWs, e.g. when passed via postMessage()
                                  #     - postMessage() should not use VAL2
                                  #  - must be manipulated using Atomics.*() to ensure thread-safety:
                                  #     - provide correct atomicity and order, using a lock under-the-hood
                                  #  - cannot be used with DataView, and no SharedArrayBuffer.isView()
                                  #  - resize|resizable -> grow|growable (cannot shrink)

Atomics.load(S_ARRBUFFER, NUM)
 ->VAL                            #Like S_ARRBUFFER[NUM]
Atomics.store
 (S_ARRBUFFER, NUM, VAL)->VAL     #Like S_ARRBUFFER[NUM] = VAL
Atomics.exchange
 (S_ARRBUFFER, NUM, VAL)->VAL2    #Like S_ARRBUFFER[NUM] = VAL, returning previous value
Atomics.compareExchange
 (S_ARRBUFFER, NUM, VAL3, VAL)    #Like if (S_ARRBUFFER[NUM] == VAL3) S_ARRBUFFER[NUM] = VAL,
 ->VAL2                           #returning previous value

Atomics.add|sub|and|or|xor
 (S_ARRBUFFER, NUM, VAL)->VAL2    #Like S_ARRBUFFER[NUM] += -= &= |= ^= VAL, returning previous value

Atomics.wait                      #Wait until Atomics.notify(), providing test passes.
 (S_INT32_ARR, NUM, VAL[, NUM2])  #I.e.:
 ->STR                            #  - if S_INT32_ARR[NUM] != VAL, does nothing (STR is "not-equal")
                                  #  - otherwise:
                                  #     - wait until Atomics.notify() (STR is "ok")
                                  #     - or until timeout NUM2ms (STR is "timed-out")
Atomics.waitAsync
 (S_INT32_ARR, NUM, VAL[, NUM2])
 ->>STR                           #Same but async
Atomics.notify
 (S_INT32_ARR, NUM, NUM2)         #Wake up NUM2 workers Atomics.waiting, with same first two arguments

Atomics.pause(NUM)              *~#Wait for NUM CPU cycles

Atomics.isLockFree                #True if underlying hardware can avoid locks for S_ARRBUFFER in a typed array of size NUM
 (S_ARRBUFFER, NUM)->BOOL         #Always true for NUM 4, often true for 1|2, usually false otherwise
                                  #Used for optimization, i.e. not relying on shared buffers if underlying
                                  #hardware is going to be slow

                                  ┌───────────────┐
                                  │   ITERATORS   │
                                  └───────────────┘

ITERATOR                          #OBJ with:
                                  #  - next([ARG]):
                                  #     - iterates over next value -> { done: false, value: NEXT }
                                  #     - if iteration finished -> { done: true, value: RETURN }
                                  #        - RETURN is the optional return value of the whole iteration
                                  #           - it is not the iteration's last value
                                  #           - should be either undefined or not defined if already returned by previous next|return()
                                  #  - return([ARG])->{ done: true, value: RETURN }
                                  #     - finish iteration successfully
                                  #     - if iteration finished, noop and RETURN is undefined
                                  #     - ARG is usually RETURN
                                  #     - optional
                                  #  - throw([ARG]):
                                  #     - finish iteration due to error
                                  #     - if iteration finished, fails
                                  #     - ARG is usually ERROR
                                  #     - optional
ITERABLE                          #OBJ where OBJ[Symbol.iterator]()->ITERATOR
                                  #Each call returns a new ITERATOR
                                  #STR|[TYPED_]ARR|MAP|SET are ITERABLE (only next() is defined)
ITERABLETOR                       #ITERATOR where OBJ[Symbol.iterator]()->ITERABLETOR (itself)
                                  #I.e. used as an ITERABLE, but always with the same ITERATOR
ASYNC_ITERATOR|ITERABLE           #Same except:
 |ITERABLETOR                     #  - next|return|throw() can return a PROMISE
                                  #  - Symbol.iterator -> Symbol.asyncIterator
                                  #Can be used as ITERATOR|ITERABLE|ITERABLETOR, but not vice-versa
                                  #PROMISE_ARR are ASYNC_ITERABLE

[ASYNC_]ITERATOR
 [Symbol.[async]dispose]()      *~#Calls [ASYNC_]ITERATOR.return()

[async] function* [FUNC](){...}   #Generator. FUNC returns an ITERABLETOR with ITERATOR:
[class ...] {                     #  - next([VAL]):
  [async] * FUNC(...) {...}       #     - continue execution of function until any of:
  ...                             #        - yield NEXT -> { done: false, value: NEXT }
}                                 #        - return RETURN -> { done: true, value: RETURN }
                                  #           - execution finished -> { done: true, value: undefined }
                                  #        - throw VAL -> propagate exception
                                  #     - VAL is `yield` return value
                                  #     - initially stopped at the beginning
                                  #        - i.e. VAL is ignored since no "yield" yet
                                  #  - return([RETURN])
                                  #     - `return RETURN` from current `yield`, i.e. finish execution
                                  #     - `finally` blocks still executed
                                  #     - if execution already finished, noop and RETURN ignored
                                  #     - returns { done: true, value: RETURN }
                                  #  - throw(VAL):
                                  #     - `throw VAL` from current `yield`
                                  #     - `catch|finally` blocks still executed
                                  #     - if execution already finished, throw VAL from caller position instead
yield* ITERABLE                   #Like: for (const NEXT of ITERABLE) { yield NEXT }
                                  #Return value is ITERABLE's RETURN
yield* ASYNC_ITERABLE             #Same for: for await (const NEXT of ASYNC_ITERABLE) { yield NEXT }
new [Async]GeneratorFunction(...) #Like new Function(...) but for [async] function*(){}
                                  #[Async]GeneratorFunction not available globally, but with:
                                  #  Object.getPrototypeOf([async] function*(){}).constructor

for ([QUAL] NEXT of ITERABLE)     #Iterates with NEXT = ITERATOR.next().value until done true
 {...}                            #Explicit break|return|throw calls ITERATOR.return()
                                  #  - but not on implicit break when .next() returns done true
                                  #Never calls ITERATOR.throw()
                                  #Never pass any argument to ITERATOR.next|return()
for await
 (QUAL NEXT of [ASYNC_]ITERABLE)
 {...}                            #Same but using await [ASYNC_]ITERATOR.next().value

[...ITERABLE]                     #In ARR literal form
                                  #Iterates with ITERATOR.next().value until done true, then returns aggregated values as ARR
                                  #Does not call ITERATOR.return|throw()
FUNC(...ITERABLE)
yield* ITERABLE
new [Weak]Map|Set(ITERABLE)
Promise.all[Settled]|race|any
 (ITERABLE)
Array.from(ITERABLE)
Object|Map.groupBy(ITERABLE)      #Uses the same logic as [...ITERABLE]
[...VAR] = ITERABLE               #Same but calls ITERATOR.next() if fewer VARs than available

new Iterator()              22.0.0#CITERATOR. ITERABLETOR returned by generators, STR.matchAll(), ARR.keys|values|entries()
                            22.0.0#CITERATOR.*()->CITERATOR2 do not keep ITERATOR.throw() nor forward ITERATOR.next|return() argument
                            22.0.0#Constructor cannot be called directly
Iterator.from(ITERABLETOR)
 ->CITERATOR                22.0.0#

EAGER EVALUATION ==>        22.0.0#
CITERATOR.toArray()->ARR    22.0.0#Same as [...CITERATOR]
CITERATOR.find(...)->VAL    22.0.0#Like ARR.find(...)
CITERATOR.some|every
 (...)->BOOL                22.0.0#Like [...CITERATOR].some|every(...)

LAZY EVALUATION ==>         22.0.0#
CITERATOR.map|flatMap|filter
 |reduce(...)->CITERATOR2   22.0.0#Like ARR.map|flatMap|filter|reduce(...)
CITERATOR.forEach(...)      22.0.0#Like ARR.forEach(...)
CITERATOR.indexed()
 ->CITERATOR2              22.0.0#Like ARR.entries()
CITERATOR.take(NUM)
 ->CITERATOR2              22.0.0#Make CITERATOR return after next NUM iterations
CITERATOR.drop(NUM)
 ->CITERATOR2              22.0.0#Skip next NUM iterations

new AsyncIterator()            *~#Same but async. Returned by async generators.

                                  ┌─────────────────┐
                                  │   MAPS & SETS   │
                                  └─────────────────┘

new Map([ITERABLE])               #ITERABLE must iterate over [KEY, VAL] elements (e.g. Object.entries(OBJ))
                                  #Is an ITERABLE itself, iterating over [KEY, VAL] in insertion order.
                                  #To use instead of OBJ, when:
                                  #  - KEY must be other than STR
                                  #  - VALs are conceptually similar to each other

MAP.get(KEY)->VAL                 #Like OBJ[KEY] and OBJ[KEY] = VAL, except KEY can be any type.
MAP.set(KEY, VAL)->MAP            #KEY equality uses Object.is() not ===
MAP.has(KEY)->BOOL                #
MAP.delete(KEY)->BOOL             #
MAP.clear()                       #

MAP.size                          #

MAP.keys|values|entries()         #Like ARR
MAP.forEach(...)                  #Like ARR


WeakMap                           #Like Map, except WEAKMAP does not own its children:
                                  #  - VAL will be garbage collected when its KEY is, whether WEAKMAP is still
                                  #    around or not
                                  #  - while MAP.set(KEY, VAL) is conceptually like MAP.KEY = VAL,
                                  #    WEAKMAP.set(KEY, VAL) is like KEY.__value = VAL
                                  #  - as such, cannot use clear|size|keys|values|entries|forEach()
                                  #    and is not ITERABLE
                                  #  - KEY must be OBJ
                            20.0.0#    or SYM, except Symbol.for() that are not well-known
                                  #To use when passive relation to children (proxying, listening, etc.) not
                                  #ownership (children existing mainly as MAP properties).

Set                               #Like a Map where KEY === VAL (i.e. keep unique values):
                                  #  - ITERABLE iterates over VAL elements, not [KEY, VAL]
                                  #  - entries() iterates over [VAL, VAL], keys|values() are same
                                  #  - no SET.get()
                                  #  - SET.set() -> SET.add(VAL)
SET.intersection(SET2)
 ->SET3                     22.0.0#Elements in both
SET.union(SET2)->SET3       22.0.0#Elements in either
SET.symmetricDifference
 (SET2)->SET3               22.0.0#Elements in either, but not both
SET.difference(SET2)->SET3  22.0.0#Elements in SET but not SET2
SET.isSubsetOf(SET2)->BOOL  22.0.0#Has same elements or subset
                            22.0.0#True if both empty
SET.isSupersetOf(SET2)
 ->BOOL                     22.0.0#Has same elements or superset
                            22.0.0#True if both empty
SET.isDisjointFrom(SET2)    22.0.0#Has no common elements
 ->BOOL                     22.0.0#True if both empty

WeakSet                           #Like WeakMap, but for Set.

                                  ┌──────────┐
                                  │   DATE   │
                                  └──────────┘

Date                              #Milliseconds-precise. Is internally:
                                  #  - only an Epoch NUM.
                                  #  - NaN for InvalidDate
                                  #UTC vs local:
                                  #  - input:
                                  #     - local: new Date(...)
                                  #     - does not matter: new Date()
                                  #     - UTC: new Date(Date.UTC(...))
                                  #  - output:
                                  #     - local: get|set*()
                                  #     - UTC: get|setUTC*(), getTime()
new Date([YEAR, MONTH, DAY, HOUR,
 MIN, SEC, MILLISEC])             #Each final arguments are optional. Def: now.
new Date(STR)                     #InvalidDate if cannot parse.
Date()                            #Same as (new Date()).toString()

DATE.toString()                   #"Day Mon DD YYYY HH:MM:SS TZ" (local timezone)
DATE.toISOString()                #"YYYY-MM-DDTHH:MM:SS.SSSZ" (UTC)
DATE.toUTCString()                #"Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
DATE.toDateString()               #"Day Mon DD YYYY" (local timezone)
DATE.toTimeString()               #"HH:MM:SS TZ" (local timezone)

DATE.valueOf()->NUM               #DATE.getTime()

DATE.*et[UTC][Time|FullYear|Month #Date is month day, Day week day (0 for Sunday)
 |Date|Day|Hours|Minutes|Seconds  #Time is Epoch in seconds
 |Milliseconds|TimezoneOffset]()  #TimezoneOffset is in minutes
                                  #set* returns DATE.getTime()

Date.now()                        #Like new DATE().getTime()
Date.parse(STR)                   #Like new DATE(STR).getTime()
Date.UTC(...)                     #Like new DATE(...).getTime() but new Date(...) uses UTC

                                  ┌──────────┐
                                  │   MATH   │
                                  └──────────┘

Math.min|max(NUM...)              #NaN if one NUM not a number. [-]Infinity if no arguments.

Math.sumPrecise                 *~#Sum
 (NUM_ITERABLE)->NUM2           *~#-0 if empty

Math.abs(NUM)                     #
Math.sign(NUM)                    #Returns -|+ 0|1 or NaN

Math.ceil|floor(NUM)              #Ceiling|flooring
Math.trunc(NUM)                   #Truncation
Math.round(NUM)                   #Nearest round. Tie-breaking towards Infinity
Math.fround(NUM)                  #Converts to single-precision float (binary32)
Math.f16round(NUM)              *~#Converts to float (binary16)

Math.PI                           #
Math.E                            #
Math.LN2                          #ln(2)
Math.LN10                         #ln(10)
Math.LOG2E                        #log2(e)
Math.LOG10E                       #log10(e)
Math.SQRT2                        #
Math.SQRT1_2                      #

Math.pow(NUM1, NUM2)              #
Math.sqrt(NUM)                    #NaN if negative
Math.cbrt(NUM)                    #
Math.exp(NUM)                     #
Math.expm1(NUM)                   #Same as Math.exp(NUM)-1
Math.log(NUM)                     #Base e. NaN if negative
Math.log2|10(NUM)                 #Base 2|10
Math.log1p(NUM)                   #Same as Math.log(NUM+1)

Math.imul(NUM, NUM2)              #Like NUM*NUM2, except only for 32-bits signed integers, where the sign is the
                                  #first bit, e.g. 4e9 is negative.
                                  #Used to emulate x86 ASM imul.
Math.clz32(NUM)                   #Number of leading zeros in a 32-bits signed binary format.

Math.[a]sin|cos|tan[2](NUM)       #In radian
Math.[a]sin|cos|tan[2]h(NUM)      #Hyperbolic version
Math.hypot(NUM...)                #sqrt(NUM**2 + NUM2**2 ...)

Math.random()                     #Float in [0,1). Seeded from current time.

                                  ┌──────────┐
                                  │   JSON   │
                                  └──────────┘

JSON ==>                          #See JSON-js doc

                                  ┌──────────────────────┐
                                  │   STRUCTURED CLONE   │
                                  └──────────────────────┘

STRUCTURED CLONE ALGORITHM ==>    #Serialization of almost any JavaScript VAL:
                                  #  - can be:
                                  #     - any JSON value
                                  #     - undefined|NaN|Infinity|MAP|SET|DATE|REGEXP|BIGINT
                                  #     - BLOB|FILE[LIST]|[ARR]BUFFER[VIEW]|DATAVIEW|TYPED_ARR|IMAGEDATA|ABORT_SIGNAL
                                  #     - circular references
                                  #     - ERROR
                                  #        - message|stack|cause|errors
                                  #        - name|constructor: if native error class, use Error
                                  #        - ignores other properties, including ones not serializable
                                  #  - OBJ keep their constructors
                                  #  - cannot be:
                                  #     - FUNC|SYM|PROMISE
                                  #     - PROXY|INTL.*
                                  #     - DOM ELEM
                                  #  - does not keep:
                                  #     - inherited properties
                                  #     - non-enumerated properties
                                  #     - REGEXP.lastIndex
                                  #     - setters, getters, property descriptors
                                  #  - can transfer memory of some types: ARRBUFFER[VIEW]|MESSAGEPORT
                                  #Used in:
                                  #  - WINDOW|WORKER.postMessage()
                                  #  - structuredClone() (global in DOM or Node.js)
                                  #  - IndexedDB
                                  #  - Node.js v8.[de]serialize() and IPC
                                  #  - Deno KV

                                  ┌─────────────┐
                                  │   PROMISE   │
                                  └─────────────┘

PROMISE                           #Represents an async function call.
                                  #Has two non-accessible members:
                                  #  - state 'pending|resolved|rejected': whether call is ongoing or done
                                  #  - value VAL: async function call return value or exception thrown
PROMISABLE                        #Any OBJ with OBJ.then(FUNC, FUNC2)

TASKS ==>                         #new Promise() FUNC is fired right away, i.e. in current microtask, sync,
                                  #before next statement.
                                  #But PROMISE.then|catch() FUNC is fired in next microtask, even if PROMISE is
                                  #already resolved|rejected.
                                  #This means await PROMISE, but also await VAL, will wait at least one microtask

new Promise                       #Returns PROMISE:
 (FUNC(RESOLVE(VAL|PROMISABLE),   #  - RESOLVE(VAL): state 'resolved', value VAL
 REJECT(VAL)))                    #  - REJECT(VAL): state 'rejected', value VAL
                                  #  - throw VAL: like REJECT(VAL)
                                  #     - if VAL is PROMISABLE, keep it as is
                                  #  - RESOLVE(PROMISABLE):
                                  #     - does PROMISABLE.then(RESOLVE, REJECT)
                                  #     - so PROMISE will have same state|value as PROMISABLE
                                  #RESOLVE|REJECT() defer state change
Promise.resolve|reject(...)       #Same as new Promise((resolve, reject) => { resolve|reject(...) })
Promise.try(FUNC()->[>]VAL)
 ->>VAL                     23.0.0#Same as Promise.resolve(FUNC()) except sync exceptions are converted to async

Promise.withResolvers()     22.0.0#Like:
 ->OBJ                      22.0.0#  let resolve, reject
                            22.0.0#  const promise = new Promise((RESOLVE, REJECT) => { resolve = RESOLVE; reject = REJECT; })
                            22.0.0#  return { promise, resolve, reject }

PROMISE.then                      #Call FUNC|FUNC2 with PROMISE value if|when PROMISE.state 'resolved|rejected'
 ([FUNC(VAL)[, FUNC2(VAL)]])      #Returns new PROMISE2, which fires (according to what happens in
                                  #either FUNC|FUNC2):
                                  #  - if return VAL|PROMISABLE (including undefined): RESOLVE(VAL|PROMISABLE)
                                  #  - if throw VAL: REJECT(VAL)
                                  #Def FUNC|FUNC2:
                                  #  - return|throw VAL
                                  #  - if not a function, use def
                                  #FUNC2 does not catch errors in FUNC, i.e. should prefer PROMISE.then(FUNC).catch(FUNC2) instead
PROMISE.catch(...)                #Same as PROMISE.then(null, ...)
PROMISE.finally(FUNC())           #Like PROMISE.then(FUNC(), FUNC())
                                  #Difference:
                                  #  - returning does not change PROMISE value
                                  #  - but throwing does
                                  #  - i.e. unlike `finally` in sync or async function: return statements
                                  #    (but not exceptions) have lower priority than try|catch's return|exception

Promise.all                       #Returns PROMISE:
 (VAL|PROMISABLE_ITERABLE)        #  - if all PROMISABLE resolved -> resolved with VAL2_ARR
                                  #  - if any PROMISABLE rejected with VAL2 -> rejected with VAL2
                                  #     - if two already rejected, use first in argument position order
                                  #     - otherwise, use the first that is being rejected, regardless of argument position order
                                  #VAL is converted to PROMISE2 using Promise.resolve(VAL)
Promise.race                      #Same but instead:
 (VAL|PROMISABLE_ITERABLE)        #  - if any PROMISABLE resolved|rejected with VAL2 -> resolved|rejected with VAL2
Promise.allSettled                #Same but instead:
 (VAL|PROMISABLE_ITERABLE)        #  - after all PROMISABLE resolved|rejected with VAL2 -> resolved with OBJ_ARR:
                                  #     - status 'fulfilled|rejected'
                                  #     - value VAL2 (if resolved)
                                  #     - reason VAL2 (if rejected)
Promise.any                       #Same but instead:
 (VAL|PROMISABLE_ITERABLE)        #  - if any PROMISABLE resolved with VAL2 -> resolved with VAL2
                                  #  - if all PROMISABLE rejected -> rejected with AGGREGATE_ERROR: errors VAL2_ARR

async function [*] [FUNC](...)
 {...}
[class ...] {
 async [*] FUNC() {...}           #Returns FUNC2(...)->PROMISE, where FUNC can:
 ...                              #  - return VAL -> resolve PROMISE with VAL
}                                 #  - throw VAL -> reject PROMISE with VAL
async (...) => ...                #  - return PROMISE2 -> reject|resolve PROMISE with PROMISE2 value
await PROMISABLE|VAL              #Inside async FUNC:
                                  #  - waits for PROMISABLE to resolve|reject
                                  #     - if PROMISABLE value returns PROMISABLE2, use PROMISABLE2 value instead
                                  #     - VAL is like Promise.resolve(VAL)
                                  #  - then returns|throws PROMISABLE value
                                  #Can be in top-level scope too, but only if file uses pure ES modules

                                  ┌───────────┐
                                  │   PROXY   │
                                  └───────────┘

new Proxy(OBJ, OBJ2)              #Returns PROXY:
                                  #  - live deep mirror of OBJ: OBJ and PROXY are always deep equal
                                  #     - including prototype and inherited properties
                                  #     - but Object.prototype.toString.call(PROXY) is always '[object Object]'
                                  #  - can override some basic object operations with OBJ2:
                                  #     - providing they are performed on PROXY (not on OBJ)
                                  #     - they usually have same arguments, plus a first argument being PROXY
                                  #     - can call themselves without creating infinite recursion
                                  #        - but set|get() OBJ3 can't, i.e. OBJ3.VAR = VAL as opposed to
                                  #          PROXY.VAR = VAL
                                  #     - there are some special rules ('invariants') to handle
                                  #       non-extensible|configurable|writable properties (see online doc)
                                  #       Should not worry unless writing a library.
                                  #     - return value:
                                  #        - mutating methods must return BOOL:
                                  #           - if falsy, throws TypeError
                                  #        - non-mutating methods must return the same return value as the underlying method
                                  #        - should return the corresponding Reflect.*(...) to get the original behavior
                                  #  - 'VAR' can be SYM
                                  #OBJ2 members follow.
                                  #Limited polyfill|ponyfill GoogleChrome 'proxy-polyfill'
Proxy.revocable(OBJ, OBJ2)        #Like new Proxy(OBJ, OBJ2) but returns OBJ3:
                                  #  - proxy PROXY
                                  #  - revoke(): make accessing OBJ3.proxy throw a TypeError

OBJ2.set(OBJ, 'VAR', VAL, OBJ3)   #OBJ.VAR = VAL
 ->BOOL                           #OBJ3 is `this` used if this is a setter
                                  #  - for own property, OBJ3 === PROXY
                                  #  - with Reflect.set():
                                  #     - def: OBJ
                                  #     - if prop is not a setter, OBJ3 is set instead of OBJ
OBJ2.get(OBJ, 'VAR', OBJ3)->VAL   #OBJ.VAR
                                  #OBJ3: like set(...) but for getter
                                  #  - with Reflect.get():
                                  #     - def: OBJ
                                  #     - if prop is not a getter, OBJ is still used (not OBJ3)
OBJ2.deleteProperty(OBJ, 'VAR')
 ->BOOL                           #delete OBJ.VAR

OBJ2.has(OBJ, 'VAR')->BOOL        #'VAR' in OBJ
OBJ2.ownKeys(OBJ)->STR_ARR        #Object.getOwnPropertyNames(OBJ) + Object.getOwnPropertySymbols(OBJ)
                                  #Must at least contain same keys as original call

OBJ2.defineProperty
 (OBJ, 'VAR', OBJ3)->BOOL         #Object.defineProperty(OBJ, 'VAR', OBJ3)
OBJ2.getOwnPropertyDescriptor
 (OBJ, 'VAR')[->OBJ3]             #Object.getOwnPropertyDescriptor(OBJ, 'VAR')
OBJ2.isExtensible(OBJ)->BOOL      #Object.isExtensible(OBJ)
                                  #Must return same value
OBJ2.preventExtensions(OBJ)->BOOL #Object.preventExtensions(OBJ)
                                  #Must return Object.isExtensible(OBJ)

OBJ2.getPrototypeOf(OBJ)          #OBJ.__proto__ or Object.getPrototypeOf(OBJ)
 ->OBJ3|null                      #Internally used by isPrototypeOf() and instanceof
OBJ2.setPrototypeOf(OBJ, OBJ3)
 ->BOOL                           #PROXY.__proto__ = OBJ3 or Object.setPrototypeOf(OBJ, OBJ3)

OBJ2.apply(OBJ, THIS, ARGS_ARR)
 ->VAL                            #OBJ(ARGS...)
OBJ2.construct(OBJ, ARGS_ARR)
 ->OBJ                            #new OBJ(ARGS...)

                                  ┌─────────────┐
                                  │   REFLECT   │
                                  └─────────────┘

Reflect.*(OBJ, ...)               #Does same thing as what Proxy OBJ2.*(PROXY, ...) proxies.
                                  #E.g. Reflect.set(OBJ, 'VAR', VAL, OBJ3) will:
                                  #  - OBJ.VAR = VAL
                                  #  - must return BOOL
                                  #Def OBJ3 is OBJ for Reflect.get|set(...)

                                  ┌─────────────┐
                                  │   MODULES   │
                                  └─────────────┘

ES MODULES DIFFERENCES ==>        #Implies 'use strict'
                                  #Variables are file-scoped
                                  #Because of those differences, must use export {} if nothing is exported, since
                                  #without import|export keyword, cannot distinguish.

export QUAL VAR = VAL[, ...]      #
export function VAR(...){...}     #
export class CLASS { ... }        #
export { VAR[ as VAR2], ... }     #Specific VAR ("named export")
export { VAR as default, ... }
export default VAL                #Default VAR ("default export"). Is just a named export called "default".
export {}                         #Do not export anything (i.e. not an empty object)
export {} from "MDL"
export {...} from "MDL"
export ... from "MDL"             #Same as import ... from "MDL", then multiple export

import { VAR[ as VAR2], ... }
 from "MDL"                       #Specific VAR
import * as VAR2 from "MDL"       #All VARs, including "default"
import { default as VAR2, ... }
 from "MDL"
import VAR[, ...] from "MDL"      #"default" VAR. Can be combined, e.g. import VAR, {...} from "MDL"
import {} from "MDL"
import "MDL"                      #Do not import the variable, just execute the file

import("MDL")->>OBJ               #As opposed to above, not static (dynamic), i.e. does not have to be top-level
                                  #If default export, defined in OBJ.default

import ... "MDL"
 with { VAR: "VAL", ... }
import("MDL",              18.20.5#Adds information about import using VAR: VAL
 {with: {VAR: "VAL", ...}})18.20.5#Most VAR is host-specific, but the following are standard:
 ->>VAL                    18.20.5#  - type 'json': file format is JSON
                           18.20.5#     - default import only

import {"VAR" as VAR2, ...}
 from "MDL"
export {VAR2 as "VAR", ...}
 ...                            *~#Arbitrary export names. Only useful when importing|exporting from non-JavaScript, e.g. WASM

CIRCULAR DEPENDENCIES ==>         #Accessing circular import during file loading throws an error.
                                  #But accessing them later works.
                                  #Accessing other non-circular imports also works.

import.meta.url
import.meta.resolve(STR)          #See DOM doc

import PHASE ... "MDL"          *~#PHASE can be:
import.PHASE("MDL")->>OBJ       *~#  - 'source': source code
                                *~#  - 'defer': see below

import defer * as OBJ from "MDL"*~#Make IO request, parse top-level code, but only execute it once OBJ is being accessed
                                *~#Noop if MDL uses top-level await

<script>
  type="module"                   #Must be specified in browser to use modules.
                                  #Each import creates an async request
                                  #To avoid long loading time, should preload each file with
                                  #  <link rel="modulepreload" href="FILE">

[export] module MDL { ... }     *~#Declare a module inline.
                                *~#Behave like declaring module in a separate file in terms of scope
                                *~#   - except import.meta.url is same
module { ... }                         *~#Same but anonymous
                                       *~#Return its 'MDL'
