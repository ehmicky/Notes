
              
   JAVASCRIPT  
              



VERSION ==>                                     #Standard is called ECMAScript. JavaScript and ActionScript are dialects.
                                                #This doc shows strict mode only

SUPPORT ==>                                     #Use this notation for new features:
                                               ~#  - stage 3 proposal
                                            NUM*#  - introduced by Node NUM.*.* (starting at Node 12.20.0)
                                               *#  - not Node 16.6.1
                                               -#  - not all supported web browsers
                                               |#  - a core Babel plugin exists (only documented if lacks Node/browser support)
                                              ||#  - a non-core Babel plugin exists
                                             |||#  - a polyfill/ponyfill exists
                                                #Only document|use features in stage >= 3
                                                #Can look at support with:
                                                #  - EcmaScript kangax compat-table
                                                #  - http://node.green/

MAIN PRINCIPLES ==>                             #Case-sensitive. Whitespaces are ignored.
                                                #Type: weak, dynamic, generic, late/duck.
                                                #Lexical-scope
                                                #Functional (first-class functions)
                                                #Object-oriented (prototype-based)
                                                #Imperative (structures close to C)
                                                #Need a host environnement (e.g. browser) for I/O
                                                #Memory management: garbage collection.

EXECUTION ==>                                   #Each browser has own JavaScript engine, which was in the past interpreted,
                                                #but now is byte-compiled or compiled:
                                                #  - Chakra (IE9+)
                                                #  - SpiderMonkey (Firefox)
                                                #  - V8 (Chrome, Opera 12.15+)
                                                #  - SquirrelFish (Safari)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ASYNC             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EVENT LOOP ==>                                  #Loops:
                                                #  - each event loop loops through [macro]tasks
                                                #  - each macrotask loops through microtasks|tick
                                                #  - each microtask is run synchronously

NEW TASKS ==>                                   #The following create each of them:
                                                #  - each thread has a single event loop
                                                #     - creates a new thread: WEBWORKER, cross-origin <iframe>, CHILDPROCESS
                                                #  - macrotasks are created by I/O code, which includes:
                                                #     - setTimeout|Interval|Immediate()
                                                #     - filesystem, network or OS calls
                                                #        - not streams on their own
                                                #     - event handlers triggered by browser interaction.
                                                #       Events triggered directly through JavaScript, which include
                                                #       Node.js EVENTEMITTER, are sync.
                                                #  - microtasks are created by:
                                                #     - process.nextTick()
                                                #     - queueMicrotask()
                                                #     - PROMISE.then|catch() callbacks
                                                #     - priority:
                                                #        - first-in first-out
                                                #        - process.nextTick() before other types of microtasks
                                                #           - e.g. if a process.nextTick() create a new process.nextTick(),
                                                #             it will be fired before pending PROMISE microtasks

PERFORMANCE ==>                                 #For Node.js:
                                                #  - minimal time of a macrotask is 1ms.
                                                #    I.e. a macrotask that only does setTimeout(..., 0) will last 1ms
                                                #  - there is no minimal time for a microtask

SINGLE-THREADED ==>                             #Each event loop is single-threaded:
                                                #  - i.e. only one microtask and one macrotask runs at any time
                                                #Resources:
                                                #  - I/O-intensive tasks:
                                                #     - are the slowest
                                                #     - should yield the thread and be woken up on a new macrotask
                                                #     - this is what most I/O functions do by default, i.e. I/O calls are
                                                #       optimally handled
                                                #     - i.e. developer just need to use async I/O functions
                                                #  - CPU-intensive tasks:
                                                #     - will hold the whole thread
                                                #     - if too slow, should spawn a new thread instead
                                                #  - memory consumption:
                                                #     - is very low, because thread and processes is what makes memory go high

ASYNC EXPECTATION ==>                           #Libraries exposing callbacks should trigger them in a new microtask,
                                                #because this what consumers usually expect.
                                                #  - e.g. this would otherwise be problematic:
                                                #     let VAR = FUNC(CALLBACK); VAR.on('start', ...)

THREAD EXIT ==>                                 #Thread exits when the event loop has no more macrotasks
                                                #In a browser, this never happens, as there are always DOM event listeners.
                                                #In Node.js:
                                                #  - this means any of the following will keep the thread running:
                                                #     - process.nextTick(), queueMicrotask(), setTimeout|setInterval()
                                                #     - PROMISE.then|catch() FUNC, await PROMISE
                                                #     - TCPSERVER.ref(), CHILDPROCESS.ref(), and anything higher
                                                #  - some I/O objects expose unref() methods to yield the macrotask

ASYNC STACK TRACE ==>                           #Also called "long stack trace"
                                                #When using async, the callback function does not include stack trace from parent function
                                                #  - because it is processed on different microtask
                                                #This includes:
                                                #  - setTimeout|Interval|Immediate(FUNC), process.nextTick(FUNC), queueMicrotask(), promise.*()
                                                #  - any code after an await statement (but not before)
                                                #     - stack trace starts at async function where await statement is (which is
                                                #       better than promises which start at promise.*() function)
                                                #  - filesystem, network, OS or browser interaction event handlers
                                                #However, this is supported:
                                                #  - only for async|await and Promise.all()
                                                #     - not for Promise[.resolve|reject()], Promise.race() nor anything else
                                                #  - supported in Chrome dev tools (but not in ERROR.stack without using a library)
                                                #  - see my async stack trace documentation


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SCOPE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GENERAL ==>                                     #  - variable scope is:
                                                #     - "var": function() {...}
                                              -|#     - "let|const": any {...}
                                                #  - any function inherits scope of the function in which it is declared
                                                #    (not fired)
                                                #     - inherits by reference, not by value
globalThis                                    -|#Global scope reference
                                              -|#Otherwise can be in many places (self in WORKER, window in DOM, global in Node.js, this otherwise)
                                              -|#Polyfill|ponyfill ljharb 'globalThis'

DECLARATION ==>                                 #  - using undeclared VAR throws ReferenceError (except with typeof)
                                                #  - using VAR (even if declared in parent scope) declared later in
                                                #    current scope with:
                                              -|#     - "let|const": throws ReferenceError ("Temporal Dead Zone")
                                                #     - "var": adds an implicit empty declaration before, i.e. will be
                                                #       undefined (variable hoisting)
                                                #     - function FUNC(){}: adds an implicit declaration+assignment before

DECLARING FUNCTIONS ==>                         #  - FUNC = function [FUNC2](){}
                                                #     - declared+assigned at runtime (like other variables)
                                                #     - this also covers anonymous function, and void function [FUNC2](){}
                                                #     - Using "FUNC2":
                                                #        - equivalent of doing let FUNC2 = function(){} at the beginning of
                                                #          the same function
                                                #        - allow recursion to reference themselves without risk of parent
                                                #          scope to reassign FUNC2
                                                #  - function FUNC2(){}:
                                                #     - declared+assigned at parsetime
                                                #        - i.e. equivalent of doing let FUNC2 = function () {} at {...} scope
                                                #          beginning
                                                #  - new Function(...): child of global scope

MEMORY MANAGEMENT ==>                           #Garbage collection:
                                                #  - use tracing, i.e. no problem with reference cycles
                                                #  - root objects are global variables
                                                #  - closures carry references to their parent scope, but only of the
                                                #    references they use
                                                #     - this might be problematic when closures are returned, i.e. go up the
                                                #       stack, extending their parent scope lifetime
                                                #Memory leak happens with combination of variables being:
                                                #  - big, e.g.:
                                                #     - functions carrying parent SCOPEs
                                                #     - big objects
                                                #     - raw data returned from server
                                                #  - long-lived, e.g.:
                                                #     - attached to top/long-lived SCOPEs, e.g. global variables, e.g.:
                                                #        - long-lived DOM elements
                                                #        - global functions (e.g. global event handlers, setInterval(), ...)
                                                #Avoiding:
                                                #  - unset variables just after being used if they are big or attached to
                                                #    long-lived objects
                                                #     - "unset": prefer setting empty value than using "delete"
                                                #  - only use closures as argument or return value when needed

new WeakRef(OBJ)                        14.6.0*-#Keep a reference to OBJ, without preventing OBJ from being GC'd
                                        14.6.0*-#Should not rely:
                                        14.6.0*-#  - on when|whether GC happens, since this is very variable
                                        14.6.0*-#  - on it to guess when|whether GC happens
                                        14.6.0*-#For example, should not be used for resource cleanup.
                                        14.6.0*-#Should only be used as a way to prevent increasing memory usage.
                                        14.6.0*-#  - e.g. caches or weak maps
                                        14.6.0*-#  - consider using WeakMap|WeakSet if possible
WEAKREF.deref()->OBJ|undefined          14.6.0*-#Returns OBJ. undefined if OBJ was GC'd

new FinalizationRegistry(FUNC(OBJ, VAL))14.6.0*-#Same improper use warnings as WeakRef
FINALIZATION_REGISTRY.register          14.6.0*-#Calls FUNC(OBJ, VAL) when OBJ is GC'd
 (OBJ[, VAL][, VAL2])                   14.6.0*-#Keeps weak reference to OBJ|VAL2 (does not prevent it from being GC'd)
                                        14.6.0*-#Keep strong reference to VAL (i.e. should not be OBJ)
                                        14.6.0*-#VAL2 is the one to use with unregister() (can be same as OBJ)
FINALIZATION_REGISTRY.unregister
 (VAL2)->BOOL                           14.6.0*-#BOOL is whether it was registered


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         TYPES GENERAL         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPING SYSTEM ==>                               #  - weak: no type specified at Declaration
                                                #  - generic: native operators accepts any type, since each native type
                                                #    transtype to any (except OBJ->undefined|null)
                                                #  - dynamic: type is not checked at compile-time nor (since generic) run-time

AVAILABLE TYPES ==>                             #  - simple: number|boolean|string|undefined|null
                                                #  - object (TYPE): Object and its children
                                                #    - native: Object|Array|Number|Boolean|String|Error|...
                                                #    - user-defined:
                                                #      - host objects: defined by browser (e.g. DOM elements)

Boolean|String|Number|BigInt                    #Not same as boolean|string|number|bigint:
                                                #  - are objects, constructed as new TYPE([VAL])
                                                #  - but transtypes to|from simple types
                                                #     - STR|BOOL|(NUM).VAR work, because of transtype
                                                #     - not that null|undefined.VAR will throw error
                                                #Note: new Boolean|...(...) returns OBJ, whereas Boolean|...(...) returns
                                                #native type

typeof VAR                                      #Returns "boolean|string|number|bigint|symbol|undefined|object|function"
                                                #"object": includes null, excludes FUNC
OBJ.constructor                                 #Returns TYPE (read-only)
VAR instanceof TYPE                             #Returns true if VAR is instance of TYPE (of a child of TYPE), i.e.:
                                                #  - VAR.[__proto__...]constructor === TYPE,
                                                #    but without transtyping VAR if it is not an OBJ
                                                #  - VAR.[__proto__...]__proto__ === TYPE.prototype
                                                #For TYPE that are global variables (e.g. instanceof Error):
                                                #  - the caller might have a different sets of global variables than the callee
                                                #     - e.g. when using Node.js 'vm', or iframes in browser
                                                #  - should instead rely on VAR.toString()
                                                #     - e.g. Object.prototype.toString.call(VAR) === '[object Error]'
TYPE.prototype.isPrototypeOf(VAR)               #Same
TYPE[Symbol.hasInstance](VAR)->BOOL           -|#Define to override VAR instanceof TYPE

Array.isArray(VAR)->BOOL                        #Same as VAR instanceof Array, except works if current global is different
                                                #from VAR's global, e.g. if communicating between <iframe>

CHECKING TYPE ==>                               #  - boolean|string|number|bigint|symbol: typeof VAR === '...'
                                                #  - object: typeof VAR === 'object' && VAR !== null
                                                #  - null: VAR === null
                                                #  - null|undefined: VAR == null
                                                #  - undefined:
                                                #     - (VAR declared) VAR === undefined
                                                #     - (VAR maybe not declared) typeof VAR === "undefined"
                                                #       Should never be necessary:
                                                #        - useless in local scopes
                                                #        - in global scope, use global.VAR === undefined
                                                #  - ARR: Array.isArray(VAR) or VAR instanceof Array
                                                #  - Node: VAR.nodeType === 1
                                                #  - TYPE (excluding children): OBJ.constructor === TYPE
                                                #  - TYPE (including children): OBJ instanceof TYPE
                                                #  - OBJ (no parent TYPE): OBJ.constructor === Object

TYPEDETECT(VAL)->STR                           ##Returns:
                                               ##  - 'number|boolean|string|symbol|undefined|function' (like typeof)
                                               ##  - 'null'
                                               ##  - 'Object' (plain object)
                                               ##  - 'Array|RegExp|Date|Promise|[Weak]Set|Map|DataView'
                                               ##  - 'Map|Set|Array|String Iterator'
                                               ##  - 'global|Location|Document|MimeTypeArray|PluginArray'
                                               ##  - VAL[Symbol.toStringTag]
                                               ##  - TYPE from VAL.toString()->'[object TYPE]'
                                               ##Module "type-detect" (4.0.8)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         SIMPLE TYPES          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NUM                                             #Always double-precision float (binary64)
                                                #Can use TYPED_ARR for single-precision floats or 8|16|32-bits [u]ints
                                                #Radix:
                                                #  - NUM
                                                #  - 0xNUM 0XNUM
                                              -|#  - 0oNUM 0ONUM
                                              -|#  - 0bNUM 0BNUM
                                              -|#Underscores can be added:
                                              -|#  - they are ignored and meant as separators
                                              -|#  - works with any radix except octals
                                                #Operator:
                                                #  + - * / %
                                                #  -NUM
                                                #  NUM++ --NUM etc.
                                              -|#  **
                                                #  ~ & ^ | >> << >>>
                                                #  OP=  (e.g. NUM += 2 or NUM %=10)
                                                #  < <= > >=

NUMn                                        -|||#BIGINT. Infinite precision integer
                                            -|||#Behaves like NUM:
                                            -|||#  - including octal, hex, binary notations
                                            -|||#Exceptions:
                                            -|||#  - integer not double:
                                            -|||#     - / % round towards 0
                                            -|||#  - cannot use >>> nor +NUMn
                                            -|||#  - throw on JSON.stringify()
                                            -|||#  - has its own typeof, constructor
                                            -|||#Transtyping is same as NUM except:
                                            -|||#  - no implicit transtyping between NUM and BIGINT (but explicit transtyping possible)
                                            -|||#     - exception: == === != !== < <= > >=
                                            -|||#  - implicit transtyping to BIGINT throws where NUM would transtype to NaN
                                            -|||#  - no BIGINT.toFixed|toPrecision|toExponential() (since it is integer)
                                            -|||#Ponyfill 'jsbi'
BigInt.asUintN|asIntN(NUM, NUM2n)->NUM2n    -|||#Enforce max size NUM bits on NUM2n
                                            -|||#On overall, rotate to min|max value (according to NUM)

BOOL                                            #true|false
                                                #Operators:
                                                #  ! && ||

STR                                             #Can be:
                                                #  - "STR": escapes everything but " \ newline
                                                #  - 'STR': escapes everything but ' \ newline
                                              -|#  - [FUNC] `STR`: escapes everything (including newline) but ` ${ \
                                              -|#     - can include ${EXPR}
                                                #Any backslash escape, except \a, \c et \e
                                                #To include newline, can:
                                                #  - use `STR`
                                                #  - trailing backslash
                                                #  - concatenation
                                                #Operators:
                                                #  + +=
                                                #  < <= > >=: char by char, codepoint-wise
                                                #Newline:
                                                #  - OS-independent: '\n' is LF, '\r' is CR
                                                #  - OS-dependent (CR+LF on Windows, LF others): terminal|file I/O

SYM                                           -|#Symbol([STR])
                                              -|#Used as OBJ key for private members, i.e. OBJ[SYM] is like OBJ['RANDOM']
                                              -|#Operators:
                                              -|#  OBJ[SYM]

undefined                                       #Value of:
                                                #  - non-declared VAR: throw ReferenceError when used, except with typeof
                                                #  - declared but non-assigned VAR (including arguments and return value)

null                                            #Special keyword indicating emptiness


EQUALITY ==>                                    #Native types:
                                                #  - == != (transtypes)
                                                #  - === !== (does not transtype)
                                                #OBJ:
                                                #  - == === != !== (only check same reference)
Object.is(VAL, VAL2)                          -|#Same as ===, except !Object.is(+0,-0) and Object.is(NaN, NaN)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TRANSTYPING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


IMPLICIT ==>                                    #To STR:
                                                #  - BOOL|NUM|undefined|null: 'BOOL|...'
                                                #  - BIGINT: 'NUM' (not 'NUMn')
                                              -|#  - SYM: 'Symbol(VAR)' (only with String(SYM) or SYM.toString())
                                                #  - OBJ:
                                                #     - OBJ.toString|valueOf() (valueOf has priority)
                                                #       (otherwise "[object NAME]")
                                              -|#        - NAME is OBJ[Symbol.toStringTag] 'NAME':
                                              -|#          'Object|Math|JSON|Function|AsyncFunction'
                                                #        - REGEXP|DATE|ERROR: '...'
                                                #        - ARR: ARR.join(',')
                                                #        - FUNC: see FUNC.toString()
                                              -|#     - or OBJ[Symbol.toPrimitive]('string')
                                                #To NUM:
                                                #  - STR: '' 0, 'NUM' NUM (trims whitespaces), others NaN
                                                #  - BOOL: true 1, false 0
                                            -|||#  - BIGINT: TypeError
                                            -|||#     - can be explicitely converted though
                                            -|||#     - in which case, transtyped to [-]Infinity if out-of-bound
                                                #  - undefined: NaN
                                                #  - null: 0
                                              -|#  - SYM: TypeError
                                                #  - OBJ:
                                                #     - OBJ.valueOf() (otherwise NaN)
                                                #        - DATE: DATE.getTime()
                                              -|#     - or OBJ[Symbol.toPrimitive]('number')
                                            -|||#To BIGINT:
                                            -|||#  - STR: '' 0n, 'NUM' NUMn (trims whitespace), others TypeError
                                            -|||#  - BOOL|OBJ: like NUM
                                            -|||#  - NUM: like BIGINT to NUM
                                            -|||#  - undefined|null|SYM: TypeError
                                                #To BOOL:
                                                #  - STR: '' false, '...' true
                                                #  - NUM|BIGINT: 1 true, 0 false
                                                #  - undefined|null: false
                                                #  - OBJ|SYM: true
                                                #To OBJ
                                                #  - NUM|BIGINT|STR|BOOL: use Number|BigInt|String|Boolean()
                                                #     - parsers forbid NUM|BIGINT.VAR but (NUM|BIGINT).VAR is allowed
                                              -|#  - SYM: use Object()
                                                #  - undefined|null: throws error
                                                #To null|undefined:
                                                #  - null|undefined: null|undefined
                                              -|#OBJ[Symbol.toPrimitive]('default'): called when implicit type ambiguous,
                                              -|#e.g. VAL + STR or VAL == VAL2

IMPLICIT (KEEPS SAME) ==>                       #The following use implicit transtyping while keeping the value the same
                                                #(i.e. behaves like an explicit transtyping)
                                                #To BOOL: !!VAL
                                                #To NUM: +VAL, VAL*1, VAL/1, ~~VAL, VAL|0, VAL-0
                                                #To STR: VAL + ''

EXPLICIT (GENERAL) ==>                          #To BOOL: Boolean(VAL)
                                                #To NUM;
                                                #  - Number(VAL)
                                                #  - parseFloat(VAL): same but:
                                                #     - removes trailing non-numerical chars in STR
                                                #     - only understands decimal form
                                                #     - returns NaN for non-NUM|STR
                                                #  - parseInt(VAL[, NUM]): same as parseFloat() but:
                                                #     - removes decimals
                                                #     - understands decimal or hexadecimal form by default.
                                                #       If NUM, forces radix
                                              -|#  - Number.parseFloat|Int(...): same
                                            -|||#To BIGINT:
                                            -|||#  - BigInt(VAL): similar to Number(...)
                                                #To STR: String(VAL)
                                                #To OBJ: [new ]Object(VAL):
                                                #  - null|undefined -> {}
                                                #  - valueOf()->VAL
                                              -|#To SYM: impossible, except if converting to STR then using Symbol.for(STR)

EXPLICIT (SPECIFIC) ==>                         #To STR:
                                                #  - NUM:
                                                #     - NUM.toFixed|toPrecision|toExponential([NUM]): specify number
                                                #       of decimals, significant numbers or exponential notation.
                                                #     - NUM.toString(RADIX)
                                            -|||#  - BIGINT:
                                            -|||#     - BIGINT.toString(RADIX)
                                                #  - DATE:
                                                #     - DATE.toString(): "Day Mon DD YYYY HH:MM:SS TZ" (local timezone)
                                                #     - DATE.toISOString(): "YYYY-MM-DDTHH:MM:SS.SSSZ" (UTC)
                                                #     - DATE.toUTCString(): "Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
                                                #     - DATE.toDateString(): "Day Mon DD YYYY" (local timezone)
                                                #     - DATE.toTimeString(): "HH:MM:SS TZ" (local timezone)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       BASIC STATEMENTS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RESERVED WORDS ==>                              #enum, await, implements, package, protected, public, private, interface,
                                                #static

STATEMENT;                                      #; optional, but recommended in case could be interpreted as multiline

STATEMENT\                                      #Only required for multiline statements:
                                                #  - within a STR
                                                #  - if first line could be interpreted as standalone statement.

// COMMENT
/* COMMENT */

"use strict";                                   #Start strict mode:
                                                #  - i.e. strict ES6|ES7 conformance
                                                #  - allows faster optimization by browsers
                                                #  - not compatible until IE10
                                                #Applies to current and child scopes:
                                                #  - child scopes: including nested functions, anonymous functions, eval(),
                                                #    new Function(), etc.
                                                #  - but not functions declared in different scopes and called in current|child scopes
                                                #  - warning: concatenating with other scripts might put them in same scope,
                                                #    making them strict too.
                                                #  - must be before any statement (otherwise noop)
                                                #Implicit in any ES6 module (i.e. useless), but not in Node.js modules or
                                                #global scripts
                                                #In the web console, can use an anonymous function in order to use strict mode.

QUAL VAR[ = VAL]                                #Declaration. Default value is undefined.
  [, VAR2[ = VAL2]]...                          #VAR:
                                                #  - cannot be a reserved keyword
                                                #  - can contain:
                                                #     - any Unicode char with property "ID_Continue"
                                                #       (letters-like, numbers-like, diacretics)
                                                #     - $ or _
                                                #     - U+200C U+200D (zero-width space)
                                                #  - can be included as is, or using \u.... or \u{....}
                                                #  - first character must be Unicode char with property "ID_Start",
                                                #    i.e. only letters-like or $ or _
VAR = VAL;                                      #Assignation.
                                                #Returns VAL, so chain possible: VAR = VAR2 = VAL, but means VAR2 is global

[QUAL] [ VAR[ = VAL], ...[, ...ITERBL] ] = ARR-|#[QUAL ]VAR = ARR[NUM], ...
                                              -|#VAL is default value
                                              -|#Final ITERABLE is for variadic assignment
[QUAL] { KEY: VAR[ = VAL] } = OBJ             -|#[QUAL ]VAR = OBJ[KEY], ...
                                              -|#Without 'QUAL', must wrap with ({...} = OBJ)
                                              -|#VAL is default value
                                              -|#Can be { KEY: { KEY2: ... } }
                                              -|#KEY can appear several times with different VAR,
                                              -|#including { KEY: { KEY2 }, KEY: KEY }
[QUAL] { KEY[ = VAL] } = OBJ                  -|#Same as QUAL { KEY: KEY[ = VAL] } = OBJ

QUAL                                            #var|let|const
let VAR                                       -|#Like var VAR, but {} block scoped.
const VAR                                     -|#Like let VAR but read-only, i.e. throws error on assignments beyond
                                              -|#declaration
                                              -|#Is shallow: if OBJ, only OBJ is read-only, not OBJ.VAR
                                              -|#Is only for current block scope since:
                                              -|#  - function arguments imply new assignment
                                              -|#  - function return value must be assigned to be used as reference

delete OBJ.VAR                                  #Like assigning undefined except:
                                                #  - remove key as well
                                                #  - cannot be performed if non-configurable
                                                #  - can be performed if non-writable
                                                #Note: for ARR[NUM], does not modify length (like assigning undefined)
                                                #Returns true if OBJ (not OBJ.VAR) exists.

void STATEMENT                                  #Same as STATEMENT, but returns undefined
                                                #Sometimes void 0 is used as synonym of undefined (for older browsers where
                                                #undefined can be reassigned)

eval("STATEMENT...")                            #Fire STATEMENT... in current scope. Return last STATEMENT return value.
                                                #To avoid.
                                                #If argument non STR, renvoie VAL.
                                                #"VAR = VAL" does not declare anything.
                                                #Can throw SyntaxError or EvalError.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FUNC                                            #Is OBJ, so can be assigned.
Function                                        #FUNC TYPE
function [FUNC]([...]) { ... [return VAL;] ... }#Declare and returns FUNC.
                                                #See "Scope" above.
[new ]Function(['...',]'...')                   #Same as function(...) { ... } but:
                                                #  - scope will be child of global scope.
                                                #  - body is STR can be dynamically created. Can create injection risk.
                                                #Use only if really necessary.

(...) => {...}                                -|#Same as (function(...) {...}).bind(this), except:
                                              -|#  - arguments|super|new.target refer to current function's
                                              -|#  - no FUNC.prototype, i.e. cannot be inherited or used as constructor
(...) => VAL                                  -|#Same as (...) => { return VAL; }
                                              -|#To return an OBJ, wrap in ({...})
ARG => {...}                                  -|#Same as (ARG) => {...}

PARAMETERS ==>                                  #  - positional
                                                #  - extra parameters do not fire exceptions
                                                #  - non-OBJ are passed by value, but OBJ always by reference:
                                                #     - including in assignment
                                                #     - left-hand value keeps reference to right-hand value, but not inverse
                                                #        - i.e. assigning to an OBJ argument removes precedent reference:
                                                #            function(OBJ){ OBJ = OBJ2 }     // Removes OBJ reference
                                                #            function(OBJ){ OBJ.VAR = VAL }  // Keep OBJ reference
                                              -|#  - can use trailing commas
                                              -|#  - VAR = VAL: default value:
                                              -|#     - can refer to previous parameter of same function.
                                              -|#     - VAL is evaluated at each function call, not at declaration,
                                              -|#       in its own child scope.
                                              -|#     - explicitely passing undefined gets the default value
                                              -|#     - does not have to be last parameters, but makes more sense
                                              -|#  - ...ARR: variadic args
                                              -|#  - {...}: assigns {...} = OBJ
                                              -|#     - including { [...] ...OBJ [...] } = OBJ2
                                              -|#  - [VAR...]: assigns ARR = [VAL...]
arguments                                       #Readonly ARRAYLIKE containing currently passed arguments.

FUNC([VAL]...)                                  #Fire FUNC and returns its return value
                                              -|#Can be ...ITERABLE, replaced by NEXT...
                                              -|#Can use trailing commas

FUNC?.(...)                            14.0.0*-|#Like FUNC == null ? undefined : FUNC(...)
                                       14.0.0*-|#Does not work with new FUNC?.(...)
OBJ?.FUNC(...)                         14.0.0*-|#Like OBJ == null ? undefined : OBJ.FUNC(...)

FUNC.length                                     #Number of required arguments

FUNC.name                                     -|#Is:
                                              -|#  - function NAME (...) {...} -> 'NAME'
                                              -|#  - { NAME() {...} } -> 'NAME'
                                              -|#  - (...) => {...} -> ''
                                              -|#  - function (...) {...} -> ''
                                              -|#  - NAME = FUNC -> FUNC.name || NAME
                                              -|#  - { NAME: FUNC } -> FUNC.name || NAME
                                              -|#  - OBJ.VAR = FUNC -> FUNC.name
                                              -|#Prepends:
                                              -|#  - "bound " if FUNC.bind()
                                              -|#  - "get|set " if getter|setter
                                              -|#If NAME is SYM -> '[STR]' with STR from Symbol(STR)
                                              -|#Might be changed by minifiers (e.g. done by default by Uglify, although there
                                              -|#is an option)
                                              -|#Used in stack trace of ERROR or debuggers
                                              -|#Read-only, but configurable (so can Object.defineProperty() the value).
FUNC.toString()                                 #Function declaration, can be eval'd()
                                               -#I.e. either:
                                               -#  - 'function[*] [NAME] (...) {...}'
                                               -#  - '(...) => {...}' or ARG => VAL (or mixed of both) if arrow function
                                               -#  - '[get|set] [*]NAME(...) {...}' if member function
                                               -#  - 'class [CLASS] {...}' if CLASS
                                               -#  - 'function anonymous(ARG...\n) {...} if new Function()
                                                #If native function, will contain "[native code]"

this                                            #OBJ if current function fired as OBJ.FUNC(), otherwise null|undefined
                                                #Read-only
                                                #Notes:
                                                #  - FUNC2 = OBJ.FUNC or FUNC3(OBJ.FUNC)
                                                #     - must OBJ.FUNC.bind(OBJ) to keep "this"
                                                #  - OBJ = new FUNC(); calls FUNC.call(OBJ)
FUNC.bind(VAL[, ...])                           #Returns FUNC, but binds "this" to VAL (except if called with 'new'),
                                                #and first arguments to ...
                                                #Cannot rebind.
FUNC.call(VAL[, ...])                           #Same as FUNC.bind(VAL[, ...])()
FUNC.apply(VAL[, ARR])                          #Same but using an ARR instead of comma-separated arguments.
                                                #Often used to forward to another function: FUNC.apply(this, arguments)

VAR = FUNC([...]); return VAR;              *||-#Two examples of a tail call optimization:
return FUNC([...]);                         *||-#  - the last FUNC() performed before "return" (besides assignments)
                                            *||-#    (includes FUNC like native operators)
                                            *||-#This will optimize FUNC() call:
                                            *||-#  - faster, because optimizer can replace call stack current frame instead
                                            *||-#    of adding to it
                                            *||-#  - allow infinite recursion


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OBJECTS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[new ]Object()                                  #Base TYPE of all OBJ

OBJ.VAR                                         #Access property (can be any type)
OBJ['VAR']                                      #OBJ.VAR has same naming restrictions as QUAL VAR, except can be a reserved word
                                                #OBJ['VAR'] can use any valid STR

OBJ?.VAR                               14.0.0*-|#Like OBJ == null ? undefined : OBJ.VAR
OBJ?.['VAR']                           14.0.0*-|#Like OBJ == null ? undefined : OBJ['VAR']

{ VAR[: VAL] ... }                              #Literal OBJ.
                                                #If could be interpreted as a { ... } structure (e.g. beginning of line),
                                                #wrap with ()
                                                #VAR can either:
                                                #  - be "VAR" or 'VAR': any valid STR
                                                #  - be unquoted, with same naming restrictions as QUAL VAR except:
                                                #     - can be reserved keywords
                                                #     - can be any NUM, which will be converted to STR
                                              -|#Def VAL is VAR
                                              -|#VAR can be [STR], for dynamic property name
                                              -|#If duplicate key, the last one will overwrite the ones before.
{ FUNC() {...} ... }                          -|#Same as { FUNC: function FUNC() {...} ... }

ITERATING OVER PROPERTIES ==>                   #              +-------------------------------+---------------------------+
                                                #              | Own                           | Own+shared                |
                                                # +------------+-------------------------------+---------------------------+
                                                # | enum       |Object.keys(OBJ)               | for (QUAL VAR in OBJ)     |
                                                # +------------+-------------------------------+---------------------------+
                                                # | [non-]enum |Object.getOwnPropertyNames(OBJ)| 'VAR' in OBJ              |
                                                # +------------+-------------------------------+---------------------------+

PROPERTIES ORDER ==>                            #Guaranteed to be in that order:
                                                #  - 'NUM', sorted numerically
                                                #  - STR, sorted by creation time
                                                #  - SYM, sorted by creation time

Object.keys(OBJ)                                #Returns own keys, excluding non-enumerable
Object.values(OBJ)                            -|#Same as Object.keys() but for values
Object.entries(OBJ)                           -|#Same as Object.keys() but for [KEY, VALUE]

Object.fromEntries(ITERABLE)                  -|#Inverse Object.entries(), i.e. from ITERABLE of [KEY, VALUE] to OBJ
                                              -|#As opposed to Object.entries(), KEY that SYM are not skipped

Object.getOwnPropertyNames(OBJ)                 #Returns own keys, including non-enumerable
OBJ.propertyIsEnumerable('VAR')                 #Returns true if OBJ['VAR'] is in Object.keys()
OBJ.hasOwnProperty('VAR')                       #Returns true if OBJ['VAR'] is in Object.getOwnPropertyNames()
Object.hasOwn(OBJ, 'VAR')                   *-|~#Same

'VAR' in OBJ                                    #Returns true if OBJ['VAR'] is member, including shared or non-enumerable.
                                                #Negation: !('VAR' in OBJ)
                                                #Note: for (QUAL STR in OBJ) includes shared, but excludes non-enumerable
#PROP in OBJ                           16.5.0*-|#Returns true if OBJ has private #PROP

Object.assign(OBJ[, OBJ2...])                 -|#Shallow copy of own enumerable OBJ2 members to OBJ, which is returned.
                                              -|#Also copies SYMs.
                                              -|#If OBJ2 has descriptors, they will be normalized in copy, i.e.
                                              -|#configurable|writable true, and remove getters|setters.
{ [...] ...OBJ2 [...] }                       -|#Same as Object.assign({}, OBJ2, ...)
                                              -|#Exception: descriptors setters are not triggered

[QUAL] { [...] ...OBJ } = OBJ2                -|#Does Object.assign(OBJ, OBJ2), except the parts mentioned in ...

OBJ.FUNC                                        #Since OBJ.* can be overriden, can avoid shadowing by using
                                                #Object.prototype.FUNC.call(OBJ, ...) instead of OBJ.FUNC(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      OBJECT DESCRIPTORS       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


{ get|set VAR: FUNC() ... }                     #Like { VAR: FUNC() } followed by Object.defineProperty()
                                                #with configurable|enumerable true and writable false

Object.defineProperty(OBJ, 'VAR', OBJ2)         #Assign OBJ['VAR'] = VAL, where VAL depends on OBJ2 ('descriptors'):
                                                #  - either:
                                                #     - value VAL (def: undefined)
                                                #     - get()->VAL and set(VAL), fired at OBJ.VAR and OBJ.VAR = VAL
                                                #  - enumerable BOOL (def: false): if false, not listed by Object.keys(),
                                                #    OBJ.propertyIsEnumerable() and for (QUAL STR in OBJ)
                                                #  - configurable BOOL (def: false):
                                                #     - if false, throws TypeError if:
                                                #        - delete OBJ.VAR
                                                #        - change configurable|writable|enumerable
                                                #     - get|set() are often non-configurable
                                                #  - writable BOOL (def: false):
                                                #     - if false, thtows TypeError if OBJ.VAR = VAL
                                                #        - but can still Object.defineProperty() if configurable.
                                                #     - not possible with get|set()
                                                #When fired several times, each call only overwrite the specified descriptors.
Object.defineProperties(OBJ, OBJ3)              #Same but using OBJ3 { 'VAR': OBJ2 ... } instead.
Object.getOwnPropertyDescriptor(OBJ, 'VAR')     #Returns OBJ.VAR descriptor OBJ2 (even if not declared through
                                                #Object.defineProperty()), if own [non-]enum member.
Object.getOwnPropertyDescriptors(OBJ)         -|#

Object.preventExtensions(OBJ)                   #Make OBJ non-extensible (non-writable for new properties and __proto__,
                                                #throwing TypeError)
                                                #Not recursive.
Object.isExtensible(OBJ)                        #

Object.seal(OBJ)                                #Make OBJ non-extensible, non-configurable
                                                #Not recursive.
Object.isSealed(OBJ)                            #

Object.freeze(OBJ)                              #Make OBJ non-extensible, non-configurable, non-writable (except get|set())
                                                #Not recursive.
Object.isFrozen(OBJ)                            #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          INHERITANCE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OBJ.__proto__                                   #When OBJ.VAR is not defined:
Object.getPrototypeOf(OBJ)                      #  - tries OBJ.__proto__.VAR
                                                #     - if OBJ.__proto__
                                                #     - then tries OBJ.__proto__.__proto__.VAR, etc. (prototype chain)
                                                #     - Object.prototype.__proto__ === null
                                                #  - by convention, each __proto__ points to a TYPE.prototype
                                                #    (first TYPE, then TYPE_PARENT, etc.)
                                                #Object.getPrototypeOf() is more standard.
Object.setPrototypeOf(OBJ, VAL)               -|#Same as OBJ.__proto__ = VAL (to avoid because performance issues)
Object.create(TYPE.prototype[, OBJ])            #Returns OBJ2 { __proto__: TYPE.prototype }, then calls Object.defineProperties(OBJ2, OBJ)
                                                #Can use null as first argument:
                                                #  - this means OBJ will not have builtin OBJ methods
                                                #     - i.e. should never do OBJ.BUILTIN_FUNC(...) but Object.prototype.BUILTIN_FUNC.call(OBJ, ...)
                                                #     - for hasOwnProperty|isPrototypeOf|propertyIsEnumerable() and
                                                #       toString|valueOf() (including STR|NUM|BIGINT transtyping)
                                                #  - goals:
                                                #     - preventing prototype pollution (security)
                                                #     - semantically mean the OBJ is a map. Should use MAP instead
FUNC.prototype.constructor                      #Returns FUNC
new TYPE[(...)]                                 #Does:
                                                #  var OBJ = Object.create(TYPE.prototype);
                                                #  var ret = TYPE.call(OBJ, ...);
                                                #  return ret == null ? OBJ : ret;
                                                #Avoid returning in constructor (child constructor would not be able to inherit
                                                #own members)
                                                #By convention TYPE starts with uppercase
                                                #Requires:
                                                #  - TYPE.prototype OBJ: contains shared members
                                                #  - TYPE.prototype.constructor === TYPE: for type information (optional)
new.target                                    -|#In TYPE(), === TYPE (i.e. this.constructor). Otherwise undefined.
                                              -|#In CHILD_TYPE(), === CHILD_TYPE

INHERITANCE ==>                                 #Prototype-based, using either:
                                                #  - own members:
                                                #     - accessed directly on OBJ:
                                                #        - TYPE(...) assigning this OBJ (or returning OBJ (to avoid))
                                                #     - inheritance: children constructor fire parent constructor
                                                #     - created each time new TYPE(...) is fired
                                                #        - i.e. one object per instance
                                                #  - shared members:
                                                #     - accessed|inherited through prototype chain
                                                #     - created once declaration-time
                                                #        - i.e. single reference for all instances
                                                #Example:
                                                #  function TYPE(...) {
                                                #    TYPE_PARENT.apply(this[, ...])
                                                #    this.VAR = ...; ...
                                                #  }
                                                #  TYPE.prototype = Object.create
                                                #    (TYPE_PARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE

STATIC MEMBERS ==>                              #Own members of TYPE itself, i.e. TYPE.VAR = VAL:
                                                #  - not inherited (unless using Backbone extend())
                                                #  - must be called on TYPE itself, not an instance

class [TYPE] [extends TYPE_PARENT] {          -|#Other syntax to define inheritance, defining let TYPE = FUNC:
  [constructor(...) { ... }]                  -|#  - extends TYPE2:
  [static] FUNC(...) { ... }                  -|#      constructor() -> function TYPE():
}                                             -|#       - must call super(...) before assigning to this
                                              -|#       - by def: constructor(...args) { super(...args) }
                                              -|#      TYPE.prototype = Object.create(TYPE2.prototype)
                                              -|#      TYPE.prototype.constructor = TYPE (non-enumerable)
                                              -|#      TYPE.__proto__ = TYPE2
                                              -|#      Inherits static members too.
                                              -|#  (non-static)
                                              -|#  - TYPE.prototype.FUNC = FUNC (non-enumerable)
                                              -|#  (static)
                                              -|#  - TYPE.FUNC = FUNC (non-enumerable)
                                              -|#TYPE has same naming restrictions as let TYPE = FUNC
                                              -|#Throw error if not called with new.
                                              -|#No comma between definition members.
                                              -|#Returns TYPE
                                              -|#TYPE_PARENT can be a value, not only an identifier
class ... {
  VAR[ = EXPR][, ...];                        -|#Calls this.VAR = EXPR in constructor, in beginning, just after super()
                                              -|#VAR can [STR]
  static VAR[ = EXPR][, ...];                 -|#Calls TYPE.VAR = EXPR right-away (in EXPR, this is TYPE)
  [static] #VAR[ = EXPR][, ...];       14.6.0*-|#Like VAR = EXPR and FUNC(...), except can only be refered to inside class,
  #FUNC(...) { ... }                   14.6.0*-|#i.e. using this.#VAR and this.#FUNC(...). Not inherited.
}                                             -|#Can only be declared during class declaration.

super                                         -|#Inside class {...}, same as TYPE_PARENT

UTIL.inherits(TYPE, TYPE_PARENT)               ##For Node.js:
                                               ##  TYPE.prototype = Object.create(TYPE_PARENT.prototype);
                                               ##  TYPE.prototype.constructor = TYPE;
                                               ##  TYPE.super_ = TYPE_PARENT;
                                               ##So setup shared members, and allow TYPE constructor to call parent constructor
                                               ##using this.constructor.super_.apply(this, arguments);

MULTIPLE INHERITANCE ==>                        #For:
                                                #  - own members: call several parent constructors in TYPE()
                                                #  - shared members: use mixins, i.e. assign TYPE_PARENT.prototype.* to
                                                #    TYPE.prototype.* instead of using prototype chain.

USING EXTEND ==>                                #Basic extend() (like jQuery, Underscore, not like Backbone) are sometimes used
                                                #for inheriting shared members. They help for mixins (see above). However:
                                                #  - if does not include shared members (like Lodash), will not inherit
                                                #    grandparents
                                                #    members (unless copied to parent)
                                                #  - TYPE_PARENT.prototype.VAR will be copied, not referenced, if it is
                                                #    native type

NATIVE OBJECTS INHERITANCE ==>                  #Native objects constructors return a value instead of assigning to this.
                                                #So inheriting not possible, but can extend prototype (to avoid though).
                                                #new TYPE() vs TYPE():
                                                #  - Object|Array|Function|RegExp: no difference
                                                #  - String|Boolean|Number: without new, returns native type
                                                #  - Date: without new, returns DATE.toString()
                                                #  - Error: same except stack trace (prefer new Error)
                                                #  - ArrayBuffer: mandatory new
                                              -|#Can however use class ... extends syntax to extend native objects.

TYPE[Symbol.species]()->TYPE2                 -|#To override TYPE construcor used to create empty new objects.
                                              -|#Used e.g. by ARR.concat|filter|map|slice|splice(), STR.split(REGEXP)
                                              -|#or PROMISE.then ()
                                              -|#E.g. if TYPE deriving from Array, TYPE.map() will return TYPE not ARR,
                                              -|#unless this is used


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            SYMBOLS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


QUAL SYM = Symbol([STR])                      -|#Same as OBJ["RANDOM"], semantically for private members:
OBJ[SYM]                                      -|#  - STR optional, just used for toString() description
                                              -|#    OBJ[Symbol(STR)] !== OBJ[STR]
                                              -|#  - Symbol() != Symbol(), so avoid naming collisions
                                              -|#  - not enumerable:
                                              -|#     - getOwnPropertyNames() -> getOwnPropertySymbols()
                                              -|#     - Object.keys|getOwnPropertyNames() or '... in OBJ' will not
                                              -|#       show symbols.
                                              -|#  - properties with a key of SYM will be ignored by JSON.stringify()
                                              -|#Also used as "well-known symbols":
                                              -|#  - methods to define on TYPE[Symbol.VAR] to emulate native type behavior
                                              -|#    (e.g. Symbol.iterator)
                                              -|#  - when printed, abbreviated to @@VAR
SYM.description                               -|#STR from constructor

Symbol.for(STR)                               -|#Like Symbol(STR), except register it to a global store using STR as a key,
                                              -|#so that Symbol.for(STR) === Symbol.for(STR)
Symbol.keyFor(SYM)                            -|#Returns STR if SYM was created as Symbol.for(STR), undefined otherwise.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          STRUCTURES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SINGLE LINE ==>                                 #Block braces can be skipped if only on single next line (to avoid)

VAL                                             #Anything that returns a VAL
EXPR                                            #Anything that could go on a single line of code ending with ;
...                                             #Several EXPR


TEST ? VAL1 : VAL2                              #Returns VAL1 or VAL2

VAL && VAL2                                     #Same as VAL ? VAL : VAL2
VAL || VAL2                                     #Same as VAL ? VAL2 : VAL
VAL ?? VAL2                            14.0.0*-|#Same as VAL == null ? VAL : VAL2

VAR &&= VAL2                           15.0.0*-|#Same as VAR = VAR && VAL2
VAR ||= VAL2                           15.0.0*-|#Same as VAR = VAR || VAL2
VAR ??= VAL2                           15.0.0*-|#Same as VAR = VAR ?? VAL2

VAL1, VAL2                                      #Evaluates both, but returns VAL2.
                                                #Use case: in for or while loops.


{ ... }                                         #Creates a scope

(VAL)                                           #To increase precedence.

if ( TEST ) { ... }
[else if ( TEST ) { ... }]...
[else { ... }]

switch (VAL) {                                  #Use VAL === VAL2
  case VAL2: ...  [break;] ...                  #If no break, execute next case (including "default")
  case VAL3: case VAL4: ...  [break;] ...       #Case can be empty, meaning several "case" match when any matches.
  [default: ...  [break;]]                      #... can be wrapped in { ... }, which creates a scope
}

for ( [EXPR1] ; [TEST] ; [EXPR2] ) { ... }      #Same as:
                                                #  EXPR1; while ( TEST ) { ...; EXPR2; }
while ( TEST ) { ... }
do { ... } while ( TEST )

for ( [QUAL] VAR in OBJ ) { ... }               #Iterate over own+shared enumerable keys.
                                                #OBJ can be ITERATOR.

break [LABEL]                                   #Stop current for|while|switch iteration or (only with LABEL)
                                                #if_else|anonymous block
                                                #Can target a specific for|while|switch iteration by specifying LABEL: before
                                                #it (to avoid), e.g. LABEL: for ... or LABEL: if ...
continue [LABEL]                                #Same but only current loop, and only for|while


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ERRORS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


throw VAL                                       #Throw exception VAL, i.e. interrupt each function in the call stack until
                                                #inside try { ... } followed by catch ( VAR ) { ... }
                                                #Thrown errors will reject parent PROMISEs and be propagated in async|await stacks
                                                #However they will stop at other top-level functions creating async context
                                                #  - e.g. setTimeout()
                                                #  - i.e. should be promisified
try { ...  }
[catch [(VAR)] { ... }]                       -|#(VAR) can be omitted
[finally { ... }]                               #finally { ... } is always fired

[new ]Error([STR])                              #OBJ usually used when throw VAL, because more info.
                                                #Prefer with "new"
                                                #STR is ERROR.message (def: "")
                                                #Some builtin ERROR thrown:
                                                #  - ReferenceError: console.log(notdeclared)
                                                #  - TypeError: null.FUNC()
                                                #  - SyntaxError: 5 *** 7
                                                #  - RangeError: new Array(Infinity)
                                                #  - URIError: decodeURIComponent('%')
                                                #  - EvalError: with eval()
ERROR.name                                      #ERROR type (def: "Error"), redefined by children.
ERROR.message                                   #
ERROR.stack                                     #Stack trace STR
                                                #Created|evaluated on new Error()
                                                #  - i.e. represents position at that moment
                                                #  - however actual stack creating code is called lazily because slightly slow
                                                #Uses FUNC.name|message on first line.
                                                #Format is dependent on the engine.
                                                #See "async" above for async stack trace
                                                #See stack trace documentation for more information on: parsing, normalizing,
                                                #beautifying, visualizing, etc.
                                                #Printed by UTIL.inspect(ERROR)
ERROR.toString()                                #'NAME: MESSAGE'


debugger                                        #Sets a breakpoint


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BOOLEAN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Boolean(BOOL)                               #Returns OBJ (see above).
Boolean(BOOL)                                   #Returns BOOL (see above)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            NUMBER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Number(NUM)                                 #Returns OBJ (see above)
Number(NUM)                                     #Returns NUM (see above)

Number.isInteger(NUM)                         -|#Does not coerce to NUM

[Number.]NaN                                    #Returned e.g. by √-1, 0/0 or wrong NUM conversion
                                                #Test:
                                                #  - NaN !== NaN but Object.is(NaN, NaN)
                                              -|#  - Number.isNaN(VAL): same as Object.is(VAL, NaN)
                                                #  - isNaN(VAL): same as Number.isNaN(Number(VAL))
[-]Infinity                                     #Returned e.g. by overflow like 1e400, or 1/0
Number.POSITIVE_INFINITY|NEGATIVE_INFINITY      #Test:
                                                #  - [-]Infinity === [-]Infinity
                                              -|#  - Number.isFinite(VAL): same as VAL !== Infinity && VAL !== -Infinity
                                              -|#    && !Number.isNaN(VAL)
                                                #  - isFinite(VAL): same as Number.isFinite(Number(VAL))
Number.MIN_VALUE                                #Closest to 0 (underflow) (about 5e-324)
Number.MAX_VALUE                                #After it is Infinity (overflow) (about 2e+308)
Number.MIN|MAX_SAFE_INTEGER                   -|#Smallest|highest integer that can be represented as a float precisely
                                              -|#(about +|-1e16)
                                              -|#Test: Number.isSafeInteger(VAL) (does not coerce to NUM)
Number.EPSILON                                -|#NUM +|- NUM2 can create small discrepancies, e.g. 0.3 - 0.1 within a
                                              -|#EPSILON range:
                                              -|#  - When comparing non-integer NUMs, should check NUM-NUM2 < +|-EPSILON
                                              -|#  - about 2e-16


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new String(STR)                                 #Returns OBJ (see above)
String(STR)                                     #Returns STR (see above)

`...${EXPR}...`                               -|#"..." + EXPR + "..."
                                              -|#Escapes everything (including " ' or newline) but ` ${ or \
FUNC`...`                                     -|#FUNC(STR_ARR, VAL...)->VAL:
FUNC `...`                                    -|#  - VAL... are each ${EXPR}
                                              -|#  - STR_ARR[.raw][NUM] are each `...` in-between, including empty ""
                                              -|#at beginning|end if starts|ends
                                              -|#    with ${EXPR}
                                              -|#    If "raw", escape backslashes
                                              -|#  - special case for backslash sequences (only if FUNC specified):
                                              -|#     - STR is undefined
                                              -|#     - escaped in STR.raw, e.g. '\\n'
                                              -|#FUNC can be String.raw(), which concanates all like normal template,
                                              -|#except it escape backslashes


STR[NUM]                                        #Read-only. undefined if out of range.
STR.charAt(NUM)                                 #Same except "" if out of range
STR.at(NUM)->'CHAR'                   16.6.0*-|~#Like STR[NUM] except -NUM is from end, and is not writable

STR.length                                      #Number of characters (not bytes)

STR.match(REGEXP)                               #Like REGEXP.exec(STR), except that if g flag, returns all matches as ARR
                                                #(or null)
STR.matchAll(REGEXP)                          -|#Returns ITERABLE that returns successive REGEXP.exec(STR)
                                              -|#I.e. as opposed to STR.match(), when using a g flag, parenthesis groups and
                                              -|#indices will be returned too
STR.search(REGEXP)                              #Like STR.indexOf() but with a REGEXP
STR.starts|endsWith|includes(STR2[, NUM])     -|#

STR.replace(REGEXP|STR2, STR3)                  #Returns STR, replacing REGEXP with STR3, which can contain:
                                                #  - $1, etc.: parenthesis group matches
                                                #  - $&: full match
                                                #  - $`: what's before full match
                                                #  - $': what's after full match
                                                #  - $$: $ literal
STR.replace(REGEXP|STR2,
 FUNC($&, $1..., INDEX, STR))                   #Returns STR, replacing REGEXP with FUNC(...)
STR.replaceAll(REGEXP|STR2, STR3)
STR.replaceAll(REGEXP|STR2,            15.0.0*-|#Same as STR.replace(...) but STR2 implies a 'g' flag.
 FUNC($&, $1..., INDEX, STR))          15.0.0*-|#If REGEXP, must have a 'g' flag.
STR.split(REGEXP|STR2[, UINT])                  #Returns an ARR, with REGEXP|STR2 being split delimiter.
                                                #If STR2 is '', means between each characters.
                                                #If REGEXP contains parenthesis groups, each is included in ARR between
                                                #each element.
                                                #If UINT, does ARR.slice(0, UINT)
STR.repeat(NUM)                               -|#

OBJ[Symbol.match](...)                        -|#Methods to implement to be able to use STR.match(OBJ)
                                              -|#or STR.startsWith|endsWith|includes(OBJ)
                                              -|#Implemented by REGEXP
OBJ[Symbol.replace|split](...)                -|#Methods to implement to be able to use STR.replace|split(OBJ).
                                              -|#Implemented by REGEXP
OBJ[Symbol.search](...)                       -|#Methods to implement to be able to use STR.search(OBJ).
                                              -|#Implemented by REGEXP

STR.toUpper|LowerCase()                         #
STR.trim()                                      #
STR.trimLeft|Right()                            #Remove whitespaces on left and|or right.
STR.trimStart|End()                            |#Aliases for trimLeft|Right()
STR.padStart|End(NUM[, STR2])                 -|#If STR.length < NUM, prepends|appends STR2 (def: ' ') until STR.length === NUM

STR.concat(STR2...)                             #Prefer + and +=

STR.[lastI/i]ndexOf(STR[, NUM])
STR.slice(NUM[, NUM2])                          #Like ARR
STR.substring(NUM[, NUM2])                      #Like .slice() except:
                                                #  - negative NUM2 -> 0
                                                #  - If NUM2 < NUM, swap
STR.substr(NUM[, NUM2])                         #Like .slice() except:
                                                #  - NUM can be negative (index from end)
                                                #  - NUM2 is length, not index

en|decodeURI(STR)                               #Percent-encode any character not permitted in URIs, i.e. anything but:
                                                #  [:alnum:] - . _ ~ ! ' ( ) * # : ? & = + $ ; , / @
                                                #Should be used for full URIs
                                                #Uses UTF-8
                                                #decodeURI() can throw URIError
en|decodeURIComponent(STR)                      #Same but also percent-encode characters that might have semantics in
                                                #URIs parts:
                                                #                              # : ? & = + $ ; , / @
                                                #I.e. does not percent-encode the following (should escape if it has semantics
                                                #for specific case):
                                                #  [:alnum:] - . _ ~ ! ' ( ) *
                                                #Should be used for URI parts
[un]escape(STR)                                 #Like en|decodeURIComponent() but using a different set of what's considered URI part:
                                                #                  ~ ! ' ( )   # : ? & =   $ ; ,
                                                #I.e. does not percent-encode the following:
                                                #  [:alnum:] - . _           *           +       / @
                                                #Also, Unicode chars percent encoded as %uUUUU, not a series of %XX
                                                #Deprecated


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            UNICODE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


\uCODEPOINT_HEXA                                #CODEPOINT:
                                                #  - for all Unicode <=FFFF
                                                #  - considered a single char by all methods
\u{S_CODEPOINT_HEXA}                          -|#S_CODEPOINT:
                                              -|#  - for all Unicode
                                              -|#  - considered one or two chars depending on whether <=FFFF
                                              -|#     - exception: considered a single char by methods specifying S_CODEPOINT

String.fromCharCode(CODEPOINT...)               #
String.fromCodePoint(S_CODEPOINT...)          -|#Returns STR

STR.charCodeAt(NUM)                             #Returns CODEPOINT. If out-of-range, returns NaN.
STR.codePointAt(NUM)                          -|#Returns S_CODEPOINT. If out-of-range, returns undefined.

STR.normalize([STR2])                          -#Compose|decompose combined Unicode (e.g. with diacretics):
                                               -#  - "NFC|NFD" (def: "NFC"): compose|decompose (canonical)
                                               -#  - "NFKC|NFKD": same for compatibility form

/REGEXP/u                                     -|#  - allow . and [] to match S_CODEPOINT, not just CODEPOINT
                                              -|#     - does not work for Emojis, regional symbols and combining characters
                                              -|#  - stricter REGEXP syntax enforcement, e.g. /{/ throws
                                              -|#  - allow using \p or \P


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             INTL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OBJ.toLocaleString()                            #Same as OBJ.toString(), but can be reimplemented by children
                                                #(like OBJ.toString())
ARR.toLocaleString()                            #Same as ARR.toString() with locale commas
STR.toLocaleUpper|LowerCase()                   #Using current locale

new Intl.Locale(LOCALE, LOCALE_ARGS)           -#LOCALE_OBJ
                                               -#LOCALE_ARGS is an OBJ:
                                               -#  - are Unicode "Language tags"
                                               -#  - list: see its doc
                                               -#  - supports: ca|calendar, co|collation, hc|hourCycle, kf|caseFirst,
                                               -#    kn|numeric, nu|numberingSystem
                                               -#Def: current locale
                                               -#For Node, support must be done during building
LOCALE_OBJ.*                                   -#Anything from LOCALE_ARGS (using long name)
LOCALE_OBJ.language                            -#STR
LOCALE_OBJ.script                              -#STR
LOCALE_OBJ.region                              -#STR
LOCALE_OBJ.basename                            -#STR
LOCALE_OBJ.calendar                            -#STR
LOCALE_OBJ.caseFirst                           -#BOOL
LOCALE_OBJ.collation                           -#STR
LOCALE_OBJ.hourCycle                           -#STR
LOCALE_OBJ.numeric                             -#STR
LOCALE_OBJ.numberingSystem                     -#STR
LOCALE_OBJ.toString()->LOCALE                  -#
LOCALE_OBJ.locale                              -#Like LOCALE, but only the first part
LOCALE                                      -|||#STR serialization of LOCALE_OBJ:
                                            -|||#  - e.g. 'fr-FR'
                                            -|||#  - LOCALE_ARGS is serialized as final -u-SHORTEN_ARG-VAL
                                            -|||#  - true for current locale
                                            -|||#Polyfill|ponyfill 'intl.js'
Intl.getCanonicalLocales                    -|||#Normalize LOCALE, e.g. its case and remove duplicates
 (LOCALE[_ARR])->LOCALE_ARR                 -|||#Throws if invalid

LOCALEOPTS ==>                              -|||#Is LOCALE[_ARR][, OPTS]
                                               -#Or LOCALE_OBJ[_ARR][, OPTS]
                                            -|||#OPTS:
                                            -|||#  - depends on the method
                                            -|||#  - defaults to using CLDR with the provided LOCALE
                                            -|||#  - always has members:
                                            -|||#     - locale LOCALE
                                            -|||#     - localeMatcher 'best fit' (def) or 'lookup' (poorer algorithm)
                                            -|||#  - some members might be read-only
Intl.*.supportedLocalesOf([LOCALEOPTS])     -|||#Returns LOCALE_ARR matching LOCALEOPTS and being installed on client.

new Intl.*([LOCALOPTS])                     -|||#Returns new instance of a specific intl operation
                                            -|||#Is expensive, so should be cached
                                            -|||#Returned member always has members:
                                            -|||#  - resolvedOptions()->OPTS

Intl.supportedValuesOf(STR)->STR_ARR        *-|~#Returns all possible values for a specific Intl.* method|option
                                            *-|~#STR can be: 'currency|calendar|collation|numberingSystem|timeZone|unit'

new Intl.Collator([LOCALEOPTS])                -#Locale-specific collation.
                                               -#OPTS:
                                               -#  - usage 'sort' (def) or 'search': like co "search" LOCALE_ARGS
                                               -#  - sensitivity 'base|accent|case|variant' (def: 'variant'):
                                               -#     - case-sensitive: 'case|variant'
                                               -#     - accent-sensitive: 'accent|variant'
                                               -#  - ignorePunctuation BOOL (def: false)
                                               -#  - numeric BOOL (def: false): like kn LOCALE_ARGS
                                               -#  - caseFirst 'upper|lower' or 'false' (def, i.e. locale's): like
                                               -#    kf LOCALE_ARGS
                                               -#Relevant LOCALE_ARGS: co, kn, kf
COLLATOR.compare(STR, STR2)->NUM               -#Like STR < <= >= > STR2, except:
STR.localCompare(STR2[, LOCALEOPTS])->NUM      -#  - returns as -1|0|1
                                               -#  - real sorting, not just codepoint-wise
                                               -#  - takes locales into account

new Intl.DisplayNames([LOCALEOPTS])        14*-|#Language string translation
                                           14*-|#OPTS:
                                           14*-|#  - type STR among:
                                           14*-|#     - 'region': countries (ISO-3166, e.g. 'US' to 'United States') or world regions (UN M49 code, e.g. '419' to 'Latin America')
                                           14*-|#     - 'language' (e.g. 'fr' or 'fr-CA' to 'French' or 'Canadian French')
                                           14*-|#     - 'script' (ISO-15924, e.g. 'Latn' or 'Arab' to 'Latin' or 'Arabic')
                                           14*-|#     - 'currency' (ISO-4217, e.g. 'USD' to 'US Dollar')
                                            *-~|#     - 'calendar' (calendar name, e.g. 'gregory' to 'Gregorian Calendar')
                                            *-~|#     - 'dateTimeField' ('era|year|month|quarter|weekOfYear|weekday|dayPeriod|day|hour|minute|second'
                                            *-~|#  - languageDisplay STR:
                                            *-~|#     - when using type 'language'
                                            *-~|#     - either 'dialect' (def, 'British English') or 'standard' ('English (United Kingdom)')
DISPLAYNAMES.of(STR)->STR2                 14*-|#

new Intl.NumberFormat([LOCALEOPTS])         -|||#Number locale formatting.
                                            -|||#OPTS:
                                            -|||#  - style 'decimal|currency|percent|unit' (def: 'decimal')
                                            -|||#  - useGrouping BOOL (def: auto): throusands separators
                                          *-|||~#    Can also be:
                                          *-|||~#      - 'never|always' (like false|true)
                                          *-|||~#      - 'auto' (def): depends on locale
                                          *-|||~#      - 'min2': if at least two digits in each group
                                            -|||#  - minimum|maximumInteger|Fraction|SignificantDigits NUM
                                          *-|||~#  - roundingPriority STR:
                                          *-|||~#     - when *FractionDigits and *SignificantDigits are both specified and they
                                          *-|||~#       lead to different number of digits, decides which one has priority:
                                          *-|||~#        - 'auto' (def): *SignificantDigits
                                          *-|||~#        - 'morePrecision': one with most digits
                                          *-|||~#        - 'lessPrecision': one with least digits
                                          *-|||~#  - trailingZeroDisplay STR:
                                          *-|||~#     - whether to show fraction digits if all 0s
                                          *-|||~#     - can be 'auto' (yes, def) or 'stripIfInteger' (no)
                                          *-|||~#  - roundingMode STR:
                                          *-|||~#     - 'ceil|floor': towards +|-Infinity
                                          *-|||~#     - 'expand|trunc': away|towards 0
                                          *-|||~#     - 'halfExpand' (def) or 'halfTrunc|Ceil|Floor': closest. If half, expand|trunc|ceil|floor
                                          *-|||~#     - 'halfEven'
                                          *-|||~#  - roundingIncrement NUM
                                          *-|||~#     - among 1|2[5]|5[0[0[0]]]
                                            -|||#  - signDisplay 'auto' (def) (-1|-0|0|1), 'always' (-1|-0|+0|+1),
                                            -|||#    'never' (1|0|0|1), 'exceptZero' (-1|-0|0|+1),
                                          *-|||~#    'negative' (-1|0|0|1)
                                            -|||#  (for style 'decimal')
                                            -|||#  - notation 'standard' (def) ('987654321'), 'compact' ('988M'),
                                            -|||#    'engineering' ('987.654E6'), 'scientific' ('9.877E8')
                                            -|||#  (for style 'decimal', notation 'compact')
                                            -|||#  - compactDisplay 'short' (def) ('988M'), 'long' ('988 million')
                                            -|||#  (for style 'currency')
                                            -|||#  - currency STR (no def)
                                            -|||#  - currencyDisplay 'symbol|code|name' (def: 'symbol')
                                            -|||#  - currencySign 'standard' (def) or 'accounting' (show negative as '(NUM)')
                                            -|||#  (for style 'unit')
                                            -|||#  - unit STR among:
                                            -|||#     - acceleration-g-force|meter-per-second-squared
                                            -|||#     - angle-arc-minute|second|degree|radian|revolution
                                            -|||#     - area-acre|hectare|square-centimeter|foot|inch|kilometer|meter|mile|yard
                                            -|||#     - concentr-karat|milligram-per-deciliter|millimole-per-liter|part-per-million
                                            -|||#     - consumption-liter-per-100kilometers|kilometer|mile-per-gallon[-imperial]
                                            -|||#     - digital-[giga|kilo|mega|tera]bit|byte
                                            -|||#     - duration-century|day[-person]|hour|[micro|nano]second|millisecond|minute|month[-person]|week[-person]|year[-person]
                                            -|||#     - electric-ampere|milliampere|ohm|volt
                                            -|||#     - energy-calorie|foodcalorie|joule|kilocalorie|kilojoule|kilowatt-hour
                                            -|||#     - frequency-[kilo|mega|giga]hertz
                                            -|||#     - length-astronomical-unit|centimeter|decimeter|fathom|foot|furlong|inch|kilometer|light-year|meter|micrometer|mile|
                                            -|||#       mile-scandinavian|millimeter|nanometer|nautical-mile|parsec|picometer|yard
                                            -|||#     - light-lux
                                            -|||#     - mass-carat|[micro|milli|kilo]gram|[metric-]ton|ounce|ounce-troy|pound|stone
                                            -|||#     - power-[milli|kilo|mega|giga]watt|horsepower
                                            -|||#     - pressure-hectopascal|inch-hg|millibar|millimeter-of-mercury|pound-per-square-inch
                                            -|||#     - speed-kilometer-per-hour|knot|meter-per-second|mile-per-hour
                                            -|||#     - temperature-celsius|fahrenheit|generic|kelvin
                                            -|||#     - volume-acre-foot|bushel|cubic-centimeter|cubic-foot|cubic-inch|cubic-kilometer|cubic-meter|cubic-mile|cubic-yard|cup[-metric]|fluid-ounce|
                                            -|||#       gallon[-imperial]|[milli|centi|deci|hecto|mega]liter|pint[-metric]|quart|tablespoon|teaspoon
                                            -|||#  - unitDisplay 'narrow', 'short' or 'long'
                                            -|||#Relevant LOCALE_ARGS: nu
NUMBERFORMAT.format(ARG)->STR               -|||#ARG is NUM|BIGINT|STR
NUM|BIGINT.toLocaleString([LOCALEOPTS])->STR-|||#
NUMBERFORMAT.formatToParts(NUM|BIGINT)      -|||#OBJ_ARR:
 ->OBJ_ARR                                  -|||#  - type STR:
                                            -|||#     - 'integer|fraction': integer|fraction part of the number
                                            -|||#     - 'decimal': decimal separator
                                            -|||#     - 'group': thousands separator
                                            -|||#     - 'currency': currency string
                                            -|||#     - 'percentSign': %
                                            -|||#     - 'plusSign|minusSign': + or -
                                            -|||#     - 'infinity|nan': ∞ or NaN
                                            -|||#     - 'literal': anything else, e.g. spaces
                                            -|||#  - value STR
NUMBERFORMAT.formatRange
 (NUM|BIGINT, NUM|BIGINT2)->STR           *-|||~#Like format() but for range between two NUMs ('USD3-5')
NUMBERFORMAT.formatRangeToParts
 (NUM|BIGINT, NUM|BIGINT2)->OBJ_ARR       *-|||~#Like formatToParts() but for range. OBJ has extra member source 'startRange|endRange|shared'
NUMBERFORMAT.format[Range][ToParts]Select *-|||~#Like format[Range][ToParts](...) but returns an OBJ: string (singular), pluralForm
 (...)                                    *-|||~#similar to Intl.PluralRules

new Intl.DateTimeFormat([LOCALEOPTS])       -|||#Date|Time|Date+Time locale formatting.
                                            -|||#OPTS:
                                            -|||#  - timeZone STR (def: locale's)
                                            -|||#  - hour12 BOOL (def: locale's)
                                            -|||#  - formatMatcher 'basic' or 'best fit' (def): like localeMatcher, but for
                                            -|||#    OPTS.weekday|etc.
                                            -|||#  - weekday|era 'narrow|short|long' (no def)
                                            -|||#  - month 'numeric|2-digit|narrow|short|long' (no def)
                                            -|||#  - year|day|hour|minute|second 'numeric|2-digit' (no def)
                                            -|||#  - timeZoneName (no def) among:
                                            -|||#     - 'short'
                                          *-|||~#       or 'shortOffset': 'GMT-8'
                                          *-|||~#     - 'longOffset': 'GMT-0800'
                                          *-|||~#     - 'shortGeneric': 'PT'
                                            -|||#     - 'long'
                                          *-|||~#       or 'longGeneric': 'Pacific Time'
                                            -|||#  - timeStyle 'short' (HH:MM), 'medium' (HH:MM:SS), 'long' (HH:MM:SS Z), 'full' (HH:MM:SS ZZZZ)
                                            -|||#  - dateStyle 'short' (D/M/YY), 'medium' (MMM D, YYYY), 'long' (MMMM D, Y), 'full' (Tuesday, MMMM D, Y)
                                            -|||#Relevant LOCALE_ARGS: nu, ca
DATETIMEFORMAT.format(DATE)->STR            -|||#
DATE.toLocale[Date|Time]String([LOCALOPTS])
 ->STR                                      -|||#
DATETIMEFORMAT.formatToParts(DATE)->OBJ_ARR -|||#Same but returned as OBJ_ARR:
                                            -|||#  - type 'era|year|month|weekday|day|hour|minute|second|timeZoneName|separator'
                                            -|||#  - value STR
DATETIMEFORMAT.formatRange
 (DATE, DATE2)->STR                         -|||#Like format() but for range between two DATEs ('1/10/07, 10:00 AM – 1/20/07, 10:00 AM')
DATETIMEFORMAT.formatRangeToParts
 (DATE, DATE2)->OBJ_ARR                     -|||#Like formatToParts() but for range. OBJ has extra member source 'startRange|endRange|shared'

new Intl.RelativeTimeFormat([LOCALEOPTS])   -|||#Date|Time|Date+Time locale formatting, for relative time ("time ago")
                                            -|||#OPTS:
                                            -|||#  - style STR:
                                            -|||#     - 'long' (def) ("in 1 month")
                                            -|||#     - 'short' ("in 1 mo.")
                                            -|||#     - 'narrow' ("in 1 mo.")
                                            -|||#Ponyfill yahoo 'intl-relativeformat'
RELATIVETIMEFORMAT.format
 (NUM, STR)->STR2                           -|||#STR: 'year|quarter|month|week|day|hour|minute|second'
RELATIVETIMEFORMAT.formatToParts            -|||#OBJ_ARR:
 (NUM, STR)->OBJ_ARR                        -|||#  - type STR: like unit (e.g. "year") or "literal" (anything else)
                                            -|||#  - value STR

new Intl.PluralRules([LOCALEOPTS])             -#Locale-specific plural group of a NUM
                                               -#OPTS:
                                               -#  - type 'cardinal' (def) or 'ordinal'.
                                               -#    It's because some languages have different rules for either.
                                               -#  (read-only)
                                               -#  - minimum|maximumFraction|SignificantDigits NUM
                                               -#  - pluralCategories STR_ARR
PLURALRULES.select(NUM)->STR                   -#Returns plurality of NUM according to locale, among 'zero', 'one', 'two',
                                               -#'few', 'many', 'other'
PLURALRULES.selectRange(NUM, NUM2)->STR     *-|~#STR

new Intl.ListFormat([LOCALEOPTS])              -#Format list of items with natural language.
                                               -#OPTS:
                                               -#  - type:
                                               -#     - 'regular' (def) ("and")
                                               -#     - 'disjunction' ("or")
                                               -#     - 'unit' (only commas|spaces)
                                               -#  - style STR:
                                               -#     - 'long' (def)
                                               -#     - 'short' (use abbreviations|punctuations, no words) (only type 'unit')
                                               -#     - 'narrow' (use only spaces)
LISTFORMAT.format(STR_ARR)->STR                -#
LISTFORMAT.formatToParts(STR_ARR)->OBJ_ARR     -#OBJ_ARR:
                                               -#  - type 'element' (STR) or 'literal' (separators)
                                               -#  - value STR

new Intl.Segmenter([LOCALEOPTS])       16.0.0*-~#Break down strings into smaller parts, locale-specific.
                                       16.0.0*-~#OPTS:
                                       16.0.0*-~#  - granularity STR:
                                       16.0.0*-~#     - 'grapheme' (def): might include several chars, since accents are chars
                                       16.0.0*-~#     - 'word'
                                       16.0.0*-~#     - 'sentence'
SEGMENTER.segment(STR)->SEGMENTS       16.0.0*-~#SEGMENTS is SEGMENT_ITERABLE:
                                       16.0.0*-~#  - segment STR2
                                       16.0.0*-~#  - input STR: full input
                                       16.0.0*-~#  - index NUM: STR2 inside STR, in Unicode codepoint
                                       16.0.0*-~#  - isWordLike BOOL:
                                       16.0.0*-~#     - undefined if granularity not 'word'
                                       16.0.0*-~#     - otherwise, whether word-like (letters|numbers) or punctuation|space-like
SEGMENTS.containing(NUM)
 ->SEGMENT|undefined                   16.0.0*-~#Retrieve SEGMENT at index NUM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REGEXP             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


/PATTERN/[FLAGS]                                #Def STR: '(?:)'
[new ]RegExp(['PATTERN'[, 'FLAGS']])            #Backslashes must be escaped in the second form
                                                #Perl RegExp except:
                                                #  - no [[:CLASS:]]
                                                #  - no \< \>
                                                #  - no +-greediness
                                                #  - no additional flags
                                                #  - no \A \Z but ^ $ behave like \A \Z unless m flag
                                                #Also has:
                                              -|#  - \p \P: requires u flag
                                               -#  - (?<=) (?<!)
                                              -|#  - (?<GROUP>) \k<GROUP>:
                                              -|#     - REGEXP.exec() return value ARR also defines ARR.groups.GROUP to access those
                                              -|#     - STR.replace() accesses those using:
                                              -|#        - ${GROUP} if using a string (with normal quotes)
                                              -|#        - extra parameter groups OBJ if using a FUNC
                                                #Flags:
                                                #  - possible:
                                                #     - i: case insensitive
                                                #     - g:
                                                #        - use REGEXP.lastIndex:
                                                #           - initially 0, set to last match index (or 0 if no match)
                                                #           - next REGEXP.exec|test() will start from there
                                                #        - if using ^, if no match, returns null but set REGEXP.lastIndex
                                                #          to next match
                                                #        - function taking REGEXP as argument should iterate using
                                                #          REGEXP.lastIndex
                                                #           - this is what do standard JavaScript methods,
                                                #             e.g. STR.match|replace()
                                                #     - m: ^ $ newline-wise (otherwise whole-string-wise)
                                              -|#     - s: . whole-string-wise (otherwise newline-wise),
                                              -|#       i.e. match any character including: LF CR U+2028 U+2029
                                              -|#     - y: same as g, with ^ in beginning of PATTERN
                                              -|#     - u: see above
                                       *16.0.0-|#     - d: enable ARR.indices with REGEXP.exec()
                                                #  - available at REGEXP.ignoreCase|global|multiline|sticky BOOL
REGEXP.source                                   #'PATTERN' (read-only)
REGEXP.flags                                  -|#'FLAGS' (read-only)

REGEXP.exec(STR)                                #Search REGEXP in STR and returns ARR (or null):
                                                #  - ARR[0]: whole match
                                                #  - ARR[NUM]: parenthesis matches
                                                #  - ARR.index: first match index
                                                #  - ARR.input: STR
                                              -|#  - ARR.groups.GROUP: STR (see (?<GROUP>))
                                       *16.0.0-|#  - ARR.indices[0|NUM], ARR.indices.groups.GROUP: like ARR[0|NUM], ARR.groups.GROUP
                                       *16.0.0-|#    but as start|end indices [NUM2, NUM3] instead of STR
REGEXP.test(STR)                                #Returns BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ARRAY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Array                                           #Are actually OBJ with numeric property names, so can do ARR[NUM]
                                                #Can contain different types.
                                                #Multidimensional ARR: use ARR of ARRs
[new ]Array(NUM)                                #Returns ARR with NUM undefined values.
                                                #Throw RangeError if non-positive or decimal.
[new ]Array(VAL...)                             #Like [ VAL... ]
Array.of(VAL...)                              -|#Same as new Array(VAL...) except not interpreted as new Array(NUM) if
                                              -|#only VAL is NUM
[ [VAL...] ]                                    #Literal form.
                                                #Can use trailing commas

ARR[NUM]                                        #
ARR?.[NUM]                             14.0.0*-|#Like ARR == null ? undefined : ARR[NUM]
ARR.at(NUM)->VAL                      16.6.0*-|~#Like STR[NUM] except -NUM is from end, and is not writable

ARRAYLIKE                                       #Any OBJ which understand OBJ[NUM] and OBJ.length
                                                #Can use all ARR methods, except concat() using:
                                                #  Array.prototype.FUNC.call(ARRAYLIKE, ...) is like ARR.FUNC(...)
                                                #If expected to return ARR, returns ARR not ARRAYLIKE.
Array.from(ARRAYLIKE|ITERABLE[, ...])         -|#Returns as ARR
                                              -|#If ..., also calls ARR.map(...)
                                              -|#Can do Array.from({ length }, (_, i) => i) to get [0, 1, ...]

ARR.length                                      #Can be modified (will truncate or extend with undefined values)
                                                #Max 4 billions (32-bits).

ARR.concat(VAL...)                              #Pushes each VAL (does not modify)
                                                #If VAL is ARR2, pushes ARR2 elements, not ARR2 itself,
                                              -|#unless ARR[Symbol.isConcatSpreadable] false
ARR.slice([NUM[, NUM2]])                        #Returns ARR copy from index NUM (def: 0) to NUM2 (def: ARR.length).
                                                #NUM|NUM2 can be negative, i.e. from ARR end.
ARR.splice(NUM[, NUM2[, VAL...]])               #Erase and return NUM2 elements (def: all) from index NUM, and replace them with VAL... (def: nothing)
ARR.fill(VAL[, NUM[, NUM2]])                  -|#Same as ARR.splice(NUM, NUM2, VAL...) with VAL being repeated NUM2-NUM times.
ARR.copyWithin(NUM, NUM2[, NUM3])             -|#Copies ARR.slice(NUM2[, NUM3]) to ARR.slice(NUM, ...)
                                              -|#Returns ARR.
ARR.join([STR])                                 #Returns as STR2, with STR delimiter (def: ',')

ARR.push|unshift(VAL)                           #Adds VAL to end|beginning (modifies). Returns ARR.length
ARR.pop|shift()                                 #Remove and returns last|first element (modifies).

ARR.reverse()                                   #Modifies and returns ARR.
ARR.sort([FUNC(VAL, VAL2)->-1|0|1])             #Modifies and returns ARR.
                                                #Default FUNC does STR comparison.
                                                #Implementation algorithm detail:
                                                #  - v8 uses insertion sort if ARR.length <= 10, quick sort otherwise

ARR.indexOf(VAL[, NUM])                         #Returns VAL index, or -1. Uses ===
                                                #If NUM, skip first NUM elements (but still returns index from beginning)
                                                #Using ~VAL is shortcut for VAL !== -1, e.g. ~ARR.indexOf(VAL) is
                                                #like ARR.includes(VAL)
ARR.lastIndexOf(VAL[, NUM])                     #Same but from end.
ARR.find[Index]
 (FUNC(VAL, KEY, ARR)->BOOL[, THIS])          -|#Returns first VAL|KEY that returns true. Otherwise does not return.
ARR.find[Index]Last(...)                    *-|~#Same but from end.
ARR.includes(VAL[, NUM])                      -|#Same as ARR.indexOf(...) !== -1
                                              -|#Except NaN === NaN

ARR.forEach(FUNC(VAL, KEY, ARR)[, THIS])        #
ARR.map(FUNC(VAL, KEY, ARR)->VAL[, THIS])       #Returns [VAL...]

ARR.reduce[Right]                               #MEMO is:
(FUNC(MEMO, VAL, KEY, ARR)[, MEMO])             #  - first: argument passed (def: first value, which is then not iterated)
                                                #  - then: previous FUNC() return value
                                                #  - final return value
                                                #reduceRight iterates from end to beginning
ARR.filter(FUNC(VAL, KEY, ARR)->BOOL[, THIS])   #Excludes if false
ARR.every|some(FUNC(VAL, KEY, ARR)->BOOL[,THIS])#Returns true if all|any true.
ARR.flat([INT])                               -|#Flattens INT levels of depth (def: 1)
ARR.flatMap(...)                              -|#Same as ARR.map(...).flatten(1)

ARR.keys()                                    -|#Returns all INDEX as ITERABLETOR
ARR.values()                                  -|#Returns all VAL as ITERABLETOR (i.e. same as ARR[Symbol.iterator])
ARR.entries()                                 -|#Returns all [INDEX, VAL] as ITERABLETOR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         TYPED ARRAYS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new ArrayBuffer(UINT[, OPTS])                   #Raw data chunk. Useful for:
                                                #  - binary data
                                                #  - memory allocation performance optimization
                                                #UINT is byteLength. Filled with \0
                                                #Needs a view to be manipulated, which gives:
                                                #  - start|end indices
                                                #  - a specific type to read it
                                                #Available:
                                                #  - DATAVIEW: can change type
                                                #  - TYPED_ARR: more convenient because manipulated as an ARR
                                                #Several DATAVIEW|TYPED_ARR can be applied to a single ARRBUFFER.
                                                #OPTS:
                                            *-|~#  - maximumByteLength NUM (def: UINT)
ARRBUFFER.byteLength                            #Readonly.
ARRBUFFER.maximumByteLength                 *-|~#Readonly. Set by OPTS.maximumByteLength
                                            *-|~#Maximum size to resize() to (def: UINT)
                                            *-|~#Allocates memory right away, i.e. more efficient
                                            *-|~#Set to byteLength (not resizable) in return values of slice|transfer()
ARRBUFFER.resize(UINT)                      *-|~#Must be < maximumByteLength
ARRBUFFER.resizable                         *-|~#Readonly. BOOL. True if OPTS.maximumByteLength > UINT specified
ARRBUFFER.transfer([UINT])->ARRBUFFER2      *-|~#Returns new ARRBUFFER2 with same underlying data chunk, but potentially
                                            *-|~#different byteLength UINT (def: same, cannot be higher).
                                            *-|~#ARRBUFFER is reset (byteLength|maximumByteLength 0)
ARRBUFFER.slice(...)                            #Like ARR.slice(...)

ArrayBuffer.isView(OBJ)                         #True if DATAVIEW|TYPED_ARR

new DataView(ARRBUFFER[, UINT[, UINT2]])        #UINT is offset (def: 0), UINT2 length (def: ARRBUFFER.byteLength)
DATAVIEW.buffer|byteLength|byteOffset           #Readonly

DATAVIEW.get[Ui|I]nt8|16|32([UINT[, BOOL]])
DATAVIEW.getFloat32|64(UINT[, BOOL])            #UINT is byte offset, BOOL endianness (def: true, i.e. little endian)
DATAVIEW.getBig[Ui|I]nt64(UINT[, BOOL])       -|#
DATAVIEW.set*(UINT, UINT2[, BOOL])              #UINT2 is the value to set


TypedArray                                      #Base prototype of [Ui|I]nt8|16|32Array or Float32|64Array
                                              -|#and Big[Ui|i]nt64Array
                                                #Each have a given associated type
                                                #Not accessible globally but through prototype chain.
                                              -|#Mixes in all ARR methods:
                                              -|#  - including TYPED_ARR[NUM], TypedArray.of|from()
                                              -|#  - excluding concat(), splice(), push|pop|shift|unshift(), flat[Map]()
                                              -|#There is also a special Uint8ClampedArray, which do not 'roll' too low|high
                                              -|#values, e.g.:
                                              -|#  - UINT8_ARR[0] = -10 (246) vs UINT8_CLAMPED_ARR[0] = -1 (0)
                                              -|#  - UINT8_ARR[0] = 260 (4) vs UINT8_CLAMPED_ARR[0] = 260 (255)
new TypedArray(NUM)                             #Same as new TypedArray(new ArrayBuffer(NUM))
new TypedArray(ARRBUFFER[, UINT[, UINT2]])      #Same args as DataView
new TypedArray(TYPED_ARR2)                      #Copy
new TypedArray(ARRAYLIKE|ITERABLE)              #Uses TYPED_ARR.from(...)
                                                #Elements must be integers

TypedArray|TYPED_ARR.BYTES_PER_ELEMENT          #
TYPED_ARR.buffer|byteLength|byteOffset          #Readonly
TYPED_ARR.length                                #

TYPED_ARR.subarray(...)                         #Like slice(...) except it shares same ARRBUFFER
TYPED_ARR.set(ARR|TYPED_ARR2[, UINT])           #Sets all ARR|TYPED_ARR2 values into TYPED_ARR, starting at index UINT (def: 0)
                                                #If ARR|TYPED_ARR2 too big, RangeError thrown
TYPED_ARR.toString()                            #Is like ARR, not OBJ

REFERENCES ==>                                  #Different ARRBUFFERs always point to different data
                                                #But 2 DATAVIEW|TYPED_ARR might point to same ARRBUFFER|data
                                                #  - with: new DataView|TypedArray(ARRBUFFER), TYPED_ARR.subarray()
                                                #  - but not with: new TypedArray(NUM|TYPED_ARR2|ARRAYLIKE|ITERABLE), TypedArray.from(), TYPED_ARR.slice()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        SHARED BUFFERS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new SharedArrayBuffer(UINT)                    -#Can be used like an ARRBUFFER including:
                                               -#  - new TypedArray(...)
                                               -#  - postMessage(...)
                                               -#Except:
                                               -#  - shared between contexts|WINDOWs, e.g. when passed via postMessage()
                                               -#     - postMessage() should not use VAL2
                                               -#  - must be manipulated using Atomics.*() to ensure thread-safety:
                                               -#     - provide correct atomicity and order, underlyingly using a lock
                                               -#  - cannot be used with DataView, and no SharedArrayBuffer.isView()
                                               -#  - resize|resizable -> grow|growable (cannot shrink)

Atomics.load(S_ARRBUFFER, NUM)->VAL            -#Like S_ARRBUFFER[NUM]
Atomics.store(S_ARRBUFFER, NUM, VAL)->VAL      -#Like S_ARRBUFFER[NUM] = VAL
Atomics.exchange(S_ARRBUFFER, NUM, VAL)->VAL2  -#Like S_ARRBUFFER[NUM] = VAL, returning previous value
Atomics.compareExchange                        -#Like if (S_ARRBUFFER[NUM] == VAL3) S_ARRBUFFER[NUM] = VAL,
 (S_ARRBUFFER, NUM, VAL3, VAL)->VAL2           -#returning previous value

Atomics.add|sub|and|or|xor
 (S_ARRBUFFER, NUM, VAL)->VAL2                 -#Like S_ARRBUFFER[NUM] += -= &= |= ^= VAL, returning previous value

Atomics.wait                                   -#Wait until Atomics.notify(), providing test passes.
 (S_INT32_ARR, NUM, VAL[, NUM2])->STR          -#I.e.:
                                               -#  - if S_INT32_ARR[NUM] != VAL, does nothing (STR is "not-equal")
                                               -#  - otherwise:
                                               -#     - wait until Atomics.notify() (STR is "ok")
                                               -#     - or until timeout NUM2ms (STR is "timed-out")
Atomics.waitAsync
 (S_INT32_ARR, NUM, VAL[, NUM2])
 ->PROMISE_STR                         *16.0.0-~#Same but async
Atomics.notify(S_INT32_ARR, NUM, NUM2)         -#Wake up NUM2 workers Atomics.waiting, with same first two arguments

Atomics.isLockFree(S_ARRBUFFER, NUM)->BOOL     -#True if underlying hardware can avoid locks for S_ARRBUFFER in a typed array
                                               -#of size NUM
                                               -#Always true for NUM 4, often true for 1|2, usually false otherwise
                                               -#Used for optimization, i.e. not relying on shared buffers if underlying
                                               -#hardware is going to be slow


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           ITERATORS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ITERATOR                                      -|#OBJ with:
                                              -|#  - next([ARG]):
                                              -|#     - iterates over next value -> { done: false, value: NEXT }
                                              -|#     - if iteration finished -> { done: true, value: RETURN }
                                              -|#        - RETURN is the optional return value of the whole iteration
                                              -|#           - it is not the iteration's last value
                                              -|#           - undefined if already returned by previous next|return()
                                              -|#  - return([ARG])->{ done: true, value: RETURN }
                                              -|#     - finish iteration successfully
                                              -|#     - if iteration finished, noop and RETURN is undefined
                                              -|#     - optional
                                              -|#  - throw([ARG]):
                                              -|#     - finish iteration due to error
                                              -|#     - if iteration finished, fails
                                              -|#     - ARG is usually ERROR
                                              -|#     - optional
ITERABLE                                      -|#OBJ where OBJ[Symbol.iterator]()->ITERATOR
                                              -|#Each call returns a new ITERATOR
                                              -|#STR|[TYPED_]ARR|MAP|SET are ITERABLE (only next() is defined)
ITERABLETOR                                   -|#ITERATOR where OBJ[Symbol.iterator]()->ITERABLETOR (itself)
                                              -|#I.e. used as an ITERABLE, but always with the same ITERATOR
ASYNC_ITERATOR|ITERABLE|ITERABLETOR           -|#Same except:
                                              -|#  - next|return|throw() can return a PROMISE
                                              -|#  - Symbol.iterator -> Symbol.asyncIterator
                                              -|#Can be used as ITERATOR|ITERABLE|ITERABLETOR, but not vice-versa
                                              -|#PROMISE_ARR are ASYNC_ITERABLE

[async] function* [FUNC](){...}               -|#Generator. FUNC returns an ITERABLETOR with ITERATOR:
[class ...] { [async] * FUNC(...) {...} ... } -|#  - next([VAL]):
                                              -|#     - continue execution of function until any of:
                                              -|#        - yield NEXT -> { done: false, value: NEXT }
                                              -|#        - return RETURN -> { done: true, value: RETURN }
                                              -|#        - execution finished -> { done: true, value: undefined }
                                              -|#        - throw VAL -> propagate exception
                                              -|#     - VAL is previous "yield" return value
                                              -|#     - initially stopped at the beginning
                                              -|#        - i.e. VAL is ignored since no "yield" yet
                                              -|#  - return([RETURN])
                                              -|#     - "return RETURN" from current execution position, i.e. finish execution
                                              -|#     - if execution finished, noop and RETURN ignored
                                              -|#     - returns { done: true, value: RETURN }
                                              -|#  - throw(VAL):
                                              -|#     - "throw VAL" from current execution position
                                              -|#     - if execution finished, throw VAL from caller position
yield* ITERABLE                               -|#Like: for (const NEXT of ITERABLE) { yield NEXT }
                                              -|#Return value is ITERABLE's RETURN
yield* ASYNC_ITERABLE                         -|#Same for: for await (const NEXT of ASYNC_ITERABLE) { yield NEXT }
new [Async]GeneratorFunction(...)             -|#Like new Function(...) but for [async] function*(){}
                                              -|#[Async]GeneratorFunction not available globally, but with:
                                              -|#  Object.getPrototypeOf([async] function*(){}).constructor

for ( [QUAL] NEXT of ITERABLE ) {...}         -|#Iterates with NEXT = ITERATOR.next().value until done true
                                              -|#break|return|throw calls ITERATOR.return()
                                              -|#Does not call ITERATOR.throw()
for await (QUAL NEXT of [ASYNC_]ITERABLE)
 {...}                                        -|#Same but using await [ASYNC_]ITERATOR.next().value

[...ITERABLE]                                 -|#In ARR literal form
                                              -|#Iterates with ITERATOR.next().value until done true, then returns aggregated values as ARR
                                              -|#Does not call ITERATOR.return|throw()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          MAPS & SETS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Map([ITERABLE])                           -|#ITERABLE must iterate over [KEY, VAL] elements (e.g. Object.entries(OBJ))
                                              -|#Is an ITERABLE itself, iterating over [KEY, VAL] in insertion order.
                                              -|#To use instead of OBJ, when:
                                              -|#  - KEY must be other than STR
                                              -|#  - VALs are conceptually similar to each other

MAP.get(KEY)->VAL                             -|#Like OBJ[KEY] and OBJ[KEY] = VAL, except KEY can be any type.
MAP.set(KEY, VAL)->MAP                        -|#KEY equality uses Object.is() not ===
MAP.has(KEY)->BOOL                            -|#
MAP.delete(KEY)->BOOL                         -|#
MAP.clear()                                   -|#

MAP.size                                      -|#

MAP.keys|values|entries()                     -|#Like ARR
MAP.forEach(...)                              -|#Like ARR


WeakMap                                       -|#Like Map, except WEAKMAP does not own its children:
                                              -|#  - VAL will be garbage collected when its KEY is, whether WEAKMAP is still
                                              -|#    around or not
                                              -|#  - while MAP.set(KEY, VAL) is conceptually like MAP.KEY = VAL,
                                              -|#    WEAKMAP.set(KEY, VAL) is like KEY.__value = VAL
                                              -|#  - as such, cannot use clear|size|keys|values|entries|forEach()
                                              -|#    and is not ITERABLE
                                              -|#  - KEY must be OBJ
                                              -|#To use when passive relation to children (proxying, listening, etc.) not
                                              -|#ownership (children existing mainly as MAP properties).

Set                                           -|#Like a Map where KEY === VAL (i.e. keep unique values):
                                              -|#  - ITERABLE iterates over VAL elements, not [KEY, VAL]
                                              -|#  - entries() iterates over [VAL, VAL], keys|values() are same
                                              -|#  - no SET.get()
                                              -|#  - SET.set() -> SET.add(VAL)

WeakSet                                       -|#Like WeakMap, but for Set.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DATE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Date                                            #Milliseconds-precise. Is internally:
                                                #  - only an Epoch NUM.
                                                #  - NaN for InvalidDate
                                                #UTC vs local:
                                                #  - input:
                                                #     - local: new Date(...)
                                                #     - does not matter: new Date()
                                                #     - UTC: new Date(Date.UTC(...))
                                                #  - output:
                                                #     - local: get|set*()
                                                #     - UTC: get|setUTC*(), getTime()
new Date([YEAR,MONTH,DAY,HOUR,MIN,SEC,MILLISEC])#Each final arguments are optional. Def: now.
new Date(STR)                                   #InvalidDate if cannot parse.
Date([...])                                     #Same as (new Date()).toString()

DATE.*et[UTC][Time/FullYear/Month/Date/Day/     #Date is month day, Day week day (0 for Sunday)
Hours/Minutes/Seconds/Milliseconds/             #Time is Epoch in seconds
TimezoneOffset]()                               #TimezoneOffset is in minutes
                                                #set* returns DATE.getTime()

Date.now()                                      #Like new DATE().getTime()
Date.parse(STR)                                 #Like new DATE(STR).getTime()
Date.UTC(...)                                   #Like new DATE(...).getTime() but new Date(...) uses UTC


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MATH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Math.min|max(NUM...)                            #NaN if one NUM not a number. [-]Infinity if no arguments.

Math.abs(NUM)                                   #
Math.sign(NUM)                                -|#Returns -|+ 0|1 or NaN

Math.ceil|floor(NUM)                            #Ceiling|flooring
Math.trunc(NUM)                               -|#Truncation
Math.round(NUM)                                 #Nearest round. Tie-breaking towards Infinity
Math.fround(NUM)                              -|#Converts to single-precision float (binary32)

Math.PI                                         #
Math.E                                          #
Math.LN2                                        #ln(2)
Math.LN10                                       #ln(10)
Math.LOG2E                                      #log2(e)
Math.LOG10E                                     #log10(e)
Math.SQRT2                                      #
Math.SQRT1_2                                    #

Math.pow(NUM1, NUM2)                            #
Math.sqrt(NUM)                                  #NaN if negative
Math.cbrt(NUM)                                -|#
Math.exp(NUM)                                   #
Math.expm1(NUM)                               -|#Same as Math.exp(NUM)-1
Math.log(NUM)                                   #Base e. NaN if negative
Math.log2|10(NUM)                             -|#Base 2|10
Math.log1p(NUM)                               -|#Same as Math.log(NUM+1)

Math.imul(NUM, NUM2)                          -|#Like NUM*NUM2, except only for 32-bits signed integers, where the sign is the
                                              -|#first bit, e.g. 4e9 is negative.
                                              -|#Used to emulate x86 ASM imul.
Math.clz32(NUM)                               -|#Number of leading zeros in a 32-bits signed binary format.

Math.[a]sin|cos|tan[2](NUM)                     #In radian
Math.[a]sin|cos|tan[2]h(NUM)                  -|#Hyperbolic version
Math.hypot(NUM...)                            -|#sqrt(NUM**2 + NUM2**2 ...)

Math.random()                                   #Float in [0,1). Seeded from current time.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             JSON              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JSON ==>                                        #See JSON-js doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       STRUCTURED CLONE        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STRUCTURED CLONE ALGORITHM ==>                  #Serialization of almost any JavaScript VAL:
                                                #  - can be:
                                                #     - any JSON value
                                                #     - undefined|NaN|Infinity|MAP|SET|DATE|REGEXP|BIGINT
                                                #     - BLOB|FILE[LIST]|[ARR]BUFFER[VIEW]|DATAVIEW|TYPED_ARR|IMAGEDATA
                                                #     - circular references
                                                #  - OBJ keep their constructors
                                                #  - cannot be:
                                                #     - ERROR|FUNC|SYM|PROMISE
                                                #     - PROXY|INTL.*
                                                #     - DOM ELEM
                                                #  - does not keep:
                                                #     - inherited properties
                                                #     - non-enumerated properties
                                                #     - REGEXP.lastIndex
                                                #     - setters, getters, property descriptors
                                                #Used in:
                                                #  - WINDOW|WORKER.postMessage()
                                                #  - IndexedDB
                                                #  - Node.js v8.[de]serialize()


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROMISE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PROMISE                                       -|#Represents an async function call.
                                              -|#Has two non-accessible members:
                                              -|#  - state 'pending|resolved|rejected': whether call is ongoing or done
                                              -|#  - value VAL: async function call return value or exception thrown
PROMISABLE                                    -|#Any OBJ with OBJ.then(FUNC, FUNC2)

TASKS ==>                                     -|#new Promise() FUNC is fired right away, i.e. in current microtask, sync,
                                              -|#before next statement.
                                              -|#But PROMISE.then|catch() FUNC is fired in next microtask, even if PROMISE is
                                              -|#already resolved|rejected.
                                              -|#This means await PROMISE, but also await VAL, will wait at least one microtask

new Promise                                   -|#Returns PROMISE:
(FUNC(RESOLVE(VAL|PROMISABLE), REJECT(VAL)))  -|#  - RESOLVE(VAL): state 'resolved', value VAL
                                              -|#  - REJECT(VAL): state 'rejected', value VAL
                                              -|#  - RESOLVE(PROMISABLE):
                                              -|#     - does PROMISABLE.then(RESOLVE, REJECT)
                                              -|#     - so PROMISE will have same state|value as PROMISABLE
                                              -|#RESOLVE|REJECT() defer state change
Promise.resolve|reject(...)                   -|#Same as new Promise(function(resolve, reject) { resolve|reject(...) })

PROMISE.then([FUNC(VAL)[, FUNC2(VAL)]])       -|#Fire FUNC|FUNC2 with PROMISE value if|when PROMISE.state 'resolved|rejected'
                                              -|#Returns new PROMISE2, which fires (according to what happens in
                                              -|#either FUNC|FUNC2):
                                              -|#  - if return VAL|PROMISABLE (including undefined): RESOLVE(VAL|PROMISABLE)
                                              -|#  - if throw VAL: REJECT(VAL)
                                              -|#Def FUNC|FUNC2:
                                              -|#  - return|throw VAL
                                              -|#  - if not a function, use def
PROMISE.catch(...)                            -|#Same as PROMISE.then(null, ...)
PROMISE.finally(FUNC())                       -|#Like PROMISE.then(FUNC(), FUNC())
                                              -|#Difference: FUNC() does not change PROMISE value, whatever it returns.
                                              -|#But it changes PROMISE value if it throws or returns rejected PROMISE2.
                                               ##Ponyfill: seee p-finally

Promise.all(VAL|PROMISABLE_ITERABLE)          -|#Returns PROMISE:
                                              -|#  - if all PROMISABLE resolved -> resolved with VAL2_ARR
                                              -|#  - if any PROMISABLE rejected with VAL2 -> rejected with VAL2
                                              -|#VAL is converted to PROMISE2 using Promise.resolve(VAL)
Promise.race(VAL|PROMISABLE_ITERABLE)         -|#Same but instead:
                                              -|#  - if any PROMISABLE resolved|rejected with VAL2 -> resolved|rejected with VAL2
Promise.allSettled(VAL|PROMISABLE_ITERABL)    -|#Same but instead:
                                              -|#  - after all PROMISABLE resolved|rejected with VAL2 -> resolved with OBJ_ARR:
                                              -|#     - status 'fulfilled|rejected'
                                              -|#     - value VAL2 (if resolved)
                                              -|#     - reason VAL2 (if rejected)
Promise.any(VAL|PROMISABLE_ITERABLE)   15.0.0*-|#Same but instead:
                                       15.0.0*-|#  - if any PROMISABLE resolved with VAL2 -> resolved with VAL2
                                       15.0.0*-|#  - if all PROMISABLE rejected -> rejected with AGGREGATE_ERROR: errors VAL2_ARR

async function [*] [FUNC](...) {...}          -|#Returns FUNC2(...)->PROMISE, where FUNC can:
[class ...] { async [*] FUNC() {...} ... }    -|#  - return VAL -> resolve PROMISE with VAL
async (...) => ...                            -|#  - throw VAL -> reject PROMISE with VAL
                                              -|#  - return PROMISE2 -> reject|resolve PROMISE with PROMISE2 value
await PROMISABLE|VAL                          -|#Inside async FUNC:
                                              -|#  - waits for PROMISABLE to resolve|reject
                                              -|#     - if PROMISABLE value returns PROMISABLE2, use PROMISABLE2 value instead
                                              -|#     - VAL is like Promise.resolve(VAL)
                                              -|#  - then returns|throws PROMISABLE value
                                       14.8.0*-|#Can be in top-level scope too


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PROXY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Proxy(OBJ, OBJ2)                        -|||#Returns PROXY:
                                            -|||#  - live deep mirror of OBJ: OBJ and PROXY are always deep equal
                                            -|||#  - can override some basic object operations with OBJ2:
                                            -|||#     - providing they are performed on PROXY (not on OBJ)
                                            -|||#     - they usually have same arguments, plus a first argument being PROXY
                                            -|||#     - can call themselves without creating infinite recursion,
                                            -|||#        - but set|get() OBJ3 can't, i.e. OBJ3.VAR = VAL as opposed to
                                            -|||#          PROXY.VAR = VAL
                                            -|||#     - there are some special rules ('invariants') to handle
                                            -|||#       non-extensible|configurable|writable properties (see online doc)
                                            -|||#       Should not worry unless writing a library.
                                            -|||#     - return value:
                                            -|||#        - mutating methods must return BOOL:
                                            -|||#           - if falsy, throws TypeError
                                            -|||#        - non-mutating methods must return the same return value as the underlying method
                                            -|||#        - should return the corresponding Reflect.*(...) to get the original behavior
                                            -|||#OBJ2 members follow.
                                            -|||#Limited polyfill|ponyfill GoogleChrome 'proxy-polyfill'
Proxy.revocable(OBJ, OBJ2)                  -|||#Like new Proxy(OBJ, OBJ2) but returns OBJ3:
                                            -|||#  - proxy PROXY
                                            -|||#  - revoke(): make accessing OBJ3.proxy throw a TypeError

OBJ2.set(PROXY, 'VAR', VAL, OBJ3)->BOOL     -|||#PROXY.VAR = VAL
                                            -|||#OBJ3 === PROXY, unless PROXY is in prototype chain, in which case OBJ3 is the target child
OBJ2.get(PROXY, 'VAR', OBJ3)->VAL           -|||#PROXY.VAR
                                            -|||#OBJ3: like set(...)
OBJ2.deleteProperty(PROXY, 'VAR')->BOOL     -|||#delete PROXY.VAR

OBJ2.has(PROXY, 'VAR')->BOOL                -|||#'VAR' in PROXY
OBJ2.ownKeys(PROXY)->STR_ARR                -|||#Object.getOwnPropertyNames(PROXY) + Object.getOwnPropertySymbols()
                                            -|||#Must at least contain same keys as original call

OBJ2.defineProperty(PROXY, 'VAR', OBJ3)
 ->BOOL                                     -|||#Object.defineProperty(PROXY, 'VAR', OBJ3)
OBJ2.getOwnPropertyDescriptor(PROXY, 'VAR')
 [->OBJ]                                    -|||#Object.getOwnPropertyDescriptor(PROXY, 'VAR')
OBJ2.isExtensible(PROXY)->BOOL              -|||#Object.isExtensible(PROXY)
                                            -|||#Must return same value
OBJ2.preventExtensions(PROXY)->BOOL         -|||#Object.preventExtensions(PROXY)
                                            -|||#Must return Object.isExtensible(PROXY)

OBJ2.getPrototypeOf(PROXY)->OBJ|null        -|||#PROXY.__proto__ or Object.getPrototypeOf(PROXY)
                                            -|||#Internally used by isPrototypeOf() and instanceof
OBJ2.setPrototypeOf(PROXY, OBJ3)->BOOL      -|||#PROXY.__proto__ = OBJ3 or Object.setPrototypeOf(PROXY, OBJ3)

OBJ2.apply(PROXY, THIS, ARGS_ARR)->VAL      -|||#PROXY(ARGS...)
OBJ2.construct(PROXY, ARGS_ARR)->OBJ        -|||#new PROXY(ARGS...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REFLECT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Reflect.*(OBJ, ...)                           -|#Does same thing as what Proxy OBJ2.*(PROXY, ...) proxies.
                                              -|#E.g. Reflect.set(OBJ, 'VAR', VAL, OBJ3) will:
                                              -|#  - OBJ.VAR = VAL
                                              -|#  - must return BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ES MODULES DIFFERENCES ==>                    -|#Implies 'use strict'
                                              -|#Variables are file-scoped
                                              -|#Because of those differences, must use export {} if nothing is exported, since
                                              -|#without import|export keyword, cannot distinguish.

export QUAL VAR = VAL[, ...]                  -|#
export function VAR(...){...}                 -|#
export class CLASS { ... }                    -|#
export { VAR[ as VAR2], ... }                 -|#Specific VAR ("named export")
export { VAR as default, ... }
export default VAL                            -|#Default VAR ("default export"). Is just a named export called "default".
export {}                                     -|#Do not export anything (i.e. not an empty object)
export {} from "MDL"
export {...} from "MDL"
export ... from "MDL"                         -|#Same as import ... from "MDL", then multiple export

import { VAR[ as VAR2], ... } from "MDL"      -|#Specific VAR
import * as VAR2 from "MDL"                   -|#All VARs, including "default"
import { default as VAR2, ... } from "MDL"
import VAR[, ...] from "MDL"                  -|#"default" VAR. Can be combined, e.g. import VAR, {...} from "MDL"
import {} from "MDL"
import "MDL"                                  -|#Do not import the variable, just execute the file

import("MDL")->PROMISE(OBJ)                   -|#As opposed to above, not static (dynamic), i.e. does not have to be top-level
                                              -|#If default export, defined in OBJ.default

import ... "MDL" assert { VAR: "VAL", ... } *-|~#Adds information about import using VAR: VAL
import("MDL", { assert: { VAR: "VAL", ...}})*-|~#Most VAR is host-specific, but the following are standard:
 ->PROMISE(VAL)                             *-|~#  - type 'json': file format is JSON

CIRCULAR DEPENDENCIES ==>                     -|#Accessing circular properties during file loading throws an error.
                                              -|#But accessing them later works.

import.meta.url                             -|||#Current file absolute path, as file:// URL
                                            -|||#Polyfill babel-plugin-bundled-import-meta

<script>
  type="module"                              *-|#Must be specified in browser to use modules.
                                             *-|#Each import creates an async request
                                             *-|#  - to avoid long loading time, should preload each file with
                                             *-|#    <link rel="modulepreload" href="FILE">

module { ... }                               *-|#Declare a module inline.
                                             *-|#Return its 'MDL' which must be passed to import()
                                             *-|#Behave like declaring module in a separate file in terms of scope
                                             *-|#   - except import.meta.url is same

new Realm()                                 *-|~#Global environment
REALM.importValue('MDL', 'VAR')             *-|~#Like (await import('MDL')).VAR but bound to a REALM
 ->PROMISE_VAL                              *-|~#VAL must be simple type or FUNC
REALM.evaluate('CODE')->PROMISE_VAL         *-|~#Like eval('CODE') but bound to a REALM
                                            *-|~#VAL must be simple type or FUNC


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CODING STYLE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CODING STYLES GUIDES ==>                        #  - A: airbnb javascript
                                                #  - B: bevacqua js
                                                #  - C: clean-code-javascript
                                                #  - D: Douglas crockford code conventions for JavaScript
                                                #  - E: elierotenberg coding-styles es6
                                                #  - F: felixge node-style-guide
                                                #  - G: Google JavaScript style guide
                                                #  - H: hapi JavaScript coding conventions
                                                #  - I: idiomatic.js
                                                #  - J: jQuery JavaScript style guide
                                                #  - K: Khan JavaScript styleguide
                                                #  - M: MediaWiki Coding conventions JavaScript
                                                #  - S: feross standard javascript
                                                #  - W: Wordpress JavaScript coding standards

ALTERNATIVES ==>                                #When there are competing recommandations, we use / instead of -, with the
                                                #preferred choice on top


FILE ORGANIZATION ==>                         GD#Use .js extension
                                               D#Separate JavaScript from HTML

COMMENTS ==>                                    #// vs /* */:
                                           GHMJF#  / always //
                                              AW#  / if single line //, if multiple /* */
                                              DJ#  - no end-of-line comments
                                              CB#Do not comment out blocks of code
                                                #Whitespaces:
                                             AWJ#  - blank line before comment
                                          GSAHWJ#  - space after // or /*
                                                #Sentences:
                                           GHWMJ#  - capitalize comments
                                             GMW#  / add period at end, if sentence
                                               H#  / add period at end, if several sentences

STRICTNESS ==>                               HEB#'use strict' on top of any file
                                               H#'use strict' should be followed by blank line

LINE WIDTH ==>                                  #General:
                                           GJFBK#  / Max 80 chars
                                             AWM#  / Max 100 chars
                                               H#  / Max 150 chars
                                               D#  / Avoid long lines
                                                #Exception to long lines:
                                               J#  / long URL in comment, or long REGEXP
                                               A#  / long STR

LONG STATEMENTS ==>                             #Long statement delimited by dot:
                                           AWDJF#  / VAL
                                                #      .VAL2
                                                #      .VAL3
                                               E#  / VAL.VAL2
                                                #      .VAL3
                                               G#  / VAL.VAL2.
                                                #      VAL3
                                                #Long statement delimited by operation (+ && || ...):
                                             HJM#  / VAL
                                                #      && VAL2
                                             GWK#  / VAL
                                                #        && VAL2 (double identation)

BLANK LINES ==>                             GAMD#Use blank lines to separate sections
                                               S#No blank lines at beginning|end of { } block
                                               S#No multiple blank lines

INDENTATION ==>                                 #General:
                                         GSAMEFB#  / 2 spaces indentation
                                             HDK#  / 4 spaces indentation
                                              WJ#  / Tab indentation
                                               G#Avoid using spaces to horizontally align items

STRUCTURES INDENTATION ==>                      #General:
                                       GSAIWDJFK#  / if ... {
                                                #      ...
                                                #    } else {
                                                #      ...
                                                #    }
                                              HE#  / if ... {
                                                #      ...
                                                #    }
                                                #    else {
                                                #      ...
                                                #    }
                                                #Spacing:
                                        GSAIHMDJ#  / while|if|... (...)
                                               E#  / while|if|...(...)
                                                #Ternary:
                                             SAK#  / (if short) TEST ? VAL : VAL2
                                                #    (if long) TEST
                                                #      ? VAL
                                                #      : VAL2
                                             WDF#  / TEST
                                                #      ? VAL
                                                #      : VAL2
                                              EJ#  / TEST ? VAL : VAL2
                                               G#  / (if short) TEST ? VAL : VAL2
                                                #    (if long) TEST ?
                                                #      VAL :
                                                #      VAL2
                                                #Single statement structures:
                                       AIHWEDJBK#  / use { }
                                              GS#  / use { } unless on same less as the TEST

SPACES ==>                                      #Operators:
                                            SWDJ#  - no space around unary operators
                                          GSAMED#  - one space around binary operators
                                            HWEJ#  - no space before ,
                                           GSHED#  - space after ,
                                             HWJ#  - no space before ;
                                           GSHDJ#  - space after ; if not end-of-line (e.g. in for loops)
                                             HWJ#  - no space before : in VAR:
                                             GSH#  - space after : in VAR:
                                                #Blocks:
                                            SAHE#  / Spaces inside any {}, none inside [] ()
                                              GK#  / No space inside any [] {} ()
                                               I#  / Spaces inside any [] {} (), except ({ ... }) and ([ ... ])
                                            IWMJ#  / Spaces inside any [] {} ()
                                            IHWJ#  - no space inside empty [] {} ()
                                              SH#No multiple spaces

STATEMENTS ==>                                  #Semi-colon:
                                       GAHWEDJFB#  / End statement with ;
                                               S#  / Do not end statement with ; providing no line starts with ( [ or `
                                           GHWDJ#One statement per line
                                                #Side-effects:
                                             DJB#  - avoid statement that is not a function or assignment
                                              SB#  - avoid unassigned new FUNC()

DECLARATION ==>                                 #Scope:
                                          GWDJBK#  - no global vars
                                              GS#  - prefix global vars with global|window
                                                #Where:
                                            GAHK#  / Declare vars before first use
                                            IMDB#  / Declare vars on top of function body, in alphabetical order
                                              DB#  - do not use variable hoisting
                                               A#  - group const declarations before let declarations
                                                #How:
                                        GSAEDFBK#  / QUAL VAR = VAL; one per line
                                              WM#  / QUAL VAR = VAL,
                                                #         VAR2 = VAL2;
                                               A#  - no chained declarations, e.g. const a = b = VAL
                                            GAEK#  - use ARR|OBJ destructuring when possible
                                                #QUAL:
                                           GAHEK#  - use let|const, not var
                                            GCHE#  - prefer const over let
                                                #When:
                                               C#  - assign constants to variables
                                               B#  - assign REGEXP to variables
                                              CF#  - assign to variables instead of using long TEST
                                            GAEC#Use ES6 default values
                                             SJB#No unused vars
                                               S#Do not initialize VAR to undefined
                                              GS#Use VAR = null instead of delete VAR
                                              AE#Avoid ++, +=, etc.

VARIABLES NAMING ==>                            #Case:
                                               M#  / normalVar VAR, including for acronyms, e.g. findHtmlTag()
                                       GSAHWEJFK#  / normalVar VAR
                                               D#  / normal_var VAR
                                           GIFKD#  - CONSTANTS
                                               E#  - __COMPILE_TIME_CONSTANTS__
                                    GSAIHWMEDJFB#  - Type
                                              GI#  - Enum
                                                #Prefixes:
                                            GHEK#  - _privateVar
                                               G#  - get|set*() for getters|setters
                                              GA#  - is|has*() for FUNC()->BOOL
                                               H#Name "for" loops variables i, j, k, etc.
                                               I#Use plurals for ARR

TRANSTYPING ==>                                A#Do not use implicit transtyping, e.g. use (ARR.length > 0) instead of
                                               A#(ARR.length)
                                               A#Use String|Number|parseInt|parseFloat|Boolean() for explicit transtyping

TEST ==>                                        #Use === not ==:
                                             SWK#  / except == null
                                        AIMEDJFB#  / always
                                                #Early returns:
                                                #  - i.e.:
                                                #      if (TEST) { ... return VAL } ...
                                                #    instead of:
                                                #      if (TEST) { ... } else { ... }
                                                #Avoid ternary operators:
                                             AEB#  / if nested
                                               E#  / always
                                                #Assignments, e.g. if (VAR = VAL)
                                             DJB#  / avoid
                                               S#  / wrap with extra set of parenthesis
                                                #Use Yoda conditions, i.e. VAL == VAR instead of VAR == VAL:
                                              SM#  / never
                                               W#  / always

SWITCH STATEMENT ==>                         IWE#Avoid switch, prefer if|else or OBJ[VAL]()
                                                #Identation of case|default:
                                             GIW#  / yes
                                              DJ#  / no
                                                #break|return|throw must end all:
                                              SD#  / all case|default
                                               G#  / all case|default unless commented
                                              WJ#  / all case but not default
                                               W#  - avoid return
                                               G#Must have a default
                                               A#Wrap case|default statements in { ... }

EXCEPTIONS ==>                                GS#Only throw ERROR
                                               S#No return statement in finally block

FUNCTIONS (SPACING) ==>                    SIHMD#FUNC(), not FUNC ()
                                                #Unnamed declaration:
                                           SAHMD#  / function () {}
                                              GI#  / function() {}
                                                #Named declaration
                                           GAHMD#  / function NAME() {}
                                               S#  / function NAME () {}
                                                #Functions wrapping whole file:
                                              WM#  / indented
                                               J#  / not indented

FUNCTIONS (PARENTHESIS) ==>                SADJB#(function ... { ... }())
                                              SJ#new FUNC() not new FUNC
                                               J#(new FUNC()).VAR not new FUNC().VAR

FUNCTIONS (DECLARATION) ==>                     #Assign to VAR:
                                              AH#  / always
                                            GEDB#  / never
                                              AE#{ FUNC() {} } not { FUNC: function() {} }
                                               S#Avoid non-top-level FUNC declaration

FUNCTIONS (ANONYMOUS) ==>                       #When:
                                               B#  / always for non-top-level FUNC
                                               F#  / not inside another anonymous FUNC
                                               E#  / never
                                                #Shortcut syntaxes:
                                            GAEK#  - always use =>
                                                #  - ARG => VAL instead of (ARG) => VAL:
                                               A#      / always
                                              HE#      / never
                                                #  - () => VAL instead of () => {...}:
                                               A#      / VAL if single line, (VAL) is several lines
                                               H#      / never
                                              EF#Anonymous FUNC not assigned to VAR should have a NAME

FUNCTIONS (ARGUMENTS) ==>                       #Named parameters:
                                              GE#  / for options
                                               C#  / if more than 2 positional parameters
                                            GAEK#Use ARR|OBJ destructuring when possible
                                             AEK#Use ...args for variadic arguments, not "arguments"

FUNCTIONS (GENERATORS) ==>                      #Spacing:
                                             GAE#  - function* [FUNC](...) {}, not function *[FUNC](...) {}
                                              GE#  - { *FUNC(...) {} }, not { * FUNC(...) {} }
                                               G#  / yield* VAL
                                               S#  / yield * VAL

FUNCTIONS (GETTERS/SETTERS) ==>               GA#Avoid getters
                                             GAF#Avoid setters
                                               S#Define a getter if a setter is defined
                                              GF#No side-effects with getters

FUNCTIONS (OTHERS) ==>                         B#No empty functions
                                               F#No long functions
                                               S#Avoid call|apply() unless necessary

OBJECTS ==>                                     #One VAR per line:
                                             GJF#  / if whole OBJ too long for one line
                                               H#  / always
                                                #Commas:
                                           GSAEF#  - use trailing commas
                                               S#  - no commas in beginning of lines
                                                #Shortcuts:
                                      GSAIWMEDBK#  - {} instead of new Object
                                           SAWEF#  - only quote 'VAR' in OBJ if necessary
                                               A#  - { [VAL]: VAL2 } instead of OBJ[VAL] = VAL2
                                               A#  - { VAR } instead of { VAR: VAR }
                                              AK#  - object spread instead of Object.assign()

INHERITANCE ==>                                B#Avoid inheritance
                                            GSFB#Avoid extending native types
                                            GACB#Use ES6 classes when using inheritance
                                              SE#Avoid __proto__, prefer get|setPrototypeOf()
                                               E#Properties order: constructor first, public < private,
                                               E#getter/setter < normal < static, alphabetical
                                               S#Child constructors must call parent constructors, and before using this
                                               S#No empty constructors
                                               A#Use method chaining, by returning this

ARRAYS ==>                                      #One VAR per line:
                                               A#  - if whole ARR too long for one line
                                                #Commas:
                                               G#  - use trailing commas
                                                #Shorcuts:
                                      GSAIWMEDBK#  - [] instead of new Array
                                               K#  - ARR.includes() instead of indexOf
                                              GA#  - ...ARR instead of ARR.concat|slice()
                                                #Iteration:
                                               K#  / for ... of
                                              AE#  / forEach()
                                                #Spacing:
                                              GS#  - ...ARR not ... ARR
                                               S#Avoid sparse ARR
                                               G#Only ARR[NUM], not ARR.VAR

STRINGS ==>                                     #Quoting:
                                         AHWMEFB#  / 'STR'
                                               S#  / 'STR' except to avoid escaping '
                                             GIJ#  / "STR"
                                                #Concatenation:
                                           GSAEK#  - `STR` instead of STR + STR2 or trailing backslashes
                                               S#  - PATH.join() to concatenate __dirname|__filename
                                               S#${...} not ${ ... }

NUMBERS ==>                                    S#0.NUM instead of .NUM
                                                #Octals:
                                               G#  / 0o... instead of 0...
                                               S#  / never
                                               H#++VAR instead of VAR++

PROMISE ==>                                    C#Prefer async|await > PROMISE > callbacks
                                               E#PROMISE.then(FUNC).catch(FUNC2) instead of PROMISE.then(FUNC, FUNC2)

MODULES ==>                                     #Prefered syntaxes:
                                               A#  - avoid import *
                                               A#  - avoid import { ... as ... }
                                               A#  - import + export instead of export ... from "MDL"
                                               A#  - export default VAL if only one export
                                             AHF#require|import on top of file
                                               H#Use relative paths with require|import
                                               A#Should name default import|export after filename
                                               A#Export const variables, not let|var
                                               S#Use single import per MDL
                                               S#No new require(...)

FEATURES TO AVOID ==>                         SD#comma operator
                                               D#continue
                                                #Labels:
                                               S#  / never
                                               D#  / only with while|do|for|switch
                                           GSDFE#with
                                          GSADFE#eval() or related (new Function(STR), setTimeout|Interval(STR))
                                             SJB#arguments.caller|callee
                                             GSE#new String|Number|Boolean|Array|Object()
                                               F#Object.freeze|seal|preventExtensions()
