
              
   JAVASCRIPT  
              



VERSION ==>                                     #Standard is called ECMAScript. JavaScript and ActionScript are dialects.
                                                #This doc shows strict mode only

SUPPORT ==>                                     #Use this notation for new features:
                                                #  - works with current web browsers
                                                #  - not current web browsers but works with Babel:
                                               |#     - out of the box
                                               +#     - require polyfill
                                              ++#     - requires experimental plugin
                                               -#  - does not work with current web browsers nor Babel
                                               *#  - not Node 10.10.0
                                                #Summary:
                                                #  - does not work with Node nor Babel:
                                                #     - import.meta
                                                #     - INTL: RelativeTimeFormat, ListFormat, Segmenter, Locale
                                                #     - SIMD
                                                #     - NUM thousands separator
                                                #     - ARR.flat|flatMap()
                                                #     - private class members (#VAR)
                                                #     - tail call optimization
                                                #     - STR.matchAll()
                                                #     - SYM.description
                                                #     - Object.entries()
                                                #  - does not work with Node:
                                                #     - class properties (VAR = EXPR;)
                                                #     - ES modules
                                                #  - does not work with Babel:
                                                #     - INTL: NUMBERFORMAT|DATETIMEFORMAT.formatToParts(), PluralRules
                                                #     - Symbol, Symbol.hasInstance|toPromitive|species|isConcatSpreadable
                                                #     - BigInt
                                                #     - PROXY
                                                #     - new.target
                                                #     - extending native objects
                                                #     - STR.normalize()
                                                #     - TYPED_ARR array methods
                                                #     - SHARED_ARRBUFFER
                                                #     - backslash sequences in `...`
                                                #     - REGEXP: (?<=) (?<!) /REGEXP/s /REGEXP/y \p \P (?<GROUP>) \k<GROUP>
                                                #     - global
                                                #     - "bound|get|set" in FUNC.name
                                                #     - catch [(...)] instead of catch (...)

UPDATING SUPPORT ==>                            #Can look at support with:
                                                #  - EcmaScript kangax compat-table
                                                #  - http://node.green/
                                                #Only consider features in stage >= 3, unless already some support
                                                #Need to consider different environments: Babel, Node, different browsers
                                                #I am subscribed to new ES features.
                                                #I have the following features documented in this doc:
                                                #  - entire ES5, ES6, ES2016, Intl, non-standard
                                                #  - ES2017:
                                                #     - Object static methods
                                                #     - String padding
                                                #     - trailing commas in function syntax
                                                #     - async functions
                                                #     - shared memory and atomics
                                                #     - Proxy "ownKeys" handler, duplicate keys for non-extensible targets
                                                #     - RegExp "u" flag, case folding
                                                #     - arguments.caller removed
                                                #     - Object.prototype getter/setter methods
                                                #     - Proxy internal calls, getter/setter methods
                                                #     - assignments allowed in for-in head in non-strict mode
                                                #  - ES2018:
                                                #     - template literal revision
                                                #     - object rest properties
                                                #     - object spread properties
                                                #     - PROMISE.finally()
                                                #     - s (dotAll) flag for regular expressions
                                                #     - RegExp named capture groups
                                                #     - RegExp lookbehind
                                                #     - RegExp Unicode Property Escape
                                                #     - Async iteration
                                                #     - catch [(...)] instead of catch (...)
                                                #     - unescaped U+2028|2029 in "..."
                                                #  - ESNext stage 3:
                                                #     - STR.trim*()
                                                #     - global
                                                #     - STR.matchAll()
                                                #     - instance class fields
                                                #     - Function.prototype.toString
                                                #     - NUM thousands separator
                                                #     - BigInt
                                                #     - SYM.description
                                                #  - not in kangax, but actually in ESNext stage 3:
                                                #     - import("MDL")->PROMISE(OBJ)
                                                #     - import.meta

MAIN PRINCIPLES ==>                             #Case-sensitive. Whitespaces are ignored.
                                                #Type: weak, dynamic, generic, late/duck.
                                                #Lexical-scope
                                                #Functional (first-class functions)
                                                #Object-oriented (prototype-based)
                                                #Imperative (structures close to C)
                                                #Need a host environnement (e.g. browser) for I/O
                                                #Memory management: garbage collection.

EXECUTION ==>                                   #Each browser has own JavaScript engine, which was in the past interpreted,
                                                #but now is byte-compiled or compiled:
                                                #  - Chakra (IE9+)
                                                #  - SpiderMonkey (Firefox)
                                                #  - V8 (Chrome, Opera 12.15+)
                                                #  - SquirrelFish (Safari)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ASYNC             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


EVENT LOOP ==>                                  #Loops:
                                                #  - each event loop loops through [macro]tasks
                                                #  - each macrotask loops through microtasks|tick
                                                #  - each microtask is run synchronously

NEW TASKS ==>                                   #The following create each of them:
                                                #  - each thread has a single event loop
                                                #     - creates a new thread: WEBWORKER, cross-origin <iframe>, CHILDPROCESS
                                                #  - macrotasks are created by I/O code, which includes:
                                                #     - setTimeout|Interval|Immediate()
                                                #     - filesystem, network or OS calls
                                                #     - event handlers triggered by browser interaction.
                                                #       Events triggered directly through JavaScript, which include
                                                #       Node.js EVENTEMITTER, are sync.
                                                #  - microtasks are created by:
                                                #     - process.nextTick()
                                                #     - PROMISE.then|catch() callbacks

PERFORMANCE ==>                                 #For Node.js:
                                                #  - minimal time of a macrotask is 1ms.
                                                #    I.e. a macrotask that only does setTimeout(..., 0) will last 1ms
                                                #  - there is no minimal time for a microtask

SINGLE-THREADED ==>                             #Each event loop is single-threaded:
                                                #  - i.e. only one microtask and one macrotask runs at any time
                                                #Resources:
                                                #  - I/O-intensive tasks:
                                                #     - are the slowest
                                                #     - should yield the thread and be woken up on a new macrotask
                                                #     - this is what most I/O functions do by default, i.e. I/O calls are
                                                #       optimally handled
                                                #     - i.e. developer just need to use async I/O functions
                                                #  - CPU-intensive tasks:
                                                #     - will hold the whole thread
                                                #     - if too slow, should spawn a new thread instead
                                                #  - memory consumption:
                                                #     - is very low, because thread and processes is what makes memory go high

ASYNC EXPECTATION ==>                           #Libraries exposing callbacks should trigger them in a new microtask,
                                                #because this what consumers usually expect.
                                                #  - e.g. this would otherwise be problematic:
                                                #     let VAR = FUNC(CALLBACK); VAR.on('start', ...)

THREAD EXIT ==>                                 #Thread exits when the event loop has no more macrotasks
                                                #In a browser, this never happens, as there are always DOM event listeners.
                                                #In Node.js:
                                                #  - this means any of the following will keep the thread running:
                                                #     - process.nextTick(), setTimeout|setInterval()
                                                #     - PROMISE.then|catch() FUNC, await PROMISE
                                                #     - TCPSERVER.ref(), CHILDPROCESS.ref(), and anything higher
                                                #  - some I/O objects expose unref() methods to yield the macrotask

ASYNC STACK TRACE ==>                           #Also called "long stack trace"
                                                #When using async, the callback function does not include stack trace from parent function
                                                #  - because it is processed on different microtask
                                                #This includes:
                                                #  - setTimeout|Interval|Immediate(FUNC), process.nextTick(FUNC), promise.*()
                                                #  - any code after an await statement (but not before)
                                                #     - stack trace starts at async function where await statement is (which is
                                                #       better than promises which start at promise.*() function)
                                                #  - filesystem, network, OS or browser interaction event handlers
                                                #Support:
                                                #  - see my async stack trace documentation
                                                #  - supported in Chrome dev tools (but not in ERROR.stack without using a library)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SCOPE             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


GENERAL ==>                                     #  - variable scope is:
                                                #     - "var": function() {...}
                                               |#     - "let|const": any {...}
                                                #  - any function inherits scope of the function in which it is declared
                                                #    (not fired)
                                                #     - inherits by reference, not by value
global                                         -#Global scope reference

DECLARATION ==>                                 #  - using undeclared VAR throws ReferenceError (except with typeof)
                                                #  - using VAR (even if declared in parent scope) declared later in
                                                #    current scope with:
                                               |#     - "let|const": throws ReferenceError ("Temporal Dead Zone")
                                                #     - "var": adds an implicit empty declaration before, i.e. will be
                                                #       undefined (variable hoisting)
                                                #     - function FUNC(){}: adds an implicit declaration+assignment before

DECLARING FUNCTIONS ==>                         #  - FUNC = function [FUNC2](){}
                                                #     - declared+assigned at runtime (like other variables)
                                                #     - this also covers anonymous function, and void function [FUNC2](){}
                                                #     - Using "FUNC2":
                                                #        - equivalent of doing let FUNC2 = function(){} at the beginning of
                                                #          the same function
                                                #        - allow recursion to reference themselves without risk of parent
                                                #          scope to reassign FUNC2
                                                #  - function FUNC2(){}:
                                                #     - declared+assigned at parsetime
                                                #        - i.e. equivalent of doing let FUNC2 = function () {} at {...} scope
                                                #          beginning
                                                #  - new Function(...): child of global scope

MEMORY MANAGEMENT ==>                           #Garbage collection:
                                                #  - use tracing, i.e. no problem with reference cycles
                                                #  - root objects are global variables
                                                #  - closures carry references to their parent scope, but only of the
                                                #    references they use
                                                #     - this might be problematic when closures are returned, i.e. go up the
                                                #       stack, extending their parent scope lifetime
                                                #Memory leak happens with combination of variables being:
                                                #  - big, e.g.:
                                                #     - functions carrying parent SCOPEs
                                                #     - big objects
                                                #     - raw data returned from server
                                                #  - long-lived, e.g.:
                                                #     - attached to top/long-lived SCOPEs, e.g. global variables, e.g.:
                                                #        - long-lived DOM elements
                                                #        - global functions (e.g. global event handlers, setInterval(), ...)
                                                #Avoiding:
                                                #  - unset variables just after being used if they are big or attached to
                                                #    long-lived objects
                                                #     - "unset": prefer setting empty value than using "delete"
                                                #  - only use closures as argument or return value when needed


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         TYPES GENERAL         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPING SYSTEM ==>                               #  - weak: no type specified at Declaration
                                                #  - generic: native operators accepts any type, since each native type
                                                #    transtype to any (except OBJ->undefined|null)
                                                #  - dynamic: type is not checked at compile-time nor (since generic) run-time

AVAILABLE TYPES ==>                             #  - simple: number|boolean|string|undefined|null
                                                #  - object (TYPE): Object and its children
                                                #    - native: Object|Array|Number|Boolean|String|Error|...
                                                #    - user-defined:
                                                #      - host objects: defined by browser (e.g. DOM elements)

Boolean|String|Number|BigInt                    #Not same as boolean|string|number|bigint:
                                                #  - are objects, constructed as new TYPE([VAL])
                                                #  - but transtypes to|from simple types
                                                #     - STR|BOOL|(NUM).VAR work, because of transtype
                                                #     - not that null|undefined.VAR will throw error
                                                #Note: new Boolean|...(...) returns OBJ, whereas Boolean|...(...) returns
                                                #native type

typeof VAR                                      #Returns "boolean|string|number|bigint|symbol|undefined|object|function"
                                                #"object": includes null, excludes FUNC
OBJ.constructor                                 #Returns TYPE (read-only)
VAR instanceof TYPE                             #Returns true if VAR is instance of TYPE (of a child of TYPE), i.e.:
                                                #  - VAR.[__proto__...]constructor === TYPE,
                                                #    but without transtyping VAR if it is not an OBJ
                                                #  - VAR.[__proto__...]__proto__ === TYPE.prototype
TYPE.prototype.isPrototypeOf(VAR)               #Same
TYPE[Symbol.hasInstance](VAR)->BOOL            -#Define to override VAR instanceof TYPE

Array.isArray(VAR)->BOOL                        #Same as VAR instanceof Array, except works if current global is different
                                                #from VAR's global, e.g. if communicating between <iframe>

CHECKING TYPE ==>                               #  - boolean|string|number|bigint|symbol: typeof VAR === '...'
                                                #  - object: typeof VAR === 'object' && VAR !== null
                                                #  - null: VAR === null
                                                #  - null|undefined: VAR == null
                                                #  - undefined:
                                                #     - (VAR declared) VAR === undefined
                                                #     - (VAR maybe not declared) typeof VAR === "undefined"
                                                #       Should never be necessary:
                                                #        - useless in local scopes
                                                #        - in global scope, use global.VAR === undefined
                                                #  - ARR: Array.isArray(VAR) or VAR instanceof Array
                                                #  - Node: VAR.nodeType === 1
                                                #  - TYPE (excluding children): OBJ.constructor === TYPE
                                                #  - TYPE (including children): OBJ instanceof TYPE
                                                #  - OBJ (no parent TYPE): OBJ.constructor === Object

TYPEDETECT(VAL)->STR                           ##Returns:
                                               ##  - 'number|boolean|string|symbol|undefined|function' (like typeof)
                                               ##  - 'null'
                                               ##  - 'Object' (plain object)
                                               ##  - 'Array|RegExp|Date|Promise|[Weak]Set|Map|DataView'
                                               ##  - 'Map|Set|Array|String Iterator'
                                               ##  - 'global|Location|Document|MimeTypeArray|PluginArray'
                                               ##  - VAL[Symbol.toStringTag]
                                               ##  - TYPE from VAL.toString()->'[object TYPE]'
                                               ##Module "type-detect" (4.0.8)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         SIMPLE TYPES          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


NUM                                             #Always double-precision float
                                                #Can use TYPED_ARR or SIMD for single-precision floats or 8|16|32-bits [u]ints
                                                #Radix:
                                                #  - NUM
                                                #  - 0xNUM 0XNUM
                                               |#  - 0oNUM 0ONUM
                                               |#  - 0bNUM 0BNUM
                                             *-|#Underscores inside NUM are ignored (used as a visual thousands separator)
                                                #Keywords (see below):
                                                #  - NaN: possible illegal NUM operations
                                                #  - [-]Infinity: very low|high NUM
                                               +#  - Number.MIN|MAX_SAFE_INTEGER: very low|high integers
                                                #  - Number.MAX_VALUE: very low|high floats
                                                #  - Number.MIN_VALUE: very close to 0 floats
                                               +#  - Number.EPSILON: comparing floats
                                                #Operator:
                                                #  + - * / %
                                                #  -NUM
                                                #  NUM++ --NUM etc.
                                               |#  **
                                                #  ~ & ^ | >> << >>>
                                                #  OP=  (e.g. NUM += 2 or NUM %=10)
                                                #  < <= > >=

NUMn                                           -#BIGINT. Infinite precision integer
                                               -#Behaves like NUM:
                                               -#  - including octal, hex, binary notations
                                               -#Exceptions:
                                               -#  - integer not double:
                                               -#     - / % round towards 0
                                               -#  - cannot use >>> nor +NUMn
                                               -#  - throw on JSON.stringify()
                                               -#  - has its own typeof, constructor
                                               -#Transtyping is same as NUM except:
                                               -#  - no implicit transtyping between NUM and BIGINT (but explicit transtyping possible)
                                               -#     - exception: == === != !== < <= > >=
                                               -#  - implicit transtyping to BIGINT throws where NUM would transtype to NaN
                                               -#  - no BIGINT.toFixed|toPrecision|toExponential()
BigInt.asUintN|asIntN(NUM, NUM2n)->NUM2n       -#Enforce max size NUM bits on NUM2n
                                               -#On overall, rotate to min|max value (according to NUM)

BOOL                                            #true|false
                                                #Operators:
                                                #  ! && ||

STR                                             #Can be:
                                                #  - "STR": escapes everything but " \ newline
                                                #  - 'STR': escapes everything but ' \ newline
                                               |#  - [FUNC] `STR`: escapes everything (including newline) but ` ${ \
                                               |#     - can include ${EXPR}
                                                #Any backslash escape, except \a, \c et \e
                                                #To include newline, can:
                                                #  - use `STR`
                                                #  - trailing backslash
                                                #  - concatenation
                                                #Operators:
                                                #  + +=
                                                #  < <= > >=: char by char, codepoint-wise

SYM                                            +#Symbol([STR])
                                               +#Used as OBJ key for private members, i.e. OBJ[SYM] is like OBJ['RANDOM']
                                               +#Operators:
                                               +#  OBJ[SYM]

undefined                                       #Valeur par défaut:
                                                #  - non-declared VAR: throw ReferenceError when used, except with typeof
                                                #  - declared but non-assigned VAR (including arguments and return value)

null                                            #Special keyword indicating emptiness


EQUALITY ==>                                    #Native types:
                                                #  - == != (transtypes)
                                                #  - === !== (does not transtype)
                                                #OBJ:
                                                #  - == === != !== (only check same reference)
Object.is(VAL, VAL2)                           |#Same as ===, except !Object.is(+0,-0) and Object.is(NaN, NaN)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TRANSTYPING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


IMPLICIT ==>                                    #To STR:
                                                #  - BOOL|NUM|BIGINT|undefined|null: 'BOOL|...'
                                               -#  - SYM: 'Symbol(VAR)' (only with String(SYM) or SYM.toString())
                                                #  - OBJ:
                                                #     - OBJ.toString|valueOf() (valueOf has priority)
                                                #       (otherwise "[object NAME]")
                                               |#        - NAME is OBJ[Symbol.toStringTag]()->'NAME':
                                               |#          'Object|Math|JSON|Function|AsyncFunction'
                                                #        - REGEXP|DATE|ERROR: '...'
                                                #        - ARR: ARR.join(',')
                                                #        - FUNC: see FUNC.toString()
                                              *-#        - SOBJ: 'SIMD.TYPE(VAL,...)'
                                               -#     - or OBJ[Symbol.toPrimitive]('string')
                                                #To NUM:
                                                #  - STR: '' 0, 'NUM' NUM (trims whitespaces), others NaN
                                                #  - BOOL: true 1, false 0
                                               -#  - BIGINT: TypeError
                                               -#     - can be explicitely converted though
                                               -#     - in which case, transtyped to [-]Infinity if out-of-bound
                                                #  - undefined: NaN
                                                #  - null: 0
                                               -#  - SYM: TypeError
                                                #  - OBJ:
                                                #     - OBJ.valueOf() (otherwise NaN)
                                                #        - DATE: DATE.getTime()
                                              *-#        - SOBJ: throws error
                                               -#     - or OBJ[Symbol.toPrimitive]('number')
                                               -#To BIGINT:
                                               -#  - STR: '' 0n, 'NUM' NUMn (trims whitespace), others TypeError
                                               -#  - BOOL|OBJ: like NUM
                                               -#  - NUM: like BIGINT to NUM
                                               -#  - undefined|null|SYM: TypeError
                                                #To BOOL:
                                                #  - STR: '' false, '...' true
                                                #  - NUM|BIGINT: 1 true, 0 false
                                                #  - undefined|null: false
                                                #  - OBJ|SYM: true
                                                #To OBJ
                                                #  - NUM|BIGINT|STR|BOOL: use Number|BigInt|String|Boolean()
                                                #     - parsers forbid NUM|BIGINT.VAR but (NUM|BIGINT).VAR is allowed
                                               -#  - SYM: use Object()
                                                #  - undefined|null: throws error
                                                #To null|undefined:
                                                #  - null|undefined: null|undefined
                                               -#OBJ[Symbol.toPrimitive]('default'): called when implicit type ambiguous,
                                               -#e.g. VAL + STR or VAL == VAL2

IMPLICIT (KEEPS SAME) ==>                       #The following use implicit transtyping while keeping the value the same
                                                #(i.e. behaves like an explicit transtyping)
                                                #To BOOL: !!VAL
                                                #To NUM: +VAL, VAL*1, VAL/1, ~~VAL, VAL|0, VAL-0
                                                #To STR: VAL + ''

EXPLICIT (GENERAL) ==>                          #To BOOL: Boolean(VAL)
                                                #To NUM;
                                                #  - Number(VAL)
                                                #  - parseFloat(VAL): same but:
                                                #     - removes trailing non-numerical chars in STR
                                                #     - only understands decimal form
                                                #     - returns NaN for non-NUM|STR
                                                #  - parseInt(VAL[, NUM]): same as parseFloat() but:
                                                #     - removes decimals
                                                #     - understands decimal or hexadecimal form by default.
                                                #       If NUM, forces radix
                                               +#  - Number.parseFloat|Int(...): same
                                               -#To BIGINT:
                                               -#  - BigInt(VAL): similar to Number(...)
                                                #To STR: String(VAL)
                                                #To OBJ: [new ]Object(VAL):
                                                #  - null|undefined -> {}
                                                #  - valueOf()->VAL
                                               -#To SYM: impossible, except if converting to STR then using Symbol.for(STR)

EXPLICIT (SPECIFIC) ==>                         #To STR:
                                                #  - NUM:
                                                #     - NUM.toFixed|toPrecision|toExponential([NUM]): specify number
                                                #       of decimals, significant numbers or exponential notation.
                                                #     - NUM.toString(RADIX)
                                               -#  - BIGINT:
                                               -#     - BIGINT.toString(RADIX)
                                                #  - DATE:
                                                #     - DATE.toString(): "Day Mon DD YYYY HH:MM:SS TZ"
                                                #     - DATE.toISOString(): "YYYY-MM-DDTHH:MM:SS.SSSZ"
                                                #     - DATE.toUTCString(): "Day, DD Mon YYYY HH:MM:SS TZ" (UTC)
                                                #     - DATE.toDateString(): "Day Mon DD YYYY"
                                                #     - DATE.toTimeString(): "HH:MM:SS TZ"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       BASIC STATEMENTS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


RESERVED WORDS ==>                              #enum, await, implements, package, protected, public, private, interface,
                                                #static

STATEMENT;                                      #; optional, but recommended in case could be interpreted as multiline

STATEMENT\                                      #Only required for multiline statements:
                                                #  - within a STR
                                                #  - if first line could be interpreted as standalone statement.

// COMMENT
/* COMMENT */

"use strict";                                   #Start strict mode:
                                                #  - i.e. strict ES6|ES7 conformance
                                                #  - allows faster optimization by browsers
                                                #  - not compatible until IE10
                                                #Applies to current and child scopes:
                                                #  - child scopes: including nested functions, anonymous functions, eval(),
                                                #    new Function(), etc.
                                                #  - but not functions declared in different scopes and called in current|child scopes
                                                #  - warning: concatenating with other scripts might put them in same scope,
                                                #    making them strict too.
                                                #  - must be before any statement (otherwise noop)
                                                #Implicit in any ES6 module (i.e. useless), but not in Node.js modules or
                                                #global scripts
                                                #In the web console, can use an anonymous function in order to use strict mode.

QUAL VAR[ = VAL]                                #Declaration. Default value is undefined.
  [, VAR2[ = VAL2]]...                          #VAR:
                                                #  - cannot be a reserved keyword
                                                #  - can contain:
                                                #     - any Unicode char with property "ID_Continue"
                                                #       (letters-like, numbers-like, diacretics)
                                                #     - $ or _
                                                #     - U+200C U+200D (zero-width space)
                                                #  - can be included as is, or using \u.... or \u{....}
                                                #  - first character must be Unicode char with property "ID_Start",
                                                #    i.e. only letters-like or $ or _
VAR = VAL;                                      #Assignation.
                                                #Returns VAL, so chain possible: VAR = VAR2 = VAL, but means VAR2 is global

[QUAL] [ VAR[ = VAL], ...[, ...ITERBL] ] = ARR |#[QUAL ]VAR = ARR[NUM], ...
                                               |#VAL is default value
                                               |#Final ITERABLE is for variadic assignment
[QUAL] { KEY: VAR[ = VAL] } = OBJ              |#[QUAL ]VAR = OBJ[KEY], ...
                                               |#Without 'QUAL', must wrap with ({...} = OBJ)
                                               |#VAL is default value
                                               |#Can be { KEY: { KEY2: ... } }
                                               |#KEY can appear several times with different VAR,
                                               |#including { KEY: { KEY2 }, KEY: KEY }
[QUAL] { KEY[ = VAL] } = OBJ                   |#Same as QUAL { KEY: KEY[ = VAL] } = OBJ

QUAL                                            #var|let|const
let VAR                                        |#Like var VAR, but {} block scoped.
const VAR                                      |#Like let VAR but read-only, i.e. throws error on assignments beyond
                                               |#declaration
                                               |#Is shallow: if OBJ, only OBJ is read-only, not OBJ.VAR
                                               |#Is only for current block scope since:
                                               |#  - function arguments imply new assignment
                                               |#  - function return value must be assigned to be used as reference

delete OBJ.VAR                                  #Like assigning undefined except:
                                                #  - remove key as well
                                                #  - cannot be performed if non-configurable
                                                #  - can be performed if non-writable
                                                #Note: for ARR[NUM], does not modify length (like assigning undefined)
                                                #Returns true if OBJ (not OBJ.VAR) exists.

void STATEMENT                                  #Same as STATEMENT, but returns undefined
                                                #Sometimes void 0 is used as synonym of undefined (for older browsers where
                                                #undefined can be reassigned)

eval("STATEMENT...")                            #Fire STATEMENT... in current scope. Return last STATEMENT return value.
                                                #To avoid.
                                                #If argument non STR, renvoie VAL.
                                                #"VAR = VAL" does not declare anything.
                                                #Can throw SyntaxError or EvalError.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTIONS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FUNC                                            #Is OBJ, so can be assigned.
Function                                        #FUNC TYPE
function [FUNC]([...]) { ... [return VAL;] ... }#Declare and returns FUNC.
                                                #See "Scope" above.
[new ]Function([...,]'...')                     #Same as function(...) { ... } but:
                                                #  - scope will be child of global scope.
                                                #  - body is STR can be dynamically created. Can create injection risk.
                                                #Use only if really necessary.

(...) => {...}                                 |#Same as (function(...) {...}).bind(this), except:
                                               |#  - arguments|super|new.target refer to current function's
(...) => VAL                                   |#Same as (...) => { return VAL; }
                                               |#To return an OBJ, wrap in ({...})
ARG => {...}                                   |#Same as (ARG) => {...}

ARGUMENTS ==>                                   #  - positional
                                                #  - extra parameters do not fire exceptions
                                                #  - non-OBJ are passed by value, but OBJ always by reference:
                                                #     - including in assignment
                                                #     - left-hand value keeps reference to right-hand value, but not inverse
                                                #        - i.e. assigning to an OBJ argument removes precedent reference:
                                                #            function(OBJ){ OBJ = OBJ2 }     // Removes OBJ reference
                                                #            function(OBJ){ OBJ.VAR = VAL }  // Keep OBJ reference
                                               |#  - can use trailing commas
                                               |#  - VAR = VAL: default value:
                                               |#     - Can refer to previous argument of same function.
                                               |#     - VAL is evaluated at each function call, not at declaration,
                                               |#       in its own child scope.
                                               |#     - explicitely passing undefined gets the default value
                                               |#  - ...ARR: variadic args
                                               |#  - {...}: assigns {...} = OBJ
                                              ++#     - including { [...] ...OBJ [...] } = OBJ2
                                               |#  - [VAR...]: assigns ARR = [VAL...]
arguments                                       #Readonly ARRAYLIKE containing currently passed arguments.

FUNC([VAL]...)                                  #Fire FUNC and returns its return value
                                               |#Can be ...ITERABLE, replaced by NEXT...
                                               |#Can use trailing commas
FUNC.length                                     #Number of required arguments

FUNC.name                                      |#Is:
                                               |#  - function NAME (...) {...} -> 'NAME'
                                               |#  - { NAME() {...} } -> 'NAME'
                                               |#  - (...) => {...} -> ''
                                               |#  - function (...) {...} -> ''
                                               |#  - NAME = FUNC -> FUNC.name || NAME
                                               |#  - { NAME: FUNC } -> FUNC.name || NAME
                                               |#  - OBJ.VAR = FUNC -> FUNC.name
                                               |#Prepends:
                                               -#  - "bound " if FUNC.bind()
                                               -#  - "get|set " if getter|setter
                                               -#If NAME is SYM -> '[STR]' with STR from Symbol(STR)
                                               |#Might be changed by minifiers (e.g. done by default by Uglify, although there
                                               |#is an option)
                                               |#Used in stack trace of ERROR or debuggers
                                               |#Read-only, but configurable (so can Object.defineProperty() the value).
FUNC.toString()                                 #Function declaration, can be eval'd()
                                                #I.e. either:
                                                #  - 'function [NAME] (...) {...}'
                                                #  - '(...) => {...}' if arrow function
                                                #  - 'NAME(...) {...}' if member function
                                                #If native function, will contain "[native code]"

this                                            #OBJ if current function fired as OBJ.FUNC(), otherwise null|undefined
                                                #Read-only
                                                #Notes:
                                                #  - FUNC2 = OBJ.FUNC or FUNC3(OBJ.FUNC)
                                                #     - must OBJ.FUNC.bind(OBJ) to keep "this"
                                                #  - OBJ = new FUNC(); calls FUNC.call(OBJ)
FUNC.bind(VAL[, ...])                           #Returns FUNC, but binds "this" to VAL (except if called with 'new'),
                                                #and first arguments to ...
                                                #Cannot rebind.
FUNC.call(VAL[, ...])                           #Same as FUNC.bind(VAL[, ...])()
FUNC.apply(VAL[, ARR])                          #Same but using an ARR instead of comma-separated arguments.
                                                #Often used to forward to another function: FUNC.apply(this, arguments)

VAR = FUNC([...]); return VAR;                *-#Two examples of a tail call optimization:
return FUNC([...]);                           *-#  - the last FUNC() performed before "return" (besides assignments)
                                              *-#    (includes FUNC like native operators)
                                              *-#This will optimize FUNC() call:
                                              *-#  - faster, because optimizer can replace call stack current frame instead
                                              *-#    of adding to it
                                              *-#  - allow infinite recursion


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OBJECTS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[new ]Object()                                  #Base TYPE of all OBJ

OBJ.VAR                                         #Access property (can be any type)
OBJ['VAR']                                      #OBJ.VAR has same naming restrictions as QUAL VAR, except can be a reserved word
                                                #OBJ['VAR'] can use any valid STR

{ VAR[: VAL] ... }                              #Literal OBJ.
                                                #If could be interpreted as a { ... } structure (e.g. beginning of line),
                                                #wrap with ()
                                                #VAR can either:
                                                #  - be "VAR" or 'VAR': any valid STR
                                                #  - be unquoted, with same naming restrictions as QUAL VAR except:
                                                #     - can be reserved keywords
                                                #     - can be any NUM, which will be converted to STR
                                               |#Def VAL is VAR
                                               |#VAR can be [STR], for dynamic property name
                                               |#If duplicate key, the last one will overwrite the ones before.
{ FUNC() {...} ... }                           |#Same as { FUNC: function FUNC() {...} ... }

ITERATING OVER PROPERTIES ==>                   #              +-------------------------------+---------------------------+
                                                #              | Own                           | Own+shared                |
                                                # +------------+-------------------------------+---------------------------+
                                                # | enum       |Object.keys(OBJ)               | for (QUAL VAR in OBJ)     |
                                                # +------------+-------------------------------+---------------------------+
                                                # | [non-]enum |Object.getOwnPropertyNames(OBJ)| 'VAR' in OBJ              |
                                                # +------------+-------------------------------+---------------------------+

Object.keys(OBJ)                                #Returns own keys, excluding non-enumerable
Object.values(OBJ)                             |#Same as Object.keys() but for values
Object.entries(OBJ)                            |#Same as Object.keys() but for [KEY, VALUE]

Object.fromEntries(ITERABLE)                  *-#Inverse Object.entries(), i.e. from ITERABLE of [KEY, VALUE] to OBJ
                                              *-#As opposed to Object.entries(), KEY that SYM are not skipped

Object.getOwnPropertyNames(OBJ)                 #Returns own keys, including non-enumerable
OBJ.propertyIsEnumerable('VAR')                 #Returns true if OBJ['VAR'] is in Object.keys()
OBJ.hasOwnProperty('VAR')                       #Returns true if OBJ['VAR'] is in Object.getOwnPropertyNames()

'VAR' in OBJ                                    #Returns true if OBJ['VAR'] is member, including shared or non-enumerable.
                                                #Negation: !('VAR' in OBJ)
                                                #Note: for (QUAL STR in OBJ) includes shared, but excludes non-enumerable

Object.assign(OBJ[, OBJ2...])                  +#Shallow copy of own enumerable OBJ2 members to OBJ, which is returned.
                                               +#Also copies SYMs.
                                               +#If OBJ2 has descriptors, they will be normalized in copy, i.e.
                                               +#configurable|writable true, and remove getters|setters.
{ [...] ...OBJ2 [...] }                       ++#Same as Object.assign({}, OBJ2, ...)
                                              ++#Exception: descriptors setters are not triggered

[QUAL] { [...] ...OBJ } = OBJ2                ++#Does Object.assign(OBJ, OBJ2), except the parts mentioned in ...

OBJ.FUNC                                        #Since OBJ.* can be overriden, can avoid shadowing by using
                                                #Object.prototype.FUNC.call(OBJ, ...) insteas of OBJ.FUNC(...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      OBJECT DESCRIPTORS       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


{ get|set VAR: FUNC() ... }                     #Like { VAR: FUNC() } followed by Object.defineProperty()
                                                #with configurable|enumerable true and writable false

Object.defineProperty(OBJ, 'VAR', OBJ2)         #Assign OBJ['VAR'] = VAL, where VAL depends on OBJ2 ('descriptors'):
                                                #  - either:
                                                #     - value VAL (def: undefined)
                                                #     - get()->VAL and set(VAL), fired at OBJ.VAR and OBJ.VAR = VAL
                                                #  - enumerable BOOL (def: false): if false, not listed by Object.keys(),
                                                #    OBJ.propertyIsEnumerable() and for (QUAL STR in OBJ)
                                                #  - configurable BOOL (def: false):
                                                #     - if false, cannot call delete OBJ.VAR nor
                                                #       Object.defineProperty(OBJ, 'VAR', OBJ2) (throws TypeError)
                                                #     - if get|set(), often non-configurable
                                                #  - writable BOOL (def: false):
                                                #     - if false, OBJ.VAR = VAL throws TypeError
                                                #       However, can still Object.defineProperty() if configurable.
                                                #     - not possible with get|set()
                                                #When fired several times, each call only overwrite the specified descriptors.
Object.defineProperties(OBJ, OBJ3)              #Same but using OBJ3 { 'VAR': OBJ2 ... } instead.
Object.getOwnPropertyDescriptor(OBJ, 'VAR')     #Returns OBJ.VAR descriptor OBJ2 (even if not declared through
                                                #Object.defineProperty()), if own [non-]enum member.
Object.getOwnPropertyDescriptors(OBJ)          |#

Object.preventExtensions(OBJ)                   #Make OBJ non-extensible (non-writable for new properties and __proto__,
                                                #throwing TypeError)
                                                #Not recursive.
Object.isExtensible(OBJ)                        #

Object.seal(OBJ)                                #Make OBJ non-extensible, non-configurable
                                                #Not recursive.
Object.isSealed(OBJ)                            #

Object.freeze(OBJ)                              #Make OBJ non-extensible, non-configurable, non-writable (except get|set())
                                                #Not recursive.
Object.isFrozen(OBJ)                            #


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          INHERITANCE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OBJ.__proto__                                   #When OBJ.VAR is not defined:
Object.getPrototypeOf(OBJ)                      #  - tries OBJ.__proto__.VAR
                                                #     - if OBJ.__proto__
                                                #     - then tries OBJ.__proto__.__proto__.VAR, etc. (prototype chain)
                                                #     - Object.prototype.__proto__ === null
                                                #  - by convention, each __proto__ points to a TYPE.prototype
                                                #    (first TYPE, then TYPE_PARENT, etc.)
                                                #Object.getPrototypeOf() is more standard.
Object.setPrototypeOf(OBJ, VAL)                |#Same as OBJ.__proto__ = VAL (to avoid because performance issues)
Object.create(TYPE.prototype[, OBJ])            #Returns OBJ2 { __proto__: TYPE.prototype }, then calls
                                                #Object.defineProperties(OBJ2, OBJ)
                                                #Can use null as first argument:
                                                #  - sometimes used as a way to semantically mean the OBJ is a map.
                                                #    Should use MAP instead
                                                #  - this means OBJ with not have builtin OBJ methods
FUNC.prototype.constructor                      #Returns FUNC
new TYPE[(...)]                                 #Does:
                                                #  var OBJ = Object.create(TYPE.prototype);
                                                #  var ret = TYPE.call(OBJ, ...);
                                                #  return ret == null ? OBJ : ret;
                                                #Avoid returning in constructor (child constructor would not be able to inherit
                                                #own members)
                                                #By convention TYPE starts with uppercase
                                                #Requires:
                                                #  - TYPE.prototype OBJ: contains shared members
                                                #  - TYPE.prototype.constructor === TYPE: for type information (optional)
new.target                                     -#In TYPE(), === TYPE (i.e. this.constructor). Otherwise undefined.
                                               -#In CHILD_TYPE(), === CHILD_TYPE

INHERITANCE ==>                                 #Prototype-based, using either:
                                                #  - own members:
                                                #     - accessed directly on OBJ:
                                                #        - TYPE(...) assigning this OBJ (or returning OBJ (to avoid))
                                                #     - inheritance: children constructor fire parent constructor
                                                #     - created each time new TYPE(...) is fired
                                                #        - i.e. one object per instance
                                                #  - shared members:
                                                #     - accessed|inherited through prototype chain
                                                #     - created once declaration-time
                                                #        - i.e. single reference for all instances
                                                #Example:
                                                #  function TYPE(...) {
                                                #    TYPE_PARENT.apply(this[, ...])
                                                #    this.VAR = ...; ...
                                                #  }
                                                #  TYPE.prototype = Object.create
                                                #    (TYPE_PARENT.prototype)
                                                #  TYPE.prototype.constructor = TYPE

STATIC MEMBERS ==>                              #Own members of TYPE itself, i.e. TYPE.VAR = VAL:
                                                #  - not inherited (unless using Backbone extend())
                                                #  - must be called on TYPE itself, not an instance

class [TYPE] [extends TYPE_PARENT]             |#Other syntax to define inheritance, defining let TYPE = FUNC:
{                                              |#  - extends TYPE2:
  [constructor(...) { ... }]                   |#      constructor() -> function TYPE():
  [static] FUNC(...) { ... }                   |#       - must call super(...) before assigning to this
}                                              |#       - by def: constructor(...args) { super(...args) }
                                               |#      TYPE.prototype = Object.create(TYPE2.prototype)
                                               |#      TYPE.prototype.constructor = TYPE (non-enumerable)
                                               |#      TYPE.__proto__ = TYPE2
                                               |#      Inherits static members too.
                                               |#  (non-static)
                                               |#  - TYPE.prototype.FUNC = FUNC (non-enumerable)
                                               |#  (static)
                                               |#  - TYPE.FUNC = FUNC (non-enumerable)
                                               |#TYPE has same naming restrictions as let TYPE = FUNC
                                               |#Throw error if not called with new.
                                               |#No comma between definition members.
                                               |#Returns TYPE
class ... {
  VAR[ = EXPR][, ...];                       *++#Calls this.VAR = EXPR in constructor, in beginning, just after super()
  static VAR[ = EXPR][, ...];                *++#Calls TYPE.VAR = EXPR right-away (in EXPR, this is TYPE)
  [static] #VAR[ = EXPR][, ...];             *++#Like VAR = EXPR and FUNC(...), except can only be refered to inside class,
  #FUNC(...) { ... }                         *++#i.e. using this.#VAR and this.FUNC(...)
                                             *++#Can only be declared during class declaration.
}

super                                          |#Inside class {...}, same as TYPE_PARENT

UTIL.inherits(TYPE, TYPE_PARENT)               ##For Node.js:
                                               ##  TYPE.prototype = Object.create(TYPE_PARENT.prototype);
                                               ##  TYPE.prototype.constructor = TYPE;
                                               ##  TYPE.super_ = TYPE_PARENT;
                                               ##So setup shared members, and allow TYPE constructor to call parent constructor
                                               ##using this.constructor.super_.apply(this, arguments);

MULTIPLE INHERITANCE ==>                        #For:
                                                #  - own members: call several parent constructors in TYPE()
                                                #  - shared members: use mixins, i.e. assign TYPE_PARENT.prototype.* to
                                                #    TYPE.prototype.* instead of using prototype chain.

USING EXTEND ==>                                #Basic extend() (like jQuery, Underscore, not like Backbone) are sometimes used
                                                #for inheriting shared members. They help for mixins (see above). However:
                                                #  - if does not include shared members (like Lodash), will not inherit
                                                #    grandparents
                                                #    members (unless copied to parent)
                                                #  - TYPE_PARENT.prototype.VAR will be copied, not referenced, if it is
                                                #    native type

NATIVE OBJECTS INHERITANCE ==>                  #Native objects constructors return a value instead of assigning to this.
                                                #So inheriting not possible, but can extend prototype (to avoid though).
                                                #new TYPE() vs TYPE():
                                                #  - Object|Array|Function|RegExp: no difference
                                                #  - String|Boolean|Number: without new, returns native type
                                                #  - Date: without new, returns DATE.toString()
                                                #  - Error: same except stack trace (prefer new Error)
                                                #  - ArrayBuffer: mandatory new
                                               -#Can however use class ... extends syntax to extend native objects.

TYPE[Symbol.species]()->TYPE2                  -#To override TYPE construcor used to create empty new objects.
                                               -#Used e.g. by ARR.concat|filter|map|slice|splice(), STR.split(REGEXP)
                                               -#or PROMISE.then ()
                                               -#E.g. if TYPE deriving from Array, TYPE.map() will return TYPE not ARR,
                                               -#unless this is used


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            SYMBOLS            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


QUAL SYM = Symbol([STR])                       -#Same as OBJ["RANDOM"], semantically for private members:
OBJ[SYM]                                       -#  - STR optional, just used for toString() description
                                               -#    OBJ[Symbol(STR)] !== OBJ[STR]
                                               -#  - Symbol() != Symbol(), so avoid naming collisions
                                               -#  - not enumerable:
                                               -#     - getOwnPropertyNames() -> getOwnPropertySymbols()
                                               -#     - Object.keys|getOwnPropertyNames() or '... in OBJ' will not
                                               -#       show symbols.
                                               -#  - properties with a key of SYM will be ignored by JSON.stringify()
                                               -#Also used as "well-known symbols":
                                               -#  - methods to define on TYPE[Symbol.VAR] to emulate native type behavior
                                               -#    (e.g. Symbol.iterator)
                                               -#  - when printed, abbreviated to @@VAR
SYM.description                               *-#STR from constructor

Symbol.for(STR)                                -#Like Symbol(STR), except register it to a global store using STR as a key,
                                               -#so that Symbol.for(STR) === Symbol.for(STR)
Symbol.keyFor(SYM)                             -#Returns STR if SYM was created as Symbol.for(STR), undefined otherwise.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          STRUCTURES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


SINGLE LINE ==>                                 #Block braces can be skipped if only on single next line (to avoid)

VAL                                             #Anything that returns a VAL
EXPR                                            #Anything that could go on a single line of code ending with ;
...                                             #Several EXPR


TEST ? VAL1 : VAL2                              #Returns VAL1 or VAL2

VAL && VAL2                                     #Same as !!VAL ? VAL : VAL2, for any type (including BOOL)
VAL || VAL2                                     #Inverse

VAL1, VAL2                                      #Evaluates both, but returns VAL2.
                                                #Use case: in for or while loops.


{ ... }                                         #Creates a scope

(VAL)                                           #To increase precedence.

if ( TEST ) { ... }
[else if ( TEST ) { ... }]...
[else { ... }]

switch (VAL) {                                  #Use VAL === VAL2
  case VAL2: ...  [break;] ...                  #If no break, execute next case (including "default")
  case VAL3: case VAL4: ...  [break;] ...       #Case can be empty, meaning several "case" match when any matches.
  [default: ...  [break;]]                      #... can be wrapped in { ... }, which creates a scope
}

for ( [EXPR1] ; [TEST] ; [EXPR2] ) { ... }      #Same as:
                                                #  EXPR1; while ( TEST ) { ...; EXPR2; }
while ( TEST ) { ... }
do { ... } while ( TEST )

for ( QUAL VAR in OBJ ) { ... }                 #Iterate over own+shared enumerable keys.
                                                #OBJ can be ITERATOR.
for ( QUAL VAR of ITERABLE ) {...}             |#Iterates with VAR = NEXT

break [LABEL]                                   #Stop current for|while|switch iteration or (only with LABEL)
                                                #if_else|anonymous block
                                                #Can target a specific for|while|switch iteration by specifying LABEL: before
                                                #it (to avoid), e.g. LABEL: for ... or LABEL: if ...
continue [LABEL]                                #Same but only current loop, and only for|while


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            ERRORS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


throw VAL                                       #Throw exception VAL, i.e. interrupt each function in the call stack until
                                                #inside try { ... } followed by catch ( VAR ) { ... }
                                                #Thrown errors will reject parent PROMISEs and be propagated in async|await stacks
                                                #However they will stop at other top-level functions creating async context
                                                #  - e.g. setTimeout()
                                                #  - i.e. should be promisified
try { ...  }
[catch [(VAR)] { ... }]                       ++#(VAR) can be omitted
[finally { ... }]                               #finally { ... } is always fired

[new ]Error([STR])                              #OBJ usually used when throw VAL, because more info.
                                                #Prefer with "new"
                                                #STR is ERROR.message (def: "")
                                                #Some builtin ERROR thrown:
                                                #  - ReferenceError: console.log(notdeclared)
                                                #  - TypeError: null.FUNC()
                                                #  - SyntaxError: 5 *** 7
                                                #  - RangeError: new Array(Infinity)
                                                #  - URIError: decodeURIComponent('%')
                                                #  - EvalError: with eval()
ERROR.name                                      #ERROR type (def: "Error"), redefined by children.
ERROR.message                                   #
ERROR.stack                                     #Stack trace STR
                                                #Created|evaluated on new Error()
                                                #  - i.e. represents position at that moment
                                                #  - however actual stack creating code is called lazily because slightly slow
                                                #Uses FUNC.name
                                                #Format is dependent on the engine.
                                                #See "async" above for async stack trace
                                                #See stack trace documentation for more information on: parsing, normalizing,
                                                #beautifying, visualizing, etc.
ERROR.toString()                                #'NAME: MESSAGE'
                                                #However UTIL.inspect(ERROR) is 'NAME: MESSAGE\nSTACK'


debugger                                        #Sets a breakpoint


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            BOOLEAN            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Boolean(BOOL)                               #Returns OBJ (see above).
Boolean(BOOL)                                   #Returns BOOL (see above)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            NUMBER             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Number(NUM)                                 #Returns OBJ (see above)
Number(NUM)                                     #Returns NUM (see above)

Number.isInteger(NUM)                          +#Does not coerce to NUM

[Number.]NaN                                    #Returned e.g. by √-1, 0/0 or wrong NUM conversion
                                                #Test:
                                                #  - NaN !== NaN but Object.is(NaN, NaN)
                                               +#  - Number.isNaN(VAL): same as Object.is(VAL, NaN)
                                                #  - isNaN(VAL): same as Number.isNaN(Number(VAL))
[-]Infinity                                     #Returned e.g. by overflow like 1e400, or 1/0
Number.POSITIVE_INFINITY|NEGATIVE_INFINITY      #Test:
                                                #  - [-]Infinity === [-]Infinity
                                               +#  - Number.isFinite(VAL): same as VAL !== Infinity && VAL !== -Infinity
                                               +#    && !Number.isNaN(VAL)
                                                #  - isFinite(VAL): same as Number.isFinite(Number(VAL))
Number.MIN_VALUE                                #Closest to 0 (underflow) (about 5e-324)
Number.MAX_VALUE                                #After it is Infinity (overflow) (about 2e+308)
Number.MIN|MAX_SAFE_INTEGER                    +#Smallest|highest integer that can be represented as a float precisely
                                               +#(about +|-1e16)
                                               +#Test: Number.isSafeInteger(VAL) (does not coerce to NUM)
Number.EPSILON                                 +#NUM +|- NUM2 can create small discrepancies, e.g. 0.3 - 0.1 within a
                                               +#EPSILON range:
                                               +#  - When comparing non-integer NUMs, should check NUM-NUM2 < +|-EPSILON
                                               +#  - about 2e-16


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            STRING             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new String(STR)                                 #Returns OBJ (see above)
String(STR)                                     #Returns STR (see above)

`...${EXPR}...`                                |#"..." + EXPR + "..."
                                               |#Escapes everything (including " ' or newline) but ` ${ or \
FUNC`...`                                      |#FUNC(STR_ARR, VAL...)->VAL:
FUNC `...`                                     |#  - VAL... are each ${EXPR}
                                               |#  - STR_ARR[.raw][NUM] are each `...` in-between, including empty ""
                                               |#at beginning|end if starts|ends
                                               |#    with ${EXPR}
                                               |#    If "raw", escape backslashes
                                               -#  - special case for backslash sequences (only if FUNC specified):
                                               -#     - STR is undefined
                                               -#     - escaped in STR.raw, e.g. '\\n'
                                               |#FUNC can be String.raw(), which concanates all like normal template,
                                               |#except it escape backslashes


STR[NUM]                                        #Read-only. undefined if out of range.
STR.charAt(NUM)                                 #Same except "" if out of range

STR.length                                      #

STR.match(REGEXP)                               #Like REGEXP.exec(STR), except that if g flag, returns all matches as ARR
                                                #(or null)
STR.matchAll(REGEXP)                          *-#Returns ITERABLE that returns successive REGEXP.exec(STR)
                                              *-#I.e. as opposed to STR.match(), when using a g flag, parenthesis groups and
                                              *-#indices will be returned too
STR.search(REGEXP)                              #Like STR.indexOf() but with a REGEXP
STR.starts|endsWith|includes(STR2[, NUM])      +#

STR.replace(REGEXP|STR2, STR3)                  #Returns STR, replacing REGEXP with STR3, which can contain:
                                                #  - $1, etc.: parenthesis group matches
                                                #  - $&: full match
                                                #  - $`: what's before full match
                                                #  - $': what's after full match
                                                #  - $$: $ littéral
STR.replace(REGEXP|STR2,
FUNC($&, $1..., INDEX, STR))                    #Returs STR, replacing REGEXP with FUNC(...)
STR.split(REGEXP|STR2[, UINT])                  #Returns an ARR, with REGEXP|STR2 being split delimiter.
                                                #If STR2 is '', means between each characters.
                                                #If REGEXP contains parenthesis groups, each is included in ARR between
                                                #each element.
                                                #If UINT, does ARR.slice(0, UINT)
STR.repeat(NUM)                                +#

OBJ[Symbol.match](...)                         +#Methods to implement to be able to use STR.match(OBJ)
                                               +#or STR.startsWith|endsWith|includes(OBJ)
                                               +#Implemented by REGEXP
OBJ[Symbol.search|replace|split](...)          +#Methods to implement to be able to use STR.search|replace|split(OBJ).
                                               +#Implemented by REGEXP

STR.toUpper|LowerCase()                         #
STR.trim()                                      #
STR.trimLeft|Right()                            #Remove whitespaces on left and|or right.
STR.trimStart|End()                             #Aliases for trimLeft|Right()
STR.padStart|End(NUM[, STR2])                  |#If STR.length < NUM, prepends|appends STR2 (def: ' ') until STR.length === NUM

STR.concat(STR2...)                             #Prefer + and +=

STR.[lastI/i]ndexOf(STR[, NUM])
STR.slice(NUM[, NUM2])                          #Like ARR
STR.substring(NUM[, NUM2])                      #Like .slice() except:
                                                #  - negative NUM2 -> 0
                                                #  - If NUM2 < NUM, swap
STR.substr(NUM[, NUM2])                         #Like .slice() except:
                                                #  - NUM can be negative (index from end)
                                                #  - NUM2 is length, not index

en|decodeURI(STR)                               #Percent-encode any character not permitted in URIs, i.e. anything but:
                                                #  [:alnum:] - . _ ~ ! ' ( ) * # : ? & = + $ ; , / @
                                                #Should be used for full URIs
                                                #Uses UTF-8
                                                #decodeURI() can throw URIError
en|decodeURIComponent(STR)                      #Same but also percent-encode characters that might have semantics in
                                                #URIs parts:
                                                #  : ? & = # + $ ; , / @
                                                #I.e. does not percent-encode the following (should escape if it has semantics
                                                #for specific case):
                                                #  [:alnum:] - . _ ~ ! ' ( ) *
                                                #Should be used for URI parts


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            UNICODE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


\uCODEPOINT_HEXA                                #CODEPOINT:
                                                #  - for all Unicode <=FFFF
                                                #  - considered a single char by all methods
\u{S_CODEPOINT_HEXA}                           |#S_CODEPOINT:
                                               |#  - for all Unicode
                                               |#  - considered one or two chars depending on whether <=FFFF
                                               |#     - exception: considered a single char by methods specifying S_CODEPOINT

String.fromCharCode(CODEPOINT...)               #
String.fromCodePoint(S_CODEPOINT...)           |#Returns STR

STR.charCodeAt(NUM)                             #Returns CODEPOINT. If out-of-range, returns ''.
STR.codePointAt(NUM)                           |#Returns S_CODEPOINT. If out-of-range, returns undefined.

STR.normalize([STR2])                          -#Compose|decompose combined Unicode (e.g. with diacretics):
                                               -#  - "NFC|NFD" (def: "NFC"): compose|decompose (canonical)
                                               -#  - "NFKC|NFKD": same for compatibility form

/REGEXP/u                                      |#  - allow . and [] to match S_CODEPOINT, not just CODEPOINT
                                               |#     - does not work for Emojis, regional symbols and combining characters
                                               |#  - stricter REGEXP syntax enforcement, e.g. /{/ throws
                                               -#  - allow using \p or \P


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             INTL              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


OBJ|SOBJ.toLocaleString()                       #Same as OBJ.toString(), but can be reimplemented by children
                                                #(like OBJ.toString())
ARR.toLocaleString()                            #Same as ARR.toString() with locale commas
STR.toLocaleUpper|LowerCase()                   #Using current locale

new Intl.Locale(LOCALE, LOCALE_ARGS)           *-#LOCALE_OBJ
                                               *-#LOCALE_ARGS is an OBJ:
                                               *-#  - are Unicode "Language tags"
                                               *-#  - list: see its doc
                                               *-#  - supports: ca|calendar, co|collation, hc|hourCycle, kf|caseFirst,
                                               *-#    kn|numeric, nu|numberingSystem
                                               *-#Def: current locale
                                               *-#For Node, support must be done during building
LOCALE_OBJ.*                                   *-#Anything from LOCALE_ARGS (using long name)
LOCALE_OBJ.language                            *-#STR
LOCALE_OBJ.script                              *-#STR
LOCALE_OBJ.region                              *-#STR
LOCALE_OBJ.toString()->LOCALE                  *-#
LOCALE_OBJ.locale                              *-#Like LOCALE, but only the first part
LOCALE                                          |#STR serialization of LOCALE_OBJ:
                                                |#  - e.g. 'fr-FR'
                                                |#  - LOCALE_ARGS is serialized as final -u-SHORTEN_ARG-VAL
                                                |#  - true for current locale
Intl.getCanonicalLocales                        |#Normalize LOCALE, e.g. its case and remove duplicates
 (LOCALE[_ARR])->LOCALE_ARR                     |#Throws if invalid

LOCALEOPTS ==>                                  |#Is LOCALE[_ARR][, OPTS]
                                               *-#Or LOCALE_OBJ[_ARR][, OPTS]
                                                |#OPTS:
                                                |#  - depends on the method
                                                |#  - defaults to using CLDR with the provided LOCALE
                                                |#  - always has members:
                                                |#     - locale LOCALE
                                                |#     - localeMatcher 'best fit' (def) or 'lookup' (poorer algorithm)
                                                |#  - some members might be read-only
Intl.*.supportedLocalesOf([LOCALEOPTS])         |#Returns LOCALE_ARR matching LOCALEOPTS and being installed on client.

new Intl.*([LOCALOPTS])                         |#Returns new instance of a specific intl operation
                                                |#Is expensive, so should be cached
                                                |#Returned member always has members:
                                                |#  - resolvedOptions()->OPTS

new Intl.Collator([LOCALEOPTS])                 |#Locale-specific collation.
                                                |#OPTS:
                                                |#  - usage 'sort' (def) or 'search': like co "search" LOCALE_ARGS
                                                |#  - sensitivity 'base|accent|case|variant' (def: 'variant'):
                                                |#     - case-sensitive: 'case|variant'
                                                |#     - accent-sensitive: 'accent|variant'
                                                |#  - ignorePunctuation BOOL (def: false)
                                                |#  - numeric BOOL (def: false): like kn LOCALE_ARGS
                                                |#  - caseFirst 'upper|lower' or 'false' (def, i.e. locale's): like
                                                |#    kf LOCALE_ARGS
                                                |#Relevant LOCALE_ARGS: co, kn, kf
COLLATOR.compare(STR, STR2)->NUM                |#Like STR < <= >= > STR2, except:
STR.localCompare(STR2[, LOCALEOPTS])->NUM       |#  - returns as -1|0|1
                                                |#  - real sorting, not just codepoint-wise
                                                |#  - takes locales into account

new Intl.NumberFormat([LOCALEOPTS])             |#Number locale formatting.
                                                |#OPTS:
                                                |#  - style 'decimal|currency|percent' (def: 'decimal')
                                                |#  - currency STR (no def)
                                                |#  - currencyDisplay 'symbol|code|name' (def: 'symbol')
                                                |#  - useGrouping BOOL (def: true): throusands separators
                                                |#  - minimum|maximumInteger|Fraction|SignificantDigits NUM
                                                |#Relevant LOCALE_ARGS: nu
NUMBERFORMAT.format(NUM)->STR                   |#
NUM.toLocaleString([LOCALEOPTS])->STR           |#
NUMBERFORMAT.formatToParts(NUM)->OBJ_ARR        -#OBJ_ARR:
                                                -#  - type STR:
                                                -#     - 'integer|fraction': integer|fraction part of the number
                                                -#     - 'decimal': decimal separator
                                                -#     - 'group': thousands separator
                                                -#     - 'currency': currency string
                                                -#     - 'percentSign': %
                                                -#     - 'plusSign|minusSign': + or -
                                                -#     - 'infinity|nan': ∞ or NaN
                                                -#     - 'literal': anything else, e.g. spaces
                                                -#  - value STR

new Intl.DateTimeFormat([LOCALEOPTS])           |#Date|Time|Date+Time locale formatting.
                                                |#OPTS:
                                                |#  - timeZone STR (def: locale's)
                                                |#  - hour12 BOOL (def: locale's)
                                                |#  - formatMatcher 'basic' or 'best fit' (def): like localeMatcher, but for
                                                |#    OPTS.weekday|etc.
                                                |#  - weekday|era 'narrow|short|long' (no def)
                                                |#  - month 'numeric|2-digit|narrow|short|long' (no def)
                                                |#  - year|day|hour|minute|second 'numeric|2-digit' (no def)
                                                |#  - timeZoneName 'short|long' (no def)
                                                |#Relevant LOCALE_ARGS: nu, ca
DATETIMEFORMAT.format(DATE)->STR                |#
DATE.toLocale[Date|Time]String([LOCALOPTS])->STR|#
DATETIMEFORMAT.formatToParts(DATE)             -|Same but returned as OBJ_ARR:
                                               -|#  - type 'era|year|month|weekday|day|hour|minute|second|timeZoneName|separator'
                                               -|#  - value STR

new Intl.RelativeTimeFormat([LOCALEOPTS])      *-#Date|Time|Date+Time locale formatting, for relative time ("time ago")
                                               *-#OPTS:
                                               *-#  - style STR:
                                               *-#     - 'long' (def) ("in 1 month")
                                               *-#     - 'short' ("in 1 mo.")
                                               *-#     - 'narrow' ("in 1 mo.")
RELATIVETIMEFORMAT.format(NUM, STR)->STR2      *-#STR: 'year|quarter|month|week|day|hour|minute|second'
RELATIVETIMEFORMAT.formatToParts(NUM, STR)     *-#OBJ_ARR:
 ->OBJ_ARR                                     *-#  - type STR: like unit (e.g. "year") or "literal" (anything else)
                                               *-#  - value STR

new Intl.PluralRules([LOCALEOPTS])              -#Locale-specific plural group of a NUM
                                                -#OPTS:
                                                -#  - type 'cardinal' (def) or 'ordinal'.
                                                -#    It's because some languages have different rules for either.
                                                -#  (read-only)
                                                -#  - minimum|maximumFraction|SignificantDigits NUM
                                                -#  - pluralCategories STR_ARR
PLURALRULES.select(NUM)->STR                    -#Returns plurality of NUM according to locale, among 'zero', 'one', 'two',
                                                -#'few', 'many', 'other'

new Intl.ListFormat([LOCALEOPTS])              *-#Format list of items with natural language.
                                               *-#OPTS:
                                               *-#  - type 'regular' (def) (can use "and") or 'unit' (use only commas)
                                               *-#  - style 'long' (def), 'short' or 'narrow'
LISTFORMAT.format(STR_ARR)->STR                *-#
LISTFORMAT.formatToParts(STR_ARR)->STR_ARR     *-#

new Intl.Segmenter([LOCALEOPTS])               *-#Break down strings into smaller parts, locale-specific.
                                               *-#OPTS:
                                               *-#  - granularity STR:
                                               *-#     - 'grapheme': might include several chars, since accents are chars
                                               *-#     - 'word'
                                               *-#     - 'sentence'
                                               *-#     - 'line': line breaking
                                               *-#  - strictness STR: for granularity 'sentence', whether line breaking
                                               *-#    should be 'strict', 'normal', 'loose'
SEGMENTER.segment(STR)->OBJ_ITERABLE           *-#OBJ:
                                               *-#  - segment STR2
                                               *-#  - breakType STR3: undefined (beginning or end), 'none' (not a word),
                                               *-#    'soft' (line break possible), 'hard' (explicit line break)
                                               *-#  - position NUM


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REGEXP             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


/PATTERN/[FLAGS]                                #Def STR: '(?:)'
[new ]RegExp(['PATTERN'[, 'FLAGS']])            #Backslashes must be escaped in the second form
                                                #Perl RegExp except:
                                                #  - no [[:CLASS:]]
                                                #  - no \< \>
                                                #  - no +-greediness
                                                #  - no additional flags
                                                #  - no \A \Z but ^ $ behave like \A \Z unless m flag
                                                #Also has:
                                               -#  - \p \P: requires u flag
                                               -#  - (?<=) (?<!)
                                               -#  - (?<GROUP>) \k<GROUP>:
                                               -#     - REGEXP.exec() return value ARR also defines ARR.groups.GROUP to access
                                               -#       those
                                               -#     - STR.replace() accesses those using:
                                               -#        - ${GROUP} if using a string (with normal quotes)
                                               -#        - extra parameter groups OBJ if using a FUNC
                                                #Flags:
                                                #  - possible:
                                                #     - i: case insensitive
                                                #     - g:
                                                #        - use REGEXP.lastIndex:
                                                #           - initially 0, set to last match index (or 0 if no match)
                                                #           - next REGEXP.exec|test() will start from there
                                                #        - if using ^, if no match, returns null but set REGEXP.lastIndex
                                                #          to next match
                                                #        - function taking REGEXP as argument should iterate using
                                                #          REGEXP.lastIndex
                                                #           - this is what do standard JavaScript methods,
                                                #             e.g. STR.match|replace()
                                                #     - m: ^ $ newline-wise (otherwise not)
                                               -#     - s: . newline-wise (otherwise not), i.e. match any character including:
                                               -#       LF CR U+2028 U+2029
                                               -#     - y: same as g, with ^ in beginning of PATTERN
                                               |#     - u: see above
                                                #  - available at REGEXP.ignoreCase|global|multiline|sticky BOOL
REGEXP.source                                   #'PATTERN' (read-only)
REGEXP.flags                                   |#'FLAGS' (read-only)

REGEXP.exec(STR)                                #Search REGEXP in STR and returns ARR (or null):
                                                #  - ARR[0]: whole match
                                                #  - ARR[n]: parenthesis matches
                                                #  - ARR.index: first match index
                                                #  - ARR.input: STR
REGEXP.test(STR)                                #Returns BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ARRAY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Array                                           #Are actually OBJ with numeric property names, so can do ARR[NUM]
                                                #Can contain different types.
                                                #Multidimensional ARR: use ARR of ARRs
[new ]Array(NUM)                                #Returns ARR with NUM undefined values.
                                                #Throw RangeError if non-positive or decimal.
[new ]Array(VAL...)                             #Like [ VAL... ]
Array.of(VAL...)                               |#Same as new Array(VAL...) except not interpreted as new Array(NUM) if
                                               |#only VAL is NUM
[ [VAL...] ]                                    #Literal form.
                                                #Can use trailing commas
                                               |#VAL can be ...ITERABLE

ARRAYLIKE                                       #Any OBJ which understand OBJ[NUM] and OBJ.length
                                                #Can use all ARR methods, except concat() using:
                                                #  Array.prototype.FUNC.call(ARRAYLIKE, ...) is like ARR.FUNC(...)
                                                #If expected to return ARR, returns ARR not ARRAYLIKE.
Array.from(ARRAYLIKE|ITERABLE[, ...])          |#Returns as ARR
                                               |#If ..., also calls ARR.map(...)
                                               |#Can do Array.from({ length }, (_, i) => i) to get [0, 1, ...]

ARR.length                                      #Can be modified (will truncate or extend with undefined values)
                                                #Max 4 billions (32-bits).

ARR.concat(VAL)                                 #Pushes VAL (does not modify)
                                                #If VAL is ARR2, pushes ARR2 elements, not ARR2 itself,
                                               -#unless ARR[Symbol.isConcatSpreadable] false
ARR.slice([NUM[, NUM2]])                        #Returns ARR copy from index NUM (def: 0) to NUM2 (def: ARR.length).
                                                #NUM|NUM2 can be negative, i.e. from ARR end.
ARR.splice(NUM, NUM2[, VAL...])                 #Erase and return NUM2 elements from index NUM, and replace them with VAL...
ARR.fill(VAL[, NUM[, NUM2]])                   |#Same as ARR.splice(NUM, NUM2, VAL...) with VAL being repeated NUM2-NUM times.
ARR.copyWithin(NUM, NUM2[, NUM3])              |#Copies ARR.slice(NUM2, NUM3) to ARR itself, starting at index NUM.
                                               |#Returns ARR.
ARR.join([STR])                                 #Returns as STR2, with STR delimiter (def: ',')

ARR.push|unshift(VAL)                           #Adds VAL to end|beginning (modifies). Returns ARR.length
ARR.pop|shift()                                 #Remove and returns last|first element (modifies).

ARR.reverse()                                   #Modifies and returns ARR.
ARR.sort([FUNC(VAL, VAL2)->-1|0|1])             #Modifies and returns ARR.
                                                #Default FUNC does STR comparison.
                                                #Implementation algorithm detail:
                                                #  - v8 uses insertion sort if ARR.length <= 10, quick sort otherwise

ARR.indexOf(VAL[, NUM])                         #Returns VAL index, or -1. Uses ===
                                                #If NUM, skip first NUM elements (but still returns index from beginning)
                                                #Using ~VAL is shortcut for VAL !== -1, e.g. ~ARR.indexOf(VAL) is
                                                #like ARR.includes(VAL)
ARR.lastIndexOf(VAL[, NUM])                     #Same but from end.
ARR.find[Index](FUNC(VAL,KEY,ARR)->BOOL[,THIS])|#Returns first VAL|KEY that returns true. Otherwise does not return.
ARR.includes(VAL[, NUM])                       +#Same as ARR.indexOf(...) !== -1
                                               +#Except NaN === NaN

ARR.forEach(FUNC(VAL, KEY, ARR)[, THIS])        #
ARR.map(FUNC(VAL, KEY, ARR)->VAL[, THIS])       #Returns [VAL...]

ARR.reduce[Right]                               #MEMO is:
(FUNC(MEMO, VAL, KEY, ARR)[, MEMO])             #  - first: argument passed (def: first value, which is then not iterated)
                                                #  - then: previous FUNC() return value
                                                #  - final return value
                                                #reduceRight iterates from end to beginning
ARR.filter(FUNC(VAL, KEY, ARR)->BOOL[, THIS])   #Excludes if false
ARR.every|some(FUNC(VAL, KEY, ARR)->BOOL[,THIS])#Returns true if all|any true.
ARR.flat([INT])                              *-|#Flattens INT levels of depth (def: 1)
ARR.flatMap(...)                             *-|#Same as ARR.map(...).flatten(1)

ARR.keys()                                     |#Returns all KEY as ITERABLETOR
ARR.values()                                   |#Returns all VAL as ITERABLETOR (i.e. same as ARR[Symbol.iterator])
ARR.entries()                                  |#Returns all [KEY, VAL] as ITERABLETOR


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         TYPED ARRAYS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new ArrayBuffer(UINT)                           #Raw data chunk (initially filled with zeros). UINT is byteLength.
                                                #Needs a DATAVIEW|TYPED_ARR to be manipulated, which gives:
                                                #  - a specific type to read it
                                                #  - an offset from the beginning of it
                                                #Available:
                                                #  - DATAVIEW: can change type
                                                #  - TYPED_ARR: more convenient because manipulated as an ARR
                                                #Several DATAVIEW|TYPED_ARR can be applied to a single ARRBUFFER.
ArrayBuffer.isView(OBJ)                         #True if DATAVIEW|TYPED_ARR
ARRBUFFER.byteLength                            #Readonly.
                                                #This is different from STR.length which returns number of characters
ARRBUFFER.slice(...)                            #Like ARR.slice(...)


new DataView(ARRBUFFER[, UINT[, UINT2]])        #UINT is offset (def: 0), UINT2 length (def: ARRBUFFER.byteLength)
DATAVIEW.buffer|byteLength|byteOffset           #Readonly

DATAVIEW.get[Ui|I]nt8|16|32([UINT[, BOOL]])
DATAVIEW.getFloat32|64(UINT[, BOOL])            #UINT is byte offset, BOOL endianness (def: true, i.e. little endian)
DATAVIEW.getBig[Ui|I]nt64(UINT[, BOOL])       *-#
DATAVIEW.set*(UINT, UINT2[, BOOL])              #UINT2 is the value to set


TypedArray                                      #Base prototype of [Ui|I]nt8|16|32Array or Float32|64Array
                                              *-#and Big[Ui|i]nt64Array
                                                #Each have a given associated type
                                                #Not accessible globally but through prototype chain.
                                               -#Mixes in all ARR methods, including static ones.
                                               -#There is also a special Uint8ClampedArray, which do not 'roll' too low|high
                                               -#values, e.g.:
                                               -#  - UINT8_ARR[0] = -10 (246) vs UINT8_CLAMPED_ARR[0] = -1 (0)
                                               -#  - UINT8_ARR[0] = 260 (4) vs UINT8_CLAMPED_ARR[0] = 260 (255)
new TypedArray(ARRBUFFER[, UINT[, UINT2]])      #Same args as DataView
new TypedArray(NUM)                             #Same as new TypedArray(new ArrayBuffer(NUM))
new TypedArray(TYPED_ARR2)                      #Copy (no reference between each other)
new TypedArray(ARRAYLIKE|ITERABLE)              #Uses TYPED_ARR.from(...)

TypedArray|TYPED_ARR.BYTES_PER_ELEMENT          #
TYPED_ARR.buffer|byteLength|byteOffset          #Readonly
TYPED_ARR.length                                #

TYPED_ARR.subarray(...)                         #Like slice(...) except it shares same ARRBUFFER
TYPED_ARR.set(ARR|TYPED_ARR2[, UINT])           #Sets all ARR|TYPED_ARR2 values into TYPED_ARR, starting at index UINT (def: 0)
                                                #If ARR|TYPED_ARR2 too big, RangeError thrown
TYPED_ARR.toString()                            #Is like ARR, not OBJ


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        SHARED BUFFERS         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new SharedArrayBuffer(UINT)                    -#Can be used like an ARRBUFFER including:
                                               -#  - new TypedArray(...)
                                               -#  - postMessage(...)
                                               -#Except:
                                               -#  - cannot be used with DataView, and no SharedArrayBuffer.isView()
                                               -#  - shared between contexts|WINDOWs, e.g. when passed via postMessage()
                                               -#     - postMessage() should not use VAL2
                                               -#  - must be manipulated using Atomics.*() to ensure thread-safety:
                                               -#     - provide correct atomicity and order, underlyingly using a lock

Atomics.load(S_ARRBUFFER, NUM)->VAL            -#Like S_ARRBUFFER[NUM]
Atomics.store(S_ARRBUFFER, NUM, VAL)->VAL      -#Like S_ARRBUFFER[NUM] = VAL
Atomics.exchange(S_ARRBUFFER, NUM, VAL)->VAL2  -#Like S_ARRBUFFER[NUM] = VAL, returning previous value
Atomics.compareExchange                        -#Like if (S_ARRBUFFER[NUM] == VAL3) S_ARRBUFFER[NUM] = VAL,
 (S_ARRBUFFER, NUM, VAL3, VAL)->VAL2           -#returning previous value

Atomics.add|sub|and|or|xor
 (S_ARRBUFFER, NUM, VAL)->VAL2                 -#Like S_ARRBUFFER[NUM] += -= &= |= ^= VAL, returning previous value

Atomics.wait                                   -#Wait until Atomics.notify(), providing test passes.
 (S_INT32_ARR, NUM, VAL[, NUM2])->STR          -#I.e.:
                                               -#  - if S_INT32_ARR[NUM] != VAL, does nothing (STR is "not-equal")
                                               -#  - otherwise:
                                               -#     - wait until Atomics.notify() (STR is "ok")
                                               -#     - or until timeout NUM2ms (STR is "timed-out")
Atomics.notify(S_INT32_ARR, NUM, NUM2)         -#Wake up NUM2 workers Atomics.waiting, with same first two arguments

Atomics.isLockFree(S_ARRBUFFER, NUM)->BOOL     -#True if underlying hardware can avoid locks for S_ARRBUFFER in a typed array
                                               -#of size NUM
                                               -#Always true for NUM 4, often true for 1|2, usually false otherwise
                                               -#Used for optimization, i.e. not relying on shared buffers if underlying
                                               -#hardware is going to be slow


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           ITERATORS           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ITERATOR                                       +#OBJ with:
                                               +#  - next([VAL])->{ done BOOL, value NEXT }
                                               +#     - NEXT is next value
                                               +#     - iteration stops when BOOL true, then should always return {done true}
                                               +#     - consumers usually call NEXT = next() until BOOL true
                                               +#  (optional)
                                               +#  - return(FINAL_NEXT)->{ done true, value FINAL_NEXT }
                                               +#     - consumer can use this to stop iteration, e.g. for (... of ...)
                                               +#       break|throw
                                               +#  - throw(ERROR):
                                               +#     - should throw ERROR, from where current iteration is
                                               +#     - consumer can use this to notify of iteration error
ITERABLE                                       +#OBJ where OBJ[Symbol.iterator]()->ITERATOR
                                               +#STR|[TYPED_]ARR|MAP|SET are ITERABLE.
ITERABLETOR                                    +#ITERABLE which is also an ITERATOR.

function* [FUNC](){...}                        +#Generator.
[class ...] { * FUNC(...) {...} ... }          +#Returns a FUNC()->ITERABLETOR:
                                               +#  - next([VAL]):
                                               +#     - VAL is current "yield" returns value
                                               +#        - note: for (... of ...) only calls next(), so yield returns undefined
                                               +#     - stops at next "yield NEXT" or "return FINAL_NEXT"
                                               +#  - return(FINAL_NEXT)->{ done true, value FINAL_NEXT }
                                               +#     - meant for cleanup codde
                                               +#  - throw(ERROR): throw ERROR from context of last yield
                                               +#Can also use yield* ITERABLE:
                                               +#  - yield NEXT several times
                                               +#  - return value is final yield's return value
new GeneratorFunction(...)                     +#Like new Function(...) but for function*(){}
                                               +#GeneratorFunction not available globally, but with:
                                               +#  Object.getPrototypeOf(function*(){}).constructor


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          MAPS & SETS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Map([ITERABLE])                            +#ITERABLE must iterate over [KEY, VAL] elements (e.g. Object.entries(OBJ))
                                               +#Is an ITERABLE itself, iterating over [KEY, VAL] in insertion order.
                                               +#To use instead of OBJ, when:
                                               +#  - KEY must be other than STR
                                               +#  - VALs are conceptually similar to each other

MAP.get(KEY)->VAL                              +#Like OBJ[KEY] and OBJ[KEY] = VAL, except KEY can be any type.
MAP.set(KEY, VAL)->MAP                         +#KEY equality uses Object.is() not ===
MAP.has(KEY)->BOOL                             +#
MAP.delete(KEY)->BOOL                          +#
MAP.clear()                                    +#

MAP.size                                       +#

MAP.keys|values|entries()                      +#Like ARR
MAP.forEach(...)                               +#Like ARR


WeakMap                                        +#Like Map, except WEAKMAP does not own its children:
                                               +#  - VAL will be garbage collected when its KEY is, whether WEAKMAP is still
                                               +#    around or not
                                               +#  - while MAP.set(KEY, VAL) is conceptually like MAP.KEY = VAL,
                                               +#    WEAKMAP.set(KEY, VAL) is like KEY.__value = VAL
                                               +#  - as such, cannot use clear|size|keys|values|entries|forEach()
                                               +#    and is not ITERABLE
                                               +#To use when passive relation to children (proxying, listening, etc.) not
                                               +#ownership (children existing mainly as MAP properties).

Set                                            +#Like a Map where KEY === VAL (i.e. keep unique values):
                                               +#  - ITERABLE iterates over VAL elements, not [KEY, VAL]
                                               +#  - entries() iterates over [VAL, VAL], keys|values() are same
                                               +#  - no SET.get()
                                               +#  - SET.set() -> SET.add(VAL)

WeakSet                                        +#Like WeakMap, but for Set.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             DATE              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Date                                            #Milliseconds-precise. Is internally:
                                                #  - only an Epoch NUM.
                                                #  - NaN for InvalidDate
                                                #UTC vs local:
                                                #  - input:
                                                #     - local: new Date(...)
                                                #     - does not matter: new Date()
                                                #     - UTC: new Date(Date.UTC(...))
                                                #  - output:
                                                #     - local: get|set*()
                                                #     - UTC: get|setUTC*(), getTime()
new Date([YEAR,MONTH,DAY,HOUR,MIN,SEC,MILLISEC])#Each final arguments are optional. Def: now.
new Date(STR)                                   #InvalidDate if cannot parse.
Date([...])                                     #Same as (new Date()).toString()

DATE.*et[UTC][Time/FullYear/Month/Date/Day/     #Date is month day, Day week day (0 for Sunday)
Hours/Minutes/Seconds/Milliseconds/             #Time is Epoch in seconds
TimezoneOffset]()                               #TimezoneOffset is in minutes
                                                #set* returns DATE.getTime()

Date.now()                                      #Like new DATE().getTime()
Date.parse(STR)                                 #Like new DATE(STR).getTime()
Date.UTC(...)                                   #Like new DATE(...).getTime() but new Date(...) uses UTC


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             MATH              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Math.min|max(NUM...)                            #NaN if one NUM not a number. [-]Infinity if no arguments.

Math.abs(NUM)                                   #
Math.sign(NUM)                                 +#Returns -|+ 0|1 or NaN

Math.ceil|floor|round(NUM)                      #Upper|lowest|nearest round
Math.trunc(NUM)                                +#Closest to 0 round
Math.fround(NUM)                               +#Converts to single-precision float

Math.PI                                         #
Math.E                                          #
Math.LN2                                        #ln(2)
Math.LN10                                       #ln(10)
Math.LOG2E                                      #log2(e)
Math.LOG10E                                     #log10(e)
Math.SQRT2                                      #
Math.SQRT1_2                                    #

Math.pow(NUM1, NUM2)                            #
Math.sqrt(NUM)                                  #NaN if negative
Math.cbrt(NUM)                                 +#
Math.exp(NUM)                                   #
Math.expm1(NUM)                                +#Same as Math.exp(NUM)-1
Math.log(NUM)                                   #Base e. NaN if negative
Math.log2|10(NUM)                              +#Base 2|10
Math.log1p(NUM)                                +#Same as Math.log(NUM+1)

Math.imul(NUM, NUM2)                           +#Like NUM*NUM2, except only for 32-bits signed integers, where the sign is the
                                               +#first bit, e.g. 4e9 is negative.
                                               +#Used to emulate x86 ASM imul.
Math.clz32(NUM)                                +#Number of leading zeros in a 32-bits signed binary format.

Math.[a]sin|cos|tan[2](NUM)                     #In radian
Math.[a]sin|cos|tan[2]h(NUM)                   +#Hyperbolic version
Math.hypot(NUM...)                             +#sqrt(NUM**2 + NUM2**2 ...)

Math.random()                                   #Float in [0,1). Seeded from current time.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             SIMD              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STATUS ==>                                    *-#Withdrawn from standard, but might be integrated into WebAssembly

new SIMD.TYPE(VAL...)->SOBJ                   *-#TYPE is like TypeArray's (+ Bool types):
                                              *-#  - Unit: Float|Int|Uint|Bool
                                              *-#  - Dimension: 32x4|16x8|8x16:
                                              *-#     - first number is number of bits per VAL
                                              *-#        - operations must be done on SOBJ with same number of bits
                                              *-#     - second number is number of VALs ('lane')
                                              *-#        - def: false (BOOL), 0 ([U]INT), NaN (FLOAT)
                                              *-#     - Float can only be 32x4
                                              *-#Does SIMD operations:
                                              *-#  - use CPU's SIMD: x86 SSE, ARMv7 NEON
SIMD.TYPE.splat(VAL)->SOBJ                    *-#Same as new SIMD.TYPE(VAL...)

SIMD.TYPE.check(SOBJ)->SOBJ                   *-#Throws error if not SOBJ of TYPE

SIMD.TYPE.extractLane(SOBJ, NUM)->VAL         *-#SOBJ[NUM]
SIMD.TYPE.replaceLane(SOBJ, NUM, VAL)         *-#SOBJ[NUM] = VAL

SIMD.NUM|FLOAT.load[NUM](TYPED_ARR[, NUM2])   *-#TYPED_ARR.slice(NUM2) -> SOBJ
->SOBJ                                        *-#NUM is number of SOBJ lanes to write on (def: all)
SIMD.NUM|FLOAT.store[NUM](TYPE_ARR, NUM2,SOBJ)*-#SOBJ -> TYPED_ARR.slice(NUM2)

SIMD.TYPE.fromTYPE2(SOBJ)->SOBJ2              *-#Transtype, bit-wise
                                              *-#TYPE|TYPE2 cannot be BOOL


SIMD.NUM|FLOAT.swizzle(SOBJ, NUM...)->SOBJ2   *-#Picks each from SOBJ[NUM]
SIMD.NUM|FLOAT.shuffle(SOBJ, SOBJ2, NUM...)
->SOBJ3                                       *-#Picks each from SOBJ.concat(SOBJ2)[NUM]
SIMD.NUM|FLOAT.select(BOOL_SOBJ4, SOBJ, SOBJ2)
->SOBJ3                                       *-#Picks each from SOBJ (if true) or SOBJ2 (if false)


SIMD.BOOL.all|anyTrue(SOBJ)->BOOL             *-#

SIMD.BOOL|NUM.and|or|xor(SOBJ)->SOBJ2         *-#& | ^ (or && || ^)
SIMD.BOOL|NUM.not(SOBJ)->SOBJ2                *-#~NUM or !BOOL

SIMD.NUM|FLOAT.[not]Equal(SOBJ, SOBJ2)->SOBJ3 *-# === !==
SIMD.NUM|FLOAT.less|greaterThen[OrEqual]
(SOBJ, SOBJ2)->SOBJ3                          *-# < <= > >=


SIMD.NUM|FLOAT.add|sub[Saturate](SOBJ, SOBJ2) *-# + -
->SOBJ3                                       *-#Saturate:
                                              *-#  - if overflow|underflow, stays at max|min value
                                              *-#  - not for >= 32 bits
SIMD.NUM|FLOAT.mul(SOBJ, SOBJ2)->SOBJ3        *-# *
SIMD.FLOAT.div(SOBJ, SOBJ2)->SOBJ3            *-# /

SIMD.NUM.shiftLeft|RightByScalar(SOBJ, NUM)
->SOBJ2                                       *-# << >>

SIMD.NUM|FLOAT.neg(SOBJ)->SOBJ2               *-# NUM * -1
SIMD.FLOAT.abs(SOBJ)->SOBJ2                   *-# Math.abs()
SIMD.FLOAT.sqrt(SOBJ)->SOBJ2                  *-# Math.sqrt()
SIMD.FLOT.reciprocalApproximation(SOBJ)->SOBJ2*-# 1 / NUM
SIMD.FLOAT.reciprocalSqrtApproximation(SOBJ)
->SOBJ2                                       *-# 1 / Math.sqrt(NUM)

SIMD.FLOAT.min|max[Num](SOBJ, SOBJ2)->SOBJ3   *-# Math.min|max()
                                              *-#NaN is < -Infinity if not "Num", > Infinity if "num"


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             JSON              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JSON ==>                                        #See JSON-js doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            PROMISE            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PROMISE                                        +#Represents an async function call.
                                               +#Has two non-accessible members:
                                               +#  - state 'pending|resolved|rejected': whether call is ongoing or done
                                               +#  - value VAL: async function call return value or exception thrown
PROMISABLE                                     +#Any OBJ with OBJ.then(FUNC, FUNC2)

TASKS ==>                                      +#new Promise() FUNC is fired right away, i.e. in current microtask, sync,
                                               +#before next statement.
                                               +#But PROMISE.then|catch() FUNC is fired in next microtask, even if PROMISE is
                                               +#already resolved|rejected.
                                               +#This means await PROMISE, but also await VAL, will wait at least one microtask

new Promise                                    +#Returns PROMISE:
(FUNC(RESOLVE(VAL|PROMISABLE), REJECT(VAL)))   +#  - RESOLVE(VAL): state 'resolved', value VAL
                                               +#  - REJECT(VAL): state 'rejected', value VAL
                                               +#  - RESOLVE(PROMISABLE):
                                               +#     - does PROMISABLE.then(RESOLVE, REJECT)
                                               +#     - so PROMISE will have same state|value as PROMISABLE
                                               +#RESOLVE|REJECT() defer state change
Promise.resolve|reject(...)                    +#Same as new Promise(function(resolve, reject) { resolve|reject(...) })

PROMISE.then([FUNC(VAL)[, FUNC2(VAL)]])        +#Fire FUNC|FUNC2 with PROMISE value if|when PROMISE.state 'resolved|rejected'
                                               +#Returns new PROMISE2, which fires (according to what happens in
                                               +#either FUNC|FUNC2):
                                               +#  - if return VAL|PROMISABLE (including undefined): RESOLVE(VAL|PROMISABLE)
                                               +#  - if throw VAL: REJECT(VAL)
                                               +#Def FUNC|FUNC2:
                                               +#  - return|throw VAL
                                               +#  - if not a function, use def
PROMISE.catch(...)                             +#Same as PROMISE.then(null, ...)
PROMISE.finally(FUNC())                        +#Like PROMISE.then(FUNC(), FUNC())
                                               +#Difference: FUNC() does not change PROMISE value, whatever it returns.
                                               +#But it changes PROMISE value if it throws or returns rejected PROMISE2.

Promise.all(VAL|PROMISABLE_ITERABLE)           +#Converts to PROMISE2 using Promise.resolve(VAL|PROMISABLE),
                                               +#then returns PROMISE where:
                                               +#  - first PROMISE2 rejected with VAL -> PROMISE rejected with VAL
                                               +#  - all PROMISE2 resolved -> PROMISE resolved with VAL_ARR
Promise.race(VAL|PROMISABLE_ITERABLE)          +#Same but first PROMISE2 resolved -> PROMISE resolved with VAL


async function [*] [FUNC](...) {...}           +#Returns FUNC2(...)->PROMISE, where FUNC can:
[class ...] { async [*] FUNC() {...} ... }     +#  - return VAL -> resolve PROMISE with VAL
async (...) => ...                             +#  - throw VAL -> reject PROMISE with VAL
                                               +#  - return PROMISE2 -> reject|resolve PROMISE with PROMISE2 value
await PROMISE2|VAL                             +#Inside async FUNC:
                                               +#  - waits for PROMISE2 to resolve|reject
                                               +#     - if PROMISE2 value returns PROMISE3, use PROMISE3 value instead
                                               +#     - VAL is like Promise.resolve(VAL)
                                               +#  - then returns|throws PROMISE2 value

ASYNC_ITERATOR                                ++#ITERATOR whose next|return|throw(...)->PROMISE(VAL) (instead of returning|throwing VAL)
ASYNC_ITERABLE                                ++#OBJ where OBJ[Symbol.asyncIterator]()->ASYNC_ITERATOR
                                              ++#PROMISE_ARR are ASYNC_ITERABLE
                                              ++#Cannot be used as an ITERABLE, only as an ASYNC_ITERABLE (i.e. for await)
for await (QUAL VAR of ASYNC_ITERABLE) {...}  ++#Iterates with VAR = NEXT_PROMISE_VAL, i.e. async loop
                                              ++#Must be within an async function

async function * [FUNC](...) {...}            ++#Generator that:
[class ...] { async * FUNC(...) {...} ... }   ++#  - is an ASYNC_ITERATOR|ITERABLE
new AsyncGeneratorFunction(...)               ++#  - can use yield* ASYNC_ITERABLE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             PROXY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


new Proxy(OBJ, OBJ2)                           -#Returns PROXY:
                                               -#  - live deep mirror of OBJ: OBJ and PROXY are always deep equal
                                               -#  - can override some basic object operations with OBJ2:
                                               -#     - providing they are performed on PROXY (not on OBJ)
                                               -#     - they usually have same arguments, plus a first argument being PROXY
                                               -#     - can call themselves without creating infinite recursion,
                                               -#        - but set|get() OBJ3 can't, i.e. OBJ3.VAR = VAL as opposed to
                                               -#          PROXY.VAR = VAL
                                               -#     - there are some special rules ('invariants') to handle
                                               -#       non-extensible|configurable|writable properties (see online doc)
                                               -#       Should not worry unless writing a library.
                                               -#OBJ2 members follow.
Proxy.revocable(OBJ, OBJ2)                     -#Like new Proxy(OBJ, OBJ2) but returns OBJ3:
                                               -#  - proxy PROXY
                                               -#  - revoke(): make accessing OBJ3.proxy throw a TypeError

OBJ2.set(PROXY, 'VAR', VAL, OBJ3)              -#PROXY.VAR = VAL
                                               -#  - OBJ3 === PROXY, unless PROXY is in prototype chain, in which case OBJ3
                                               -#    is the target child
                                               -#  - must return BOOL. If false, will throw TypeError.
OBJ2.get(PROXY, 'VAR', OBJ3)                   -#PROXY.VAR
                                               -#  - OBJ3: see set(...)
OBJ2.delete(PROXY, 'VAR')                      -#delete PROXY.VAR

OBJ2.has(PROXY, 'VAR')                         -#'VAR' in PROXY
OBJ2.ownKeys(PROXY)->STR_ARR                   -#Object.getOwnPropertyNames(PROXY) + Object.getOwnPropertySymbols()
                                               -#  - must at least contain same keys as original call

OBJ2.defineProperty(PROXY, 'VAR', OBJ3)        -#Object.defineProperty(PROXY, 'VAR', OBJ3)
                                               -#  - must return BOOL. If false, will throw TypeError.
OBJ2.getOwnPropertyDescriptor(PROXY, 'VAR')
  [->OBJ]                                      -#Object.getOwnPropertyDescriptor(PROXY, 'VAR')
OBJ2.isExtensible(PROXY)->BOOL                 -#Object.isExtensible(PROXY)
                                               -#  - must return same value
OBJ2.preventExtensions(PROXY)->BOOL            -#Object.preventExtensions(PROXY)
                                               -#  - must return Object.isExtensible(PROXY)

OBJ2.getPrototypeOf(PROXY)->OBJ|null           -#PROXY.__proto__ or Object.getPrototypeOf(PROXY)
                                               -#  - internally used by isPrototypeOf() and instanceof
OBJ2.setPrototypeOf(PROXY, OBJ3)               -#PROXY.__proto__ = OBJ3 or Object.setPrototypeOf(PROXY, OBJ3)

OBJ2.apply(PROXY, THIS, ARGS_ARR)              -#PROXY(ARGS...)
OBJ2.construct(PROXY, ARGS_ARR)->OBJ           -#new PROXY(ARGS...)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            REFLECT            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Reflect.*(OBJ, ...)                            +#Does same thing as what Proxy OBJ2.*(PROXY, ...) proxies.
                                               +#E.g. Reflect.set(OBJ, 'VAR', VAL, OBJ3) will:
                                               +#  - OBJ.VAR = VAL
                                               +#  - must return BOOL


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            MODULES            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


export ...                                    *|#Must always be used in a module, even if nothing is exported (use export {}) then
                                              *|#This is because modules are run differently (e.g. variables scope) than
                                              *|#global script imports but without export keyword cannot distinguish

export QUAL VAR = VAL[, ...]                  *|#
export function VAR(...){...}                 *|#
export { VAR[ as VAR2], ... }                 *|#Specific VAR
export { VAR as default, ... }
export default VAL                            *|#Default VAR
export {}                                     *|#Do not export anything (i.e. not an empty object)
export ... from "MDL"                         *|#Same as import ... from "MDL", then multiple export

import { VAR[ as VAR2], ... } from "MDL"      *|#
import * as VAR2 from "MDL"                   *|#Specific VAR
import { default as VAR2, ... } from "MDL"
import VAR from "MDL"                         *|#Default VAR. Can be combined, e.g. import VAR, {...} from "MDL"
import {} from "MDL"
import "MDL"                                  *|#Do not import the variable, just execute the file

import("MDL")->PROMISE(OBJ)                  *++#As opposed to above, not static (dynamic), i.e. does not have to be top-level

<script>
  type="module"                               *|#Must be specified in browser to use modules
                                              *|#As opposed to normal <script>:
                                              *|#  - variables are scoped to that module.
                                              *|#  - dependencies are fetched, as each file is being loaded
                                              *|#     - to avoid long loading time, should preload each file with
                                              *|#       <link rel="modulepreload" href="FILE">

import.meta                                   *-#Host-specific OBJ containing module-related metadata, similar to CommonJS
                                              *-#__filename, __dirname, process.mainModules, MODULE.children, etc.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CODING STYLE          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CODING STYLES GUIDES ==>                        #  - A: airbnb javascript
                                                #  - B: bevacqua js
                                                #  - C: clean-code-javascript
                                                #  - D: Douglas crockford code conventions for JavaScript
                                                #  - E: elierotenberg coding-styles es6
                                                #  - F: felixge node-style-guide
                                                #  - G: Google JavaScript style guide
                                                #  - H: hapi JavaScript coding conventions
                                                #  - I: idiomatic.js
                                                #  - J: jQuery JavaScript style guide
                                                #  - K: Khan JavaScript styleguide
                                                #  - M: MediaWiki Coding conventions JavaScript
                                                #  - S: feross standard javascript
                                                #  - W: Wordpress JavaScript coding standards

ALTERNATIVES ==>                                #When there are competing recommandations, we use / instead of -, with the
                                                #preferred choice on top


FILE ORGANIZATION ==>                         GD#Use .js extension
                                               D#Separate JavaScript from HTML

COMMENTS ==>                                    #// vs /* */:
                                           GHMJF#  / always //
                                              AW#  / if single line //, if multiple /* */
                                              DJ#  - no end-of-line comments
                                              CB#Do not comment out blocks of code
                                                #Whitespaces:
                                             AWJ#  - blank line before comment
                                          GSAHWJ#  - space after // or /*
                                                #Sentences:
                                           GHWMJ#  - capitalize comments
                                             GMW#  / add period at end, if sentence
                                               H#  / add period at end, if several sentences

STRICTNESS ==>                               HEB#'use strict' on top of any file
                                               H#'use strict' should be followed by blank line

LINE WIDTH ==>                                  #General:
                                           GJFBK#  / Max 80 chars
                                             AWM#  / Max 100 chars
                                               H#  / Max 150 chars
                                               D#  / Avoid long lines
                                                #Exception to long lines:
                                               J#  / long URL in comment, or long REGEXP
                                               A#  / long STR

LONG STATEMENTS ==>                             #Long statement delimited by dot:
                                           AWDJF#  / VAL
                                                #      .VAL2
                                                #      .VAL3
                                               E#  / VAL.VAL2
                                                #      .VAL3
                                               G#  / VAL.VAL2.
                                                #      VAL3
                                                #Long statement delimited by operation (+ && || ...):
                                             HJM#  / VAL
                                                #      && VAL2
                                             GWK#  / VAL
                                                #        && VAL2 (double identation)

BLANK LINES ==>                             GAMD#Use blank lines to separate sections
                                               S#No blank lines at beginning|end of { } block
                                               S#No multiple blank lines

INDENTATION ==>                                 #General:
                                         GSAMEFB#  / 2 spaces indentation
                                             HDK#  / 4 spaces indentation
                                              WJ#  / Tab indentation
                                               G#Avoid using spaces to horizontally align items

STRUCTURES INDENTATION ==>                      #General:
                                       GSAIWDJFK#  / if ... {
                                                #      ...
                                                #    } else {
                                                #      ...
                                                #    }
                                              HE#  / if ... {
                                                #      ...
                                                #    }
                                                #    else {
                                                #      ...
                                                #    }
                                                #Spacing:
                                        GSAIHMDJ#  / while|if|... (...)
                                               E#  / while|if|...(...)
                                                #Ternary:
                                             SAK#  / (if short) TEST ? VAL : VAL2
                                                #    (if long) TEST
                                                #      ? VAL
                                                #      : VAL2
                                             WDF#  / TEST
                                                #      ? VAL
                                                #      : VAL2
                                              EJ#  / TEST ? VAL : VAL2
                                               G#  / (if short) TEST ? VAL : VAL2
                                                #    (if long) TEST ?
                                                #      VAL :
                                                #      VAL2
                                                #Single statement structures:
                                       AIHWEDJBK#  / use { }
                                              GS#  / use { } unless on same less as the TEST

SPACES ==>                                      #Operators:
                                            SWDJ#  - no space around unary operators
                                          GSAMED#  - one space around binary operators
                                            HWEJ#  - no space before ,
                                           GSHED#  - space after ,
                                             HWJ#  - no space before ;
                                           GSHDJ#  - space after ; if not end-of-line (e.g. in for loops)
                                             HWJ#  - no space before : in VAR:
                                             GSH#  - space after : in VAR:
                                                #Blocks:
                                            SAHE#  / Spaces inside any {}, none inside [] ()
                                              GK#  / No space inside any [] {} ()
                                               I#  / Spaces inside any [] {} (), except ({ ... }) and ([ ... ])
                                            IWMJ#  / Spaces inside any [] {} ()
                                            IHWJ#  - no space inside empty [] {} ()
                                              SH#No multiple spaces

STATEMENTS ==>                                  #Semi-colon:
                                       GAHWEDJFB#  / End statement with ;
                                               S#  / Do not end statement with ; providing no line starts with ( [ or `
                                           GHWDJ#One statement per line
                                                #Side-effects:
                                             DJB#  - avoid statement that is not a function or assignment
                                              SB#  - avoid unassigned new FUNC()

DECLARATION ==>                                 #Scope:
                                          GWDJBK#  - no global vars
                                              GS#  - prefix global vars with global|window
                                                #Where:
                                            GAHK#  / Declare vars before first use
                                            IMDB#  / Declare vars on top of function body, in alphabetical order
                                              DB#  - do not use variable hoisting
                                               A#  - group const declarations before let declarations
                                                #How:
                                        GSAEDFBK#  / QUAL VAR = VAL; one per line
                                              WM#  / QUAL VAR = VAL,
                                                #         VAR2 = VAL2;
                                               A#  - no chained declarations, e.g. const a = b = VAL
                                            GAEK#  - use ARR|OBJ destructuring when possible
                                                #QUAL:
                                           GAHEK#  - use let|const, not var
                                            GCHE#  - prefer const over let
                                                #When:
                                               C#  - assign constants to variables
                                               B#  - assign REGEXP to variables
                                              CF#  - assign to variables instead of using long TEST
                                            GAEC#Use ES6 default values
                                             SJB#No unused vars
                                               S#Do not initialize VAR to undefined
                                              GS#Use VAR = null instead of delete VAR
                                              AE#Avoid ++, +=, etc.

VARIABLES NAMING ==>                            #Case:
                                               M#  / normalVar VAR, including for acronyms, e.g. findHtmlTag()
                                       GSAHWEJFK#  / normalVar VAR
                                               D#  / normal_var VAR
                                           GIFKD#  - CONSTANTS
                                               E#  - __COMPILE_TIME_CONSTANTS__
                                    GSAIHWMEDJFB#  - Type
                                              GI#  - Enum
                                                #Prefixes:
                                            GHEK#  - _privateVar
                                               G#  - get|set*() for getters|setters
                                              GA#  - is|has*() for FUNC()->BOOL
                                               H#Name "for" loops variables i, j, k, etc.
                                               I#Use plurals for ARR

TRANSTYPING ==>                                A#Do not use implicit transtyping, e.g. use (ARR.length > 0) instead of
                                               A#(ARR.length)
                                               A#Use String|Number|parseInt|parseFloat|Boolean() for explicit transtyping

TEST ==>                                        #Use === not ==:
                                             SWK#  / except == null
                                        AIMEDJFB#  / always
                                                #Early returns:
                                                #  - i.e.:
                                                #      if (TEST) { ... return VAL } ...
                                                #    instead of:
                                                #      if (TEST) { ... } else { ... }
                                                #Avoid ternary operators:
                                             AEB#  / if nested
                                               E#  / always
                                                #Assignments, e.g. if (VAR = VAL)
                                             DJB#  / avoid
                                               S#  / wrap with extra set of parenthesis
                                                #Use Yoda conditions, i.e. VAL == VAR instead of VAR == VAL:
                                              SM#  / never
                                               W#  / always

SWITCH STATEMENT ==>                         IWE#Avoid switch, prefer if|else or OBJ[VAL]()
                                                #Identation of case|default:
                                             GIW#  / yes
                                              DJ#  / no
                                                #break|return|throw must end all:
                                              SD#  / all case|default
                                               G#  / all case|default unless commented
                                              WJ#  / all case but not default
                                               W#  - avoid return
                                               G#Must have a default
                                               A#Wrap case|default statements in { ... }

EXCEPTIONS ==>                                GS#Only throw ERROR
                                               S#No return statement in finally block

FUNCTIONS (SPACING) ==>                    SIHMD#FUNC(), not FUNC ()
                                                #Unnamed declaration:
                                           SAHMD#  / function () {}
                                              GI#  / function() {}
                                                #Named declaration
                                           GAHMD#  / function NAME() {}
                                               S#  / function NAME () {}
                                                #Functions wrapping whole file:
                                              WM#  / indented
                                               J#  / not indented

FUNCTIONS (PARENTHESIS) ==>                SADJB#(function ... { ... }())
                                              SJ#new FUNC() not new FUNC
                                               J#(new FUNC()).VAR not new FUNC().VAR

FUNCTIONS (DECLARATION) ==>                     #Assign to VAR:
                                              AH#  / always
                                            GEDB#  / never
                                              AE#{ FUNC() {} } not { FUNC: function() {} }
                                               S#Avoid non-top-level FUNC declaration

FUNCTIONS (ANONYMOUS) ==>                       #When:
                                               B#  / always for non-top-level FUNC
                                               F#  / not inside another anonymous FUNC
                                               E#  / never
                                                #Shortcut syntaxes:
                                            GAEK#  - always use =>
                                                #  - ARG => VAL instead of (ARG) => VAL:
                                               A#      / always
                                              HE#      / never
                                                #  - () => VAL instead of () => {...}:
                                               A#      / VAL if single line, (VAL) is several lines
                                               H#      / never
                                              EF#Anonymous FUNC not assigned to VAR should have a NAME

FUNCTIONS (ARGUMENTS) ==>                       #Named parameters:
                                              GE#  / for options
                                               C#  / if more than 2 positional parameters
                                            GAEK#Use ARR|OBJ destructuring when possible
                                             AEK#Use ...args for variadic arguments, not "arguments"

FUNCTIONS (GENERATORS) ==>                      #Spacing:
                                             GAE#  - function* [FUNC](...) {}, not function *[FUNC](...) {}
                                              GE#  - { *FUNC(...) {} }, not { * FUNC(...) {} }
                                               G#  / yield* VAL
                                               S#  / yield * VAL

FUNCTIONS (GETTERS/SETTERS) ==>               GA#Avoid getters
                                             GAF#Avoid setters
                                               S#Define a getter if a setter is defined
                                              GF#No side-effects with getters

FUNCTIONS (OTHERS) ==>                         B#No empty functions
                                               F#No long functions
                                               S#Avoid call|apply() unless necessary

OBJECTS ==>                                     #One VAR per line:
                                             GJF#  / if whole OBJ too long for one line
                                               H#  / always
                                                #Commas:
                                           GSAEF#  - use trailing commas
                                               S#  - no commas in beginning of lines
                                                #Shortcuts:
                                      GSAIWMEDBK#  - {} instead of new Object
                                           SAWEF#  - only quote 'VAR' in OBJ if necessary
                                               A#  - { [VAL]: VAL2 } instead of OBJ[VAL] = VAL2
                                               A#  - { VAR } instead of { VAR: VAR }
                                              AK#  - object spread instead of Object.assign()

INHERITANCE ==>                                B#Avoid inheritance
                                            GSFB#Avoid extending native types
                                            GACB#Use ES6 classes when using inheritance
                                              SE#Avoid __proto__, prefer get|setPrototypeOf()
                                               E#Properties order: constructor first, public < private,
                                               E#getter/setter < normal < static, alphabetical
                                               S#Child constructors must call parent constructors, and before using this
                                               S#No empty constructors
                                               A#Use method chaining, by returning this

ARRAYS ==>                                      #One VAR per line:
                                               A#  - if whole ARR too long for one line
                                                #Commas:
                                               G#  - use trailing commas
                                                #Shorcuts:
                                      GSAIWMEDBK#  - [] instead of new Array
                                               K#  - ARR.includes() instead of indexOf
                                              GA#  - ...ARR instead of ARR.concat|slice()
                                                #Iteration:
                                               K#  / for ... of
                                              AE#  / forEach()
                                                #Spacing:
                                              GS#  - ...ARR not ... ARR
                                               S#Avoid sparse ARR
                                               G#Only ARR[NUM], not ARR.VAR

STRINGS ==>                                     #Quoting:
                                         AHWMEFB#  / 'STR'
                                               S#  / 'STR' except to avoid escaping '
                                             GIJ#  / "STR"
                                                #Concatenation:
                                           GSAEK#  - `STR` instead of STR + STR2 or trailing backslashes
                                               S#  - PATH.join() to concatenate __dirname|__filename
                                               S#${...} not ${ ... }

NUMBERS ==>                                    S#0.NUM instead of .NUM
                                                #Octals:
                                               G#  / 0o... instead of 0...
                                               S#  / never
                                               H#++VAR instead of VAR++

PROMISE ==>                                    C#Prefer async|await > PROMISE > callbacks
                                               E#PROMISE.then(FUNC).catch(FUNC2) instead of PROMISE.then(FUNC, FUNC2)

MODULES ==>                                     #Prefered syntaxes:
                                               A#  - avoid import *
                                               A#  - avoid import { ... as ... }
                                               A#  - import + export instead of export ... from "MDL"
                                               A#  - export default VAL if only one export
                                             AHF#require|import on top of file
                                               H#Use relative paths with require|import
                                               A#Should name default import|export after filename
                                               A#Export const variables, not let|var
                                               S#Use single import per MDL
                                               S#No new require(...)

FEATURES TO AVOID ==>                         SD#comma operator
                                               D#continue
                                                #Labels:
                                               S#  / never
                                               D#  / only with while|do|for|switch
                                           GSDFE#with
                                          GSADFE#eval() or related (new Function(STR), setTimeout|Interval(STR))
                                             SJB#arguments.caller|callee
                                             GSE#new String|Number|Boolean|Array|Object()
                                               F#Object.freeze|seal|preventExtensions()
