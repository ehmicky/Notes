
                                  ┏━━━━━━━━━━━━━━━━━━┓
                                  ┃   C++_SYNTHESE   ┃
                                  ┗━━━━━━━━━━━━━━━━━━┛

                                  ┌─────────────────────────┐
                                  │   DIFFERENCES C / C++   │
                                  └─────────────────────────┘

COMPATIBILITE C/C++ ==> #C++ est un superset de C. Ainsi, il ajoute seulement
                        #des fonctionnalités à C, et un programme en C peut
                        #en général être compilé par g++ par exemple.
                        #C'est pourquoi toute la syntaxe appartenant à C n'a pas
                        #été reexpliquée ici, et seuls les ajouts le sont.
                        #Pour autant, il y a quelques différences entre C et C++
                        #Les voici :
                        #  - il est interdit de faire un transtypage implicite
                        #    entre un VOID_ADR et un TYPE_ADR. Par exemple :
                        #     - char *STR = malloc(TOUINTVAL)
                        #    doit être noté :
                        #     - char *STR = (char*)malloc(TOUINTVAL)
                        #  - NULL n'est pas (void*)0, mais une sorte de magic
                        #    word utilisé par le compilateur. Utiliser donc
                        #    explicitement NULL
                        #  - les inline fonctions doivent être définies dans
                        #    chaque fichier où elles apparaissent
                        #  - sizeof(CHAR_LIT) vaut sizeof(CHAR_VAL) et non
                        #    sizeof(INT_VAL)
                        #  - il peut y avoir des conflits de noms, avec :
                        #    - des keywords ou fonctions standards C++ étant
                        #      utilisé comme identifiant dans un programme C
                        #    - des fonctions redéfinies par C++, par exemple
                        #      getline(), ou keywords, par exemple bool
                        #  - on ne peut affecter à une ENUM_VAR que des VAL
                        #    correspondant aux MOT... de sa définition
                        #  - faire qu'un code C++ soit compilé avec du code C
                        #    pose des problèmes de mangling (car différent).
                        #    Il faut donc
                        #    rajouter "extern "C"" devant le prototype de toute
                        #    fonction C ou C++ devant être utilisée par un
                        #    code écrit et compilé avec l'autre langage. Par
                        #    exemple, pour qu'un header C puisse être compilé
                        #    par un compilateur C++ et du code C++, il faut
                        #    faire ceci pour toute fonction :
                        #      - #ifdef __cplusplus
                        #        extern "C" {
                        #        #endif
                        #        FONCTIONS...
                        #        #idef _cplusplus
                        #        }
                        #        #endif
                        #  - un goto ou switch ne peut pas sauter au-dessus 
                        #    d'une déclaration
                        #  - noms de variables ne peuvent pas contenir plus de
                        #    2 underscores consécutifs
                        #  - les mots clefs "struct", "union" et "enum" ne
                        #    peuvent pas apparaître dans un prototype de 
                        #    fonction
                        #  - plusieurs choses de C99

bool                    #Il s'agit d'une macro désignant un char en C, mais en
                        #C++, il s'agit d'un type fondamental, prenant un octet 
                        #en mémoire, mais ne pouvant contenir que des 0 et des 1
                        #(tout autre valeur est castée vers 1)
wchar_t                 #Est aussi un type fondamental, et non un typedef

                                  ┌─────────────────┐
                                  │   GENERALITES   │
                                  └─────────────────┘

STANDARDS ET            #Inventé en 1980 par Bjarne Stoustrup.
IMPLANTATION ==>        #Standards :
                        #  - en 1998
                        #  - en 2003, rajoutant peu de choses, en général
                        #    désigné par "C++ standard"
                        #  - un à venir, avec le nom C++0x.
                        #  - en attendant, un premier draft a été lâché : TR1
                        #  - puis un second : TR 24733
                        #Implémenté sous Linux par libstdc++
                        #Compilé sous Linux par g++, quasiment mêmes options que
                        #gcc

HEADERS ==>             #L'extension est .h
                        #La standard library contient les seuls headers n'ayant
                        #pas d'extension. Tout autre header doit être .h
                        #La standard library maintient des headers de la
                        #standard library C, avec l'extension .h, qui pointent
                        #vers leur version sans extension .h et avec un c au 
                        #début, juste pour la backward compatibility.
                        #La library standard C est donc contenue dans la library
                        #standard C++, en étant légèrement modifiée. Voici les
                        #modifications : 
                        #  - wchar_t est un type fondamental
                        #  - toutes les fonctions mathématiques de <cmath> et
                        #    de <cstdlib> (abs() et div()) sont overloadées,
                        #    donc les suffixes et préfixes 'f' et 'l' deviennent
                        #    inutiles. Il n'est plus nécessaire de faire -lm
                        #    lors de la compilation pour les fonctions 
                        #    mathématiques
                        #Voici les headers de la library standard C, qui sont
                        #inutiles en C++, car C++ propose d'autres solutions 
                        #(la solution suit) :
                        #  - csignal, cassert, cerrno : <exceptions>
                        #  - cwctype, cwchar : wstreams
                        #  - cfloat, climits : <limits>
                        #  - clocale : <locale>
                        #  - cstddef : builtins
                        #  - cstdio : <iostream>, etc.
                        #Solution partielle :
                        #  - cstring : <string>
                        #  - cstdarg : oveloadable fonctions 
                        #Headers de toute façon peu utilisés :
                        #  - ciso646
                        #  - csetjmp
                        #Headers utiles même en C++ :
                        #  - cmath
                        #  - cstdlib
                        #  - ctime
                        #  - cctype
                        #Le répertoire des headers C++ est /usr/include comme en
                        #C, mais la library standard C++ est dans
                        #/usr/include/c++/{VERSION}/

.cpp
.cc                     #Extension d'un fichier source. Préférer le permier

_cplusplus              #Variable globale définie si le compilateur est
                        #compatible C++

C++ STYLE               #En C++, il est de bon ton de déclarer les variables
                        #juste avant leur utilisation, non en début de bloc

                                  ┌───────────────────┐
                                  │   AJOUTS DIVERS   │
                                  └───────────────────┘

new TYPE                #Equivaut à new TYPE[1]
new TYPE[TOUINTVAL]     #Renvoie un TYPE_ADR avec une mémoire allouée 
                        #dynamiquement de sizeof(TYPE) * TOUINTVAL octets
                        #Ainsi :
                        #  - TYPE TYPE_ADR = new TYPE[TOUINTVAL]
                        #est une alternative à :
                        #  - TYPE TYPE_ADR = malloc(sizeof(TYPE) * TOUINTVAL)
                        #Si TYPE est une CLASS, le constructor de CLASS est 
                        #appelé TOUINTVAL fois (pour chaque CLASS créé dans 
                        #l'array de CLASS donc)
                        #Forme souvent utilisée (pour le polymorphisme) :
                        #   - CLASS CLASS_VAR = new CLASS2
                        #Une exception bad_alloc est lancée s'il n'arrive pas à
                        #allouer de la mémoire.
                        #Pour allouer les pointeurs d'une matrice dynamique :
                        #  - TYPE** VAR = new TYPE*[TAILLE1]
                        #    for ( int A(0) ; A < TAILLE1 ; A++ )
                        #    {
                        #      VAR[A] = new TYPE[TAILLE2];
                        #      for ( int B(0) ; B < TAILLE2 ; B++ )
                        #        VAR[A][B] = VAL;
                        #    }
delete ADR              #Equivalent de free(ADR) pour new.
                        #delete NULL n'est pas une erreur, mais ne fait rien
delete [] ADR           #La première forme est à utiliser après un new TYPE, et 
                        #la seconde après un new TYPE[TOUINTVAL], sinon erreur.
                        #De plus, si ADR est une CLASS_ADR appelle le destructor
                        #de CLASS TOUINTVAL fois.

AVANTAGES DE NEW ET     #Différences de new et delete par rapport à malloc et à
DELETE ==>              #free :
                        #  - malloc renvoie un VOID_ADR, new un TYPE_ADR
                        #  - new appelle le constructor, et delete le destructor
                        #  - exception bad_alloc, et (nothrow) pour new
                        #  - overloading operator possible de delete, delete[], 
                        #    new et new[]
                        #  - ne pas mélanger les deux

TYPE VAR(VAL)           #Equivaut à TYPE VAR = VAL, que TYPE soit un type
                        #fondamental ou une CLASS. Ne marche que pour une 
                        #déclaration + définition.

TYPE FONC_NAME          #Une déclaration + définition, ou une définition (mais
(TYPE VAR[ = VAL]       #non une déclaration seule) de fonction peut indiquer
[, TYPE VAR2 = VAL2]...)# = VAL après un argument. Cette valeur est la valeur
                        #par défaut : il est alors possible d'appeler la 
                        #fonction sans fournir cet argument.
                        #Ne marche que sur le dernier argument, ou si tous les
                        #arguments qui suivent ont aussi une valeur par défaut.
                        #Ne marche que compile-time = le mettre donc seulement
                        #dans la déclaration / le header.
                        #Notamment utile avec un constructor.

STRUCTURES ET UNIONS    #Les structures et unions sont en fait considérées comme
        ==>             #des classes, elles peuvent donc notamment utiliser :
                        #  - des CLASSFK, dont constructors et destructors
                        #  - des ACCESS
                        #  - des templates
                        #la seule différence étant que :
                        #  - l'ACCESS de leurs membres par défaut est public
                        #pour les structures uniquement :
                        #  - l'ACCESS de l'héritage est public par défaut
                        #et pour les unions uniquement :
                        #  - les CLASSDT (et non les CLASSFK) font référence à 
                        #    la même zone mémoire (comme en C)
                        #  - ne peut pas être la parente ou l'enfant d'une 
                        #    autre classe
                        #  - ne peut pas contenir de virtual CLASSFK ni de 
                        #    user-defined constructor ou destructor

MOTS FACULTATIFS ==>    #Les mots struct, union et enum deviennent facultatifs
                        #dans :
                        #  - les instantiations d'une STKT_VAR, etc.
                        #  - la référence au TYPE complexe (par exemple 
                        #    sizeof(struct STKT) ou typedef struct STKT MOT)
                        #Cela reste cependant obligatoire dans la déclaration
                        #même de la structure, de l'union ou de l'enum
                        
PLAIN OLD DATA ==>      #Désigne un type C++ pouvant être utilisé en C.
                        #Désigne donc un builtin type ou une 
                        #classe/struct/union contenant :
                        #  - des operator=, constructor, copy constructor et destructor trivial
                        #  - seulement des membres POD ou static non-POD
                        #  - pas de membres protected ou private
                        #  - pas de classe parente
                        #Une classe a un trivial assignment si :
                        #  - elle n'a pas d'operator= user-defined
                        #  - elle n'a pas de virtual CLASSFK ou virtual parent
                        #  - ses parents et CLASSDT étant des CLASS_VAR ont eux aussi un trivial assignment
                        #Même chose pour trivial constructor, destructor et copy constructor.

return 0                #Il est optionnel dans le main()

                                  ┌────────────────┐
                                  │   REFERENCES   │
                                  └────────────────┘

REFERENCES ==>          #Les références ont les mêmes fonctions que les 
                        #pointeurs, mais évite les problèmes des pointeurs dus à
                        #la manipulation de la mémoire. Une variable référence
                        #d'une autre variable désigne en fait la même valeur en
                        #mémoire. D'un point de vue technique, ce n'est pas
                        #exactement cela, c'est plus un lien qui unit les deux
                        #variables (mais peu importe), et qui fait que modifier
                        #l'une modifie l'autre.

TYPE& VAR = VAR2        #Déclaration et initialisation d'une référence. Une
                        #référence doit être initialisée à la déclaration. VAL à
                        #la place de VAR2 est illégal. VAR2 doit être de même 
                        #type que VAR. VAR2 devient elle-même, réciproquement,
                        #une référence pour VAR.
                        #Pour initialiser une CLASSDT référence, il faut donc
                        #le mettre dans le constructor après ":"
                        #Il est impossible d'enlever à une VAR le fait qu'elle
                        #soit une référence, ou de le rajouter en dehors de sa
                        #déclaration + initialisation.
TYPE& *ADR = ADR2       #Les références pointeurs lient l'adresse qu'elles
                        #contiennent. Modifie l'adresse contenue par l'une
                        #modifie celle de l'autre. Evidemment, modifier la
                        #valeur pointée aura des conséquences sur les deux aussi
VAR = VAL               #Affectation de VAL à une référence VAR, et à la VAR2 à
                        #laquelle est associée (ne modifie donc pas leur lien)
ADR = ADR2              #Même chose pour une référence pointeur

TYPE&                   #& fait partie du TYPE d'une référence, comme * pour un
                        #pointeur. & précède toujours * dans le TYPE d'une
                        #déclaration.

FONC_NAME(TYPE& VAR     #Il est possible de déclarer les arguments d'une
[, TYPE[&] VAR]...)     #fonction comme étant des références : il s'agit d'un
                        #call by reference. Ainsi, plutôt que de faire une copie
                        #de l'argument (call by value) ou de son adresse (call
                        #by adress), il s'agit de l'argument lui-même (en
                        #quelque sorte) qui est utilisé. Ainsi :
                        #  - le modifier dans l'exécution de la fonction le 
                        #    modifiera même après la fin de la fonction.
                        #  - c'est un bon moyen pour contourner la portée 
                        #    locale d'une fonction
                        #  - contrairement au call by adress, on n'a pas 
                        #    besoin d'utiliser des pointeurs et donc de changer 
                        #    le corps de la fonction.
                        #  - cela évite de faire une récréer un objet si VAR 
                        #    est une CLASS_VAR, c'est donc bien plus rapide,
                        #    et vivement recommandé lorsque l'on passe une 
                        #    CLASS_VAR en argument d'une fonction donc
                        #Une référence peut être le TYPE& d'une fonction.
                        #Cependant, il faut prendre garde à utiliser 
                        #immédiatement le retour de la fonction, et à ne plus 
                        #l'utiliser ensuite (c'est-à-dire ne pas le mettre dans 
                        #une VAR, mais faire à nouveau appel à la fonction si 
                        #l'on le veut à nouveau) car sinon cela peut buguer.

VAL ET REFERENCES ==>   #Il est impossible d'assigner une VAL temporaire à une
                        #référence non-const, ou de transtyper.
                        #Les choses suivantes sont donc interdites (soit VAR une
                        #référence non-const) :
                        #  - VAR = VAL; 
                        #  - (TYPE&) VAL;
                        #  - appeler une fonction demandant une valeur référence
                        #    non-const avec un argument non-référence
                        #Cela ne vaut pas pour les références const.

DIFFERENCE POINTEURS    #Les références sont en général implémentées (compilées)
ET REFERENCE ==>        #comme des pointeurs. Cependant, contrairement aux 
                        #pointeurs, le compilateur interdit plusieurs choses
                        #possibles avec les pointeurs, ce qui fait qu'ils sont
                        #plus safe (mais moins puissants) :
                        #  - il n'est pas possible de réaffecter une référence,
                        #    mais seulement la valeur qu'elle pointe (mais pas
                        #    la VAR/zone mémoire qu'elle réfère)
                        #  - ne sont donc pas copiable ni affectable. Ne peuvent
                        #    donc pas être utilisées dans plusieurs cas, comme
                        #    dans un std::vector
                        #  - on doit initialiser une référence lors de la
                        #    déclaration, alors qu'un pointeur peut rester NULL
                        #  - une référence ne peut pas pointer NULL
                        #  - on ne peut pas accéder à l'adresse mémoire de 
                        #    manière immédiate, comme avec un pointeur, et donc
                        #    pas d'arithmétique des pointeurs
                        #  - syntaxiquement : pas de * ni de ->
                        #  - on ne peut pas avoir plusieurs degrés d'indirection
                        #    avec les références, contrairement à **ADR_ADR
                        #  - on ne peut pas faire d'arrays de références

TYPE(&VAR)[]            #Déclare une référence vers une array statique.
                        #Le type est : TYPE(&)[]
                        #Les arrays statiques de référence sont par contre interdites.

                                  ┌─────────────────┐
                                  │   OVERLOADING   │
                                  └─────────────────┘

OVERLOADING ==>         #Il est possible de déclarer + définir plusieurs 
                        #fonctions avec le même nom, mais des types et/ou 
                        #nombre d'arguments différents. 
                        #Le choix de la bonne fonction, lors de son exécution, 
                        #se fera sur le type ou le nombre des arguments passés 
                        #à la fonction overloaded

TYPE operator SYMBOLE   #Définition d'un overloadable operator.
(ARGUMENTS) {           #Il s'agit du CLASSFK lié à un SYMBOLE (operator 
    ...                 #SYMBOLE est son FONC_NAME)
}                       #Elle :
                        #  - peut renvoyer tout type de valeur
                        #  - a un nombre d'arguments déterminés par le SYMBOLE
                        #    choisi
                        #  - a des types d'arguments libres ou non en fonction
                        #    de l'opérateur
                        #Il peut s'agir d'une CLASSFK. Si c'est le cas, le
                        #premier argument n'est pas spécifié et est 
                        #implicitement *this. De plus, certains overloadable
                        #operators ne peuvent être que des CLASSFK. Voici un
                        #résumé en fonction du SYMBOLE :

+------------------------------------------+----------------+-----------+---------------------+-------------------------------+
|   SYMBOLE                                | ARGUMENTS      | ARGUMENTS | EXECUTION           | COMMENTAIRES                  |
|                                          | (NON-CLASSFK)  | (CLASSFK) |                     |                               |
+------------------------------------------+----------------+-----------+---------------------+-------------------------------+
| + - * & ! ~ ++ --                        | CLASS          | void      | +CLASSE             |                               |
| ++ --                                    | CLASS, int     | int       | CLASS++             | int non-utilisé (dummy)       |
| + - * / % ^ & | < > == != <= >= << >> && | CLASS, TYPE ou | TYPE      | CLASS + TYPE        |                               |
| || , += -= *= /= %= ^= &= |= <<= >>=     | TYPE, CLASS    |           | ou TYPE + CLASS     |                               |
| ->*                                      | CLASS, int     | int       | CLASS_ADR->*CLASSFK | Renvoie toujours this         |
| ->                                       | Impossible     | void      | CLASS->TYPE         | Renvoie CLASS2_ADR. CLASS->VAR|
|                                          |                |           |                     | effectue CLASS2_ADR->VAR      |
|                                          |                |           |                     |                               |
| Cast operator                            | Impossible     | void      | (TYPE) CLASS        |                               |
| =                                        | Impossible     | TYPE      | CLASS = TYPE        |                               |
| []                                       | Impossible     | TYPE      | CLASS[VAL]          | Utile de renvoyer une référnce|
| ()                                       | Impossible     | [TYPE...] | CLASS( [TYPE...] )  | Fonctors                      |
+------------------------------------------+----------------+-----------+---------------------+-------------------------------+

                        #Notes :
                        #  - ils ne peuvent pas avoir d'arguments par défaut, sauf l'operator ()
                        #  - overloading possible
                        #  - les arguments devraient toujours être const&. 
                        #    Pour une CLASSFK ils devraient aussi être CLASSFK const { } pour :
                        #      - ==, <, etc., -, +, *, /, %, &&, ||, &, |, ^, <<, >>, ',', typecast overloading
                        #  - il n'y a pas de lien nécessaire entre le SYMBOLE utilisé et les COMMANDES exécutées, mais c'est
                        #    préférable
                        #  - un overloadable operator est donc toujours ou dans une classe, ou avec une CLASS_VAR en 
                        #    argument : il n'est donc pas possible de l'utiliser entre deux TYPE fondamentaux

OPERATOR PRECEDENCE ==> #Voici :

+---------------------------------------------+-----------+----+----------+---------------+--------------+--------------+-----+
|                 BASE                        |ARITHMETIC |BIN1|   TEST   |   BINARY 2    |    LOGICS    | ASSIGNATION  |     |
+----+--------------+-------------------+-----+-----+-----+----+-----+----+---+-----+-----+----+----+----+--------------+-----+
|    | ++A --A () . | A++ A-- + - !     | .*  |  *  |  +  | >> | < > |    |   |     |     |    |    |    | =  *= <<= ^= |     |
| :: | [] -> typeid | ~ (type) * &      | ->* |  /  |  -  | << | <=  | == | & |  ^  |  |  | && | || | ?: | += /= >>= |= |  ,  |
|    | *_cast<>()   | sizeof new delete |     |  %  |     |    | >=  |    |   |     |     |    |    |    | -= %= &=     |     |
+----+--------------+-------------------+-----+-----+-----+----+-----+----+---+-----+-----+----+----+----+--------------+-----+

EXTENSION ==>           #Il est possible d'étendre facilement des classes déjà
                        #existantes (std::string, std::cout, etc.) avec les
                        #opérateurs non-CLASSFK, il suffit de :
                        #  - définir un tel opérateur, avec en premier argument
                        #    la classe existante, et en deuxième sa propre
                        #    classe
                        #  - mettre en friend cet opérateur sans sa propre 
                        #    classe, s'il doit utiliser des membres protected de
                        #    la classe

EXECUTION ==>           #Un overloadable operator peuvent s'exécuter sous la
                        #forme CLASS_VAR.operatorSYMBOLE([ARGUMENTS]), mais leur
                        #intérêt est d'être exécuté sous la forme décrite dans 
                        #le tableau ci-dessus. 

FRIENDSHIP ET           #Un overloadable operator non-CLASSFK s'il veut utiliser
OVERLOADABLE OPERATOR   #son premier argument CLASS_VAR devra souvent être amie
    ==>                 #avec sa classe.
                        #Je trouve que donc les overloadable operators
                        #non-CLASSFK sont peu recommandables, sauf par exemple
                        #si l'on veut pouvoir utiliser la syntaxe :
                        #  - VAL SYMBOLE CLASSE_VAL
                        #notamment pour permettre le fait de mettre la CLASS_VAL
                        #ou à droite du symbole, ou à sa gauche (en overloadant
                        #la fonction), on ne peut le faire qu'avec un 
                        #overloadable operator non-CLASSFK.

CHAINE D'OVERLOADABLE   #Il est possible de créer des chaînes d'exécution
OPERATORS ==>           #d'overloadable operators, comme :
                        #  - CLASS_VAL SYMBOLE VAL [SYMBOLE VAL]...
                        #Pour ce faire, il suffit que l'overloadable operator
                        #renvoie une CLASS_VAL (notamment *this)

SEQUENCE POINT ==>      #Moment où l'on est sûr que tous les side effects des opérations précédentes ont été résolus.
                        #Il y a :
                        #  - EXPR && EXPR2 ; EXPR || EXPR2 ; EXPR, EXPR2
                        #     - mais non EXPR + EXPR2 par exemple : EXPR est sûr d'être évalué avant EXPR2 que dans les cas du
                        #       dessus
                        #  - EXPR ? EXPR2 : EXPR3 (le ?, pas le :)
                        #  - fin d'un statement ; avant le début d'un fonction call
                        #     - et non entre les arguments, qui peuvent donc être appelés dans n'importe quel ordre, mais on
                        #       est sûr qu'ils seront évalués avant le fonction call

                                  ┌─────────────┐
                                  │   CLASSES   │
                                  └─────────────┘

CLASS                   #Désigne un nom de classe.
                        #CLASS est un TYPE complexe, précédé facultativement
                        #de "class", sauf dans une déclaration, où c'est
                        #obligatoire (je l'indique donc).
                        #Une classe est un modèle à partir duquel sont 
                        #instantiés des objets, chaque objet ayant des data
                        #individuelles qui lui sont propres.
                        #Un objet est une instantiation de la classe : CLASS_VAR
                        #ou CLASS_ADR pour un pointeur de classe, ou CLASS_VAL
                        #pour une instantiation temporaire.
                        #Une classe n'a pas de data, mais des modèles de data :
                        #ce sont ses instantiations qui ont des data.

class CLASS             #Déclare juste CLASS (ne pas mettre les inheritances).
                        #Ne me semble pas utile en tant que tel.

class CLASS {           #Véritable déclaration de CLASS. C'est notamment celle à
    [[ACCESS:]          #mettre dans les headers.
        TYPE CLASSDT    #C'est similaire à une struct de C, sauf qu'en plus
        [, CLASSDT2]    #des data, CLASSDT, il est possible d'avoir des
        ...;]...        #fonctions comme membre, CLASSFK, les "méthodes".
    [[ACCESS:]          #CLASSDT et CLASSFK constituent les membres d'une classe
        [TYPE] CLASSFK  #Chaque membre peut être suivi par une CLASSDT ou une
        ([ARGUMENTS])   #CLASSFK du même TYPE. Pour déclarer un nouveau membre
        [, CLASSFK2     #d'un TYPE différent, il faut faire un nouveau ";"
        ([ARGUMENTS2])] #Si CLASSFK est un consructor ou un destructor, il n'y
        ...;]...        #a pas de TYPE.
} [CLASS_VAR]           #Il est possible d'instantier en même temps des 
[, CLASS_VAR2]... ;     #CLASS_VAR...
                        #ACCESS est "public", "private" ou "protected" : voir le
                        #sujet sur les droits d'accès.
                        #Ne pas oublier le ;

POINTEURS DE CLASSDT    #CLASSDT peut être :
        ==>             # - précédé de * pour en faire un pointeur
                        # - suivi de [TOUINTVAL] pour en faire une array
                        # - sous la forme (*CLASSDT)() pour être un pointeur de 
                        #   fonction
                        #Dans tous les cas, la mémoire doit être alloué (par 
                        #exemple avec new dans le consructor) et désallouée 
                        #(par exemple avec delete dans le destructor).

[TYPE] CLASSFK          #Les CLASSDT ne peuvent pas être définies lors d'une
([ARGUMENTS]) {         #déclaration de CLASS (mais on peut créer des
    COMMANDES;...       #constructors pour qu'elles le soient à chaque
    [return VAL;]       #instantiation de CLASS)
}                       #Cependant, une CLASSFK peut être ainsi définie en même
                        #temps que sa déclaration.
[TYPE] CLASS::CLASSFK   #Elle peut aussi être définie en dehors de la classe  
([ARGUMENTS]) {         #sous cette forme. Elle doit alors avoir été 
    COMMANDES;...       #prédécédemment déclarée dans CLASS, et cette
    [return VAL;]       #déclaration doit précéder, ainsi que de "inline" s'il
}                       #s'agit d'un header.

ACCES RELATIF AUX       #L'accès (lecture/écriture) d'un CLASSFK à un autre
MEMBRES DE LA MÊME     #CLASSFK ou à une CLASSDT de la même CLASS est relatif.
CLASSE ==>              #Cela signifie qu'appartenant au même namespace, il
                        #faut juste écrire par exemple CLASSDT, et non
                        #CLASS::CLASSDT (qui marche, mais est inutile) ou
                        #CLASS.CLASSDT (qui est réservé à l'instantiation d'une
                        #CLASS, donc sous la forme CLASS_VAR.CLASSDT)

STATIC CLASSDT ET       #Elles sont attachées à une classe entière, mais à
CLASSFK ==>             #aucune de ses instantiations.
                        #Elles sont accédées en faisant CLASS::CLASSDT ou
                        #CLASS::CLASSFK uniquement.
                        #Elles ajoutent une sorte de portée globale à une classe
                        #et sont donc considérées parfois comme une mauvaise
                        #pratique.

static TYPE CLASSDT;    #Déclaration d'une CLASSDT statique :
                        #  - sa valeur est partagée par toutes les instances de
                        #    la classe
                        #  - elle doit être initialisée en dehors de tout bloc,
                        #    après sa déclaration, mais avant son accès, et sans
                        #    le mot "static". Cela donne donc :
                        #      - TYPE CLASS::CLASSDT = VAL
                        #  - elle peut toutefois être initialisée dans le bloc, à
                        #    condition que la rvalue soit toujours évaluable en
                        #    compile-time, et que ce soit soit const
                        #  - ne peut pas être de TYPE void, ou mutable.
static TYPE CLASSFK     #Déclaration d'une CLASSFK statique
([ARGUMENTS])           #Elle :
                        #  - ne peut avoir accès qu'à des static CLASSDT
                        #  - ne peut pas utiliser this, être virtual, const ou
                        #    être de TYPE volatile
static TYPE CLASSFK
([ARGUMENTS]) { ... }   #Déclaration et définition d'une CLASSFK statique

INSTANTIER UNE CLASSE
     ==>                #Voici :

CLASS CLASS_VAR         #Déclare CLASS_VAR en instantiant CLASS et en exécutant 
                        #son constructor CLASS(void). CLASS CLASS_VAR() est une
                        #erreur syntaxique.
CLASS CLASS_VAR         #Déclare CLASS_VAR en instantiant CLASS et en exécutant
(VAL[, VAL2]...)        #son constructor CLASS(VAL[, VAL2]...).
CLASS CLASS_VAR =       #Si un seul VAL, et que ce VAL est une CLASS_VAR de 
CLASS(VAL[, VL2]...)    #même type, utilise donc copy constructor par défaut,
                        #sauf s'il a été redéfini
CLASS CLASS_VAR = VAL   #Exactement même chose, mais fait appel au constructor
                        #de manière implicite. Même chose pour ce qui est du
                        #copy constructor. Cependant, l'appel implicite a des
                        #restrictions :
                        #  - le constructor ne peut avoir qu'un argument VAL
                        #  - le constructor de CLASS ne doit pas être précédé du
                        #    keyword explicit, par exemple :
                        #       - explicit CLASS(VAL) { ... }

CLASS_VAR = CLASSE_VAR2 #Affectation utilisant l'overloadable operators =
                        #Seule affectation possible d'une CLASS_VAR, qui n'est
                        #pas vraiment une affectation mais l'utilisation de la
                        #fonction appelée par l'overloadable operator =

CLASS([VAL[, VAL2]...]) #Renvoie une CLASS_VAL, instantiation temporaire de
                        #CLASS avec le constructor CLASS(VAL[, VAL2]...).
                        #Il faut parfois mettre des parenthèses vides pour bien
                        #montrer qu'il s'agit d'une CLASS_VAL temporaire et non
                        #d'une CLASS (par exemple pour un fonctor temporaire 
                        #utilisé comme argument d'une fonction)
                        #"CLASS_VAL" fait référence à une CLASS_VAR ou à une
                        #CLASS_VAL temporaire de ce genre.
                        #Utilité des CLASS_VAL temporaires :
                        #  - être passés comme valeur à une fonction prenant
                        #    une CLASS_VAL non référence comme argument, sans
                        #    avoir besoin d'instantier une CLASS_VAR. Il faut
                        #    prendre garde que cette CLASS_VAL ne soit pas
                        #    ensuite retourner sous forme de référence, car cela
                        #    buguerait.
                        #    Elle peut aussi être passée sous la seule forme VAL
                        #    par exemple pour une fonction définie telle que :
                        #       - TYPE FONC_NAME(CLASS_VAR)
                        #    On peut l'invoquer sous la forme :
                        #       - FONC_NAME(VAL)
                        #    Qui équivaut à :
                        #       - FONC_NAME(CLASS(VAL))
                        #    Il s'agit d'un appel au constructor de manière
                        #    implicite : il ne peut donc y avoir qu'une seule
                        #    VAL et le constructor de CLASS ne doit pas être
                        #    "explicit"
                        #  - être la valeur return par une fonction renvoyant
                        #    une valeur non référence de type CLASS, sans avoir 
                        #    besoin d'instantier une CLASS_VAR. Exemple :
                        #      - CLASS FONC_NAME(ARGUMENTS) {
                        #           ...
                        #           return CLASS(VAL...)
                        #        }

CLASS() SYNTAXE ==>     #Une instantiation de classe ne prenant pas 
                        #d'arguments, doit être écrit :
                        #  - s'il s'agit de la déclaration de la classe :
                        #      CLASS CLASS_VAR;
                        #  - s'il s'agit d'une classe temporaire utilisée comme
                        #    seule argument d'un constructor (ou suivie par 
                        #    d'autres classes temporaires ne prenant pas 
                        #    d'arguments) :
                        #      CLASS2 CLASS2_VAR( (CLASS()) )
                        #    Sans les parenthèses, le compiler pense qu'il 
                        #    s'agit d'une fonction CLASS2_VAR prenant un 
                        #    pointeur de fonction comme argument.

ACCES AUX MEMBRES D'UNE #Dans ce qui suit, accès signifie lecture ou écriture.
CLASS_VAR ==>           #Il suffit donc de rajouter = VAL à la fin (pour une
                        #CLASSDT) pour faire une affectation.
                        #Par ailleurs, pour une CLASS_ADR, 

CLASS_VAR.CLASSDT_VAR   #Accès à une une CLASSDT_VAR dans CLASS_VAR
*CLASS_VAR.ADR          #Déférencement et accès à une ADR dans 
*(CLASS_VAR.ADR)        #CLASS_VAR
CLASS_VAR.ARR           #Accès à la CLASS_VAR numéro TOUINTVAL de ARR, 
[TOUINTVAL]             #dans CLASS_VAR

CLASS_VAR.CLASSFK_VAR   #Exécution d'une CLASSFK_VAR, dans CLASS_VAR. J'utilise
([ARGUMENTS])           #la notation courte : CLASSFK([ARGUMENTS]) pour cela,
                        #ou FONC_NAME([ARGUMENTS])
(*CLASS_VAR.ADR)        #Exécution d'un pointeur de fonction ADR, dans
([ARGUMENTS])           #CLASS_VAR

TYPE FONC_VAR(CLASS     #Déclaration d'une fonction prenant une CLASS_VAR comme
CLASS_VAR[, ARGUMENTS]) #argument. Il est préférable de faire un call by
                        #reference alors.
FONC_VAR(CLASS_VAL)     #Exécution de cette fonction. CLASS_VAL doit être de
                        #type CLASS. CLASS_VAL doit être une CLASS_VAR s'il
                        #s'agit d'un call by refrence.

CLASSFK PAR DÉFAUT ==> #Par défaut, chaque CLASSE a quatre CLASSFK implicites
                        #  - un constructor, sans arguments, qui ne fait rien.
                        #  - un destructor, qui ne fait rien
                        #  - un copy constructor, défini implicitement sous la
                        #    forme :
                        #      - CLASS(const CLASS& CLASS_VAR)
                        #  - Un overloadable operator=, défini implicitement
                        #    sous la forme : 
                        #      - CLASS& operator= (const CLASS& CLASS_VAR)
                        #    et qui retourne *this
                        #Ils sont override par une CLASSFK identique (mêmes
                        #arguments, etc.), overloaded sinon. Exception : le
                        #constructor(void) par défaut est supprimé dès qu'un 
                        #autre constructor pour la CLASS est créé, même s'il ce
                        #constructor prend des arguments. Il est donc alors
                        #conseillé souvent de recréer un constructor(void), au
                        #cas où.

COPY CONSTRUCTOR ET     #Ils permettent tous deux de copier le contenu d'une
OVERLOADABLE OPERATOR=  #CLASS_VAR2 vers une CLASS_VAR de même CLASS.
PAR DEFAUT  ==>         #Le premier s'exécute sous la forme :
                        #  - CLASS CLASS_VAR(CLASS_VAR2)
                        #  - CLASS CLASS_VAR = CLASS_VAR2
                        #et n'a donc lieu que lors de la déclaration de 
                        #CLASS_VAR
                        #Le second s'exécute sous la forme :
                        #  - CLASS CLASS_VAR = CLASS_VAR2
                        #mais n'a lieu que lors d'une affectation sans
                        #déclaration.
                        #Il y a deux manières de copier :
                        #  - shallow copy : copie les valeurs de chaque CLASSDT.
                        #    S'il s'agit de ADR, ADR est donc
                        #    copié sans être déréférencé. CLASS_VAR et 
                        #    CLASS_VAR2 auront deux un pointeur vers la même
                        #    zone mémoire, ce qui peut poser problème, si par
                        #    exemple l'une des deux devient out of scope, mais
                        #    pas l'autre, car la zone mémoire sera désallouée.
                        #    Même chose pour les références.
                        #  - deep copy : ici, pour copier un ADR, on
                        #    créer de nouveaux pointeurs, pointant donc vers une
                        #    nouvelle zone mémoire, mais avec une valeur
                        #    identique. Cela évite les problèmes précédents.
                        #    Mais cela implique que :
                        #       - s'il s'agit d'une affectation sans déclaration
                        #       - si la taille de la nouvelle zone mémoire 
                        #         pointée est susceptible d'être différente de
                        #         l'ancienne
                        #    Il faut réallouer de la mémoire, et donc :
                        #      1) checker que CLASS_VAR et CLASS_VAR2 ne font
                        #         pas référence au même objet, auquel la copie
                        #         est inutile, et les étapes qui suivent seront
                        #         dangereuses ("self-assignement")
                        #      2) désallouer la mémoire de l'ancien pointeur de
                        #         CLASS_VAR
                        #      3) lui réallouer la mémoire nécessaire en 
                        #         fonction de la nouvelle valeur pointée
                        #      4) que si le ADR de CLASS_VAR2 est NULL, 
                        #         on ne cherche pas à en déréférencer le contenu
                        #         mais simplement à faire en sorte que le 
                        #         ADR de CLASS_VAR soit un NULL aussi
                        #L'overloadable operator= et le copy constructor font
                        #un shallow copy par défaut : les redéfinir donc pour
                        #toute classe ayant des CLASSDT & ou *
                        #Par ailleurs, pour empêcher de faire une copie d'une 
                        #instantiation d'une CLASS, on peut mettre son copy 
                        #constructor et overloadable operator= en private ou 
                        #protected                      

OPERATOR= DE CLASSE     #Si l'on définit l'operator= d'une classe enfant, plutôt que d'initialiser les membres hérités de cette
 ENFANT ==>             #classe soi-même, on peut faire : Base::operator=( ENFANT ) (ENFANT étant l'argument passé par 
                        #référence)

DECLARATION DE CLASSES  #Une classe doit être déclarée entière, avec tous ces
DANS LES HEADERS        #membres déclarés (mais pas définis) dans un header :
        ==>             #  - class CLASS
                        #    {
                        #        CLASSFK1(...);
                        #        CLASSFK2(...);
                        #    }
                        #Le fichier .cpp doit contenir quant à lui la 
                        #succession des définition des CLASSFK, isolées les 
                        #unes aux autres, de cette classe (et non les 
                        #CLASSDT) :
                        #  - CLASS::CLASSFK1(...) { ... }
                        #  - CLASS::CLASSFK2(...) { ... }, etc.
                        #1 classe doit = 1 header et 1 fichier .cpp, et
                        #inversement.
                        #Le fichier .cpp doit include cet header.
                        #Un autre fichier .cpp souhaitant utiliser la classe 
                        #doit :
                        #  - include cet header
                        #  - se lier (= compiler ensemble) avec le .cpp de la
                        #    classe

SEMANTIQUE DE VALEUR    #Une classe a une sémantique de valeur si ses objets
ET D'ENTITE ==>         #peuvent être comparés (et ont donc une valeur), et une
                        #sémantique d'entité si ses objets sont singuliers et 
                        #ne peuvent être comparés. Dans le premier cas, on 
                        #pourra par exemple définir les opérateurs +, -, *, /, 
                        #=, ==, <, etc

                                  ┌───────────────┐
                                  │   CONSTNESS   │
                                  └───────────────┘

const CLASS CLASS_VAR   #Instantie CLASS de sorte que :
                        #  - les CLASSDT de CLASS_VAR soient read-only. Ils 
                        #    peuvent juste être modifiés par le constructor.
                        #  - seuls les CLASSFK const { } de CLASS_VAR sont
                        #    utilisables
const CLASS CLASSDT     #Déclarer une CLASSDT read-only.
                        #Elle ne pourra être initialisée que grâce à 
                        #l'initialisation list du constructor.
mutable CLASS CLASS_VAR #Déclare une CLASS_VAR mutable. Elle n'est pas
                        #read-only. Son intérêt est qu'elle peut être modifiée
                        #par une CLASSFK const { }. Peu utilisé car plutôt que
                        #de la mettre mutable, on aurait pu enlever const de 
                        #CLASSFK. Son intérêt est de permettre à une CLASSFK
                        #étant logiquement const de modifier malgré tout une
                        #CLASSDT, par exemple pendant un debuggage.
                        #Préférer cela à const_cast<>.
TYPE [CLASS::]CLASSFK   #Déclare une CLASSFK const { }.
const { ...} ;          #Les CLASSDT de la classe courante (qu'ils soient const
                        #ou non) ne pourront pas être modifiés dans le bloc de
                        #cette CLASSFK, à moins qu'elles soient mutable.
                        #Elles ne pourront donc pas non plus être converties en
                        #référence non-const.
                        #Revient en fait à mettre un const devant *this, le 
                        #premier argument implicite.
                        #Ne marche pas sur un constructor ou destructor.

CONST * ET & ==>        #Syntaxe :
                        #  - TYPE const* (à préférer), ou const TYPE* : valeur 
                        #    pointée est const
                        #  - TYPE const& (à préférer), ou const TYPE& : valeur 
                        #    référée est const
                        #  - TYPE* const : pointeur est const.
                        #  - TYPE& const : impossible de modifier une 
                        #    référence (seulement ce qu'elle réfère), donc 
                        #    inutile

UTILITE DE CONST ==>    #Pour :
                        #  - un argument :
                        #    I) * ou & :
                        #      1) pas modifié par fonction -> mettre const :
                        #        a) permet de passer en argument un const 
                        #           TYPE* ou const TYPE& (sinon impossible)
                        #        b) pour &, permet de passer un TYPE non-&
                        #           (sinon transtypage (non-const&) non-& est 
                        #           interdit)
                        #        c) toujours possible de passer en argument un 
                        #           non-const TYPE* ou TYPE&
                        #        d) indique dans documentation que l'argument 
                        #           ne sera pas modifié
                        #      2) modifié par fonction :
                        #        a) intentionnel (setter) -> pas const (sera 
                        #           impossible donc de passer un argument 
                        #           const). Documenter qu'argument doit être 
                        #           mutable (et, si &, référence).
                        #        b) non-intentionnel -> passer plutôt argument 
                        #           par valeur, ou éviter modification et 
                        #           mettre en const
                        #    II) non * ni & -> const inutile, car il s'agit 
                        #        d'une copie, et le caller se fiche qu'elle 
                        #        soit modifiée.
                        #        De plus, on peut transtyper tout [non-]const
                        #        [non-]& vers tout [non-]const non-&, car
                        #        copie.
                        #  - CLASSFK : fonction avec comme premier argument 
                        #    implicite CLASS. Mettre un CLASSFK const { } 
                        #    revient à mettre CLASS en const. Si CLASS :
                        #    - pas modifiée par fonction (getter) -> cf I)1). 
                        #      Sinon, instantiations const ne pourront pas 
                        #      utiliser CLASSFK (mais instantiations non-const 
                        #      peuvent toujours l'utiliser).
                        #      Par contre, instantiation temporaire peuvent
                        #      utiliser CLASSFK const ou non.
                        #    - modifiée par fonction (setter) -> cf I)2)a). Un 
                        #      setter n'est pas supposé fonctionner avec une 
                        #      instantiation const de toute façon. Documenter 
                        #      que CLASS doit être mutable.
                        #  - return value :
                        #    - non-const (laisser caller faire ce qu'il veut), 
                        #      sauf :
                        #      - * ou & pour des raisons de performance (getter
                        #        ne voulant pas réinstancier un objet) (pas 
                        #        bonne pratique ?), mais pas censé être modifié
                        #        -> const
                        #      - * ou & provenant d'un argument (dont CLASSDT 
                        #        pour une CLASSFK)
                        #        - problème : conversion entre argument const 
                        #          et non-const * ou &
                        #        -> const overloading :
                        #         - permet d'utiliser malgré tout un argument 
                        #           const (ou une instantiation const pour 
                        #           une CLASSFK), mais cela fera :
                        #             - perdre la possibilité de modifier la 
                        #               return value : const TYPE&
                        #             - ou perdre la possibité de passer par
                        #               référence : TYPE
                        #         - Très utilisé par les fonctions renvoyant 
                        #           un bout d'objet, tel operator[], 
                        #           operator(), etc.
                        #         - Exemple :
                        #           - const TYPE& FONC_VAR(const VAR);
                        #             TYPE& FONC_VAR(VAR);
                        #           - const TYPE& CLASSFK() const;
                        #             TYPE& CLASSFK();
                        #         - Ou : 
                        #           - TYPE CLASSFK() const;
                        #             TYPE& CLASSFK();

RESUME ==>              #Mettre const :
                        #  - sur argument * ou & non-modifié par fonction
                        #  - sur getter (CLASSFK() const { })
                        #( - sur return value * ou & pour raison de performance
                        #    et non de modification)
                        #  - const overloading sur return value * ou & 
                        #    provenant d'un argument et pouvant être 
                        #    intentionnellement modifiée
                        #Documenter que sont mutables :
                        #  - Argument modifié par un setter
                        #  - setter CLASSFK doivent avoir instantiations 
                        #    mutables

CONST OVERLOADING ==>   #Cela ne marche que pour les CLASSFK() const { },
                        #pas pour les arguments (pas d'overloading possible
                        #entre deux fonctions avec comme seule différence la 
                        #constness de leur arguments)

PERFORMANCE ==>         #Tout est fait compile-time, donc pas de run-time
                        #perte de safety ou performance.

CONST ADR_ADR ==>       #Ne pas caster un ADR_ADR vers un const ADR_ADR
                        #mais vers un const ADR const ADR. Non pas :
                        #  - TYPE ** VAR;
                        #    const TYPE ** VAR2(VAR);
                        #Mais :
                        #  - TYPE const* const* VAR2(VAR);

VOLATILE ==>            #De même que const, une volatile CLASS_VAR ne peut
                        #utiliser que des CLASSFK volatile { }
                        #Il est aussi impossible de convertir des non-volatile
                        #vers des volatile (mais l'inverse oui), sauf via un
                        #const_cast.
                        #Une classe volatile fait que ses CLASSDT deviennent
                        #volatile.
                        #volatile overloading : deux fonctions, une volatile
                        #si CLASS est volatile, et donc partagée par plusieurs
                        #threads, utilisant des procédés de synchronisation ;
                        #une seconde non-volatile, sans ces derniers.

                                  ┌─────────────────────────┐
                                  │   POINTEURS DE CLASSE   │
                                  └─────────────────────────┘

ARRAY DE CLASSES ==>    #Les arrays de classes ne peuvent pas utiliser toutes
                        #les possibilités des pointeurs de classes : ils ne
                        #peuvent pas être utilisés comme CLASS_ADR en tant que
                        #tels, mais seulement déférencés sous la forme :
                        #CLASS_ARR[TOUINTVAL]

CLASS CLASS_ARR         
[TOUINTVAL]             #Déclare un array de TOUINTVAL CLASS_VAR. 
CLASS_ARR[TOUINTVAL]    #Renvoie une CLASS_VAR, qui peut ensuite être utilisée
                        #dans toute occasion où CLASS_VAR est possible. 
                        #Exemple :
                        #  - CLASS_ARR[TOUINTVAL].CLASSDT

POINTEURS DE CLASSES    #Pour accéder aux membres d'une CLASS_ADR, faire :
    ==>                 #  - (*CLASS_ADR).CLASSDT
                        #  - (*CLASS_ADR).CLASSFK
                        #ou :
                        #  - CLASS_ADR->CLASSDT
                        #  - CLASS_ADR->CLASSFK
                        #Par ailleurs, considérant que :   
                        #  - *CLASS_ADR et *CLASS_ADR2 font référence à un 
                        #    objet de type CLASS
                        #  - *CLASS2_ADR fait référence à un objet de type 
                        #    CLASS2, et que CLASS2 hérite de CLASS.
                        #  - *CLASS3_ADR fait référence à un objet de type
                        #    CLASS3, et que CLASS3 n'a rien à voir avec CLASS
                        #    ni CLASS2
                        #Peu importe le nombre de classes intermédiaires dans
                        #l'héritage de CLASS2 par rapport à CLASS : les classes 
                        #intermédiaires ne sont pas prises en compte, et le 
                        #degré d'héritage ne change rien. La modification d'une 
                        #virtual CLASSFK dans CLASS_ADR ne dépend que de la
                        #CLASS_ADR qui lui est éventuellement affectée.
                        #Tous les exemples qui suivent peuvent être des
                        #déclaration + définition : il suffit de rajouter la
                        #classe du premier pointeur avant lui.
                        #Par ailleurs, s'il s'agit d'une déclaration, il est
                        #possible d'utiliser la notation :
                        #  - CLASS CLASS_ADR( ... )
                        #à la place de :
                        #  - CLASS CLASS_ADR = ...
                        #Dans les exemples qui suivent, le premier membre de
                        #l'assignation étant un pointeur, il n'appelle pas de
                        #de constructor. Cependant, le deuxième membre, quel 
                        #qu'il soit, peut voir été initialisé ou non. Il y a 
                        #trois cas en la matière :
                        #  a) il n'a pas été initialisé. Dans ce cas :
                        #        - Aucun constructor n'est donc appelé, et pas
                        #          d'allocation mémoire
                        #        - ni lui, ni le premier membre de l'assignation
                        #          ne peut utiliser de virtual fonction, ou un
                        #          homonyme d'une virtual fonction d'une classe
                        #          dont il hérite
                        #  b) il a été initialisé avec une instantiation de
                        #     CLASS. Ainsi, le constructor de CLASS a été
                        #     appelé. Exemple :
                        #        - CLASS CLASS_VAR
                        #        - CLASS3 *CLASS3_ADR = (CLASS3*) new CLASS
                        #     Comme on le voit, l'important n'est pas le type du
                        #     second membre, mais le fait qu'il ait été
                        #     initialisé avec CLASS. Le constructor de CLASS
                        #     initialisera éventuellement des CLASSDT propres à
                        #     CLASS, et même si CLASS3 ne peut pas y accéder,
                        #     cette initialisation n'est pas perdue.
                        #  c) il a été initialisé avec une instantiation de 
                        #     CLASS2. Ainsi, le constructor de CLASS, puis celui
                        #     de CLASS2 ont été appelés. Exemple :
                        #        - CLASS *CLASS_ADR = new CLASS2
                        #  d) il a été initialisé avec une instantiation de
                        #     CLASS3.

DEFINITION
NON-POLYMORPHIQUE ==>   #Voici :

CLASS *CLASS_ADR        #*CLASS_ADR et *CLASS_ADR2 font alors référence à la 
= CLASS_ADR2            #même instantiation de CLASS. Modifier l'un modifie 
                        #l'autre.
                        #*CLASS_ADR est initialisé selon les valeurs des 
                        #membres de *CLASS_ADR2.
CLASS *CLASS_ADR        #Même chose : (CLASS2*) est ignoré. 
= (CLASS2*) CLASS_ADR2  #Exception : si CLASS_ADR2 a été initialisé selon
                        #l'option c), il s'agira d'une initialisation
                        #polymorphique normale.
CLASS *CLASS_ADR        #*CLASS_ADR fait alors référence à une instantiation de
= (CLASS*) CLASS3_ADR   #CLASS, dont les virtual fonctions ne marchent pas.
                        #Si CLASS3_ADR a été initialisé selon l'option b) ou c):
                        #  - les virtual fonctions marchent
                        #  - la valeur des CLASSDT éventuellement initialisées
                        #    par le constructor sont passées à *CLASS_ADR

DEFINITION
POLYMORPHIQUE NORMALE
    ==>                 #Voici :

CLASS_ADR = CLASS2_ADR  # 1) Les CLASSDT de *CLASS_ADR, hérités par *CLASS2_ADR,
CLASS2_ADR = CLASS2_ADR #    deviennent les mêmes CLASSDT en mémoire, qu'ils se 
                        #    trouvent dans *CLASS_ADR ou dans *CLASS2_ADR :
                        #     a) Leur valeur est initialisée à partir de leur 
                        #        valeur dans *CLASS2_ADR, non de leur valeur 
                        #        dans *CLASS_ADR. Cette valeur peut avoir été
                        #        initialisée par un constructor si CLASS2_ADR a
                        #        été initialisé selon l'option b) ou c) et/ou
                        #        peuvent avoir été modifiée entre-temps
                        #     b) modifier leur valeur dans l'un modifie la 
                        #        valeur dans l'autre.
                        # 2) Les CLASSDT de *CLASS2_ADR propres à lui (non 
                        #    hérités de *CLASS_ADR), ne peuvent pas plus être 
                        #    accédées par *CLASS_ADR, si ce n'est par le biais 
                        #    de virtual CLASSFK.
                        # 3) Les private members de *CLASS_ADR :
                        #      - sont éventuellement initialisés en fonction du 
                        #        constructor de CLASS, à condition que 
                        #        CLASS2_ADR ait été initialisé selon l'option b)
                        #        ou c)
                        #      - peuvent toujours autant être accédés par
                        #        *CLASS_ADR
                        #      - ne peuvent toujours pas plus être accédés par
                        #        *CLASS2_ADR
                        # 4) Les virtual et abstraites CLASSFK de *CLASS_ADR 
                        #    ayant des homonymes dans *CLASS2_ADR :
                        #      - sont redéfinies d'après leurs homonymes.
                        #      - acquierent les mêmes accès que leurs homonymes.
                        #        Ainsi, elles :
                        #          - peuvent accéder aux membres propres à
                        #            *CLASS2_ADR
                        #          - ne peuvent pas accéder aux private membres 
                        #            de *CLASS_ADR
                        #    Il est toutefois encore possible de faire référence
                        #    à la CLASSFK de CLASS en rajoutant CLASS:: derrière
                        #    Par exemple :
                        #      - CLASS_ADR->CLASS::CLASSFK
                        #    passe outre le polymorphisme de la virtual CLASSFK
                        #    Il est possible de faire la même chose avec une 
                        #    CLASS2_VAR héritant d'une CLASS :
                        #      - CLASS2_VAR.CLASS::CLASSFK
CLASS_ADR = (CLASS*)    
CLASS2_ADR              #Même chose : le (CLASS*) est ignoré.

DEFINITION
POLYMORPHIQUE INVERSEE
        ==>             #Voici :

CLASS2_ADR = (CLASS2*)  #A le même effet que si l'on avait noté :
CLASS_ADR               #  - CLASS_ADR = CLASS2_ADR
CLASS2_ADR = (CLASS2*)  #Sauf que :
CLASS_ADR               #  - 1)a) : La valeur des CLASSDT partagées par 
                        #    CLASS2_ADR et CLASS_ADR est initialisée à partir 
                        #    de leur valeur dans *CLASS_ADR, non de leur valeur 
                        #    dans *CLASS2_ADR. 
                        #  - 3) : Les membres propres à *CLASS2_ADR sont 
                        #    éventuellement initialisés en fonction du 
                        #    constructor de CLASS2, à condition que CLASS_ADR 
                        #    ait été initialisé selon l'option c)
                        #  - 4) : Ce sont les homonymes dans *CLASS2_ADR des
                        #    virtual CLASSFK de *CLASS_ADR qui sont redéfinis 
                        #    d'après ces dernières, et non l'inverse (échoue
                        #    donc si CLASS est abstraite) acquièrent les mêmes 
                        #    accès que ces virtual CLASSFK
                        #  - le transtypage doit être explicite.

DEFINITION ILLEGALE ==> #Toute tentative d'assigner, après transtypage s'il y a,
                        #un premier pointeur à un deuxième pointeur n'étant pas 
                        #du même type, est illégal, à moins que le premier
                        #hérite du deuxième.

CLASS2_ADR = CLASS_ADR
CLASS2_ADR = (CLASS*)
CLASS3_ADR              #Exemple de définitions illégales
CLASS_ADR = CLASS3_ADR              
CLASS_ADR = (CLASS3*)
CLASS2_ADR  
CLASS_ADR = (CLASS3*)
CLASS_ADR               #Autres exemples

VIRTUAL ET ABSTRAITES   #  - Une classe contenant une abstraite CLASSFK est dite
CLASSFK ==>             #    elle-même abstraite. On ne peut pas lui instantier
                        #    d'objet. On ne peut donc l'utiliser que par le
                        #    biais du polymorphisme (créer un pointeur de 
                        #    cette classe). Son abstraite CLASSFK doit 
                        #    nécessairement être redéfinie par une classe 
                        #    dérivée lors de l'initialisation polymorphique 
                        #    de la classe, sinon cette initialisation échoue.
                        #    Elle ne peut pas non plus contenir de CLASSFK
                        #    de type CLASS (c'est-à-dire renvoyant une 
                        #    instantiation d'elle-même)
                        #  - Une classe non abstraite, mais contenant une 
                        #    virtual CLASSFK est dite polymorphique.
                        #Ces deux règles s'appliquent aussi aux classes 
                        #possédant de telles CLASSFK parcequ'elles en hérite (ce
                        #qui implique qu'elles n'ont pas d'homonymes de cette
                        #CLASSFK, sinon elles n'en hériteraient pas)
                        #C'est une bonne méthodologie de rajouter virtual devant
                        #les CLASSFK pouvant être des homonymes d'une virtual
                        #CLASSFK parente. Cela ne change presque rien, mais
                        #ça permet de se rappeler qu'elle est sensée remplacer
                        #une véritable virtual CLASSFK.

INTERFACES ==>          #Une interface est une classe ne contenant pas de
                        #CLASSDT, et ne contenant que des abstract CLASSFK. Par
                        #convention, son nom commence souvent par "I".
                        #C'est très utile de définir une interface commune à un
                        #ensemble de classes enfantes similaires entre elles.
                        #Ainsi, grâce au polymorphisme, il est possible par
                        #exemple de définir des CLASSFK prenant cette interface
                        #en argument, laissant le choix quant à l'instantiation
                        #polymorphique de cette interface, les CLASSFK pouvant
                        #alors en sécurité faire INTERFACE->ABSTRACT_FUNC()
                        #Ou bien des CLASSFK à template prenant tout type
                        #d'argument mais restreignant le type via un type 
                        #casting.

virtual TYPE CLASSFK
(ARGUMENTS)             #Déclaration d'une virtual CLASSFK.
virtual TYPE CLASSFK
(ARGUMENTS) { ... }     #Déclaration + définition d'une virtual CLASSFK.
TYPE CLASS::CLASSFK     #Définition d'une virtual CLASSFK en dehors de CLASS :
(ARGUMENTS) { ... }     #pas besoin de remettre "virtual".

virtual TYPE CLASSFK = 0#Déclaration + définition d'une abstraite CLASSFK. Seul
                        #moyen possible, et doit toujours être déclarée et
                        #définie en même temps.

CONSTRUCTORS,           #  - Appeler des virtual/abstraites CLASSFK à l'intérieur de destructors ou de constructors ne peut
DESTRUCTORS ET VIRTUAL/ #    pas appeler des CLASSFK dérivées (i.e. elles sont considérées non virtuelles)
ABSTRAITE CLASSFK ==>   #  - le destructor d'un *CLASS_ADR polymorphique initialisé à partir d'une *CLASS2_ADR s'exécute
                        #    avant celui de CLASS2. Or, cela n'est pas souhaité.
                        #    Pour rétablir l'ordre originel, toute classe polymorphique doit définir ses destructors comme
                        #    étant virtual (mais jamais abstrait).
                        #    Toute classe pouvant être dérivée doit donc déclarer ses destructors virtual, à moins qu'un parent
                        #    l'ait déjà fait (auquel cas ils sont virtual par défaut)
                        #  - A contrario, un constructor ne peut pas être virtual.

UTILITE DE NEW POUR LES #new CLASS renvoie un CLASS_ADR, ce qui est utile par
POINTEURS DE CLASS ==>  #rapport à ce que l'on vient de voir. Exemples :
                        #  - CLASS CLASS_ADR = new CLASS
                        #Permet de déclarer et créer un pointeur de classe CLASS
                        #en lui allouant de la mémoire.
                        #  - CLASS_ADR = new CLASS2
                        #Permet de définir CLASS_ADR de manière polymorphique
                        #avec sa classe dérivée CLASS2. Ainsi :
                        #  - ses CLASSDT hérités par CLASS2 sont initialisées 
                        #    avec leur valeur originelle dans CLASS2 (après
                        #    constructors de CLASS et de CLASS2)
                        #  - ses virtual/abstraites CLASSFK sont redéfinies
                        #    d'après celles de CLASS2

this                    #Pointeur vers l'instance courante (doit se trouver dans
                        #une CLASSFK).
                        #Ainsi this->CLASSFK et this->CLASSDT sont alias de 
                        #CLASS::CLASSFK et CLASS::CLASSDT, ou encore CLASSFK et 
                        #CLASSDT, en quelque sorte
                        #Autre utilité : une fonction retournant un CLASS peut 
                        #modifier l'objet courant, et renvoyer *this
                        #Par ailleurs, une CLASSFK renvoyant *this peut être
                        #appelée à nouveau sur la même ligne de commande :
                        #  - (CLASS_VAR.CLASSFK_VAR1()).CLASSFK.VAR2()
                        #  - ou même CLASS_VAR.CLASSFK_VAR1().CLASSFK.VAR2()
                        #et ainsi de suite. CLASSFK_VAR1() et CLASSFK_VAR2()
                        #seront toutes deux exécutées. CLASSFK_VAR2() aurait
                        #d'ailleurs pû être CLASSFK_VAR1()

POINTEUR DE CLASSFK ==> #Se déclare :
                        #  - TYPE (CLASS::*CLASSFK_ADR)(TYPE...)
                        #S'initialise avec &CLASS::CLASSFK :
                        #  - TYPE (CLASS::*CLASSFK_ADR)(TYPE...) = 
                        #    &CLASS::CLASSFK
                        #Type d'un pointeur de CLASSFK :
                        #  - TYPE (CLASS::*)(TYPE...)
                        #  - typedef TYPE (CLASS::*CLASSFK_ADR_TYPE)(TYPE...)
                        #S'exécute en disposant d'un CLASSVAR ou CLASSADR,
                        #car besoin de lui comme premier argument implicite.
                        #Par conséquent :
                        #  - (CLASSVAR.*CLASSFK_ADR)(ARGS...)
                        #  - (CLASSADR->*CLASSFK_ADR)(ARGS...)
                        #  - ((new CLASS)->*CLASSFK_ADR)(ARGS...)
                        #Dans ma documentation, je parlerai de CLASSFK_ADR

PREDICAT ==>            #Il s'agit d'un fonctor ou d'une FONC_ADR.
                        #Il est utilisé comme argument d'une fonction qui,
                        #faisant appel à lui via PREDICAT(...) se fiche que
                        #PREDICAT soit l'un ou l'autre.
                        #La fonction utilise une instantiation (souvent 
                        #temporaire) du fonctor ou la FONC_ADR.
PREDIC_TYPE             #Signifie soit :
                        #  1) Fonctor (classe), exemple :
                        #     - less <int>
                        #  2) type d'une FONC_ADR, exemple :
                        #     - bool(*)(int, int)
PREDIC                  #Signifie soit :
                        #  1) Fonctor (instantiation), exemple :
                        #     - less <int>()
                        #  2) FONC_ADR, exemple :
                        #     - FONC_ADR

POINTEUR DE CLASSDT ==> #Il s'agit de la même chose qu'un pointeur de CLASSFK, mais pour une CLASSDT. Donc différent d'un
                        #CLASSDT dont le type est un pointeur.
                        #Type :
                        #  - TYPE (CLASS::*) //Tout CLASSDT de type de TYPE dans toute classe CLASS
                        #Déclaration : 
                        #  - typedef TYPE (CLASS::*CLASSDT_ADR_TYPE)
                        #  - TYPE (CLASS::*CLASSDT_ADR);
                        #Initialisation :
                        #  - CLASSDT_ADR = &CLASS::CLASSDT //Ce CLASSDT dans toute classe CLASS
                        #Utilisation : 
                        #  - CLASS_VAR.*CLASSDT_ADR //CLASS_VAR.CLASSDT, où CLASSDT est celui désigné lors de l'initialisation
                        #    de CLASSDT_ADR

                                  ┌─────────────────────────────────┐
                                  │   CONSTRUCTORS ET DESTRUCTORS   │
                                  └─────────────────────────────────┘

CONSTRUCTORS ==>        #Il s'agit d'une CLASSFK qui est exécutée à chaque 
                        #instantiation d'un objet de la classe (et ne peut
                        #l'être qu'alors), à condition que cette instantiation 
                        #ait les mêmes types et nombre d'arguments que le 
                        #constructor.
                        #Les CLASSDT ne pouvant pas être initialisés dans la 
                        #déclaration d'une classe : utiliser donc les 
                        #constructors pour ce faire. Il faut essayer que le
                        #maximum soit faite lors de la construction. Ainsi, les
                        #CLASSFK n'auront pas ou peu besoin d'arguments et ne
                        #se reposeront que sur les CLASSDT initialisées par le
                        #constructor, et la cohérence interne de la classe.
                        #On ne peut pas appeler un constructor d'une classe CLASSE dans le constructor de cette même classe
                        #(même si pas de récursivité si on utilise d'autres arguments) : faire que les deux constructors
                        #appellent une fonction commune get() pour résoudre le problème.
                        #On peut utiliser this->CLASSDT pour accéder aux CLASSDT de la classe parente.

CLASS(ARGUMENTS)        #Déclaration d'un constructor (l'initialisation list est
                        #absente)
CLASS(ARGUMENTS)        #Déclaration et définition d'un constructor :
[: CLASS[DT](VAL...)    #  - CLASSE doit être la classe dans laquelle le
[, CLASS[DT](VAL...)]   #    constructor se trouve
...] {                  #  - un constructor n'a pas de TYPE, et ne renvoie donc
    COMMANDES;...       #    aucune valeur
}                       #  - les constructors peuvent être overloaded
                        #  - Le constructor (void) par défaut est supprimé dès 
                        #    la création d'un autre constructor
                        #  - Voir l'instantiation d'une CLASS_VAR pour savoir
                        #    quel constructor est choisi
                        #Il est possible d'ajouter une initialisation list après
                        #un ":". Les initialisations qui suivent sont :
                        #  - des constructors sous la forme CLASS(VAL[, VAL]...)
                        #  - des initialisations de CLASSDT sous la forme
                        #    CLASSDT(VAL[, VAL]...). Ces CLASSDT ne doivent pas 
                        #    être hérités
INITIALISATION LIST     #Ces dernières sont déclenchées lors du déclenchement du
  ==> CONSTRUCTORS      #constructor, et avant COMMANDES;...
                        #Pour les constructors de l'initialisation list, il doit
                        #s'agir de constructors de CLASS dont hérite la classe
                        #courante. En effet, un constructor appelle d'abord
                        #récursivement les constructors des classes dont il
                        #hérite. Avec l'initialisation list, on peut choisir les
                        #arguments de ces constructors plutôt que de déclencher
                        #le constructor (void) par défaut. Cela est également
                        #utile si cette classe n'a plus de constructor (void)
                        #Le constructor de la classe parente peut lui-même
                        #appelé les constructors d'une classe parente, faisant
                        #ainsi une chaîne.
INITIALISATION LIST     #L'initialisation list peut aussi contenir des 
  ==> CLASSDT           #instantiations de CLASSDT. Ces CLASSDT doivent être
                        #propres à la classe courante, pas héritées par elle.
                        #Elles sont alors initialisées à VAL.
                        #C'est par ailleurs le seul moyen pour initaliser une
                        #const CLASSDT, ou une CLASSDT référence : faire
                        #CLASSDT = VAL dans le corps du constructor ne 
                        #marcherait alors pas.
                        #CLASSDT peut être une CLASS_VAR, permettant ainsi d'en
                        #faire une instantiation en fonction des arguments
                        #donnés.
                        #Pour initialiser des CLASSDT hérités par la classe
                        #courante, le meilleur moyen est d'appeler le 
                        #constructor de la classe parente via l'initialisation
                        #list
                        #Les paramètres passés à une initialization peut être une CLASSDT de la classe courante ou parente,
                        #à condition qu'elle ait déjà été construite. L'ordre de construction est :
                        #  - les classes parentes avant enfants
                        #  - les CLASSDT de haut en bas.

CONSTRUCTORS PRIVATE    #Il peut être utile de :
     ==>                #  - mettre un constructor en private
                        #  - définir une static CLASSFK qui appelle ce 
                        #    constructor mais checke avant si une instantiation
                        #    n'a pa déjà eu lieu.
                        #Cela permet de ne permettre qu'une seule instantiation.
                        #La classe est alors un singleton. Les singleton sont
                        #beaucoup critiqués par ailleurs.

~CLASS()                #Déclaration d'un destructor
~CLASS() {              #Déclaration et définition d'un destructor. C'est la
    ...                 #même syntaxe que le constructor, sauf que :
}                       #  - un ~ précède CLASS
                        #  - il n'y a pas d'initialisation list
                        #  - il ne prend pas d'arguments
                        #Il est exécuté à la désallocation mémoire de l'objet :
                        #  - delete (pour un pointeur de classe)
                        #  - fin de portée de la variable dont :
                        #    - fin d'une fonction
                        #    - fin d'un bloc anonyme
                        #    - fin normale du programme
                        #N'est pas appelé si une exception a lieu dans le
                        #constructor : penser donc à gérer les exceptions 
                        #éventuelles du constructor et à invoquer ~CLASS alors.
                        #Il sert en général à delete la mémoire allouée aux
                        #CLASSDT pointeurs de la classe courante (mais jamais
                        #la classe elle-même, puisqu'il est justement exécuté
                        #lorsque la classe est deleted)
                        #Si CLASS hérite d'autres classes, leur destructor est
                        #aussi appelé, mais dans le sens inverse des 
                        #constructors : le destructor de la classe courante est
                        #d'abord appelé, puis celui des classes parentes.
                        #Ne jamais appeler directement un destructor. Pour ne
                        #pas attendre la fin du bloc courant, et détruire tout
                        #de suite, utiliser des blocs anonymes.
                        #Les membres de CLASS sont toujours détruits dans 
                        #l'ordre inverse de leur construction (les derniers
                        #membres d'une array d'abord, les enfants (hors
                        #virtual destructor) avant la base classe, etc.)
                        #Une array détruit les derniers membres avant les premiers.

APPELER LES DESTRUCTORS #Ne jamais faire un call de ~CLASS() : sinon double free. Solutions pour détruire un objet avant son
 ==>                    #scope prévu :
                        #  - anonymous bloc { }
                        #  - appeler DESTROY() dans ~CLASS(), et utiliser DESTROY(), qui ne détruit pas mais désalloue et 
                        #    checke si double free
                        #Exception : pour un placement new (ex : new (ADR) CLASS), il faut appeler le destructor explicitement
                        #(pas fait automatiquement)

                                  ┌───────────────────┐
                                  │   DROIT D'ACCES   │
                                  └───────────────────┘

ACCES ==>               #Chaque membre d'une classe est associée à un ACCESS.
                        #S'il n'est pas spécifié :
                        #  - il s'agit de celui du membre précédent
                        #  - s'il s'agit du premier membre, il s'agit de 
                        #    "private" par défaut
                        #Cela est fait compile-time, et donc présent seulement
                        #dans les déclarations / headers, non dans 
                        #l'exécutable/shared library créé.
                        #Différents ACCESS possibles ("accès" signifie aussi 
                        #bien lecture qu'écriture) :
public                  #Tout le monde a accès 
protected               #Accès seulement pour les CLASSFK :
                        #  - de la même CLASS
                        #  - d'une CLASS dérivée
                        #  - amie
                        #  - d'une CLASS amie
private                 #Accès seulement pour les CLASSFK :
                        #  - de la même CLASS
                        #  - amie
                        #  - d'une CLASS amie

ENCAPSULATION ==>       #Une classe bien formée ne devrait pas avoir de CLASSDT 
                        #public. Ces derniers ne devraient être accéder que via 
                        #des CLASSFK public de la classe ou de ses classes 
                        #enfants, de telles fonctions étant appelées access 
                        #fonctions.
                        #Les access fonctions peuvent éventuellement être :
                        #  - des setters (ou "accessors", accesseurs), 
                        #    modifiant une CLASSDT
                        #  - des getters (ou "modifiers", mutateurs), renvoyant 
                        #    une CLASSDT ou une valeur).
                        #Setters + getters sont appelés "mutator methods".
                        #Le fait de n'exposer qu'une partie de la classe à un 
                        #utilisateur permet :
                        #  - d'en faciliter la manipulation
                        #  - d'en contrôler (safety) l'accès
                        #Cela est appelé encapsulation

friend TYPE FONC_NAME   #Déclare le fait que FONC_NAME est un ami de la classe
([ARGUMENTS])           #courante. Il doit s'agir du prototype de la fonction.
friend class CLASS      #Déclare le fait que CLASS est une amie de la classe
                        #courante.
                        #Ces deux déclarations doivent donc être placées dans 
                        #la classe à laquelle FONC_NAME ou CLASS souhaite être
                        #amis, et donc avoir la possibité d'accéder à ses
                        #membres protected et private.
                        #Les membres de la classe amie ne peuvent cependant pas
                        #être accédés via CLASS:: ou de manière relative, il
                        #faut donc nécessairement que FONC_NAME prenne une
                        #instance de la classe amie comme argument, ou que CLASS
                        #contienne une CLASSFK prenant une instance de la classe
                        #amie comme argument
                        #La friendship n'est pas transitive : il faut la
                        #déclarer dans l'autre sens pour être mutuellement 
                        #friends
                        #Peu importe si friend est placée dans une section
                        #public, private ou protected
                        #Préférer intégrer les CLASSFK et les CLASS voulant 
                        #être amis derniers dans la classe, car "friend" n'est 
                        #pas très POO.
                        #Peut être utile si une fonction par exemple doit être
                        #exécutée sur plusieurs classes en même temps, mais
                        #préférer alors l'inheritance.
                        #Eviter d'utiliser friend donc si c'est possible

                                  ┌─────────────────┐
                                  │   INHERITANCE   │
                                  └─────────────────┘

class CLASS : [ACCESS2] #Déclare une CLASS comme héritant de CLASS2.
CLASS2[, [ACCESS3]      #CLASS est la classe enfant, CLASS2 la classe parente.
CLASS3]... {            #Si CLASS2 est en haut d'une hierarchie d'héritage, il
        ...             #s'agit de la base classe.
} ;                     #Effet de l'héritage : les membres public ou protected
                        #de CLASS2 non déclarés (avec le même protype) dans
                        #CLASS, deviennent déclarés et définis dans CLASS. 
                        #Leur ACCESS est aussi hérité. Cependant, s'il est 
                        #inférieur à ACCESS2, il devient ACCESS2. ACCESS2 est
                        #private par défaut, mais est général défini public.
                        #Cependant, ne sont pas hérités :
                        #  - les CLASSFK par défaut
                        #  - les amis
                        #Les constructors et les destructors de la chaîne de 
                        #l'héritage sont déclenchés tour à tour à 
                        #l'instantiation d'un objet de cette chaîne, mais en
                        #partant de la base classe pour le constructor, et en 
                        #finissant par la base classe pour le destructor.

MODIFIER L'ACCESS D'UN  #Il est possible de modifier l'ACCESS d'un membre
MEMBRE HERITE ==>       #CLASSDT ou CLASSFK hérité par CLASS2 de CLASS, en
                        #incluant simplement (sans rien de plus) :
                        #  - CLASS::CLASSDT
                        #  - CLASS::CLASSFK
                        #précédé implicitement ou explicitement par ACCESS:.
                        #Le membre hérité est toujours hérité de la même manière
                        #mais son access devient ACCESS (). Cela peut être un
                        #élargissement comme une encapsulation du membre, à
                        #partir d'un point de la chaîne.

INHERITANCE ET          #Une instance d'une classe enfant peut être utilisée
POLYMORPHISME ==>       #partout où une instance de sa classe parent est 
                        #attendue, notamment comme argument d'une fonction.

MULTIPLE INHERITANCE    #L'héritage multiple est à éviter. Il peut poser des
  ==>                   #problèmes à la compilation, comme :  
                        #  - si deux classes parentes non liées entre elles 
                        #    ont toutes deux un membre avec le même prototype
                        #Solution possible (mais préférer éviter l'héritage
                        #multiple) :
                        #  - faire précéder le membre de la classe parente
                        #    concernée : CLASS:: ; par exemple :
                        #     - CLASS2_VAR.CLASS::CLASSFK
                        #Autre problème : le problème du diamand :
                        #  - CLASS4 hérite de CLASS2 et CLASS3, qui toutes deux
                        #    héritent de CLASS1.
                        #Dans ce cas, CLASS2 et CLASS3 appelle tous deux le
                        #constructor de CLASS1, qui est donc appelé deux fois,
                        #sans que le compilateur se rende compte qu'il s'agit de
                        #la même classe. Ainsi cela buguera :
                        #  - en faisant CLASS CLASS_ADR = new CLASS4
                        #  - si CLASS2 redéfinit une CLASSFK de CLASS1 qui est
                        #    utilisée par CLASS4 (il ne saura pas laquelle
                        #    utiliser)
                        #Solution : mettre "virtual" devant l'ACCESS de la
                        #classe base. Ainsi, CLASS2 et CLASS3 auront toutes deux
                        #": virtual ACCESS CLASS1". De cette manière :
                        #  - le constructor de CLASS1 sera appelé une seule fois
                        #  - pendant l'instantiation de CLASS4, si 
                        #    l'initialisation list de CLASS2 ou CLASS3 appelle
                        #    le constructor de CLASS1 d'une certaine manière,
                        #    ce ne sera pas effectué. Cependant, 
                        #    l'initialisation list de CLASS4 pourra quant à elle
                        #    le faire, même s'il ne s'agit pas d'une classe
                        #    parente directe.
                        #  - cependant, pour une instantiation de CLASS2 ou
                        #    CLASS3, cela se passe comme d'habitude
                        #  - pour le problème d'une redéfinition d'une CLASSFK,
                        #    grâce à la solution, la CLASSFK de CLASS2 ou CLASS3
                        #    overridera la CLASSFK de CLASS1.

CLASSES CONTENANT DES   #Il ne faut pas confondre l'inhéritance et le fait
CLASSES  ==>            #qu'une classe soit contenue dans une autre classe :
                        #  - il n'y a pas d'inhéritance dans le second cas
                        #  - dans le premier cas, la classe enfante est
                        #    indépendante de son parent, elle hérite juste de
                        #    ses membres
                        #La seule chose similaire est le fait qu'ils déclenchent
                        #les constructors et destructors de manière récursive.

                                  ┌───────────────────────┐
                                  │   CLASSES SPECIALES   │
                                  └───────────────────────┘

RECURSION ==>           #Pour qu'une classe contienne une CLASSDT étant une
                        #instantiation d'elle-même :
                        #  - possible de déclarer une classe dans une autre 
                        #    classe même si son prototype ne précède pas)
                        #  - cependant, l'allocation mémoire sera récursive, et 
                        #    alloue ainsi une infinité de mémoire => segfault
                        #Solution :
                        #  1) utiliser des pointeurs de classe
                        #  2) ne pas utiliser de constructors allouant 
                        #     automatiquement de la mémoire au pointeur (et 
                        #     appelant donc son propre consructor, et ainsi de 
                        #     suite). Mais cela est ok pour les destructors.
                        #La CLASSDT peut aussi faire référence à la classe 
                        #dans son template. Dans ce cas-là, une simple forward
                        #declaration suffit (class CLASS; sans { })

REFERENCE MUTUELLE ==>  #Pour qu'une classe instantie une autre classe en 
                        #CLASSDT, et inversement, il suffit d'appliquer les
                        #deux règles ci-dessus. Cela peut n'être fait que sur
                        #l'un des deux classes éventuellement.

CONTAINER ==>           #Il s'agit d'une classe contenant un array d'un TYPE 
                        #(dont CLASS) donné, ainsi que des CLASSDT et des 
                        #CLASSFK pour le manipuler, par exemple :
                        #  - création de l'array
                        #  - destruction de l'array
                        #  - renvoyer une référence à un membre de l'array, 
                        #    notamment avec l'overloadable operator[] renvoyant 
                        #    une référence.
                        #  - insertion / suppression d'un membre (parfois pas 
                        #    implémenté car trop lent)
                        #  - modification de la taille de l'array (avec ou 
                        #    sans conservation des data)
                        #Un container peut être une composition (value
                        #container) ou une agrégation (reference container)

                                  ┌───────────────┐
                                  │   TEMPLATES   │
                                  └───────────────┘

TEMPLATES ET PROTOTYPES #Dans tout ce qui suit, les templates font partie du
     ==>                #prototype d'une fonction et d'une classe, et doivent
                        #donc être indiqués lors de toute déclaration

SIMPLIFICATION DE LA    #<T...> signifie <T[ = TYPE][, T[ = TYPE]]...>
SYNTAXE ==>             #Les QUALIFIER sont : const, &, *, [], [TOUINTVAL] et volatile
                        #Les overloads prennent en compte les QUALIFIER : il faut donc par exemple définir des const overloads
                        #pour les template, car <TYPE const> ne marche pas avec un TYPE non-const.

template <T...>         #Déclaration ou déclaration + définition d'une fonction prenant un template général.
TYPE FONC_NAME          #A chaque invocation de cette fonction, chaque T sera associée au type correspondante utilisée lors de 
([ARGUMENTS]) [{ ... }] #cette invocation. Il sera nommé "T" ou quelqu'autre nom que l'on aura choisi.
                        #La liste des T... est :
                        #  - celle spécifiée explicitement pendant l'invocation de la commande via FONC<TYPE...>( ... )
                        #  - si celle-ci n'est pas explicitement présente, la liste des types successifs des arguments invoqués
                        #    (paramètres donc)
                        #T peut être :
                        #  - "paramètre" : "class" ou "typename" (identiques) suivis du nom de T, qui sera alors associé à un
                        #    TYPE. Pas de QUALIFIER.
                        #  - "non-paramètre" : un TYPE (avec QUALIFIER possible), qui sera alors associé à une instantiation 
                        #    de ce type.
                        #Chaque T peut être suivie de = TYPE pour définir un TYPE par défaut, s'il s'agit du dernier T, ou
                        #qu'il est suivi par d'autre T par défaut.
                        #Une fois substituer, T peut être utilisé n'importe où dans la fonction : return type, type des
                        #arguments, valeurs et types dans la définition de la fonction.
                        #On peut manipuler un T paramètre comme un typedef, et donc lui rajouter un QUALIFIER.
                        #Un friend TYPE FONC( ARGS ); sans définition, si FONC est template, doit être écrit : 
                        #friend TYPE FONC<>( ARGS )

FONC_NAME [<T...>]      #Invocation d'une fonction ayant un template général.
(ARGUMENTS)             #T remplit le template de la fonction par un TYPE, si paramètre, ou une VAL, si non-paramètre.
                        #L'overload choisit prend en compte les QUALIFIER.
                        #Toutes les T du template doivent être devinables.
                        #Si l'on veut utiliser toutes les TYPE par défaut d'un template en fournissant pour chaque T, on 
                        #doit quand même écrire <>
                        #On peut ne pas écrire même <>, à condition : que le template n'ai que des paramètres, devinables via
                        #le type des ARGUMENTS. 

template<>              #Déclare une fonction template specialization.
TYPE FONC<TYPE...>(ARGS)#CLASSK doit avoir déjà été déclarée au sein d'une CLASS à template, sous une forme sans template, que
[{ ... }]               #cette specialized CLASSFK overloade.
                        #Fait que si l'instantiation du template matche TYPE..., elle aura la priorité de l'overload.
                        #TYPE prend en compte les QUALIFIER dans l'overload.
                        #Si TYPE... peut être déduit du type des arguments, cela est inutile, il suffit de définir un 
                        #overload sans template. Différences :
                        #  - du coup, on ne peut plus utiliser <T...> dans l'appel de la fonction : FONC<T...>( ARGS ), mais
                        #    peu important car on peut faire FONC( (T)ARGS ) qui est strictement équivalent.
                        #  - les QUALIFIER ne sont pas descriminant dans un overload classique, contrairement à un template.
                        #    Par exemple, pas besoin de définir un const overload.
                        #    Utiliser donc templates si l'on veut discriminer selon les QUALIFIER
                        #Les partial specialization n'existent pas pour les fonctions : mais les overloads permettent d'obtenir
                        #presque le même effet.

template <T...>         #Déclare une classe avec template général. Comme une fonction avec template, T... seront associés à
class CLASS { ... }     #des TYPE (si paramètres) ou VAL (si non-paramètres) à la déclaration de son type.
                        #T peuvent être utilisés dans la définition de la classe.
                        #Le type de la class devient CLASS<TYPE...> partout. Par exemple une CLASSFK définie en dehors de
                        #son scope devient :
                        #  - template <class T>
                        #    TYPE CLASS<T>::CLASSFK( ARGS )
                        #Le TYPE (ou VAL) doit de plus être instantié avec une valeur précise dans ce cas : on ne peut pas 
                        #déclarer un type générique (en dehors de la déclaration de la classe).
                        #CLASS<TYPE...>::TYPE doit toujours être précédé par typename.
                        #Pour déclarer une fonction template "template <class U> TYPE FONC( U )" d'une classe template 
                        #"template <class T> class CLASS" en dehors de son scope :
                        #  - template <class T>
                        #    template <class U>
                        #    TYPE CLASS<T>::FONC( U )

template <>             #Déclare une classe avec un template en full specialization. 
class CLASS <TYPE...>   #Comme la spécialization des fonctions.
                        #Pour définir une CLASSFK (non-template par exemple) d'une spécialisation de CLASS : 
                        #  - template <>
                        #    TYPE CLASS<TYPE>::FONC( ARGS )

template <T...>         #Déclare une classe avec un template en partial specialization.
class CLASS             #Comme full specialization, sauf que l'on précise non pas les TYPE (dont QUALIFIER), mais seulement les
<T[QUALIFIER]...>       #QUALIFIER. Chaque T doit avoir un T correspondant en bas.
                        #Exemple :
                        #  - template <class T, class U>
                        #    class CLASS <T, U*>

TEMPLATE ET HERITAGE    #Quand ENFANT hérite de PARENT<T> :
 ==>                    #  - pour utiliser une CLASSFK héritée, faire non CLASSFK() mais this->CLASSFK()
                        #  - pour utiliser une CLASSDT héritée, faire non CLASSDT, mais typename PARENT<T>::CLASSDT

TEMPLATES ET HEADERS    #Les templates posent de nombreux problèmes dans un projet multi-fichier. 
   ==>                  #De manière générale, une classe ou fonction avec template devrait être déclarée et définie dans le 
                        #même fichier. En effet, il est impossible de créer le fichier d'une classe à template séparée entre 
                        #un .cpp et un .hpp. Il est donc impossible de compiler à part le fichier objet.
                        #Plusieurs solutions :
                        #  1) déclarations + définitions dans CLASS.hpp
                        #  2) - déclarations dans CLASS.hpp
                        #     - terminer (avant l'#endif) CLASS.hpp par un 
                        #       #include CLASS.tpp
                        #     - définitions dans CLASS.tpp
                        #Pourquoi ? Parce que le compiler compile séparément chaque fichier.
                        #  - pour une déclaration classique, il se souvient des symboles définis dans les headers, et les
                        #    utilise quand il lit les .cpp
                        #  - mais un template est une "sorte de macro" générant un ensemble d'instantiations de classes ou
                        #    fonctions, i.e. celles dont le compiler voit qu'on aura besoin.
                        #    Donc si fichier.cpp include template_class.hpp, PUIS se link avec template.cpp, lors de
                        #    l'inclusion de template_class.hpp, il a besoin des définitions du template pour l'instantier.
                        #    Donc il doit connaître à la fois la déclaration et la définition => séparation en .hpp/.cpp
                        #    irrelevant (le .cpp étant utilisé "comme un header")

                                  ┌────────────────┐
                                  │   NAMESPACES   │
                                  └────────────────┘

NAMESPACES ==>          #Les namespaces affectent la manière avec laquelle la
                        #référence à un identifiant est recherchéé.
                        #Quand un identifier est indiqué, il est toujours 
                        #recherché par ordre de priorité :
                        # 1) si l'identifier est précédé de NAMESPACE::, comme 
                        #    étant dans NAMESPACE.
                        # 2) si un "using NAMESPACE::IDENTIFIER" a :
                        #      - précédé dans ce même bloc
                        #      - précédé, mais en dehors de tout bloc
                        #    et qu'IDENTIFIER est ce même identifier, NAMESPACE 
                        #    est utilisé pour cet identifier
                        # 3) Si un "using namespace NAMESPACE" a :
                        #      - précédé dans ce même bloc
                        #      - précédé, mais en dehors de tout bloc
                        #    NAMESPACE est utilisé pour cet identifier.
                        # 4) Dans le namespace courant, s'il y en a un
                        # 5) Dans le namespace global
                        # 6) Dans le bloc courant
                        #Dans une déclaration de classe, seuls 1), 4) et 5) 
                        #sont examinés.
                        #Une classe étant déclarée dans le namespace global, il
                        #suffit de faire CLASS pour y faire référence. 
                        #Cependant, si classe est déclarée dans un bloc 
                        #namespace, on doit obligatoirement faire
                        #NAMESPACES::CLASS pour y faire référence.

DIFFERENTS NAMESPACES   #Un identifiant a un namespace en fonction de l'endroit
    ==>                 #où il a été déclaré (et non défini, ainsi ce qui compte
                        #par exemple pour une fonction, c'est sa déclaration,
                        #pas sa définition) :
                        #  - Dans une classe : la classe courante est le 
                        #    namespace courant.
                        #    Ainsi les CLASSFK d'une classe peuvent faire 
                        #    référence aux membres de la classe de manière 
                        #    relative. Cependant, la notation CLASS:: fait 
                        #    référence à un membre sans instantiation de la 
                        #    classe, et ne marche donc que :
                        #     - sous la forme CLASS::CLASSFK, lorsqu'une 
                        #       CLASSFK est définie en dehors de sa classe
                        #     - la référence à un static membre
                        #  - Dans un bloc namespace : celui-ci devient le 
                        #    namespace courant. S'il contient lui-même un
                        #    "using namespace NAMESPACE2" (quel que soit sa
                        #    place dans le bloc namespace), ce NAMESPACE2 sera
                        #    compris récursivement, si le premier namespace ne
                        #    contient pas l'identifiant recherché.
                        #  - En dehors de tout bloc : le namespace global 
                        #    devient le namespace courant. Son nom est vide : 
                        #    on peut donc faire référence à un de ses objets 
                        #    avec la notation ::OBJET
                        #  - Sinon : pas de namespace courant
                        #Dans tous les cas NAMESPACE peut être nested : 
                        #  - NAMESPACE[::NAMESPACE2]...
                        #Possibilités de combinaisons de bloc namespace et de
                        #"class namespace" si nested.

namespace [NAMESPACE] { #Déclaration d'un bloc namespace dont le nom est 
    ...                 #NAMESPACE
}                       #Ne peut être déclaré qu'en dehors de tout bloc. Peut 
                        #contenir toute déclaration et définition, dont de 
                        #classes.
                        #Il est possible d'overloader un namespace avec un 
                        #NAMESPACE du même nom, qui concatène alors son contenu 
                        #au premier namespace du même nom.
                        #Si NAMESPACE est omis, il s'agit d'un anonymous 
                        #namespace : c'est la même chose que le namespace global
                        #sauf que le linkage est interne (équivalent donc à
                        #static, et est d'ailleurs préféré en C++)

namespace NAMESPACE2
= NAMESPACE             #NAMESPACE2 devient un alias de NAMESPACE

{                       #Bloc anonyme. Il s'agit d'un bloc, non d'un namespace.
    ...                 #Cela est utile notamment pour restreindre la portée
}                       #d'un "using namespace NAMESPACES" ou d'un "using 
                        #NAMESPACE::IDENTIFIER", ou encore la portée de 
                        #variables (RAII)

                                  ┌──────────────────┐
                                  │   TYPE CASTING   │
                                  └──────────────────┘

TYPE CASTERS ==>        #Ils permettent de restreindre l'utilisation du
                        #transtypage.
                        #La notation :
                        #  - TYPE_CASTER <TYPE> (VAL)
                        #est équivalente à :
                        #  - (TYPE) VAL
                        #A noter que :
                        #  - TYPE (VAL)
                        #est lui aussi équivalent à un transtypage en C++.
                        #Cependant, les TYPE_CASTER ont des effets 
                        #supplémentaires. Ils sont peu utilisés, et typeid()
                        #est en général préféré pour checker si un transtypage
                        #ne posera pas de problème.
                        #Ils sont utilisés en général si l'on ne connaît pas le
                        #type de VAL, car provenant d'un template ou d'un 
                        #CLASS_ADR, et que l'on veut restreindre ce template à 
                        #un certain type.
                        #Les effets sont (les options a), b) et c) font 
                        #référence à celles dans la partie sur les pointeurs de
                        #classe):

reinterpret_cast        #Type caster par défaut.
static_cast             #Fait échouer un transtypage vers une CLASS* 
                        #polymorphique ou abstraite d'un pointeur d'une classe 
                        #n'ayant aucun lien avec cette CLASS. Exemple :
                        #  - (CLASS*) CLASS3_ADR
                        #Si CLASS* n'est pas polymorphique, renvoie NULL
                        #Est utilisé aussi avec un transtypage sur un TYPE
                        #fondamental, si cela va provoquer un avertissement du 
                        #compilateur, afin de supprimer cet avertissement.
                        #Cela est fait compile-time.
dynamic_cast            #Même chose, mais ajoute en plus le fait que le 
                        #transtypage vers une CLASSE* d'un pointeur d'une classe
                        #dérivée, comme :
                        #  - (CLASS2*) CLASS_ADR
                        #a pour effet :
                        #  - de renvoyer un segfault si ce CLASS_ADR n'a pas été
                        #    initialisé (option a))
                        #  - renvoie NULL s'il a été initialisé selon l'option 
                        #    b) (le constructor de CLASS2 n'a donc pas été
                        #    appelé)
                        #  - d'échouer si CLASS_ADR n'est pas polymorphique.
                        #De plus, si cela arrive run-time, une exception bad_cast
                        #est lancée.
const_cast              #Seule utilité est le fait qu'une fonction prenant un
                        #argument * ou & non const :
                        #  - TYPE1 FONC_NAME(TYPE2 *ADR) { ... }
                        #ne peut pas être invoquée avec un argument pointeur
                        #const :
                        #  - FONC_NAME(CONST_ADR)
                        #sauf avec const_cast :
                        #  - FONC_NAME(const_cast<TYPE2*> CONST_ADR)

OVERLOADABLE TYPECAST   #Il est en général impossible de transtyper une 
    ==>                 #CLASS_VAR en dehors de sa propre CLASS ou de celle 
                        #d'une CLASS dérivée. C'est cependant possible avec les
                        #overloadable typecasts.

[CLASS::]operator       #Déclare un overloadable typecast.
TYPE() [{ ... }]        #Le définit aussi si { ... }
                        #Si la définition est en dehors de la déclaration de la
                        #classe, rajouter CLASS::
                        #Il n'y a pas de type de retour : la valeur retournée 
                        #est donc sensé être du même type que TYPE, sinon cela 
                        #va buguer, mais le compilateur ne donnera pas 
                        #d'avertissement
                        #TYPE peut être :
                        #  - un type fondamental. Il peut être suivi de * pour 
                        #    désigner un pointeur, mais & et [] ne semblent pas 
                        #    marcher. bool peut être utile pour pouvoir faire
                        #    des tests : if ( CLASS )
                        #  - une CLASS. 

(TYPE) CLASS_VAR        #Transtype avec TYPE l'instantiation d'une CLASS ayant
                        #un overloadable typecast pour TYPE. Le résultat
                        #renvoyé est celui renvoyé par cet overloadable typecast
                        #Dans ce cas, TYPE ne peut pas être une classe.
FONC_NAME(CLASS_VAR)    #Si FONC_NAME ne peut pas prendre de CLASS_VAR en 
                        #argument, il cherchera à la convertir en fonction des 
                        #différents overloadable typecasts disponibles, pour la 
                        #transtyper vers un type d'argument qu'il accepte.

                                  ┌────────────────┐
                                  │   EXCEPTIONS   │
                                  └────────────────┘

try {                   #Exécute ce qui est dans le contenu du bloc try,
    COMMANDES1;...      #jusqu'à interruption par throw. Ainsi COMMANDES1;...
    [throw VAL;]        #sont exécutées, mais pas COMMANDES2;...
    COMMANDES2;...      #Ensuite le premier bloc catch (et seulement le premier)
}                       #(aucun si aucun ne matche) dont le TYPE de l'argument
catch (TYPE [VAR]) {    #matche VAL, est élu :
    COMMANDES3;...      #  - VAL est affectée à son argument VAR si présent (si
}                       #    VAR est précisé)
[catch (TYPE [VAR]) {   #  - ses COMMANDES sont exécutées
    COMMANDES3;...      #les blocs catch et try doivent se suivre.
}]...                   #Lancer un throw, qu'il soit intercepté ou non, appelle
                        #le destructor de toutes les CLASS_VAR déclarées dans le
                        #bloc try.
                        #COMMANDES3 doit cleaner le terrain au cas où des 
                        #fichiers ont été ouverts, de la mémoire allouée, etc.
                        #throw peut avoir été lancé par une fonction appelée
                        #dans le bloc try.
                        #Si l'exception n'est pas catchée, elle aborte la
                        #fonction courante et cherche un bloc catch dans les 
                        #stacks supérieurs, de manière récursive ("exception 
                        #unwinding"). Si le bloc main() ne parvient pas à 
                        #catcher une exception : interruption du programme.
                        #Le bloc catch peut lui-même lancer un throw et être
                        #inclus dans un bloc try englobant, et ce de manière
                        #récursive.
                        #L'utilité des throw est surtout dans le fait de laisser
                        #à la fonction appelante le soin de faire un try and
                        #catch.
                        #VAL devrait être de préférence un const&, et throw
                        #devrait utiliser un enfant de std::exception.
                        #Penser au fait que l'on peut catcher aussi les enfants
                        #d'une CLASS dans : catch(CLASS), cela est utile. Si les
                        #enfants de CLASS doivent être catchés, ils devraient
                        #donc l'être avant CLASS elle-même

catch (...)             #Signifie "pour tout TYPE" : le bloc s'exécute donc
                        #toujours, mais doit être le dernier dans la liste
                        #de blocs catch (= catch par défaut).

throw [VAL];            #Lance une exception VAL : si dans un catch block, 
                        #par défaut celle catchée.

BLOC try { ... }        #try peut être mis avant tout bloc { }, ce qui permet
catch ...               #d'englober par un try une structure (if, while, etc.)
                        #ou une fonction, dont un constructor (mais jamais un
                        #destructor).
                        #Pour le constructor :
                        #  - try doit précéder [: CLASS[DT](ARGS)]. 
                        #  - Si une exception a lieu, la mémoire allouée par le
                        #    constructor est automatiquement désallouée
                        #Dans tous les cas, } ne doit pas être suivi de ;

TYPE FONC_NAME          #Par défaut, une fonction (FONC_NAME ou CLASSFK) peut 
(ARGUMENTS)             #lancer toute exception. Cependant, avec cette syntaxe :
throw([TYPE             #  - sans TYPE, FONC_NAME ne peut lancer aucune 
[, TYPE2]...]) {        #    exception
    COMMANDES;...       #  - sinon, seuls des VAL correspondant aux TYPE...
}                       #    précisés peut être lancée
                        #  - aucun throw signifie que toute exception peut être
                        #    lancée
                        #Ces syntaxes sont à éviter, car cela pose parfois des
                        #problèmes d'optimisation avec certains compilos.

                                  ┌──────────────────────┐
                                  │   STANDARD LIBRARY   │
                                  └──────────────────────┘

NAMESPACE ==>           #Toutes les classes sont dans le namespace std::
                        #Cependant, libstdc++ peut spécifier :
                        #  - un namespace abi:: pour les classes liées à l'ABI
                        #  - un namespace __gnu_:: pour les extensions GNU

HEADERS ==>             #Tous ces headers sont contenus dans
                        #/usr/include/c++/{VERSION}/. Voici la liste :

C COMPATIBILITY         #Utiliser ces derniers plutôt que leur version 
HEADERS ==>             #<assert.h>. Par rapport à C, ils sont légèrement
                        #remaniés : 
                        #  - sont dans le namespace std::
                        #  - cmath a des overload évitant de rajoutant "f" ou
                        #    "l" à la fin des noms de fonctions pour les floats
                        #    et long double.
                        #  - wchar_t et les macros de iso646 sont des keywords,
                        #    donc pas besoin d'inclure l'header
                        #  - ajoute quelques const
                        #Une version nommé .h avec ces changements est aussi
                        #donnée pour la backward compatibility.
                        #Voici :
cassert   cctype    cerrno    cfloat    ciso646   climits   clocale   cmath     
csetjmp   csignal   cstdarg   cstddef   cstdio    cstdlib   cstring   ctime     
cwchar    cwctype

C COMPATIBILITY
HEADERS 2003 ==>        #Voici :
ccomplex  cfenv     cinttypes cstdbool  cstdint   ctgmath   cuchar   stdatomic.h

C COMPATIBILITY         #Tous ces headers commencent sont contenus dans le
HEADERS TR1 ==>         #répertoire tr1/. Voici :
ccomplex  cfenv     cfloat    cinttypes climits   cmath     cstdarg   cstdbool  
cstdint   cstdio    cstdlib   ctgmath   ctime     cwchar    cwctype 

C++ 1998 ==>            #Voici :
algorithm bitset    complex   deque     exception fstream   functional iomanip  
ios       iosfwd    iostream  istream   iterator  limits    list       locale   
map       memory    new       numeric   ostream   queue     set        sstream  
stack     stdexcept streambuf string    typeinfo  utility   valarray   vector 

C++ TR1 ==>             #Tous ces headers commencent sont contenus dans le
                        #répertoire tr1/. Voici :
array               complex             functional          memory              random              regex               tuple               type_traits         unordered_map       unordered_set       utility      

C++ TR 24733 ==>        #Contenu dans le répertoire décimal/. Voici :
decimal

C++ 200x ==>            #Voici :
array               chrono              condition_variable  forward_list        future              initalizer_list     mutex               random              ratio               regex               system_error        thread              tuple               type_traits         unordered_map       unordered_set       

C++ ABI HEADERS ==>     #Voici :
cxxabi.h    cxxabi_forced.h

GNU EXTENSIONS HEADERS  
 ==>                    #Contenus dans le répertoire ext/. Voici :
algorithm           array_allocator.h   atomicity.h         bitmap_allocator.h  
cast.h              concurrence.h       debug_allocator.h   enc_filebuf.h     
extptr_allocator.h  functional          iterator            malloc_allocator.h  
memory              mt_allocator.h      new_allocator.h     numeric             
numeric_traits.h    pod_char_traits.h   pool_allocator.h    rb_tree             
rope                slist               stdio_filebuf.h     stdio_sync_filebuf.h
throw_allocator.h   typelist.h          type_traits.h       vstring.h 
codecvt_specializations.h               pb_ds/assoc_container.h               
pb_ds/priority_queue.h      
                        #Ceux-ci sont contenus dans le répertoire parallel/ :
algorithm   numeric

DEBUG ET PROFILE HEADERS
 ==>                    #Contenus dans le répertoire debug/, et d'autres dans le
                        #répertoire profile/ :
bitset        deque         list          map           set           string 
unordered_map unordered_set vector
