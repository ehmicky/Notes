
              
   TYPESCRIPT  
              



ALTERNATIVES ==>                  #  - typescript (preferred)
                                  #  - flow: very similar to TypeScript, a little less features, less focus on extending JavaScript, less high-profile

VERSION ==>                       #5.2-beta
                           VERSION#Means feature was introduced at that version


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            CONFIG             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


CONF                              #Can be:
                                  #  - --FLAG: for CONF.compilerOptions.FLAG
                                  #  - [../...]tsconfig.json
                                  #  - -p|--project CONF_PATH|DIR
                                  #CONF files are ignored when FILE... passed to tsc
                                  #Unless specified otherwise, all BOOL options default to false
                                  #CONF_FILE.json can contain comments
                                  #CLI flags must be --VAR VAL, not --VAR=VAL
                                  #Many CONF.* values that are enums are case-insensitive
CONF_PATH                         #Either CONF_FILE.json or DIR with tsconfig.json it

CONF.extends                      #'PATH|MODULE' to a CONF2 to merge with lower priority
                                  #If 'MODULE', uses PACKAGE.tsconfig 'PATH' or ROOT/tsconfig.json
                               5.0#Can be an ARR
@tsconfig/*                      ##Common tsconfig.json configs to extend from

--init                            #Create a boilerplate ./tsconfig.json

--showConfig                   3.2#Print the resolved CONF


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              CLI              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


tsc                               #Type checks input files.
                                  #Then transpile them to JavaScript output files
                                  #  - with different extension:
                                  #     - '.ts[x]' -> '.js[x]'
                               4.7#     - '.mts|cts' -> '.mjs|cjs'

--noEmit                          #Do not transpile (only type check).
--noEmitOnErrors                  #Do not transpile if type checks failed
--removeComments                  #Remove comments (during transpile) unless start with /*! and is on first line.
                                  #Regardless of value, comments from *.d.ts are always removed, unless start with /*! or /**


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLI: FILES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


tsc FILE...
CONF.files                        #Input FILE_ARR
CONF.include|exclude              #Input FILEs but as 'GLOB'_ARR
                                  #Def exclude: node_modules, bower_components, jspm_packages, --outDir

--outDir DIR                      #Where to output file (def: '.')
--rootDir DIR2                    #--outDir replicates input files directory layout.
                                  #It is based on --rootDir DIR2, which is the input files root (def: the lowest common root)
--outFile FILE2                   #Concatenate into single output FILE2
                                  #Cannot be used with --module es*|umd
                                  #Can be /dev/stdout (on Unix)

--explainFiles                 4.2#Print list of included files and why they were included, for debugging


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CLI: WATCH           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--watch|w                         #Watch mode
                                  #On file change, only target changed file and files importing it
CONF.compileOnSave                #Tells IDE to run tsc in watch mode.

CONF.watchOptions
 .excludeFiles|Directories     3.8#'PATH'_ARR

--preserveWatchOutput             #Do not clear screen between runs with --watch

CONF.watchOptions.watchFile    3.8#Whether --watch uses fs.watchFile() or fs.watch() on regular files:
ENVVAR TSC_WATCHFILE           3.8#  - 'FixedPollingInterval': fs.watchFile() with fixed intervals
                               3.8#  - 'PriorityPollingInterval': fs.watchFile() with longer intervals for config files and missing files
                               3.8#  - 'DynamicPriorityPolling': fs.watchFile() with longer intervals for not frequently modified files
                               3.8#  - 'UseFsEventsOnParentDirectory' (def if ENVVAR TSC_NONPOLLING_WATCHER set): use fs.watch() on root directory
                               3.8#  - 'UseFsEvents' (def): fs.watch() on files
                               3.8#  - 'UseFsEventsWithFallbackDynamicPolling': UseFsEvents, with fallback to DynamicPriorityPolling
CONF.watchOptions.watchDirectory
ENVVAR TSC_WATCHDIRECTORY      3.8#Same for directories
CONF.watchOptions.             3.8#Fallback 'fixedPollingInterval|priorityPollingInterval|dynamicPriorityPolling' when using
 fallbackPolling               3.8#'useFsEvents*' but fs.watch() not available on platform
CONF.watchOptions.
 synchronousWatchDirectory     3.8#BOOL (def: false). Disable watch bounding on directories. Only useful for specific setups


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       CLI: INCREMENTAL        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


-i|--incremental               3.4#Outputs a tsconfig.tsbuildinfo containing:
                               3.4#  - a hash of each file's content
                               3.4#  - the import|export dependency tree
                               3.4#  - the current CONF
                               3.4#On next run use it to only select newly updated files.
--tsBuildInfoFile              3.4#'PATH' to tsconfig.tsbuildinfo (def: './tsconfig.tsbuildinfo')
--assumeChangesOnlyAffect      3.8#Only select newly updated files, not their dependencies.
 DirectDependencies            3.8#Faster but does not typecheck dependencies.

CONF.references                3.0#Sub-CONFs:
                               3.0#  - when imported, only *.d.ts will be tried
                               3.0#  - must use --composite
                               3.0#Is OBJ_ARR:
                               3.0#  - path CONF_PATH
--composite                    3.0#Means the current CONF is a sub-CONF
                               3.0#Implies --declaration and --incremental
                               3.0#Sets --rootDir to the tsconfig.json's DIR
--disableSourceOfProject
 ReferenceRedirect             3.7#Unless defined, *.ts[x] are used instead of *.d.ts by IDE plugins for sub-CONFs
--disableSolutionSearching     3.8#Make IDE plugins exclude current project from type search, for IDE performance optimization
--disableReferenceProjectLoad  4.0#Make IDE plugins load sub-CONFs on-demand (when file from that project is open), for IDE performance optimization

-b|--build                     3.0#Run tsc recursively on all CONF.references
                               3.0#tsc FILE... will instead be tsc CONF_PATH...
                               3.0#Implies --noEmitOnError
-f|--force                     3.0#With --build, run tsc even on up-to-date sub-CONFs
-d|--dry                       3.0#Dry run
--clean                        3.0#Removes all *.d.ts and tsconfig.tsbuildinfo
-v|--verbose                   3.0#


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      CLI: CROSS-PLATFORM      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--forceConsistentCasingInFileNames#Unless false, paths specified as input|options are case-sensitive

--emitBOM                         #Prepend UTF-8 BOM in output

--newLine STR                     #In output: 'crlf' or 'lf' (def)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       CLI: SOURCE MAPS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--sourceMap                       #Create external source maps
--inlineSourceMap                 #Create inline source map
--declarationMap                  #Generate source maps for --declaration too.

--inlineSources                   #Set SOURCE_MAP.sourcesContent (for external source maps)
--sourceRoot 'DIR'                #SOURCE_MAP.sourceRoot
--mapRoot 'DIR'                   #'DIR' of the source maps (def: same as output file)
                                  #This changes SOURCE_MAP.sources, by assuming 'DIR' is the current directory


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        CLI: DEBUGGING         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--pretty                          #When true (def if TTY), errors have color and show source code lines.
--noErrorTruncation               #Do not truncate some error messages to 100 characters.
--locale LANG                     #LANG used in error messages (def: 'en-us')

--listEmittedFiles                #Prints (at beginning) list of output files, in order.
--listFiles                       #Same but also prints MODULEs and LIBs

--diagnostics                     #Print static analysis info:
                                  #  - number of files|lines|nodes|identifiers|symbols|types
                                  #  - time used for I/O|parse|bind|check|emit
                                  #  - memory used
--extendedDiagnostics             #Same but also show:
                                  #  - cache size
                                  #  - time used for program|transform|comment|print
--generateCpuProfile           3.7#Print CPU profile for debugging

--disableSizeLimit                #Do not crash when total non-*.ts[x] files size >= 20MB


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         PROGRAMMATIC          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


tsserver                          #Like tsc but using a server/client architecture.
                                  #Commands are as JSON on stdin, and result is on stdout.
                                  #Not documented yet (do it when I need to)

LANGUAGE SERVICE PLUGINS ==>      #Programmatic API for changing behavior of TypeScript inside IDE / code editors.
                                  #Features: inline linting, autocompletion, "go to symbol"
                                  #Not documented yet (do it when I need to)
--plugins OBJ                     #Enable a language service plugin
                                  #OBJ: name STR, then custom config properties

PROGRAMMATIC USAGE ==>            #Not documented yet (do it when I need to).
                                  #Should then check TypeScript GitHub wiki: Using-the-Compiler-API, FAQs-for-API-Consumers API-Breaking-Changes

BABEL ==>                         #Transpile (strip TYPEs only) but no type checking
                                  #See Babel doc


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       TYPE DECLARATIONS       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


STRUCTURAL TYPING ==>             #Not nominative, i.e. TYPE is the structure not the name (including for CLASS|INTERFACE).
                                  #Exception: CLASS private|protected fields.
MUTATIONS ==>                     #Types are immutable.
                                  #But a type can express mutations by being a superset of all future types of a variable.

TYPE                              #
UTYPE                             #Union of several TYPE
                                  #never when no members.

type TYPE = TYPE2                 #"Type alias"
                                  #TYPE2 name will be used (not TYPE) in error messages and IDE tools.
                               3.7#TYPE2 can reference TYPE (recursive type).

typeof VAR                        #Returns its TYPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CONDITIONAL          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE | TYPE2                      #Union ("or")
                                  #To simplify, returns TYPE if >= TYPE2 or TYPE2 if >= TYPE.
                                  #Not recursive over ARRs|tuples|OBJs

TYPE extends TYPE2 ? TYPE3 : TYPE4#If TYPE <= TYPE2, resolves to TYPE3, otherwise TYPE4 ("conditional type")
                                  #If TYPE is generic:
                                  #  - at declaration time, TYPE is understood as TYPE & TYPE2 when used inside TYPE3
                                  #  - if instantiated with UTYPE, iterate over each underlying type ("distributive conditional type")
                                  #     - including:
                                  #        - any (not unknown) -> TYPE3 | TYPE4
                                  #        - never -> never
                                  #     - only if UTYPE is a generic type
                                  #        - e.g. not if UTYPE['VAR'] extends ..., since UTYPE is the generic type, not UTYPE['VAR']
                                  #        - i.e. can wrap UTYPE in ARR|OBJ to avoid distribution, e.g. [TYPE] extends [never] ? ...
                                  #TYPE2 can contain "infer T [extends TYPE5]":
                                  #  - generic type that can be used inside TYPE3
                                  #  - inferred by trying to transtype TYPE to TYPE2
                                  #  - sometimes need () for operators precedence
                               4.7#  - "extends TYPE5" can be used

TYPE extends TYPE2 ? never : TYPE #Returns never if <= TYPE2, otherwise TYPE.
Exclude<TYPE, TYPE2>              #If UTYPE, distribute, i.e. difference: remove any TYPE <= TYPE2.

TYPE extends TYPE2 ? TYPE : never #Returns TYPE if <= TYPE2, otherwise never.
Extract<TYPE, TYPE2>              #If UTYPE, distribute, i.e. intersection: keep only any TYPE <= TYPE2.

TYPE & TYPE2                      #Intersection ("and")
                                  #Returns TYPE if <= TYPE2 or TYPE2 if <= TYPE. Otherwise never.
                                  #Recursive over:
                                  #  - ARRs
                                  #     - if no intersection, whole result is `never[]`
                                  #  - tuples
                                  #     - if different length or at least one field has no intersection, whole result is `never`
                                  #  - OBJs
                                  #     - if at least one field has no intersection, whole result is empty OBJ
                                  #     - absent OBJ fields are `unknown`, i.e. use other type


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          BASE TYPES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


unknown                        3.0#TYPE with all possible values, i.e. > any TYPE.
                               3.0#Values can only use operators common to any TYPE, i.e. === !== =
{} | undefined | null          4.8#Same as unknown
                               4.8#With | and &, considered < unknown

never                             #TYPE when no possible value, i.e. < any TYPE.
                                  #Values can only use operators common to any TYPE, i.e. === !== =
                                  #Examples:
                                  #  - union with no members
                                  #  - intersection with nothing in common
                                  #  - elements beyong ARR length
                                  #  - return statement that can't be reached, e.g.:
                                  #     - exception
                                  #     - type guard that can't be true
                                  #     - infinite loop
                                  #     - process exit

any                               #Combine unknown and never:
                                  #  - When transtyping, both < and > any TYPE, i.e. both directions always allowed
                                  #  - With |, > any TYPE (including `unknown`), i.e. result in `any`
                                  #  - With &, < any TYPE (except `never`), i.e. result in `any`
                                  #Prefer unknown|never when possible.
                                  #Values can use any operators of any TYPE.
                                  #Default TYPE when nothing can be inferred.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      UNDEFINED/NULL/VOID      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


undefined                         #
null                              #

{}                             4.8#Includes any type (like unknown) except undefined|null
TYPE & {}                      4.8#Excludes undefined|null
NonNullable<TYPE>                 #Same

--strictNullChecks                #Unless set, transtype TYPE <-- undefined|null always possible.
                                  #Means {} <-- unknown also possible.
--noUncheckedIndexedAccess     4.1#Consider any OBJ.VAR or OBJ[NUM|STR] potentially undefined:
                               4.1#  - if they have either:
                               4.1#     - an index type
                               4.1#        - i.e. including any ARR[NUM]
                               4.1#     - a mapped type, except if KUTYPE is literal
                               4.1#  - unless they are being iterated with "for of", "for in" or ARR.FUNC()
                               4.1#     - but not with normal "for" loop

{ VAR[?][: TYPE],... }            #? allows both:
([...]VAR[?][: TYPE],...) => TYPE2#  - undefined value: {VAR: undefined} FUNC(undefined) [undefined]
[TYPE?,...]                       #     - like TYPE|undefined
                                  #  - missing key|value: {} FUNC() []
                                  #     - unlike TYPE|undefined
                                  #     - only way to allow them
--exactOptionalPropertyTypes   4.4#Make ? allow only missing key|value, not undefined value
                               4.4#  - except on mapped type
                               4.4#Noop unless --strictNullChecks
Partial<OBJ_TYPE>                 #Adds ? on all properties
Required<OBJ_TYPE>                #Removes ? on all properties

void                              #TYPE for "no return value" in FUNCs
                                  #  - i.e. not returning and returning undefined is conceptually different (although the same in JavaScript)
                                  #Distinct from undefined|null TYPEs
                                  #Can only transtype from|to itself
                                  #  - exception: void <-- undefined is allowed


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           PRIMITIVE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


boolean                           #TYPE for any BOOL
number                            #TYPE for any NUM
string                            #TYPE for any STR
bigint                            #TYPE for any BIGINT
symbol                            #TYPE for any SYM (i.e. generic type)

BOOL|NUM|STR|BIGINT               #TYPE for specific value ("literal type"). Must be literal value.
                                  #Transtyping from BOOL <--> boolean (and others) is "narrowing|widening"
                                  #NaN|[-]Infinity cannot be literal.
unique symbol                     #TYPE for a specific SYM (i.e. literal type)
                                  #Child of symbol.
                                  #Implied to be const.
                                  #Well-known SYMs have their own typeof, which is not unique symbol

`...${STR_TYPE}...`            4.1#STR literal type can use template string
                               4.1#If STR_UTYPE, expanded to `...${STR}...` | ...
                               4.1#There is a max limit.

Uppercase<STR_TYPE>            4.1#STR_TYPE2 with different case
Lowercase<STR_TYPE>            4.1#Can be STR_UTYPE
Capitalize<STR_TYPE>           4.1#Noop if not literal type
Uncapitalize<STR_TYPE>         4.1#Works with Unicode characters


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ENUM              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


const enum ENUM                   #TYPE of an enum.
 { NAME [= STR|NUM],... }         #Unlike unions of TYPEs, the key (NAME) differs from the value (STR|NUM).
                                  #Def STR|NUM is previous NUM + 1, or 0 if first one.
                                  #STR|NUM can be an EXPR using () + - ~ * / % << >> >>> & | ^
[ENUM.]NAME                       #Item's VAL:
                                  #  - inlined to STR|NUM
                                  #     - ENUM itself is not transpiled
                                  #  - must be used instead of STR|NUM directly
                                  #Can also be used as TYPE providing:
                                  #  - no STR|NUM is an EXPR
                                  #  - ENUM is the original variable (not an alias)
                                  #`ENUM.` is optional inside `ENUM { ... }` declaration

--preserveConstEnums              #Inline const ENUM as OBJ
                                  #Does not apply to `declare const ENUM`
                                  #Still treated as a const ENUM during typechecking and ENUM.NAME inlining.
                                  #But can be exported, i.e. consumer can treat it as an OBJ, but not module itself.

enum ENUM {...}                   #Like const ENUM but inlined as an OBJ:
                                  #  - i.e. can be used both as a TYPE and an OBJ
                                  #  - ENUM.NAME is inlined as OBJ.NAME instead of NUM|STR
                                  #Can use ENUM[NUM] -> 'TYPE'
                                  #NUM EXPR can also use other operators providing:
                                  #  - next NAME is initialized


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            OBJECT             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


{}                                #TYPE of any OBJ
                                  #Includes:
                                  #  - Any child: FUNC, ARR, new String(STR), REGEXP, etc.
                                  #  - Object.create(null)
                                  #  - Types which can transtype to OBJ: string|number|boolean|symbol|bigint
                                  #     - Transtyped to new String|Number|Boolean|Symbol|BigInt(), i.e. prototype properties
                                  #Excludes null|undefined
object                            #Subtype of {...} that excludes types that can transtype to OBJ

PROTOTYPE CHAIN ==>               #OBJ.__proto__.* are typed when accessing OBJ.*

OBJ_TYPE["constructor"]           #Function, with no specific arguments nor return type, even when using a CLASS

ENUMERABILITY ==>                 #There is no concept of enumerability.

ITERATION ==>                     #OBJ|ARR iteration:
                                  #  - Object.*(), for, for ... in: widens the type to string and|or symbol
                                  #  - for ... of, {...OBJ}, [...ARR]: only removes `readonly`

{ VAR[?][: TYPE],... }            #Like {} but with specific properties
                                  #No missing properties unless '?'
                                  #Delimiters:
                                  #  - can be , ; or newline
                                  #  - can use trailing delimiters

{ [VAR: KUTYPE][: TYPE], ... }    #TYPE of any OBJ[NUM|STR] or OBJ.PROP ("index signature")
                                  #  - including ones already defined in ...
                                  #KUTYPE is the key type among:
                                  #  - NUM: for OBJ[NUM]
                                  #  - STR: for OBJ[STR|NUM]
                               4.4#  - SYM
                                  #  - cannot be literal type
                               4.4#     - except in `...${...}...`, outside of ${...}
                                  #VAR is only for debugging|logging, not type checking
{ [VAR: PropertyKey]: never }     #OBJ always empty
{ _?: never }                     #Same except properties (except "_") are considered unknown, which is better
--noPropertyAccess
 FromIndexSignature            4.2#Only allow OBJ[STR|NUM], not OBJ.PROP, with index types.

ADDITIONAL PROPERTIES ==>         #No additional properties ("excess properties") unless one of:
                                  #  - empty OBJ_TYPE {}
                                  #  - there is an index type
                                  #  - "implicit any index": there is no index type but using:
                                  #     - post-declaration assignment
                                  #     - with OBJ[NUM|STR] (not OBJ.PROP)
                                  #     - not if --noImplicitAny
                                  #  - the whole OBJ is replaced with an OBJ2 VAR (not VAL)
                                  #     - only if not all properties are additional
                                  #  - in `extends` of conditional type or generic constraint


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          OBJECT KEYS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


PropertyKey                       #string|number|symbol
KTYPE                             #TYPE of an OBJ key, i.e. PropertyKey.
KUTYPE                            #UTYPE of KTYPE

keyof TYPE                        #KUTYPE of TYPE properties keys:
                                  #  - OBJ_TYPE -> properties keys (including methods)
                                  #     - including FUNC (which have no properties by default)
                                  #     - ARR -> number + prototype properties
                                  #        - TUPLE: also indices 'NUM', if inside mapped type
                                  #  - BOOL|STR|NUM|BIGINT|SYM -> prototype properties
                                  #  - any|never -> string|number|symbol (any KTYPE)
                                  #  - unknown|null|undefined|void -> never (no properties)

TYPE[KUTYPE]                      #UTYPE of TYPE properties values (including methods)
                                  #KUTYPE must exist on TYPE.
OBJ_TYPE[keyof OBJ_TYPE]          #UTYPE of any property of OBJ_TYPE


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          OBJECT MAP           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


{ [T in KUTYPE [as TYPE3]]: TYPE2}#Expanded to OBJ_TYPE ("mapped type") where:
                                  #  - keys are each KTYPE in KUTYPE
                               4.1#     - can use TYPE3 to map|filter keys
                                  #  - TYPE2|TYPE3 can refer to T (current KTYPE, before TYPE3 mapping)
                                  #Cannot define other properties directly:
                                  #  - but can do it through ... & OBJ_TYPE2
                                  #Can use ? on key like other OBJ_TYPEs
{ [[-|+]readonly]              3.4#Can also use readonly on key
  [... in ...][[-|+]?]: ...}      #  - ? and readonly can each be prefixed with -|+ to mean "remove|add"
                                  #If KUTYPE is only "keyof TYPE", TYPE's readonly|? are preserved
                                  #  - otherwise, readonly is lost, and ? converts TYPE2 to TYPE2 | undefined instead

Record<KUTYPE, TYPE>              #Same as { [VAR in KUTYPE]: TYPE }

Pick<OBJ_TYPE, KUTYPE>            #Only keep KUTYPE properties
                                  #Same as { [VAR in KUTYPE]: OBJ_TYPE[VAR] }
Omit<OBJ_TYPE, KUTYPE>         3.5#Inverse
                                  #Same as Pick<OBJ_TYPE, Exclude<keyof OBJ_TYPE, KUTYPE>>


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           INTERFACE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


interface INTERFACE { ... }       #Like type INTERFACE = { ... } but preferred.
                                  #Differences:
                                  #  - not an expression, e.g. cannot use & | etc.
                                  #  - INTERFACE name is used (instead of literal OBJ) in error messages and IDE tools
                                  #  - while both `type` and `interface` do not have index types unless specified, only
                                  #    `type` can transtype to another one which has an index type

interface INTERFACE               #Inherit|mixin members (types) from OBJ_TYPE
 [extends OBJ_TYPE,...] { ... }   #  - must be a VAR, not VAL
                                  #  - when extending from CLASS: extend from CLASS instance, not from typeof CLASS, but can use:
                                  #      type TYPE = typeof CLASS
                                  #      interface INTERFACE extends TYPE, CLASS {}

INTERFACE MERGING ==>             #If INTERFACE declared several times, merge them.
                                  #Properties can have same name but must have same TYPE (i.e. unchanged)
                                  #  - except FUNCs: will be overloaded, in that order:
                                  #     - if single STR literal argument, always first
                                  #     - last declared before first declared


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           FUNCTION            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Function                          #TYPE of any FUNC
                                  #Subtype of `object`
CallableFunction               3.2#TYPE of any `Function` not callable with `new`
NewableFunction                3.2#TYPE of any `Function` callable with `new`
--strictBindCallApply          3.2#Make FUNC_TYPEs inherit from CallableFunction|NewableFunction instead of Function

{                                 #Subtype of CallableFunction with specific argument, return value and object properties.
  [new]([...]VAR[?][: TYPE])      #If "new", subtype of NewableFunction instead.
   [: TYPE2],                     #No missing arguments unless '?'
  ...                             #  - which is implied when `= VAL` (default value) used
}                                 #No additional arguments:
                                  #  - unless variadic ...VAR[: TYPE] (always optional)
                                  #     - must be last argument
                                  #        - but can use TUPLEs, e.g. ...[...ARR_TYPE, ...]
                                  #Def TYPE:
                                  #  - if at same moment as declaration and ("contextual typing"):
                                  #     - passed as callback: callback type
                                  #     - assigned to a variable: variable type
                                  #     - called: argument type
                                  #  - if `= VAL` (default value): typeof VAL
                                  #  - otherwise: any
                                  #Def TYPE2:
                                  #  - use inferred return value in body as TYPE
                                  #  - if several return statements, use union
                                  #VAR names are not significant.
                                  #Object properties:
                                  #  - FUNC[KUTYPE] retrieves FUNC properties, not FUNC itself
                                  #  - `keyof` iterates on FUNC properties, not FUNC itself
                                  #     - including when iterating indirectly, e.g. with Omit<...>, etc.
                                  #  - FUNC & VAL includes both FUNC properties and FUNC itself
                                  #  - Can omit FUNC properties using:
                                  #      type GetFunction<T> = T extends abstract (...args: infer U) => infer V ? (...args: U) => V : never
                                  #Function body is only checked against argument TYPEs during declaration statement, not when:
                                  #  - FUNC(...VAL) is called
                                  #  - FUNC is transtyped after declaration
[new] (...) => TYPE2              #Same as { [new](...)[: TYPE2] } without any additional properties.

{ [get|set] FUNC(...)[: TYPE2] }  #OBJ.FUNC: shortcut for { FUNC: (...) => TYPE2 }
                               4.3#Only syntax for getters|setters

function FUNC(...): ...           #Function overloading.
...                               #Each FUNC must have same name, but different type
function FUNC0(...): ... {...}    #FUNCs have no implementation, but FUNC0 does
                                  #The type of the first matching FUNC is used
                                  #  - excluding FUNC0, i.e. error if FUNC0 matches but no FUNC does
                                  #FUNC0 must be >= each FUNC
                                  #In essence, it is similar to using generic type on FUNC0 where:
                                  #  - arguments type is union of each FUNC's arguments type
                                  #  - return type is conditional type, resolving to retutn type of first FUNC with matching argument
class {
  FUNC(...): ...;
  ...
  FUNC0(...): ... {...}
}                                 #Same for class methods
FUNC & FUNC2                      #When called, like function overloading, but without needing to declare FUNC0:
                                  #  - matches first FUNC based on argument types
                                  #  - return type of matching FUNC
                                  #In conditional types, use last matching FUNC only
                                  #  - e.g. Parameters<> and ReturnType<> both return last FUNC's
FUNC | FUNC2                      #When called:
                                  #  - & on argument types, i.e. must match every FUNC
                                  #  - | on return types, i.e. union of every FUNC return value
                                  #In conditional types, behave like any union
                                  #  - e.g. Parameters<> and ReturnType<> both return union

FUNC_TYPE["prototype"]            #Always set, defaulting to:
                                  #  - CLASS for class
                                  #     - if generic, use `any` for generic types
                                  #  - `any` otherwise

this                              #Can be:
                                  #  - VAR (argument): must be first parameter
                                  #     - by convention, type as `void` if want to declare `this` is not used
                                  #  - TYPE2 (return value)
--noImplicitThis                  #Error when using `this` with type ANY.
                                  #I.e. caller did FUNC() instead of OBJ.FUNC() or FUNC.call|bind(OBJ)
ThisType<TYPE>                    #OBJ_TYPE where all OBJ.FUNC() use TYPE as `this`
                                  #Usually used as intersection.
                                  #Only works when --noImplicitThis is used
                                  #Not needed for CLASSes (which guess `this`) or single FUNC (which can use `this` parameter)
ThisParameterType<FUNC_TYPE>      #Retrieve `this` type. `unknown` if no explicit one.
                                  #Same as: FUNC_TYPE extends (this: infer T, ...args: never) => unknown ? T : unknown
OmitThisParameter<FUNC_TYPE>      #Return FUNC_TYPE but with `this` type being `unknown`

Parameters<FUNC_TYPE>             #Parameters [TYPE,...] (tuple). Must be a (...) => ...
ReturnType<FUNC_TYPE>             #Return value TYPE2. Must be a (...) => ...
ConstructorParameters<FUNC_TYPE>  #Same as Parameters<> but for a new (...) => ...
InstanceType<FUNC_TYPE>           #Same as ReturnType<> but for a new (...) => ...


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             CLASS             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


class CLASS
  <...>                           #Generic types can be used by instance properties, but not static ones (including prototype)
  [extends CLASS2]                #Same as JavaScript, i.e. inherit|mixin members (types+values) from CLASS2
                                  #CLASS2 cannot be a generic type itself (T), but can use them (CLASS2<T>)
                                  #  - except when class is created inside a FUNC, as opposed to top level scope
  [implements OBJ_TYPE,...]       #Must implement members of OBJ_TYPE,...
{
  ...                             #Can use the same syntax as OBJ_TYPEs (e.g. { VAR[?]: TYPE })
                                  #Generic types cannot be used in static properties.
  constructor(...)                #Constructor return type is always CLASS, i.e. must not be specified.
  constructor                     #When QUAL specified, shortcut to set this.VAR = VAL ("parameter properties")
   (QUAL VAR[?][: TYPE],...)      #QUAL is public|protected|private|readonly and used like { QUAL VAR }
  [public|protected|private] VAR  #Fields visibility is different than JavaScript:
                                  #  - VAR -> [public] VAR
                                  #  - #VAR -> private VAR
                                  #     - should prefer #VAR as it's standard JavaScript and is enforced runtime too
                                  #  - not possible -> protected VAR
                                  #     - like private VAR but child CLASS can access it too
  override FUNC(...)           4.3#Requires that parent class also defines FUNC
}
--noImplicitOverride           4.3#Requires using "override" if parent CLASS defines FUNC

typeof CLASS|CONSTRUCTOR_FUNC     #FUNC_TYPE of the constructor.
                                  #Also includes static properties, including prototype.
                                  #Like any `typeof`, argument must be VAR, not VAL
CLASS|CONSTRUCTOR_FUNC            #OBJ_TYPE of the instance.
                                  #As opposed to INTERFACE, it can also be interpreted as a runtime value.
                                  #Includes:
                                  #  - methods
                                  #  - non-initialized properties|methods
                                  #  - protected|private properties|methods
                                  #     - if any, can only match CLASS instances

interface CLASS_INTERFACE {       #Similar to class CLASS except:
  new(...): INSTANCE              #  - constructor -> new(...)
  prototype: INSTANCE             #  - static properties -> ...staticProperties
  ...staticProperties             #  - non-static properties -> INSTANCE
}                                 #  - extends CLASS2:
                                  #     - must merge both instances as INSTANCE (prototype and InstanceType<new(...)>)
                                  #     - merge both static properties
                                  #     - while keeping new(...)
                                  #     - using & and Omit<...>
                                  #CLASS_INTERFACE is constructor's type, not instance type:
                                  #  - typeof CLASS -> CLASS_INTERFACE
                                  #  - CLASS -> InstanceType<CLASS_INTERFACE>
                                  #Static properties (including prototype) can use generic types.

abstract CLASS ... {
  abstract VAR[: TYPE]
  abstract FUNC(...)[: TYPE]      #CLASS that cannot be instantiated (but children can)
}                                 #FUNC with no body, that must be reimplemented by children
abstract new (...) ...         4.2#Like new (...) ... type, except can specify abstract CLASSes

--useDefineForClassFields      3.7#When --target es2021 or lower, how to transpile class fields:
                               3.7#  - true:
                               3.7#     - Object.defineProperty() in constructor
                               3.7#     - if not initialized, value is undefined
                               3.7#     - mimicks standard behavior, i.e. recommended
                               3.7#  - false (def)
                               3.7#     - this.VAR = VAL in constructor
                               3.7#     - if not initialized, ignored


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ARRAY             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE[]
Array<TYPE>                       #Type of ARR of same TYPEs
never[]                           #Empty ARR. Prefer empty tuple instead, as error message is better.

[TYPE[?][: VAR],...]              #Type of ARR of different TYPEs ("tuple").
                                  #Each TYPE is only for that index.
                               4.0#If named (VAR):
                               4.0#  - name only for description, not used for type checking
                               5.2#  - can mix named and unnamed
                               3.0#No missing value unless '?'
                                  #No additional values.
                                  #To iterate, can use conditional types: TUPLE extends [VAL, ...TUPLE2] ? ... : ...
                                  #To infer a generic FUNC ARR argument TYPE (variadic or not) as a tuple, can use (arg: [..TYPE])
[]                                #Empty tuple

ARR_TYPE[number]                  #UTYPE of any ARR element

[..., ...ARR_TYPE, ...]        3.0#Spreads an ARR_TYPE.
                               3.0#Can be at end
                               4.2#or beginning|middle
                               3.0#Can be done only once per array
                               3.0#Cannot be followed by a "TYPE?"
                               3.0#Can also be used in destructuring.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             ERROR             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


[Eval|...]Error                   #*ERROR
[Eval|...]ErrorConstructor        #Both a NewableFunction and a CallableFunction
ErrorOptions                      #OBJ of new Error(STR, OBJ)

try { ... } catch (error) { ... } #By default, error is "any"
--useUnknownInCatchVariables   4.4#error in catch clause "unknown" instead


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         CORE OBJECTS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


Object|Number|String|Boolean|     #new Object|Number...()
 Symbol|BigInt                    #Should use object|number|string|boolean|symbol|bigint instead

RegExp                            #
Date                              #

TemplateStringsArray              #STR_ARR of FUNC`...` with FUNC(STR_ARR, ...)

Promise<T>                        #PROMISE either:
                                  #  - resolving T
                                  #     - if 'never', means cannot resolve
                                  #  - rejecting any
PromiseLike<T>                    #Same but for PROMISABLE
Awaited<T>                     4.5#Like await T, i.e. inverse of Promise<T>.
                               4.5#If T is PROMISABLE, returns awaited type, otherwise return T as is

[Readonly][Weak]Map
 <KEY_TYPE, VALUE_TYPE>           #
[Readonly][Weak]Set<VALUE_TYPE>   #


IteratorYieldResult<T>            #ITERATOR.next() non-final return value, i.e. OBJ: done false|undefined, value T
IteratorReturnResult<T>           #ITERATOR.next() final return value, i.e. OBJ: done true, value T
IteratorResult<T, U>              #ITERATOR.next() return value, i.e. OBJ: done BOOL|undefined, value T (non-final) or U (final, def: any)
[Async]Iterator<T, U, V>          #ITERATOR with IteratorResult<T, U>, next(V) (def: undefined), return(U), throw(any)
[Async]Iterable<T>                #ITERABLE with Iterator<T>
[Async]IterableIterator<T>        #ITERABLETOR with Iterator<T>
[Async]GeneratorFunction          #function*(){}
[Async]Generator<T, U, V>         #ITERABLETOR returned by (function*(){})
                                  #Doing V = yield T (def V|T: unknown) and return U (def: any)

ArrayLike<T>                      #ARRAYLIKE
ArrayBuffer                       #ARRBUFFER
DataView                          #DATAVIEW
ArrayBufferView                   #DATAVIEW|TYPEDARR
ArrayBufferLike                   #ARRBUFFER|TYPEDARR
Uint8ClampedArray                 #
[U]Int8|16|32Array                #
Float32|64Array                   #
Big[U]Int64Array                  #
SharedArrayBuffer                 #

PropertyDescriptor                #Object.getOwnPropertyDescriptor() return OBJ
PropertyDescriptorMap             #Object.getOwnPropertyDescriptors() return OBJ_OBJ

Proxy                             #PROXY
ProxyConstructor                  #
ProxyHandler<T>                   #OBJ of new Proxy(T, OBJ)

ImportMeta                        #import.meta
ImportCallOptions                 #OBJ of import(STR, OBJ)
ImportAssertions                  #OBJ of import(STR, { assert: OBJ })

ClassDecorator<T>                 #@DFUNC class ..., with class T
MethodDecorator<T>                #@DFUNC [get|set] FUNC, with T being get|set value
PropertyDecorator                 #@DFUNC VAR = EXPR
ParameterDecorator                #@DFUNC VAR = EXPR



                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           READONLY            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


<const>VAL                     3.4#If STR|NUM|BOOL:
VAL as const                   3.4#  - cannot be re-assigned, like using `const`
                               3.4#  - type inferred as literal type, i.e. specific STR|NUM|BOOL instead of any string|number|boolean
                               3.4#If OBJ|ARR: add Readonly<typeof VAL>
                               3.4#VAL must be a literal STR|NUM|BOOL|ARR|OBJ

{ readonly ...[: TYPE],... }      #Shallow immutability (like `const`) of OBJ properties.
                                  #Should be specified whenever possible.
class ...
  { readonly ...[: TYPE],... }    #Same except field is mutable in constructor()
Readonly<OBJ_TYPE>                #`readonly` to all OBJ properties.
                                  #Does not apply to the OBJ itself.

readonly TYPE[]
readonly [TYPE,...]            3.4#
ReadonlyArray<TYPE>               #Same for all ARR members.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            GENERIC            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


type TYPE<T...> = ...             #Declaring a generic TYPE
class CLASS<T...> {}              #<T...> is <[const] [VARIANCE] T [extends TYPE3,...][= TYPE4],...>
interface INTERFACE<T,...> {}     #Type of T is TYPE2, from TYPE<TYPE2> instantiation:
                                  #  - TYPE2 must be <= TYPE3 ("generic constraint")
                                  #     - def TYPE3: unknown
                                  #     - TYPE3,... means TYPE3 & ...
                                  #  - def TYPE2: TYPE4
                                  #  - if no TYPE2: error
                                  #There can be several <T,...>
                                  #  - each can refer to each other, in any order
                                  #Unlike conditional types, UTYPEs are not distributed.
                               5.0#If "const", use `VAL as const` when inferring T from a VAL
                               4.7#VARIANCE:
                               4.7#  - whether TYPE2 is used:
                               4.7#     - "out": in a FUNC return type, i.e. transtyping should be variant
                               4.7#     - "in": in a FUNC argument type, or not in a FUNC, i.e. contravariant
                               4.7#     - "in out": both, i.e. invariant
                               4.7#  - by def, automatically guessed, i.e. only useful:
                               4.7#     - to speed up type checking
                               4.7#     - for documentation
                               4.7#     - to be strict, e.g. error type check when using a TYPE2 as a FUNC return type when it was not intended as such
TYPE<TYPE2,...>                   #Generic TYPE2 instantiation

[new] <T...>(...) => ...          #Generic FUNC_TYPEs:
{ FUNC<T...>(...): ... }          #  - as opposed to: type TYPE<T...> = (...) => ...
{ [new] <T...>(...): ... }        #TYPE2 is:
                                  #  - when calling FUNC[<TYPE2,...>](...):
                                  #     - def TYPE2: inferred from arguments
                                  #     - if argument missing: inferred from return value
                                  #     - if cannot infer: use TYPE4
                                  #     - if no TYPE4: use TYPE3
                                  #  - when using FUNC type without calling it:
                                  #     - defaults to TYPE3
                                  #     - e.g. when passed to another generic type
                                  #        - including through ReturnType|Parameters<FUNC_TYPE>
                                  #Can be on `new ...`, but not on CLASS `constructor()`
                                  #  - when CLASS extends from generic `new ...`, it instantiates its generic types using TYPE4
[new] FUNC[<TYPE2,...>](...)      #Generic TYPE2 instantiation during FUNC call.
                                  #As opposed to TYPE<TYPE2,...>:
                                  #  - FUNC is value, not type
                                  #  - TYPE2 optional

typeof VAR[<T...>]             4.7#With `typeof` on a VAR that is generic (CLASS|FUNC), TYPE2 is optional and defaults to TYPE3 (not TYPE4)
                               4.7#("instantiation expression")


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        TYPE ASSERTIONS        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


QUAL VAR[: TYPE] = VAL            #Type declaration
                                  #Error unless TYPE >= typeof VAL
                                  #VAR type is TYPE.
                                  #Def TYPE is typeof VAL:
                                  #  - if:
                                  #     - const|no declaration or `readonly` value: literal TYPE
                                  #     - var|let declaration: generic TYPE, i.e. widens it
                                  #  - OBJ|ARR: recursive
                                  #  - ARR:
                                  #     - union of infered types
                                  #     - if empty: use never[]
function [FUNC][<T,...>]
 (VAR[?]: TYPE,...): TYPE2 {...}
[<T,...>]
 (VAR[?]: TYPE,...): TYPE2 => ...
[class ...] {
  FUNC[<T,...>]
   (VAR[?]: TYPE,...): TYPE2 {}
}                                 #Same as QUAL VAR: FUNC_TYPE = FUNC

VAL satisfies TYPE             4.9#Check the TYPE of VAL (like type declaration), but does not change it (unlike it)

<TYPE>VAL                         #Type assertion of a VAL, i.e. VAL's type is TYPE
VAL as TYPE                       #Works if TYPE <=> typeof VAL, error otherwise
                                  #  - VAL as unknown as TYPE: allows bypassing it
                                  #Prefer the second syntax as JSX do not allow the first one
                                  #Has stronger operator precedence than everything except () .VAR [INDEX] new (...ARGS) ++ --

VAL!                              #VAL as Exclude<typeof VAL, undefined|null>


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          UNITIALIZED          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


var|let VAR[: TYPE]               #Unitialized VARs.
var|let VAR!: TYPE                #VAR's type is TYPE (def: any)
class ... { VAR!: TYPE; ... }     #If TYPE does not allow undefined (which excludes any):
                                  #  - VAR cannot be referenced until assigned
                                  #     - including using any operators (including VAR.VAR2, === or rvalue =)
                                  #  - unless ! is used
                                  #     - useful when VAR is initialized but it cannot be guessed compile-time, e.g. when done in different scope.
                                  #If TYPE any, a new TYPE won't be inferred when a new value is assigned:
                                  #  - unless --noImplicitAny
                                  #  - including for elements of an empty ARR (whose default type is any[])

--strictPropertyInitialization    #Do not allow class properties:
                                  #  - whose TYPE does not include undefined
                                  #  - and who is not initialized (including in constructor)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TRANSTYPING          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DOCUMENTATION NOTATION ==>        #
TYPE == TYPE2                     #TYPE equal to TYPE2
TYPE < TYPE2                      #TYPE covariant to TYPE2
TYPE > TYPE2                      #TYPE contravariant to TYPE2
TYPE <= TYPE2
TYPE >= TYPE2
TYPE <=> TYPE2                    #Combinations
TYPE !== TYPE2
TYPE !>  TYPE2
TYPE !<  TYPE2
TYPE !>= TYPE2
TYPE !<= TYPE2
TYPE !<=> TYPE2                   #Negations

TRANSTYPING RULES ==>             #For TYPE2 <-- TYPE, TYPE2 must >= TYPE
                                  #Recursive on ARRs|tuples|OBJs
                                  #For ARRs:
                                  #  - readonly TYPE[] > TYPE[]
                                  #For tuples:
                                  #  - [...] !== [..., TYPE] (different lengths)
                                  #  - [..., TYPE?] > [..., TYPE]
                                  #  - [..., TYPE?] > [...]
                                  #  - readonly [...] > [...]
                                  #For OBJs:
                                  #  - { ... } > { ..., VAR: TYPE } (additional properties)
                                  #  - { ..., VAR?: TYPE } > { ..., VAR: TYPE }
                                  #  - { ..., VAR?: TYPE } <=> { ... }
                                  #  - { ..., readonly VAR: TYPE } <=> { ..., VAR: TYPE }
                                  #For FUNCs:
                                  #  - arguments:
                                  #     - (..., TYPE) => ... > (...) => ...
                                  #     (--strictFunctionTypes)
                                  #     - (SUBTYPE) => ... > (TYPE) => ...
                                  #     - (VAR: TYPE) => ... > (VAR?: TYPE) => ...
                                  #     (no --strictFunctionTypes)
                                  #     - (SUBTYPE) => ... <=> (TYPE) => ...
                                  #     - (VAR: TYPE) => ... <=> (VAR?: TYPE) => ...
                                  #  - return value:
                                  #     - (...) => TYPE > (...) => SUBTYPE
                                  #        - including type guards
                                  #For CLASS:
                                  #  - extends: PARENT >= CHILD (constructors are ignored)
                                  #  - abstract CLASS ... > CLASS ...

--strictFunctionTypes             #Always false for:
                                  #  { FUNC(...): TYPE2 }
                                  #  { constructor(...) }
                                  #But applies to:
                                  #  { FUNC: [new] (...) => TYPE2 }
                                  #  { [new](...): TYPE2 }


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        TYPE INFERENCE         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


// @ts-check                      #Use type checking on current file
// @ts-nocheck                 3.7#Inverse
// @ts-ignore                     #Ignore type checking on next line.
                                  #Works in *.js too (if --checkJs)
// @ts-expect-error            3.9#Ignore type checking error on next line, but report if no type checking error
                               3.9#Works in *.js too (if --checkJs)

TYPE INFERENCE ==>                #Determining default type of untyped values.

--noImplicitAny                   #Do not allow untyped values (type could not be inferred).
                                  #Explicit any type assertion is allowed.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          TYPE GUARDS          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


TYPE GUARDS ==>                   #When:
                                  #  - using: if|else, switch, ternary (? :), chaining (&& ||)
                                  #  - with: typeof VAL, instanceof VAL, === !== == != VAL, Boolean() (implicit|explicit), in
                                  #  - and only: ! && ||
                               4.4#Even when expression is not directly inside if|else|... but declared previously
                               4.4#  - i.e. is a variable instead of a literal value
                               4.4#  - providing it is const|readonly
                                  #Then inside the blocks:
                                  #  - ARG will be transtyped to the right TYPE
                                  #  - including return value TYPE if has `return` statement
OBJ instanceof FUNC               #Narrows to OBJ & either:
                                  #  - FUNC.prototype (if defined)
                                  #  - InstanceType<FUNC>

TAGGED UNION ==>                  #When type guarding with OBJ.VAR ("discriminant"):
                                  #  - with operators: === !== == != Boolean()
                                  #  - then it type guards OBJ as well
                               4.4#Even when OBJ.VAR is assigned to a VAR2 (as opposed to being accessed directly)
                               4.6#or when destructuring VAR from OBJ
                                  #For example:
                                  #  type A = { kind: 'A' }
                                  #  type B = { kind: 'B' }
                                  #  (obj: A|B) => obj.kind === 'A' && obj satisfies A

(...) => ARG is TYPE              #FUNC must:
                                  #  - take ARG as one of its parameters
                                  #  - return BOOL determining whether argument VAR belongs to TYPE
                                  #Means FUNC(...) can be used as a type guard ("user-defined type guards"), i.e.:
                                  #  - if BOOL can be determined during type check
                                  #  - then ARG will be transtyped to TYPE
                                  #  - inside block when using FUNC(...)
(...) => asserts VAR [is TYPE] 3.7#Same except FUNC:
                               3.7#  - throws when VAR is not TYPE instead of returning false
                               3.7#  - returns void otherwise instead of returning true
                               3.7#"Assertion function"
                               3.7#Does not works with functions expressions (const FUNC = ...),
                               3.7#only with function declarations (function FUNC(...) ...).
                               3.7#Def TYPE: true


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:           NAMESPACE           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


namespace NAMESPACE { ... }       #Scope { ... } under NAMESPACE (which is transpiled to an anonymous function).
                                  #NAMESPACE can be used as an OBJ value.
                                  #Meant:
                                  #  - for pre-ESM modules (global scope, UMD)
                                  #  - as a "trick" to export TYPEs with CommonJS|AMD|UMD default `module.exports` (see below)
export ...                        #Inside NAMESPACE: assign to NAMESPACE.VAR, i.e. allow using outside of NAMESPACE
                                  #Same syntax as `declare ...`
                                  #Not same as ESM `export` keyword.

import VAR2 = NAMESPACE[.VARR]    #Like const VAR2 = NAMESPACE.VARR except also works if NAMESPACE.VARR is a TYPE ("namespace alias")
                                  #Not same as ESM `import` keyword.

NAMESPACE MERGING ==>             #If NAMESPACE declared several times, merge exported VARs.
                                  #Non-exported VARs are not merged.
                                  #Exported VARs must not have same names.
NAMESPACE MERGING OTHERS ==>      #If another declaration|TYPE (not implementation) has same name, merge it:
                                  #  - i.e. can access NAMESPACE.* with VAR.*
                                  #Both|neither must use export
                                  #For CLASS or with Babel, NAMESPACE must de declared after.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         AMBIENT FILES         :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


declare QUAL VAR ...
declare function ...
declare ... enum ...              #Declaration|TYPEs only, not implementation ("ambient declaration"):
declare ... class ...             #  - VAR: cannot be initialized
declare CLASS_PROP: ...           #     - except with literal type
declare namespace ...             #  - FUNC: no body
declare type ...                  #  - enum|class|classProp|namespace: only TYPE not value
declare interface ...             #  - type|interface: noop

export declare ...                #ESM named `export`
declare ...
export default VAR                #ESM default `export`

*.d.ts                            #"Ambient file". File where every statement is declaration|TYPE.
                                  #Should be sibling to each build file for easy resolution|discovery.
                                  #Should be treated as a production dependency (or peer dependency), not dev dependency.
                                  #Goal:
                                  #  - source + package in JavaScript, but want to export TYPEs to TypeScript consumers
                                  #  - source in TypeScript but package in JavaScript. Reasons:
                                  #     - separation of concerns: responsability of each package to check its types
                                  #     - performance: consumers don't need to type check
                                  #     - compatibility: consumer might use different TypeScript version or options

-d|--declaration                  #Generate *.d.ts ambient files:
                                  #  - type inference on import|export statements
                                  #  - non assigned import statements are kept
                                  #  - keep comments (including JSDoc)
--declarationDir DIR              #Def: same directory as file
--emitDeclarationOnly             #Like --declaration + --noEmit
--stripInternal                   #--declaration will ignore statements preceded with /** @internal */

--skipLibCheck                    #Skip type checking of ambient files themselves (not the files that use them)
                                  #Meant to speed up compile speed. Not recommended.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      MODULES: RESOLUTION      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


FILE EXTENSIONS ==>               #import 'PATH' must not include .EXT if .ts[x]|.d.ts
                                  #import 'PATH|MODULE' tries several times using (in order) .ts[x], .d.ts, (if --allowJs) .js[x]
                                  #  - including PACKAGE.main, i.e. 'FILE.js' will search for 'FILE.ts[x]|d.ts'

--moduleResolution STR            #"MODULE|PATH" resolution:
                               5.0#  - 'bundler'
                               5.0#     - like 'nodenext' but:
                               5.0#        - can use index.js and extensionless imports even in an ESM file
                               5.0#        - can use --allowImportingTsExtensions
                               5.0#     - meant for bundlers like Vite, esbuild, swc, Webpack or Parcel
                               5.0#     - requires --module=esnext
                               4.7#  - 'nodenext'
                               4.7#     - like Node: node_modules, PACKAGE.main, index.js
                               4.7#     - must use PACKAGE.exports.types[@SEMVER] instead of PACKAGE.types|typings|typesVersions
                               4.7#     - pure ES modules
                               5.2#     - required if --module nodenext
                               4.7#  - 'node16':
                               4.7#     - same as nodenext but with Node 16
                               4.7#     - def if --module node16
                               5.2#     - requires --module node16
                                  #  - 'node' (def if --module commonjs): same as 'node*' but CommonJS
                                  #  - 'classic' (def otherwise):
                                  #     - "PATH": as is
                                  #     - "MODULE": search ".[/../...]/MODULE"
import ... assert ...          4.5#Transpile but left as is
--resolveJsonModules              #With --moduleResolution 'node*', allows import '*.json'
                                  #assert { type: 'json' } also requires --module esnext|nodenext
PACKAGE.types|typings             #Same as PACKAGE.main|exports but higher priority and TypeScript-specific
                                  #Def: sibling *.d.ts
PACKAGE.typesVersions.SEMVER   3.1#OBJ:
                               3.1#  - like PACKAGE.types but only if TypeScript version matches SEMVER
                               3.1#  - OBJ has same syntax as --paths
                               3.1#  - uses first matching SEMVER according to OBJ properties order, i.e. should start with most specific
                               3.1#<3.1 fallbacks to PACKAGE.types|typings
PACKAGE.exports|imports
 .types[@SEMVER]               4.7#CONDITION "types[@SEMVER]" is TypeScript-specific
--resolvePackageJsonExports    5.0#Force using PACKAGE.exports|imports
 |Imports                      5.0#Def: true with --moduleResolution bundler|node16|nodenext
--customConditions             5.0#Additional 'CONDITION'_ARR for PACKAGE.exports|imports.CONDITION
--traceResolution                 #Verbose|debug for --moduleResolution

--moduleDetection STR          4.7#Detection on whether a file is a ES module or a script:
                               4.7#  - "legacy": if file has import|export statement
                               4.7#  - "auto" (def): like "legacy", but also checks PACKAGE.type, providing --module node* used
                               4.7#  - "force": always ES module
--moduleSuffixes ".EXT"_ARR    4.7#List of "EXT" to try to append to import statements when looking them up.
                               4.7#Def: [""]

--allowImportingTsExtensions   5.0#Allow import statements to end with '.[m]ts[x]'
                               5.0#Only with moduleResolution 'bundler'
--allowArbitraryExtensions     5.0#Do not fail on import statements with unrecognized file extensions

--baseUrl URL|PATH                #Base URL|PATH for any "MODULE"
--paths OBJ                       #{ MODULE: "URL|PATH"_ARR, ... } for each "MODULE"
                                  #If several, tried in order.
                                  #If MODULE is "*":
                                  #  - for any "MODULE"
                                  #  - can add "*" in "URL|PATH", which will be replaced by each "MODULE"
                                  #Prefer using PACKAGE.imports.* instead
--rootDirs DIR_ARR                #When importing inside one of the "DIR"s, other "DIR"s are tried as well.
                                  #Goals:
                                  #  - when merging several source "DIR" into single "DIR2" during build
                                  #  - when "DIR" are dynamically generated and might not exist

--preserveSymlinks                #Like node --preserve-symlinks


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        MODULES: OUTPUT        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--module STR                      #Module system for output:
                               4.7#  - node16|nodenext: Node.js 16|latest
                               4.7#     - if pure ESM, same as es2020|esnext
                               4.7#     - otherwise, same as commonjs
                                  #  - esnext: ES modules
                               4.5#  - es2020|2022: ES modules
                                  #  - es2015|es6 (def): same but without dynamic import() and import.meta
                                  #  - commonjs (def if --target 'es3|es5'): CommonJS, no dynamic import()
                                  #  - amd
                                  #  - umd
                                  #  - system: SystemJS
                                  #  - none: global variables (cannot use import|export)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         MODULES: ESM          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


ES MODULES ==>                    #Must be used for sources and imported 'PATH', but optional for imported 'MODULE'

import|export type ...         3.8#Same as import|export ... except only works for TYPEs
                               3.8#  - e.g. CLASS|FUNC|ENUM are only meant as TYPEs not VAL
                               3.8#Preferred when possible as it can otherwise be ambiguous whether TYPE|VAL is imported
import { [type] VAR, ... }     4.5#Other syntax. Allows mixing importing TYPEs and VALs
--importsNotUsedAsValues STR      #How to transpile import when cannot detect whether TYPE|VAL:
                                  #  - 'remove' (def)
                                  #     - problem if imported file has side effect, which would be lost
                                  #  - 'preserve'
                                  #     - problem if was TYPE, since types cannot be executed runtime
                                  #  - 'error'
                                  #     - strictest, recommended
                                  #If detected as TYPE only (including import type ...), always removed.
--preserveValueImports         4.5#Preverse any import VAL (not TYPE) even if appears unused
--verbatimModuleSyntax         5.0#When transpiling, keep any `import ...`, and omit any `import type ...`
                               5.0#Implies --isolatedModules

import(...).VAR                   #Same as import type { VAR } from '...' except as an expression (not a statement)

export import VAR = ...           #Obsolete TypeScript-specific syntax

/// <reference ...
 resolution-mode="STR2" />     4.7#Force resolving as STR2 "import" (ES module) or "require" (CommonJS)
import type ... from 'STR' assert
 { "resolution-mode": STR2 }
import(STR, { assert:
 { "resolution-mode": STR2 }).VAR
                               4.7#Same

--alwaysStrict                    #If 'use strict' missing:
                                  #  - implied during type checking
                                  #  - prepended in transpiling


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       MODULES: COMMONJS       :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


export = VAL|TYPE                 #exporting|importing default `module.exports` of CommonJS|AMD|UMD
import VAR = require(STR)         #  - as opposed to `module.exports.default` / `export default`
                                  #Require --module commonjs|amd|umd|node*
                               4.7#With --node*, this is transpiled to `module.createRequire(import.meta.url)(STR)`
                                  #To export default `module.exports` but also export TYPEs:
                                  #  - should define TYPEs in a NAMESPACE
                                  #  - then use NAMESPACE merging, i.e. name it the same as the `module.exports` variable (even if not an OBJ)

--esModuleInterop                 #Check __esModule (like Babel) when using both:
                                  #  - ESM default import or import *
                                  #  - --module commonjs|amd|umd
                                  #I.e. when using ESM default import or import * with CommonJS|AMD|UMD default export
                                  #  - should prefer using "import VAL = require(STR)" instead, providing --module commonjs|amd|umd used
                                  #ESM exports always set __esModule true regardless, except when using --module es*
--allowSyntheticDefaultImports    #Allow (do not report) ESM default import of a CommonJS|AMD|UMD default `module.exports`
                                  #Def: true if --esModuleInterop or --module system

require(STR)                      #Dynamic CommonJS import
                                  #Should prefer dynamic import() instead.
                                  #Return value is untyped (any), i.e. must transtype.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         MODULES: UMD          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


export as namespace NAME          #Declare NAME of global variable used in UMD declaration.
                                  #I.e. any exported variable VAR is also available as global NAME.VAR
                                  #The exporting file must:
                                  #  - be named *.d.ts
                                  #  - use ESM, i.e. use another import|export statement
--allowUmdGlobalAccess         3.5#If false (def), can only import an `export as namespace NAME` if importing file:
                               3.5#  - uses <reference/>
                               3.5#  - does not use ESM, i.e. no other import|export statements


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:         MODULES: AMD          :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


/// <amd-module name="NAME"/>     #With --module amd, NAME of current file (instead of anonymous)


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:       MODULES: AMBIENT        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


declare module "MODULE" {...}     #Declare the TYPEs (inside {...}) exported by `import "MODULE"`
                                  #Should prefer directly using ESM `export` in ambient file instead.
                                  #Must be imported with <reference/>
                                  #import|export:
                                  #  - can be used in current file, but only inside {...}
                                  #  - can only import from "MODULE" not "PATH"
                                  #  - `export` inside {...} is implied (but can still be used)
                                  #"MODULE" can use globbing * ("wildcard module declaration")
                                  #  - e.g. "*!text" or "text!*" for loaders that allow such notation
declare module "MODULE";          #Make any `import "MODULE"` work, but untyped (any).

MODULE AUGMENTATION ==>           #When declaring MODULE again, merge with MODULE already declared.
                                  #Merges the same way as INTERFACEs.
                                  #import|export "MODULE|PATH" outside {...} can be used
                                  #  - it must be used in order to distinguish from normal module declaration
                                  #Cannot use globbing *
declare global { ... }            #Module augmentation for global scope.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:      MODULES: REFERENCES      :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


/// <.../>                        #Transpiler pragma directives
                                  #Must be at top of file (except other comments or blank lines)

/// <reference path="PATH" />     #Deprecated alternative to ESM `import`
                                  #To use when imported PATH|MODULE does not use ESM `export`
                                  #Declare that:
                                  #  - PATH content is included there
                                  #  - current file and PATH share same scope
                                  #     - can reference declarations from each other
                                  #     - i.e. should namespace with NAMESPACEs or 'declare module'
                                  #The inclusion itself is done separately either:
                                  #  - compile-time when using --outFile
                                  #  - by loading both files with <script> from a parent file
--noResolve                       #Ignore all /// <reference .../>


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:        DEFINITELYTYPED        :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


@types/MODULE                     #Ambient files maintained by DefinitelyTyped
                                  #  - central repository (must send PRs)
                                  #  - search at https://www.typescriptlang.org/dt/search
                                  #Prefer keeping TYPEs in same repository as code instead.
/// <reference types="MODULE"/>   #Same as <reference path> but for "@types/MODULE"

--types "MODULE" ...              #'MODULE'_ARR of @types/MODULE to automatically try during "MODULE" resolution (regardless of --moduleResolution)
                                  #Def: any
--typeRoots "DIR" ...             #Resolve "@types/*' to "DIR"_ARR instead.

CONF.typeAcquisition.disable
 FilenameBasedTypeAcquisition     #BOOL. Disable automatic usage of @types/*


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          CORE TYPES           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


typescript/lib/lib.LIB.d.ts       #Among:
                                  #  - es5|6|2015-2022: core JavaScript
                                  #     - es2015-2022.FEATURE: specific feature
                               4.6#     - including es2022
                                  #  - esnext: same as es2022, plus uncoming es2023
                                  #  - dom: browser APIs, including URL, console, setTimeout(), etc.
                                  #  - dom.iterable: DOM objects being ITERABLE. Not included by "dom".
                                  #  - webworker: WORKER
                                  #  - webworker.importscripts: WORKERGLOBAL.importScripts(). Not included by "webworker"
                                  #  - webworker.iterable. Not included by "webworker"
                                  #  - scripthost: Windows Script Host
                                  #  - esnext.full: esnext + dom[.iterable] + webworker + scripthost
@typescript/lib-LIB            4.5#If this Node module is available, it overrides the built-in lib-LIB
                               4.5#E.g. can be installed using PACKAGE.devDependencies."@typescript/lib-LIB" "npm:MODULE"

--lib 'LIB,...'                   #Same as <reference path/> but for 'typescript/lib/lib.LIB.d.ts'
                                  #Def: es* (depending on --target) + dom (always) + scripthost (always)
                                  #When creating a library, the consumer must use a compatible --lib, to get same types.
/// <reference lib="LIB"/>     3.0#Same
--noLib
/// <reference
 no-default-lib="true"/>          #Do not include any 'LIB'

@types/node                       #Types of all core Node.js modules
                                  #Includes some browser APIs (e.g. URLs, console, setTimeout(), etc.), i.e. some of the same types as --lib=dom
                                  #  - some of those are global
                                  #Should be devDependency, not production dependency, since it is actually an optional peerDependency.
                                  #  - when creating a library, the consumer must install a compatible @types/node itself


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             TSLIB             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


tslib                             #Similar to core-js but fewer features:
                                  #  - `STR`
                                  #  - ...ARR, ...OBJ, Object.assign()
                                  #  - async|await
                                  #  - ITERATOR
                                  #  - __esModule logic
                                  #  - @DECORATOR
                                  #  - private fields
                                  #Version 2.6.0

--target STR                      #Inline helpers from tslib during transpile.
                                  #Based on ES version, among es5|6|2015-2021|next
                               4.6#or 2022 (def)
                                  #I.e. --lib is for sources, --target is for build
--downlevelIteration           3.6#Whether to include ITERATOR full helpers (next|return|throw(), Symbol.iterator) instead of simplified ones.
                               3.6#Only useful when --target es3|5

--importHelpers                   #Use import 'tslib' statements (i.e. must install it) instead of inlining those functions.
--noEmitHelpers                   #Same but must use <reference/> to load 'tslib' instead.

--isolatedModules                 #Remove some features that rely on analyzing files together (instead of one at a time):
                                  #  - no NAMESPACE
                                  #  - no `declare const enum`
                                  #  - implies --preserveConstEnums
                                  #  - ES modules are required, except for ambient files
                                  #  - `import|export type` must be used when re-exporting a TYPE
                                  #  - helpers are inlined in each file, instead of shared, unless --importHelpers used
                                  #Must be enabled when using Babel TypeScript plugins


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:          JAVASCRIPT           :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


DIFFERENCE FROM JAVASCRIPT ==>    #  - types: declarations, assertions, declare, import|export
                                  #  - namespace
                                  #  - [const] enum -> inlined as VAL|OBJ
                                  #  - different CLASS syntax|features: public|protected|private, parameter properties
                                  #  - modules:
                                  #     - resolution: no '.EXT', *.ts[x]|d.ts, PACKAGE.types[Version]
                                  #     - loading: import(STR).VAR, CommonJS default export, <reference/>, declare module|global, export as namespace

--emitDecoratorMetadata           #Allow Reflect.metadata (ES stage 0 proposal)

*.JS TYPING ==>                   #*.js can be imported but are untyped (any) by default.
--allowJs                         #Use type inference of *.js exported values.
                                  #Type inferences differences:
                                  #  - OBJ additional properties always allowed
                                  #  - FUNC argument optional (?)
                                  #  - `null|undefined` TYPE -> `any`
                                  #  - [] -> `any[]` (instead of `never[]`)
                                  #Can do type assertions with JSDoc, which removes all differences above.
                                  #Also transpile *.js
--checkJs                         #Also do type checking inside *.js
                               4.1#Implies --allowJs
--maxNodeModuleJsDepth NUM        #Run --allowJs (if enabled) on imported 'MODULE' (instead of only 'PATH') providing:
                                  #  - they are NUM levels deep in dependencies tree
                                  #  - no *.ts[x]|d.ts can be found
                                  #Also run --checkJs (if enabled), but not recommended, as most *.js 'MODULE' will report errors.
                                  #Def: 0 (disabled)

CONF.typeAcquisition.enable       #BOOL (def: true). Make IDE load TypeScript types of dependencies
CONF.typeAcquisition.
 include|exclude                  #'PACKAGE'_ARR. Same for specific dependencies


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:             JSDOC             :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


JSDOC COMMENTS ==>                #Can be used for type assertions in *.js (for --allowJs|checkJs)
                                  #When comment is:
                                  #  - on line before: does not bypass transtyping rules (like QUAL VAR: TYPE)
                                  #  - inline before value: bypasses transtyping rules (like <TYPE>)

TYPE                              #TYPE in @TAG can be either JSDoc TYPE or TypeScript TYPE

@TAG                              #Only the following tags are allowed
@typedef {TYPE} TYPE2
@type {TYPE}
@readonly
@deprecated [COMMENT]
@public|protected|private
@enum [{TYPE}]
@param [{TYPE}] VAR [- COMMENT]
@returns [{TYPE}] [COMMENT]
@callback TYPE
@class                            #Like JSDoc
@this {TYPE}
@augments {TYPE}                  #Like JSDoc but slight different syntax
@template [{TYPE3}] T,... [- CMNT]#Generic <T [extends TYPE3],...> parameter
@satisfies
@overload


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:            LINTING            :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--strict                          #Alias for --noImplicitAny --noImplicitThis --alwaysStrict --strictBindCallApply
                                  #--strictNullChecks --strictFunctionTypes --strictPropertyInitialization
                               4.4#--useUnknownInCatchVariables

--allowUnreachableCode            #Do not lint against statements that can't be reached, e.g.:
                                  #  - after a `return` statement
                                  #  - inside a if|switch|... whose condition is known compile-time to be false
--allowUnusedLabels               #Do not lint against unused JavaScript LABEL:
                                  #Def: do not lint, but provide warnings in IDE
--noImplicitReturns               #Lint against omitting `return;` at end of function with no return statements
--noUnusedLocals                  #Lint against unused variables (except parameters)
                               4.2#Except in ARR destructuring if VAR starts with _
--noUnusedParameters              #Lint against unused parameters
--noFallthroughCasesInSwitch      #Lint against switch case with no break, unless followed by another case right away.


                                             /=+===============================+=\
                                            /  :                               :  \
                                            )==:              JSX              :==(
                                            \  :_______________________________:  /
                                             \=+===============================+=/


--jsx STR
--jsxFactory STR
--jsxFragmentFactory STR
--jsxImportSource
--reactNamespace
/* @jsx STR */                    #See React doc
