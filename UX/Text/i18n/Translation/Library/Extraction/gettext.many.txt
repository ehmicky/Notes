
             
   GETTEXT   
             


GENERAL ==>             #Header : <libintl.h>
                        #         "/usr/share/gettext/gettext.h" : pour pgettext()
                        #Librarie : libintl (pas nécessaire sous Linux) (pour compilation, pas besoin runtime)
                        #License : LGPL

PROCESSUS ==>           #Développeur :
                        # 1) Edition sources avec gettext( STR )
                        #Maintainer :
                        # 2) (pour toutes langues) xgettext sur sources (création) -> fichier PACKAGE.pot, human-readable, 
                        #    portable
                        # 3) (pour chaque langue) msginit (création) ou msgmerge (addition) sur .pot -> LANG.po ("catalogue")
                        #  (3b) Si fusion de packages, création de variantes régionales, correction ortho, etc., utilisation de
                        #  msgcat, etc. pour créer ces .po)
                        #Traducteur :
                        # 4) Edition du traducteur du fichier .po avec un GetText-Editeur (éditeur pour éditer des .po)
                        #Maintainer :
                        # 5) msgfmt sur .po -> fichier PACKAGE.mo, machine language, dépendant du système (.gmo -> sur 
                        #    système GNU). 
                        #User :
                        # (Installation des bonnes locales)
                        # 6) Loading du .mo à runtime, remplaçant les gettext( STR ) par string selon locale courante

INITIALISATION ==>      #  - setlocale( LC_ALL, "" ); //Ou seulement LC_MESSAGES et LC_CTYPE si souhaité. LC_CTYPE est utilisé
                        #                               pour convertir entre le charset du .mo et le charset courant
                        #                               Pour certains languages, LC_ALL ne comprend pas LC_MESSAGES, il faut
                        #                               donc le préciser.
                        #                             //Ou en C++ std::locale::global( std::locale( "" ) );
                        #    bindtextdomain( "monProgramme", "/dir" );
                        #    bind_textdomain_codeset( "monProgramme", "UTF-8" ); //Pour bon traitement par GTK
                        #    textdomain( "monProgramme" );
                        #Le fichier chargé devra être dans /dir/$LOCALE/LC_MESSAGES/monProgramme.mo
                        #$LOCALE peut être une version plus courte que la vraie locale, du moment qu'il n'y a pas d'ambiguité,
                        #par exemple "fr" si locale est "fr_FR.utf8"
                        #Si ce fichier n'est pas trouvé, gettext() renvoie la string du programme par défaut.
                        #Utiliser des macros pour "monProgramme" et "/dir".
                        #Utilise les locales C ou C++

INSTALLATION ==>        #Faire que le build system (ex: make) crée lui-même les .po
                        #Dans le répertoire source root, mettre répertoire po/ remplis avec des fichiers $LOCALE.po 
                        #Les transformer en PACKAGE.mo lors de l'installation, puis les mettre :
                        #  - Pour Linux, /usr/share/locale/$LOCALE/LC_MESSAGES/
                        #Ne faire qu'un PACKAGE.pot par programme.

LOCALES ==>             #gettext will use the .mo file corresponding to the current locale.
                        #It will use the folder matching the current locale, .i.e :
                        #  - $TEXTDMAINDIR/$LOCALE/LC_MESSAGES/$TEXTDOMAIN.mo
                        #$LOCALE can be more generic that the current locale. Therefore, use generic file name for the $LOCALE 
                        #folder (e.g. "fr" and not "fr_FR") to allow generic matching (e.g. "fr_FR" and "fr_CA" locales will 
                        #both use .mo file), unless there are .mo files for specific locales (e.g. for both "fr_FR" and 
                        #"fr_CA").
                        #.po file "Language" and "Encoding" field doesn't have any consequence on locales matching :
                        #  - "Language" field is used only for descriptive purpose.
                        #  - "Encoding" is used only for conversion between local encoding and .mo file encoding
                        #However providing the charset for the -l flag of msginit and msgmerge will automatically fill the 
                        #corresponding field in the .po file.
CHARSET ==>             #Any charset will match, but if local charset and .mo charset differ, conversion will be performed.
                        #Quoi qu'il en soit un fichier .mo est dans un encoding donné (celui désigné dans .po). 
                        #Si locale courante est dans un encoding différent, cela fait bugué. Par exemple si fichier .mo est
                        #dans fr_FR (implique fr_FR.ISO-8859-1), alors si locale courante est fr_FR.UTF-8, cela provoque des
                        #problèmes.

TROUBLESHOOTING ==>     #  - Verify the locale has been installed on the local system, and is matching the actual full name of 
                        #    that locale (e.g. don't set LANG to "fr" if you installed "fr_FR.utf8")
                        #  - Verify .mo file is put in the correct folders

bindtextdomain          #Fait que les fichiers .mo du message domain STR1 seront recherchés 
( STR1, STR2 )          #dans STR2/$LOCALE/LC_MESSAGES/STR1.mo. Par défaut STR2 est /usr/share/locale (peut être NULL).
                        #Renvoie parent directory de STR2. $LOCALE est par exemple "fr_FR"
                        #STR1 est le "message domain". Il s'agit d'un ensemble de traduction lié à un module/programme donné.
                        #Il prend souvent le nom du package. Est utile lors d'utilisation de bibliothèques : la bibliothèque 
                        #aura son propre set de traductions (message domain) différent de celui du main().
                        #errno == ENOMEM si pb d'allocation mémoire.
textdomain( STR1 )      #Fait que le message domain courant devient STR1, et donc que le fichier .mo utilisé devient celui
                        #spécifié par le message domain STR1 via un précédant appel à bindtextdomain(). Peut être NULL. 
                        #Renvoie message domain courant.
                        #errno == ENOMEM si pb d'allocation mémoire.
bind_textdomain_codeset #gettext( ) convertie du charset du fichier .mo vers l'encoding définie par le LC_CTYPE courant.
( STR1, STR2 )          #Cependant, si les fonctions courantes ont besoin d'un encoding précis, et ne pas dépendre du LC_CTYPE
                        #courant (par exemple Glib ayant besoin d'UTF-8), utiliser bind_textdomain_codeset( ).
                        #STR1 est le message domain, STR2 l'encoding à utiliser au lieu de LC_CTYPE : cf liste possible via
                        #iconv -l.

MESSAGE DOMAIN ==>      #Pour qu'un dgettext() fonctionne, ne pas oublier d'avoir fait un bindtextdomain() + 
                        #bind_textdomain_codeset() pour le message domain donné. dgettext() recherchera alors DOMAIN.mo dans
                        #le DIR spécifié.
                        #Les text domains ne servent qu'en runtime, pas pendant la détection. Donc xgettext ignorera les
                        #domains et les .po files n'en parleront pas. Mais en principe, un .po file ne devra pas avoir
                        #plusieurs message domains, car 1 message domain = 1 programme.

EDITION SOURCES ==>     # STR -> gettext( STR )
                        #Ne jamais le faire si STR peut être vide.
                        #Peut faire un #define _(String) gettext(String)
                        #Effectue deux choses :
                        #  - extraction des strings lors de xgettext
                        #  - remplacement traduction runtime lors exécution de gettext()
                        #Autres appels : [d[c]][n][p]gettext()
                        #  - p : prend un argument supplémentaire au début, le contexte : cf CONTEXTE
                        #  - n : prend un argument supplémentaire à la fin, pour le pluriel, et un ULONG_VAL : cf PLURIEL
                        #  - d : prend un argument supplémentaire au début (après l'argument de "p" si "p"), le message domain.
                        #        Si premier argument est NULL, celui précisé via un précédent textdomain() est utilisé (c'est
                        #        en fait ce que fait gettext())
                        #        A utiliser pour les bibliothèques : cf LIBRARY
                        #  - c : toujours avec d, prend un argument supplémentaire à la fin (après l'argument de "n" si "n"),
                        #        un enum pour la catégorie LC_* à utiliser au lieu de LC_MESSAGES, comme LC_TIME ou LC_MONETARY
                        #        Peu utile.
                        #Dans tous les cas, il faut utiliser l'option -k adapté de xgettext, si macro
                        #Met souvent des macros pour simplifier :
                        #  - #define _( String ) gettext( String )
                        #    #define N_( String ) ( String )
                        #    #define P_( Contexte, String ) pgettext( Contexte, String )
                        #    #define M_( Singular, Plural, Number ) ngettext( Singular, Plural, Number )
                        #On peut aussi faire un ifdef ENABLE_NLS qui, si not def, define N_, etc. vers seulement ( String )

SITUATION SPECIALE ==>  #Impossible de rajouter une fonction autour de STR
                        #  - ex : char* STR_ARR[] = { STR, STR2 };
                        #  - solution :
                        #     - pour l'extraction des strings STR et STR2 :
                        #        - #define N_( String ) ( String )
                        #          char* STR_ARR[] = { N_( STR ), N_( STR2 ) }; // Et penser à utiliser xgettext -kN_
                        #     - pour traduction runtime :
                        #        - lors de l'utilisation de STR_ARR, l'entourer de gettext()
                        #           - ex : fputs( gettext( STR_ARR[INDEX] ) );
                        #Il y a aussi gettext_noop( STR ), qui revient au même.

.PO FILE ==>            #1 programme + 1 langue spécifique.
                        #Possibilité d'utiliser des caractères non-ASCII dans le fichier. Le CHARSET du fichier doit cependant
                        #remplacer "CHARSET", par exemple "UTF-8". gettext() runtime remplacera avec des fichiers de charset
                        #CHARSET.
                        #Bonne idée pour interopérabilité : utiliser UTF-8 et manipuler avec Glib et ustring. Pour GTK+,
                        #souvent, la string est un argument USTRING, donc implicite.
                        #Format :
                        #  - Un ensemble de commentaires :
                        #    - SOME DESCRIPTIVE TITLE -> "Traduction en français (Quebec) de MonProgramme"
                        #    - COPYRIGHT : cf xgettext --copyright-holder
                        #    - FIRST AUTHOR <EMAIL@ADDRESS.COM>, YEAR -> Michel Blanc <m.blanc@lapost.net>, 2011
                        #    - "Report Msgid bugs" : cf xgettext --msgid-bugs-address
                        #    - "Language" : mettre locale de la langue
                        #    - "Content-Type" : remplacer CHARSET par le charset, par exemple "UTF-8"
                        #    - Autres commentaires
                        #  - Un bloc :
                        #    - newline
                        #    - commentaires optionnels parmi (ajoutés automatiquement par xgettext, sauf les commentaires du 
                        #      traducteur et développeur) :
                        #        - #  Commentaire du traducteur (attention : # + whitespace)
                        #        - #. Commentaire du développeur :
                        #           - pour les mettre, cf xgettext -c
                        #        - #: Endroit où a eu lieu l'extraction
                        #        - #, "Flags", parmi (Cf FORMATS) :
                        #           - "[no-]c-format" indique un printf format (ou non)
                        #           - "[no]-{objc,sh,python,lisp,elisp,librep,scheme,smalltalk,java,csharp,awk,object-pascal,
                        #             ycp,tcl,perl,perl-brace,php,gcc-internal,gfc-internal,qt-format,qt-plural,kde,boost}-
                        #             format" : pareil mais pour d'autres formats
                        #           - "fuzzy" : indiqué par le traducteur pour dire que traduction est approximative
                        #        - #| suivi d'ancien msgid, si nouveau msgstr est "fuzzy"
                        #        - #~ Ligne de code commented : cf msgmerge
                        #    - msgctxt "CONTEXTE" : cf CONTEXTE
                        #    - msgid "TEXTE ORIGINAL"
                        #    - msgstr "TRADUCTION"
                        #    - msgid_plural, msgstr[0] et msgstr[1] : cf PLURIEL
                        #  - Le traducteur doit remplir les msgstr
                        #  - Format de STR : une suite de "TEXTE" "TEXTE2" possible. Si newline, préférer faire "TEXTE\n" 
                        #    suivi de newline et "TEXTE2". Ne jamais faire de trailing backslash

EDITION DE FICHIER .PO  #A la main ou (TAO, Translation assisté par ordinateur, CAT, Computer-assisted Translation):
==>                     #  - gtranslator, poedit, lokalize : basics + TM (translation memory : suggestions de traductions à 
                        #    partir de databases) + spellchecker
                        #  - Virtaal : basics + pofilter + auto-completion + spellchecker + TM (avec Google Translate, Moses,
                        #    etc.). Très bien.
                        #  - OmegaT : a l'air un peu comme Virtaal

CONTEXTE ==>            #En utilisant pgettext( STR1, STR2 ), produit un "msgctxt" au dessus de msgid dans le .po. Il s'agit
                        #d'une sorte de "namespace de traduction" pour un mot ayant plusieurs sens selon contexte. 
                        #Utile notamment pour les strings très courtes des Menubar, où le MenuPath courant est utilisé comme
                        #contexte.
                        #Essayer de faire en sorte qu'il ne change pas avec le temps.

PLURIEL ==>             #Utiliser ngettext( STR1, STR2, ULONG_VAL ) :
                        #  - xgettext produira :
                        #     - un msgid "STR1" et msgid_plural "STR2", pour la version non-traduite, au singulier et pluriel
                        #     - un msgstr[INDEX] pour chaque version traduite pour un "nombre_genre" donné.
                        #     - rajoute dans les commentaires d'en haut : "Plural-Forms: nplurals=INTEGER; plural=EXPRESSION"
                        #       - les remplacer par ce que signifie "singulier" et pluriel dans cette langue :
                        #         - INTEGER : nombre de "nombres_genre" (par exemple 3 en latin : singulier, duel et pluriel)
                        #         - EXPRESSION : soit n INT_VAL, EXPRESSION doit renvoyer le "nombre_genre" correspondant.
                        #           msgstr[nombre_genre] sera alors utilisé.
                        #       - rempli automatiquement par msginit -l
                        #     - exemples courants :
                        #       - pas de pluriel : "nplurals=1; plural=0;"
                        #         - ex : perse, indonésien, japonais, kazakh, kenyan, coréen, chinois, vietnamien, turc, 
                        #                uyghur, thailandais
                        #       - pluriel si > 1 (0 est singulier) : "nplurals=2; plural=( n > 1 );"
                        #         - ex : français, brésilien (non portugais), occitan, arménien
                        #       - pluriel si != 1 (0 est pluriel) : "nplurals=2; plural=( n != 1 );"
                        #         - ex : majorités des autres languages, dont anglais
                        #       - 3 nombres_genre : belarusse, tchèque, croate, lithuanien, latvian, macédonien, polonais, 
                        #         romanien, russe, slovaque, serbe, ukrainien
                        #       - 4 nombres_genre : genre singulier si centaine se termine par 1, pluriel 2 si se termine par 
                        #         2, pluriel 3 si se termine par 3 ou 4, pluriel 4 sinon
                        #         - ex : slovénien
                        #       - 5 nombres_genre : irlandais
                        #       - 6 nombres_genre : genre singulier 0 si 0, singulier 1 si 1, pluriel 2 si 2, pluriel 5 si 
                        #         centaine entre 0 et 2 et que pas 0, 1 ou 2, pluriel 3 si centaine entre 3 et 10, pluriel 4 
                        #         sinon.
                        #         - ex : arabe
                        #  - runtime, ngettext utilisera la version traduite de STR1 ou STR2 suivant la valeur d'INT_VAL. Si
                        #    pas traduction, utilise les msgid fournits, avec comme EXPRESSION implicite celle de l'anglais
                        #ngettext() utilise des ULONG_VAL :
                        #  - nombres négatifs n'ont pas de distinction pluriel/singulier normalement. Sinon, utiliser valeur
                        #    absolue.
                        #  - nombre supérieur à ULONG_MAX -> faire un modulo 1000

FORMATS ==>             #xgettext devine automatiquement la présence de printf format, via la présence de format specifiers
                        #tels que "%d". Cela met un flag "#, c-format" par exemple dans le .po
                        #Pour la présence d'autres formats, cf xgettext --flags, -qt, -kde, -boost.
                        #Les traductions des entrées avec de tels flags sont checkés par msgfmt --check-format, qui produit une
                        #erreur en cas de problème. Par exemple, pour flag "c-format", lorsque la traduction a changé ordre des
                        #%*, alors, sauf si traducteur a arrangé situation en utilisant formats %N$d pour indiquer nouvel 
                        #endroit (ce qu'il doit faire).
                        #Parfois flag "c-format" n'est pas mis alors qu'il le faudrait (par exemple un printf n'utilisant pas
                        #de %*, mais traduction en utilisant sans le savoir), ou inverse (string utilisant des symboles %).
                        #Pour forcer le bon flag, faire précéder la ligne de code d'un commentaire contenant mots
                        #"xgettext:[no-]*-format"

LIBRARY ==>             #Contrairement à une application habituelle :
                        #  - pas d'appel à setlocale(), qui doit être fait par le main() utilisant la library. Dire dans doc
                        #    de la library de faire appel à setlocale() pour qu'user de la library le sache.
                        #  - ne pas modifier le message domain du main() :
                        #      - pas d'appel à textdomain()
                        #      - mais bien appel à bindtextdomain( TEXTDOMAIN, ... ) avec le DOMAIN de la bibliothèque
                        #        - mettre bindtextdomain() dans une fonction init(), à appeler qu'une fois, mais par toute 
                        #          fonction possible de l'API
                        #      - utiliser dgettext( TEXTDOMAIN, STR ) au lieu de gettext( STR )
                        #        - faire un #define D_( STR ) dgettext( "MonProgramme", STR ) pour plus simple

BUG REPORT ==>          #Rajouter dans l'endroit indiquant le bug report, une ligne indiquant translation bug report, avec :
                        #  - adresse générale 
                        #  - mettre un commentaire destiné aux traducteurs pour leur dire de mettre leur adresse spécifique

SWITCH LANGUAGE ==>     #Dans un GUI, dans un Menubar > Help > Switch language, on peut switcher le language.

CONSEIL SUR PHRASES ==> #  - Utiliser des phrases entières. Sinon, difficile de traduire sans connaître contexte.
                        #  - pas de jargon
                        #  - mettre des commentaires pour le traducteur pour qu'il comprenne le contexte.
                        #  - merge deux printf() se suivant, ou deux "STR". Eviter concaténation de plusieurs "STR" séparées.
                        #  - si STR suivi de mots ne devant pas être traduits, faire deux STR
                        #  - Pas plus de 3/4 phrases d'un coup (car si update d'un mot, doit tout retraduire)
                        #  - ne pas mettre markup tel que <a href>, mais mettre markup tel que <b> qui peut varier selon la
                        #    culture
                        #  - pas plusieurs écritures d'un même mot : "e-mail", "E-mail", "Email"
                        #  - éviter "\n", "\t", ainsi que whitespace à fin ou début d'une msgid
                        #  - Ne pas traduire acronymes tel que PNG, etc., ou indiquer ne pas le faire.
                        #  - "%d", "%f", etc. doivent être traduits, car par exemple en perse, cela est "%Id", et peut prendre
                        #    quatre fois plus de places (prévoir donc place dans buffer)
                        #  - ne pas mettre d'images avec des mots apparaissant
                        #  - ne pas afficher hyperlinks directement

CONSEIL POUR TRADUCTEUR #  - noms de personnes et lieux peuvent être traduits ou écrits avec un autre script. Penser donc à
 ==>                    #    mettre prononciation dans commentaires pour traducteurs. Traducteur doit aussi mettre entre
                        #    parenthèses le nom original si modifié (le signaler dans commentaires).

                                  ┌──────────────┐
                                  │   XGETTEXT   │
                                  └──────────────┘

xgettext FILE...        #Produit un fichier NOM.pot (en fait .po, à renommer .pot aussitôt) à partir des fichiers source 
                        #FILE... 
                        #NOM est par défaut "messages"
                        #FILE... peut être - pour stdin
                        #S'il y a une macro #define _( ), il faut utiliser -k_

-f FILE                 #Utilise chaque ligne de FILE comme FILE... (batch file)
-D DIR                  #Fait que FILE... sera recherché dans DIR/ si chemin relatif
-d STR                  #NOM devient STR
-o FILE                 #Produit fichier FILE au lieu de NOM.pot. Si FILE est -, stdout
-p DIR                  #Met FILE produit dans DIR au lieu de répertoire courant

-L STR                  #Spécifie le langage (sinon deviné en fonction extension des fichiers) parmi C, C++, ObjectiveC, PO,  
                        #Python, Lisp, EmacsLisp, librep, Scheme, Smalltalk, Java, JavaProperties, C#, awk, YCP, Tcl, Perl, 
                        #PHP, GCC-source, NXStringTable, RST, Glade, Shell
-C                      #Equivaut à -LC++
--from-code STR         #Spécifie l'encodage de FILE..., par défaut ASCII (sauf .glade, Python et .tcl, étant UTF-8)

-k STR                  #Recherche aussi les occurrence de STR, en plus de "gettext". A faire si l'on a défini une macro,
                        #notamment _( ) et N_( ).
                        #STR peut aussi être :
                        #  - STR:NUM : ne regarde que l'argument numéro NUM de STR()
                        #    - à faire notamment sur macro de dgettext
                        #  - STR:NUM1,NUM2 : le premier argument de STR prend la forme au singulier, et le deuxième celle au
                        #    pluriel
                        #    - à faire notamment sur macro de ngettext
                        #  - STR:NUM1c,NUM2 ou STR:NUM1,NUM2c : comme STR:NUM, mais utilise comme msgctxt argument numéro 
                        #    NUM1c ou NUM2c
                        #    - à faire notamment sur macro de pgettext
                        #  - STR:...,NUMst : comme STR:..., mais n'est pris en compte que si STR() a NUM arguments (pour 
                        #    l'overloading C++)
                        #  - STR:...,\"COMMENT\" : rajoutera COMMENT comme commentaires pour le traducteur
--flag=STR:NUM:STR2     #STR2 est [pass-][no-]*-format. Est comme -k STR:NUM, sauf qu'ajoute aussi le format STR2.
                        #Si "pass-", si la STR dans le code source ne contient pas de format spécifiers pour le format 
                        #indiqué, *-format n'est pas mis (préférer cela)
--qt
--kde
--boost                 #Permet détection automatique des format string de Qt, KDE ou Boost
-a                      #Recherches toutes les STR, même sans rien devant (ne marche pas pour quelques languages)
-c[STR]                 #Rajoute comme commentaires pour les traducteurs les commentaires dans le code source commençant par
                        #STR (par défaut tous)

--copyright-holder=STR  #Remplace Copyright du header par STR (si rien, public domain copyright).
                        #Un traducteur doit transférer et nier ses droits sur la traduction pour éviter au développeur des
                        #problèmes légaux. Mettre donc public domain, copyright du développeur ou celle de l'organisation
                        #chapeautant le projet.
--foreign-user          #Equivaut à --copyright-holder=""
--package-{name,version}#
=STR                    #Modifie name et version du PACKAGE dans header.
--msgid-bugs-address=STR#Modifie header : cette adresse est celle utilisée par les traducteurs pour contacter le développeur en
                        #cas de msgid problématiques : pas phrase entière, besoin de plus de contexte, pas de pluriel, 
                        #faute d'ortographe en anglais, etc.

-j                      #Rajoute aussi le contenu de stdin, qui doit correspondre au contenu de fichiers .po
-x FILE                 #Avec -j, exclue cependant le contenu se trouvant également dans FILE (fichier .po)

-i                      #Utilise des identations (le faire)
-w NUM
--no-wrap               #Wrapping des strings de traduction
--color=STR             #Rajoute du markup pour couleurs (rend le .po invalide, à n'utiliser que pour preview) :
                        #  - "always"/"never" : \e[ séquences
                        #  - "auto" : "always" si output est tty (défaut)
                        #  - "html" : HTML (utile pour certains scripts, comme Hindi, dont le rendu est mieux dans un browser
                        #             que dans un terminal)
--style=FILE            #Modifie coloration de --color en fonction du fichier .css FILE
-s                      #Trie les traductions. A éviter car fait que traducteur comprend moins le contexte.
-F                      #Trie en fonction des fichiers contenant les strings.

--no-location           #Les lignes #: ne sont plus ajoutées automatiquement (ne pas le faire)
-n                      #Contraire
--force-po              #Sinon, si pas de message, pas d'output
-m[STR]                 #Fait que les msgstr, au lieu d'être vide, sont initialisées à leur msgid, préfixé par STR.

--strict                #N'utilise pas les GNU extensions (éviter)
--properties-output     #Renvoie sous format .properties Java, équivalent de gettext() en Java (ne supporte pas les pluriels)
--strintable-output     #Même chose pour NEXTstep/GNUstep localizad ressource.

-T                      #Permet de comprendre les trigraphes

                                  ┌─────────────┐
                                  │   MSGINIT   │
                                  └─────────────┘

msginit -i FILE1 -o FIL2#Produit fichier LANG.po FILE2 à partir de fichier PACKET.pot FILE1
                        #Modifie en fait automatiquement des champs du header, dont TITRE, Revision Date, Plural Forms,
                        #Encoding (mais utilise charsets non-unicode).
                        #Est interactif (pose des questions s'il manque des choses dans le .pot)
                        #Sinon, on peut aussi faire un simple mv PACKAGE.pot LANG.po
--no-translator         #Dit que msginit n'a pas été initié par un traducteur, mais un développeur : évite question sur adresse
                        #de traducteur, etc.
-l STR
--lang=STR              #Remplit champs du header Language et Language-Team selon la locale STR
--properties-input
--stringtable-input     
-w NUM
--no-wrap
--color=STR
--style=STR             #Cf xgettext

                                  ┌──────────────┐
                                  │   MSGMERGE   │
                                  └──────────────┘

msgmerge FILE.po        #Met à jour FILE.po en fonction de FILE2.pot.
FILE2.pot               #Si :
                        #  - FILE2.pot ne contient plus des strings définies par FILE.po : les commente avec #~, sauf si pas de
                        #    traductions
                        #  - FILE2.pot contient de nouvelles strings :
                        #      - les rajoute
                        #      - ou les décommente si commentées via #~
                        #      - ou si strings sont très proches, les marques "fuzzy"
                        #  - FILE2.pot contient strings identiques : ne modifie pas FILE.po, qui garde traduction de ces
                        #    strings
                        #Par défaut ne met pas à jour, mais écrit sur stdout
                        #Les fuzzy traductions sont des traductions presques exactes et probablement exactes demandant juste
                        #un check du traducteur : il existe des touches dans les .po editors pour faire passer une traduction
                        #fuzzy vers l'état "traduit" rapidement. Un traducteur peut aussi ajouter lui-même l'attribut fuzzy
                        #pour indiquer qu'il va regarder plus tard. Les fuzzy sont ignorés par msgfmt : il faut enlever cet
                        #attribut lorsque plus fuzzy.
                        #Si --previous, le msgid précédent du .po est mise dans

-o FILE3                #Ecrit non sur stdout mais sur FILE3
-U                      #Equivaut à msgmerge -o FILE.po FILE.po FILE2.pot
--backup=STR
--suffix=STR            #Avec -U : comme pour cp (défaut "simple" et "~")
-D DIR                  #Comme pour xgettext

-N                      #Ne fait pas de fuzzy matching
--previous              #Cf ci-dessus (défaut non)
-C                      #Signifie que FILE.po est un compendium.
                        #Il s'agit de fichiers .po utilisés par plusieurs applications. Ils ne doivent pas contenir d'entrées
                        #non-traduites ou fuzzy. Evite à un traducteur de traduire plusieurs fois les mêmes choses.

--lang=LANG             #Cf msginit
--properties-
{input,output}
--stringtable-
{input,output}
--color=STR
--style=STR
--force-po
-i
--no-location
--strict
-w NUM
--no-wrap
-s
-F                      #Cf xgettext

                                  ┌───────────────────────────┐
                                  │   AUTRES POUR .PO FILES   │
                                  └───────────────────────────┘

OPTIONS COMMUNES :

TOUS ==>                #-D DIR, --properties-input, --stringtable-input : cf xgettext
TOUS SAUF MSGCMP ET     #-o FILE, --properties-output, --stringtable-output, --color=STR, --style=STR, --force-po, -i, 
MSGEXEC ==>             #--no-location, --strict,  -w NUM, --no-wrap, -s, -F : cf xgettext
MSGCAT, MSGGEN ==>      # --lang=STR : cf msginit
MSGCAT, MSGCOMM ==>     # -\> NUM : n'imprime que les msgid ayant + de NUM msgstr différentes
                        # -\< NUM : inverse
                        # -f : Lit le nom des fichiers à concaténer dans FILE.
MSGCAT, MSGUNIQ ==>     # --use-first : si msgstr différentes, utilise la première
MSGCAT, MSGUNIQ, 
MSGCOMM ==>             # -u : n'imprime que les msgid n'ayant pas de NUM msgstr différentes
MSGCAT, MSGCONV, 
MSGUNIQ                 # -t STR : imprime avec le charset STR

msgcat FILE...          #Concatène plusieurs FILE .po, par défaut sur stdout. Par exemple, lors d'une fusion de deux packages.
                        #Si traductions contradictoires, l'indique.

msgconv FILE            #Convertie le charset d'un fichier .po. Par exemple, lors d'une fusion de deux packages avec différents
                        #charsets.

msguniq                 #Supprime les msgid doublons : il s'agit de ceux simplement concaténés sans l'utilisation de msgcat,
                        #qui rajoute lui une mise en forme spéciale pour les doublons. msguniq rajoute cette mise en forme.
                        #-d n'imprime que les doublons, avec la nouvelle mise à jour, et -u les non-doublons.

msgcomm FILE...         #Imprime messages avec mêmes msgid + msgstr dans chaque FILE...

msgen FILE              #Copie les msgid vers les msgstr : utilisé pour créer catalogues anglais.

msgcmp                  #Check degré de [non-]traduction d'un fichier .po
msgcmp FILE.po FILE2.pot#Check que l'ensemble des msgid de FILE2.pot a été traduit dans FILE.po, sinon produit une erreur.
-m
-N                      #Cf msgmerge

msgattrib FILE          #Extrait (imprime) les traductions fuzzy ou non-traduites d'un fichier .po
--[un]translated        #N'imprime que les traductions [non-]traduites.
--[no|only]-fuzzy       #Pareil pour fuzzy messages
--[no|only]-obsolete    #Pareil pour messages commentés avec #~
--fuzzy                 #Equivaut à only-fuzzy et clear-fuzzy
--obsolete              #Equivaut à only-obsolete et clear-obsolete
--[set|clear]-
[fuzzy|obsolete]        #Enlève ou ajoute attribut #~ ou "fuzzy" sur tous les messages
--clear-previous        #Enlève commentaires "#|" sur tous les messages
--[only|ignore]-file=FIL#Limite/exclue action à FILE

msgexec -i FILE COMMANDE#Exécute COMMANDE sur chaque msgstr, msgid et header string du fichier .po FILE, et imprime cela.
                        #L'impression ne sera donc pas un fichier .po valide, mais une suite de strings concaténées.
                        #COMMANDE prend une STR en input et output une STR2, qui sera la nouvelle msgstr.
                        #COMMANDE peut utiliser les environment variables MSGEXEC_MSGID, MSGEXEC_LOCATION et MSGEXEC_MSGCTXT
                        #contenant le msgid, #: location et msgctxt courants.
                        #COMMANDE peut être 0 pour signifier "xargs -0"
                        #L'output vers COMMANDE est fait dans l'encoding du fichier .po : utiliser donc avant msgconv, ou
                        #iconv, pour convertir contenu du fichier .po vers l'encoding manipulé par COMMANDE (UTF-8 pour 
                        #plupart des commandes Unix)
                        #Utilisé par exemple pour qu'un traducteur fasse des vérifications ortho.

msgfilter -i FILE COMAND#Comme msgexec, sauf que :
                        #  - imprime un fichier .po valide
                        #  - ne manipule que les msgstr
                        #  - n'imprime pas le header, sauf si --keep-header
                        #Par exemple pour adapter des traductions à une variante régionale. 
                        #Peut aussi être utilisé pour obtenir une version approximative du .pot file ayant produit un .po
                        #donné, si ce .pot n'est pas disponible.

msggrep FILE            #Imprime FILE sauf les messages filtrés par :
                        #  -T : msgstr
                        #  -K : msgid
                        #  -J : msgctxt
                        #  -C : commentaires du traducteur
                        #  -X : commentaires
                        #  -N : FILE de #:
                        #correspondant à PATTERN, suivi donc par une suite de -e PATTERN
                        #Un seul filtre semble possible par invocation.
                        #Même remarque que msgexec pour l'encoding.
                        #potool est une commande un peu comme msggrep, mais légèrement mieux
-E                      #Utilise extended regex
-F                      #Utilise fixed regex
-i                      #Case insensitive
-v                      #Inverse le match.
-f FILE                 #Prend les PATTERN dans FILE

LIBGETTEXTPO ==>        #Il s'agit de plusieurs fonctions C définies pour manipuler l'input d'un fichier .po si msgcat, etc.
                        #ne suffisent pas. Pour par exemple intégrer fonctionnalité de traduction dans un logiciel. Cf doc.
                        #Cf aussi Translate Toolkit qui possède une API plus puissante, et qui manipule aussi des fichiers
                        #XLIFF.

                                  ┌────────────┐
                                  │   MSGFMT   │
                                  └────────────┘

msgfmt FILE             #Créer un fichier .mo à partir d'un fichier .po FILE, par défaut messages.mo
-D DIR
-o FILE                 
--strict                
--properties-input
--stringtable-input     #Cf xgettext

-c                      #Equivaut à --check-format --check-header --check-domain
--check-format          #Cf FORMATS
--check-header          #Produit erreur si problème dans header entries
-C                      #Produit erreur si utilisation de GNU extensions
--check-accelerators    #Produit erreur si problème lors de traduction d'accelerators

-f                      #Utilise aussi les fuzzy entries (ne pas le faire en général)

-a NUM                  #Aligne les strings du .mo sur NUM octets (défaut off)
--no-hash               #Ne produit pas de hash tables
--statistics            #Imprime sur stderr des infos sur nombres de traductions, non-traductions, fuzzy entries, etc.

msgunfmt FILE           #Inverse de msgfmt : produit fichier .po à partir d'un .mo
--color=STR
--style=STR
--force-po
-i
--strict
--properties-output
--stringtable-output
-w NUM
--no-wrap
-s                      #Cf xgettext

                                  ┌────────────┐
                                  │   AUTRES   │
                                  └────────────┘

CHANGER LANGUAGE        #Pour UNIX, modifier variable $LANGUAGE via setenv( "LANGUAGE", "fr", 1 );
RUNTIME ==>             #Cependant, gcc effectue des optimimizations, pour les désactiver faire :
                        # {
                        #   extern int _nl_msg_cat_cntr;
                        #   ++_nl_msg_cat_cntr;
                        # }
                        #Cette info est peut-être outdated

AUTRES LANGUAGES ==>    #Autres languages mis à part C et C++ : Objective C, Python, Lisp, EmacsLisp, Scheme, Smalltalk, Java, 
                        #C#, awk, Tcl, Perl, PHP, R, Glade, Boost::format, Bash, librep, Pascal, YCP, Shell
                        #Toolkits : Glade, wxWidgets, Qt
                        #Peut aussi avoir comme output des fichiers similaires pour Java (.properties), de C# (.resources), de 
                        #tlc (.msg), de Qt (.qm).
                        #Pour plus d'info sur un langage particulier, cf chapitre 15 du manuel.
                        #Pour support des languages, il suffit en général : 
                        #  - pour la détection, de rajouter une syntaxe particulière, et de faire xgettext.
                        #  - pour le remplacement runtime, dépend.
                        #  - pour le remplacement des locales, dépend
                        #libintl peut aussi être utilisé si rien n'est disponible.
SH ==>                  #Runtime :
                        #  - if type gettext.sh &> /dev/null
                        #    then
                        #      . gettext.sh (source définition de eval_[n]gettext)
                        #      export TEXTDOMAIN=STR
                        #      export TEXTDOMAINDIR=PATH (équivaut à bindtextdomain() et textdomain())
                        #    fi
                        #Locales :
                        #    export LANG=STR (ou LC_ALL)
                        #Runtime + détection :
                        #    "STRING"              -> "$(gettext "STRING")"
                        #    "MANY..."             -> "$(ngettext "Singular" "Plural" $Number)"
                        #Pour :
                        #    "$VAR"                -> "$(eval_[n]gettext "\$VAR")"
                        #    "$..." (other than    -> VAR="$..." ; "$(eval_[n]gettext "\$VAR")"
                        #    just $VAR, i.e.
                        #    $1 or $(COMMAND))
                        #    echo "..."$'...'"..." -> echo "$(gettext "...")" ; echo $'...' ; 
                        #                             echo "$(gettext "...")"
                        #    echo " \" ' $ "       -> echo -e "$(gettext " \047 \042 \$ ")"
                        #Absents : 
                        #  - contextes
BASH ==>                #Comme sh, mais $"STRING" peut remplacer "$(gettext "STRING")". Préférer [n]gettext
                        #Cependant, problèmes de sécurité traduction ne doit pas contenir ` ` ou $( ) et, si locale chinoise, 
                        #de caractères de deux octets dont le deuxième octet est \x60, interprété comme un `
R ==>                   #Runtime :
                        #  - bindtextdomain(domain|domaindir)
                        #    - par convention : domain = "R-programme" pour code en R, et = "programme" pour code en C
                        #  - pas de texdomain : semble par défaut le namespace de la fonction contenant gettext()
                        #Locales :
                        #  - Fait automatiquement (sinon manuellement: Sys.setlocale())
                        #    - attention, LC_ALL ne comprend pas LC_MESSAGES, faire donc LC_ALL + LC_MESSAGES
                        #Runtime + détection :
                        #  - gettext(STRv|domain)
                        #  - ngettext(NUM,singular,plural|domain)
                        #  - gettextf(fmt,...|domain) (comme sprintf)
                        #  - aussi stop(), message(), warning(), packupStartupMessage() (ont un arg. domain à la fin)
                        #Extraction :
                        #  - tools::xgettext2pot(dir, potFile)
                        #     - extrait dir/R/*.R (*.rdb aussi ???)
                        #Absents : 
                        #  - contextes
                        #  - utilise propre xgettext, donc pas de : #, et #. (commentaire dvloppeur), et manque certains
                        #    commentaires dans le .po
.GLADE ==>              #Détection : 
                        #  - <TAG>VAL</TAG> -> <TAG translatable="yes">VAL</TAG>
                        #  - fait automatiquement pour ensemble des strings pertinentes (mettre "no" pour enlever sur une
                        #    string particulière), soit tags : label, title, text, format, copyright, comments, preview_text et
                        #    tooltip.
                        #  - rajouter attributs comments="TEXT" rajoute commentaires pour traducteurg
                        #  - rajouter msgctxt : rajouter attributs context="TEXT", puis utiliser :
                        #     - intltool-extract --type=gettext/glade FILE.glade
                        #    produisant un fichier .c à extraire via xgettext. A l'avenir, seul un xgettext sera nécessaire,
                        #    il s'agit d'un bug temporaire
                        #  - pluriel : doit toujours utiliser un ULONG_VAL variable, impossible à mettre dans un fichier .glade
                        #    Définir donc de telles choses dans le fichier source.
                        #Runtime : comme pour fichier C/C++
                        #Traduction des StockID et des Widgets tel que Color Selection ou File Selection : via libintl ??? cf
                        #A FAIRE pour make, cmake, etc.
                        #Avec Gtkmm : BUILDER.{s,g}et_translation_domain( USTRING ) modifie le message domain, initialement à
                        #"". Le faire. Même chose pour ACTIONGROUP.*et_translation_domain( USTRING )
                        #Cf aussi macros de Glib définissant _( ), etc.
AWK ==>                 #Runtime :
                        #  - Dans BEGIN :
                        #      TEXTDOMAIN = "STR"
                        #      bindtextdomain( STR[, MESSAGE_DOMAIN] ) (par défaut $TEXTDOMAIN)
                        #Runtime + détection :
                        #  - _"STR" (équivaut à gettext( STR ))
                        #  - dcgettext( STR, MESSAGE_DOMAIN[, ENUM] )
                        #  - dcngettext( STR, MESSAGE_DOMAIN, NUM[, ENUM] )
.DESKTOP ==>            #Détection : Au lieu de VAR=VAL, mettre _VAR=VAL
XML ==>                 #Détection : Au lieu de <TAG>VAL</TAG>, mettre <_TAG>VAL</_TAG>
JAVA ==>                #  - properties-{input,output} (plusieurs commandes)
                        #  - msg[un]fmt --java, --java2, -r, -l, -d
C# ==>                  #  - msg[un]fmt --csharp, --csharp-resources, -r, -l, -d
TCL ==>                 #  - msg[un]fmt --tcl, -l, -d
QT ==>                  #  - msg[un]fmt --qt

ALTERNATIVES ==>        #  - A gettext : open-source : catgets (peu utilisé), propriétaire : plusieurs autres (dont Trados et
                        #    WordFast)
                        #  - Au .po file : XML XLIFF

SOUMETTRE PROJET A      #Faire des prereleases pour laisser temps de traduction avant vraie release.
EQUIPE DE TRADUCTION ==>#Il est possible aussi d'internationaliser une bibliothèques (ses messages sur stderr).
                        #Ne pas modifier traductions des traducteurs : ils le prennent mal.
                        #Créditer la traduction, par exemple sur le site du projet et dans la about box. Pour la About Box,
                        #mettre une string "translator-credits", avec commentaires disant aux traducteurs de la remplacer par
                        #leur nom + addresse.
                        #  - translatewiki.net : si open-source + version control system
                        #  - (GNU) translationproject.org : s'occupe du transfert de copyright (si l'on le veut), assez bien
                        #  - GNOME Translation Project : pour projets GNOME, très très bien

CHECK ==>               #pofilter vérifie fichiers .po soumis (normalement faits par les traducteurs) : format strings, 
                        #modification des accelerators, espace sequences, whitespaces, "comestiques"

A FAIRE ==>             #Message domains : msggrep -M, msgmerge -m, msgfmt --check-domain
                        #Faire make, cmake, etc. (cf GLADE plus haut) :
                        #  - Chapitre 13 "Maintainer's view"
                        #  - http://people.gnome.org/~malcolm/i18n/build-changes.html pour GTK 
                        #  - http://live.gnome.org/TranslationProject/DevGuidelines/Localize%20using%20gettext%20and%20intltool
                        #  - http://hpux.connect.org.uk/hppd/hpux/Gnome/intltool-0.41.1/readme.html
                        #  - http://developer.gnome.org/gtkmm-tutorial/3.0/chapter-internationalization.html.en
                        #  - Les différents scripts intltool-*
                        #Traduction des StockID et File Selection Widgets de GTK+ via Glade
