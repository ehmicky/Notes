
                                  ┏━━━━━━━━━━━━━━━━━━┓
                                  ┃   WEB SECURITY   ┃
                                  ┗━━━━━━━━━━━━━━━━━━┛

                                  ┌────────────────────┐
                                  │   CODE INJECTION   │
                                  └────────────────────┘

CODE INJECTION ==>                #Injecting code where data is expected
                                  #Due to wrong assumption about input:
                                  #  - constraints: length, value, characters used, type, etc.
                                  #  - legitimate or can't be modified by client
                                  #Prevention:
                                  #  - validating input
                                  #  - validating origin of input (user, domain, etc.)
                                  #  - escaping|sanitizing input

SQL|PHP|ASP|SHELL INJECTION ==>   #For those specific programming langues

BUFFER OVERFLOW ==>               #Input exceeds min|max length|value
                                  #Prevented by bound checking

                                  ┌─────────┐
                                  │   XSS   │
                                  └─────────┘

XSS ==>                           #Cross-site scripting
                                  #Code injection in a web page, so it executes within that context
                                  #E.g. to circumvent CORS, since it executes within same ORIGIN

PERSISTENT XSS ==>                #XSS persisted server-side
                                  #Also called active|stored
                                  #As opposed to not persistent or passive|reflected XSS, which is client-side only

HTML INJECTION ==>                #XSS with HTML
                                  #E.g. in an HTML comment

JAVASCRIPT INJECTION ==>          #XSS with JavaScript
                                  #E.g. eval(), setTimeout(STR), new Function(STR)

URI TEMPLATE INJECTION ==>        #XSS with an URI

                                  ┌──────────────────────┐
                                  │   HEADER INJECTION   │
                                  └──────────────────────┘

HEADER INJECTION ==>              #Code injection in HTTP headers, when their value is user-defined
                                  #E.g. set Location [C] or Set-Cookie [C]

HEADER RESPONSE SPLITTING ==>     #Header injection that inserts either:
                                  #  - \r\n: to terminate this header and inject a header
                                  #  - \r\n\r\n: to terminate all headers and inject start of body
                                  #Prevention: URL encoding user-defined HTTP header value

                                  ┌──────────┐
                                  │   CSRF   │
                                  └──────────┘

CSRF ==>                          #Cross-Site Request Forgery
                                  #Also called XSRF
                                  #An ORIGIN accessing confidential data from another ORIGIN
                                  #Preventions:
                                  #  - SOP
                                  #  - CSRF token
                                  #  - not keeping confidential data client-side
                                  #     - e.g. never caching login credentials
                                  #Not a good prevention: checking Referer [C]
                                  #  - can be forged
                                  #  - absent in private browsing mode

LOGIN CSRF ==>                    #CSRF accessing authentication data

CSRF URL ==>                      #CSRF with a GET request, i.e. can be triggered from clicking a URL
                                  #Prevention: no side-effects with GET

CSRF TOKEN ==>                    #Nonce sent by server to client to authenticate next request[s]
                                  #Also called synchronizer|challenge token
                                  #This reduces CSRF risk since attacker must know CSRF token too
X-CSRF-TOKEN: STR [S]
X-XSRF-TOKEN: STR [S]             #Common name for CSRF token

                                  ┌────────────────────────┐
                                  │   SAME ORIGIN POLICY   │
                                  └────────────────────────┘

SOP ==>                           #Same Origin Policy
                                  #RFC 6454
                                  #Goal: preventing CSRF
                                  #Forbid an ORIGIN from reading|writing resources of another ORIGIN
                                  #ORIGIN is exact, including subdomains

FORBIDDEN ==>                     #  - XHR / fetch()
                                  #  - programmatic DATATRANSFER (drag&drop, copy/cut/paste)
                                  #     - not browser default action for selection, links and images
                                  #  - IFRAME.contentDocument|contentWindow
                                  #     - unless <iframe sandbox="allow-same-origin"?
                                  #  - Canvas images, WebGL textures
                                  #  - Fonts

ALLOWED ==>                       #  - navigating, including:
                                  #     - <a|area|base href="URI">
                                  #     - LOCATION
                                  #     - HISTORY
                                  #     - WINDOW.open|alert()
                                  #  - safe MIME types, including:
                                  #     - <link href="URI">
                                  #     - <img|input|video|audio|source|iframe src="URI">
                                  #     - <script src="URI">
                                  #     - any URI in CSS (except @font-face)
                                  #  - embedding, if cannot programmatically read|write resources
                                  #  - for historical reasons, but it is unsafe:
                                  #     - <form action="URI">
                                  #  - WebSocket
                                  #     - because protocol force checking Origin [C] server-side
                                  #  - file://
                                  #     - only if same DIR or ancestor to current ORIGIN
                                  #     - in Chrome: never allowed

PROBLEMS ==>                      #Allowed but still unsafe:
                                  #  - <form action="URI">
                                  #  - navigating to GET requests with side-effects

<script src="URL?callback=FUNC">  #JSONP (JSON with Padding)
                                  #Client creates globalThis.FUNC
                                  #Response is "FUNC(VAL)", i.e. executes globalThis.FUNC
                                  #I.e. bypassed SOP to pass VAL
                                  #Client should validate that response returns FUNC(OBJ) and not arbitrary JavaScript
                                  #Old alternative to CORS: prefer CORS

postMessage()                     #Bypasses SOP for communication between IFRAMEs
                                  #However, IFRAMEs must check MESSAGEEVENT.origin to prevent CSRF

chrome --disable-web-security
 --user-data-dir                  #Bypasses SOP, for development

                                  ┌──────────┐
                                  │   CORS   │
                                  └──────────┘

CORS ==>                          #Cross Origin Resource Sharing
                                  #Server requesting client to not enforce SOP for specific ORIGINs on specific resources

ORIGIN ==>                        #Relies on ORIGIN not being forgeable
Origin: ORIGIN ... [C]            #Cannot be forged in browsers
                                  #Always sent if not same origin

Access-Control-Allow-Origin:      #Request client not to enforce SOP
 ORIGIN [S]                       #Must match one of Origin [C]
                                  #Can be * but should avoid it

PREFLIGHT REQUEST ==>             #Pre-request that ask for CORS info from server
                                  #Uses OPTIONS method + Origin [C]
                                  #Can be skipped if all of:
                                  #  - GET|HEAD|POST
                                  #  - Content-Type [C] is 'application/x-www-urlencoded', 'multipart/form-data' or 'text/plain'
                                  #  - only HTTP headers: Accept, Accept-Language, Content-Language, Content-Type, Last-Event-ID, Downlink, client hints
Access-Control-Request-* [C]      #Inform server about the upcoming request
Access-Control-Request-Method:
 METHOD [C]                       #
Access-Control-Request-Headers:
 HEADER,... [C]                   #
REQ[Q].credentials
XHR.withCredentials               #Must be true if using Cookie [C], [Proxy-]Authentication [C] or client-side SSL certificates

PREFLIGH RESPONSE ==>             #If success, 204
Access-Control-Allow-* [S]        #Inform client about all allowed request
Access-Control-Allow-Origin:
 ORIGIN [S]                       #
Access-Control-Allow-Methods:
 METHOD,... [S]                   #
Access-Control-Allow-Headers:
 HEADER,... [S]                   #
Access-Control-Allow-Credentials:
 true [S]                         #Not allowed if Access-Control-Allow-Origin: *
Access-Control-Max-Age: NUM [S]   #How many seconds client should cache preflight response
Access-Control-Expose-Headers:    #Which HEADER to show to end user in final response
 HEADER,... [S]                   #By default (and always shown), only show:
                                  #Content-Type, Cache-Control, Content-Language, Expires, Pragma, Last-Modified

                                  ┌─────────────────────────────┐
                                  │   CONTENT SECURITY POLICY   │
                                  └─────────────────────────────┘

CSP ==>                           #Content Security Policy
                                  #Ask client to restrict links to other ORIGINs
                                  #Goal: prevent injection from user-defined contents

  - Content-Security-Policy: TYPE STR ... [;...] [; sandbox][; report-uri STR] [S]
     - restrict TYPE resources to STR
     - TYPE can be:
       - default-src: default STR... for all TYPE (sinon "*")
       - script-src: <script>
       - connect-src: XHR.open(), WebSocket(), EventSource() (server-sent event)
       - font-src: @font-face
       - frame-src: <iframe>
       - image-src: <img>
       - media-src: <audio>, <video>, <source>, <track>
       - object-src: <object>
       - style-src: <style>, but not CSS <link>
     - STR is space-separated list
     - STR can be:
       - [PROTOCOL:][DOMAIN[:PORT][/PATH]]
         - wildcard * accept, but if DOMAIN, only in beginning of DOMAIN, and followed by "." or "/"
       - special values:
         - 'self': same origin
         - 'none': completly disabled
         - 'unsafe-inline|eval': using CSP bans HTML-inline JavaScript and CSS and eval() (and the like:
           setTimeout|Interval(STR), Function(STR), etc.), unless using this
     - STR is not quoted, except special values (single-quoted)
     - only one occurence for a given TYPE

Content-Security-Policy: ...
 ;sandbox [S]                     #Gives same restrictions as in a <iframe sandbox>
Content-Security-Policy: ...
 ;report-uri URL [S]
     - report-uri will:
        - POST - URL everytime a client sees attempts to circumvent CSP rules.
        - use Content-Type: "application/csp-report" and JSON body:
           - csp-report:
              - document-uri URL (origin)
              - blocked-uri
              - referrer URL
              - violated-directive, e.g. "img-src STR"
              - original-policy (full directive)
              - status-code

CSP:
  - Content-Security-Policy-Report-Only: ... [S]: same but only sends reports via report-uri.
    sed to test first before deploying.
  - CSP 1.1 features:
    - instead of HTTP headers, using HTML tags:
      - <meta http-equiv="Content-Security-Policy" content="...">, same as Content-Security-Policy: ...
      - others less interesting (JavaScript manipulation, etc.)
  - browser implementation
    - not by IE10
    - X-Webkit-CSP instead of Content-Security-Policy for Safari 7
    - <meta> only by Chrome

URI:
  - only location:
     - does not provide resource|provider authentication:
        - URI are transient. E.g. someone can buy out a domain name.
        - control can be stolen
     - does not guarantee security of resource it locates
  - URI spoofing:
     - creating one that looks the same (see typosquatting)
     - making USERINFO look like HOSTNAME|PATH
  - confidentiality:
     - knowing one URI gives hints or other possible sibling URIs:
        - unless random IDs or authorization are used
     - using USERINFO as plaintext, e.g. USER:PASSWORD

Typosquatting/URL hijacking:
  - creating similar URLs as well-known websites, but with typos/mistakes, similar word (e.g. plural) or different top-level
  - can also normal register URL if not used yet
  - can also use Unicode characters almost identical, thanks to IRI or IDNA
  - goal: selling it, redirecting to competitor, phishing, getting traffic, etc.

Clickjacking:
  - DOMAIN2 put DOMAIN in an <iframe|frame|object|embed> to make end-user work on DOMAIN while believing he is on DOMAIN2
  - defenses:
     - CSP2 frame-ancestors:
        - best but not supported by all browsers
        - when X-Frame-Options specified, frame-ancestors is ignored by Chrome/Firefox (although RFC says inverse)
     - X-Frame-Options: WORD [S]:
        - RFC 7034
        - tells the client that the served page should deny being in an <iframe|frame|object|embed>:
           - deny: never
           - sameorigin: only if parent has same origin
           - allow-from DOMAIN:
              - only if top-level from DOMAIN
              - not supported by Safari/Chrome/Opera
     - ensure before doing sensitive actions that WINDOW.top === WINDOW
     - WINDOW.confirm() before doing sensitive actions (popup cannot be framed)

HTTPS: see HTTPS doc

Sniffing:
  - Can use X-Powered-By [S] so should not be used

IE-specific:
  - X-XSS-Protection: 1; mode=block [S]: same goal as CSP but browser-specific. Also for Chrome.
  - X-Download-Options: noopen [S]:
     - don't open automatically content on Content-Disposition [S]
     - could execute JavaScript code in current context otherwise
  - X-Content-Type-Options: nosniff [S]:
     - disables IE "MIME sniffing" feature, which would allow an attacker to inject JavaScript code in a file that looks like
       another type.

Flash-specific:
  - Adobe products like Flash asks for /crossdomain.xml (if exists) as a policy file.

Cache attack:
  - steps:
     - Alice write confidential information, then cached/stored
     - Mallory takes control of Alice's device
     - Mallory read cached confidential information
  - examples:
     - accessing someone else device then browsing to logged in websites
     - use authentication URL with cached authentication headers
  - solution:
     - do not cache/store confidential information, or for shorter time
        - e.g. use no-cache="HEADER" for confidential headers, no caching for confidential body

Cache poisoning:
  - setting a cache value to an arbitrary value
  - cache might be shared by several clients, in which case one client can affect others

Cookies:
  - cannot rely only on cookies for authorization, must also use anti-CSRF measures
  - content should be encrypted (for confidentiality) and signed (for authenticity) even over HTTPS
  - should use secure and HttpOnly
  - content should contain key (to server-side hash table, e.g. session id) not direct information
  - service on same URL but different port can access cookie
  - service on same domain or superdomain can set cookies

Open redirect:
  - redirection that depends on user-generated content in URLs
     - allowing user-generated URLs has same risk as well
  - if not validated, allows user to browse to different website without consent
     - can lead to phishing

Normalization:
  - when a VAL has different variants, which should be considered equal
  - if not normalized, comparison can fail
  - examples:
     - transtyping
     - charset, encoding
     - STR: case, Unicode normalization
     - NUM: radix, FLOAT representation, decimal digits, epsilon, i18n (e.g. separators)
     - OBJ: keys order
     - ARR: order
     - base64: padding, chars outside charset, newlines
     - paths: symlinks
     - path/URIs: . .., relative links, duplicate /
     - URIs: default parts, unused parts

Browser sandbox:
  - see about:sandbox (Chrome/Opera), about:support#sandbox (Firefox)

URI:
  - are rarely confidential, and often logged by intermediaries
  - so should avoid confidential information in URI

Tracking:
  - privacy concern: giving personal information without consent is akin to forced negotiation (i.e. weakens one side of the negotation)
  - can be:
     - sanctioned, i.e. user control: user consent, based on standards so easy to detect (e.g. cookies, localStorage)
     - unsanctioned: e.g. fingerprinting, supercookies
  - standard: W3C TAG "Unsanctioned tracking"

Device|machine fingerprinting:
  - identifying a device|machine by device|machine capabilities instead of usual state mechanisms (e.g. cookies)
  - should be:
     - diverse:
        - number of possible combinations (measured in bits of entropy)
        - combinations are evenly distributed
     - stable: does not change over time
     - more capabilities add diversity but might reduce stability
        - however can update new configuration if only parts of it changes, providing the other part has enough diversity entropy
  - capabilities:
     - passive (read-only):
        - browser:
           - active extensions, e.g. AdBlock
        - HTTP:
           - User-Agent [C]
           - Accept* [C]
           - Connection [C]
           - DNT [C]
        - JavaScript:
           - DATE.getTimezoneOffset()
           - supported features, e.g. ES6
        - DOM:
           - CANVAS: draw 2D|3D to see variations due to different GPU
           - NAVIGATOR: plugins, platform, cookieEnabled
           - SCREEN: height, width, colorDepth
           - supported features, e.g. localStorage|sessionStorage
        - Flash:
           - list of OS fonts
        - NTP:
           - clock skew: small sync difference (in ms)
        - TCP/IP:
           - configuration
              - initial packet size, initial TTL, window size, max segment size, window scaling value, flags (don't fragment, sackOK, nop)
              - 67 bits of entropy
              - eases OS fingerprinting
        - IEEE 802.11 (wireless)
        - OS
     - active (can write on machine)
        - MAC address
        - machine serial number
        - HTTP enrichment (network proxies adding HTTP headers)
  - protection:
     - not sending capabilities information
     - randomizing capabilities information

Referer: URI [C]:
  - current URI (without USERINFO nor #HASH)
     - about:blank means no current URI
  - problems:
     - privacy concern: might deduce identity from current URI
     - confidentiality: if capability URI
  - solutions:
     - for specific HTTP request: WINDOW.fetch() REQ.referrer
     - for any HTTP request: "Referrer Policy":
        - VAL (def: 'no-referrer-when-downgrade'):
           +---------------------------------+-----------------+--------------+-------------+
           | NAME                            | HTTPS->HTTP     | CROSS-ORIGIN | SAME-ORIGIN |
           |                                 | (HAS PRIO)      |              |             |
           +---------------------------------+-----------------+--------------+-------------+
           | no-referrer                     | does not matter | unset                      |
           +---------------------------------+-----------------+----------------------------+
           | strict-origin                   | unset           | ORIGIN                     |
           +---------------------------------+-----------------+----------------------------+
           | origin                          | does not matter | ORIGIN                     |
           +---------------------------------+-----------------+--------------+-------------+
           | same-origin                     | does not matter | unset        | URI         |
           +---------------------------------+-----------------+--------------+-------------+
           | strict-origin-when-cross-origin | unset           | ORIGIN       | URI         |
           +---------------------------------+-----------------+--------------+-------------+
           | origin-when-cross-origin        | does not matter | ORIGIN       | URI         |
           +---------------------------------+-----------------+--------------+-------------+
           | no-referrer-when-downgrade      | unset           | URI                        |
           +---------------------------------+-----------------+----------------------------+
           | unsafe-url                      | does not matter | URI                        |
           +---------------------------------+-----------------+----------------------------+
        - can specify using:
           - Referrer-Policy: VAL [S]
           - <meta name="referrer" content="VAL">
           - <a|area|iframe|img|link referrerpolicy="VAL">
           - WINDOW.fetch() REQ.referrerPolicy
           - CSP referrer
        - Link: noreferrer [S] or <... rel="noreferrer"> can also be used
     - browser support:
        - not IE11, except for Link: noreferrer [S] or <... rel="noreferrer">, but degrades gracefully
