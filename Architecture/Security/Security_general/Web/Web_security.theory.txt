
                                  ┏━━━━━━━━━━━━━━━━━━┓
                                  ┃   WEB SECURITY   ┃
                                  ┗━━━━━━━━━━━━━━━━━━┛

                                  ┌────────────────────┐
                                  │   CODE INJECTION   │
                                  └────────────────────┘

CODE INJECTION ==>                #Injecting code where data is expected
                                  #Due to wrong assumption about input:
                                  #  - constraints: length, value, characters used, type, etc.
                                  #  - legitimate or can't be modified by client
                                  #Prevention:
                                  #  - validating input
                                  #  - validating origin of input (user, domain, etc.)
                                  #  - escaping|sanitizing input

SQL|PHP|ASP|SHELL INJECTION ==>   #For those specific programming langues

BUFFER OVERFLOW ==>               #Input exceeds min|max length|value
                                  #Prevented by bound checking

                                  ┌─────────┐
                                  │   XSS   │
                                  └─────────┘

XSS ==>                           #Cross-site scripting
                                  #Code injection in a web page, so it executes within that context
                                  #E.g. to circumvent CORS, since it executes within same ORIGIN

PERSISTENT XSS ==>                #XSS persisted server-side
                                  #Also called active|stored
                                  #As opposed to not persistent or passive|reflected XSS, which is client-side only

HTML INJECTION ==>                #XSS with HTML
                                  #E.g. in an HTML comment

JAVASCRIPT INJECTION ==>          #XSS with JavaScript
                                  #E.g. eval(), setTimeout(STR), new Function(STR)

URI TEMPLATE INJECTION ==>        #XSS with an URI

                                  ┌──────────────────────┐
                                  │   HEADER INJECTION   │
                                  └──────────────────────┘

HEADER INJECTION ==>              #Code injection in HTTP headers, when their value is user-defined
                                  #E.g. set Location [C] or Set-Cookie [C]

HEADER RESPONSE SPLITTING ==>     #Header injection that inserts either:
                                  #  - \r\n: to terminate this header and inject a header
                                  #  - \r\n\r\n: to terminate all headers and inject start of body
                                  #Prevention: URL encoding user-defined HTTP header value

                                  ┌─────────────────────────────┐
                                  │   CONTENT SECURITY POLICY   │
                                  └─────────────────────────────┘

Content-Security-Policy:          #CSP. Ask client to restrict links to other ORIGINs
 TYPE TVAL ... [;...] [S]         #Goal: prevent injection from user-defined contents
                                  #Must specify each TYPE only once
                                  #'self|none|unsafe-inline|eval' is single quoted
                                  #TYPE and other TVALs not quoted
<meta http-equiv
 ="Content-Security-Policy"
 content="...">                   #Same, but as HTML tag

TYPE default-src                  #Default for other TYPEs (def: '*')

TYPE script-src                   #<script>
TYPE connect-src                  #XHR.open(), WebSocket(), EventSource() (server-sent event)
TYPE font-src                     #@font-face
TYPE frame-src                    #<iframe>
TYPE frame-ancestors              #<iframe|frame|object|embed> parents
TYPE image-src                    #<img>
TYPE media-src                    #<audio>, <video>, <source>, <track>
TYPE object-src                   #<object>
TYPE style-src                    #<style>, but not CSS <link>

TVAL URI                          #Allows '[PROTOCOL:][DOMAIN[:PORT][/PATH]]'
                                  #Can use *
                                  #  - for DOMAIN, only at beginning, followed by . or /
TVAL 'self'                       #Allows if same origin
TVAL 'unsafe-inline'              #Allows <script> and <style> without src
TVAL 'unsafe-eval'                #Allows eval() and the likes (new Function(STR), etc.)
TVAL 'none'                       #Forbidden

Content-Security-Policy: ...
 ;sandbox [S]                     #Gives same restrictions as in a <iframe sandbox>
<iframe sandbox[="allow-STR ..."]>#Restrictions;
                                  #  - no plugins
                                  #  - no <script> (allow-scripts)
                                  #  - no <form> submit (allow-forms)
                                  #  - same origin policy (allow-same-origin)
                                  #     - also block document.cookie and localStorage
                                  #  - no popups
                                  #  - can't go up to container DOCUMENT
                                  #  - no <object> or similar
                                  #  - no seamless attribute
                                  #  - no autoplay attribute, autofocus, etc.

Content-Security-Policy: ...
 ;report-uri URL [S]              #Calls POST URL when client detects attempts to circumvent CSP
Content-Type:
 application/csp-report [S]       #
CSP_REPORT                        #JSON body
CSP_REPORT.document-uri           #'URL' of ORIGIN
CSP_REPORT.blocked-uri            #'URL' being accessed
CSP_REPORT.referrer               #'URL' of Referer [C]
CSP_REPORT.violated-directive     #'TYPE ...'
CSP_REPORT.original-policy        #STR. Full Content-Security-Policy [C]
CSP_REPORT.status-code            #STATUS_NUM

Content-Security-Policy           #Same as Content-Security-Policy [S] but do not restrict
 -Report-Only: ... [S]            #Only sends reports via report-uri
                                  #Meant for debugging

                                  ┌──────────┐
                                  │   CSRF   │
                                  └──────────┘

CSRF ==>                          #Cross-Site Request Forgery
                                  #Also called XSRF
                                  #An ORIGIN accessing confidential data from another ORIGIN
                                  #Preventions:
                                  #  - SOP
                                  #  - CSRF token
                                  #  - not keeping confidential data client-side
                                  #     - e.g. never caching login credentials
                                  #Not a good prevention: checking Referer [C]
                                  #  - can be forged
                                  #  - absent in private browsing mode

LOGIN CSRF ==>                    #CSRF accessing authentication data

CSRF URL ==>                      #CSRF with a GET request, i.e. can be triggered from clicking a URL
                                  #Prevention: no side-effects with GET

CSRF TOKEN ==>                    #Nonce sent by server to client to authenticate next request[s]
                                  #Also called synchronizer|challenge token
                                  #This reduces CSRF risk since attacker must know CSRF token too
X-CSRF-TOKEN: STR [S]
X-XSRF-TOKEN: STR [S]             #Common name for CSRF token

                                  ┌────────────────────────┐
                                  │   SAME ORIGIN POLICY   │
                                  └────────────────────────┘

SOP ==>                           #Same Origin Policy
                                  #RFC 6454
                                  #Goal: preventing CSRF
                                  #Forbid an ORIGIN from reading|writing resources of another ORIGIN
                                  #ORIGIN is exact, including subdomains

FORBIDDEN ==>                     #  - XHR / fetch()
                                  #  - programmatic DATATRANSFER (drag&drop, copy/cut/paste)
                                  #     - not browser default action for selection, links and images
                                  #  - IFRAME.contentDocument|contentWindow
                                  #     - unless <iframe sandbox="allow-same-origin"?
                                  #  - Canvas images, WebGL textures
                                  #  - Fonts

ALLOWED ==>                       #  - navigating, including:
                                  #     - <a|area|base href="URI">
                                  #     - LOCATION
                                  #     - HISTORY
                                  #     - WINDOW.open|alert()
                                  #  - safe MIME types, including:
                                  #     - <link href="URI">
                                  #     - <img|input|video|audio|source|iframe src="URI">
                                  #     - <script src="URI">
                                  #     - any URI in CSS (except @font-face)
                                  #  - embedding, if cannot programmatically read|write resources
                                  #  - for historical reasons, but it is unsafe:
                                  #     - <form action="URI">
                                  #  - WebSocket
                                  #     - because protocol force checking Origin [C] server-side
                                  #  - file://
                                  #     - only if same DIR or ancestor to current ORIGIN
                                  #     - in Chrome: never allowed

PROBLEMS ==>                      #Allowed but still unsafe:
                                  #  - <form action="URI">
                                  #  - navigating to GET requests with side-effects

<script src="URL?callback=FUNC">  #JSONP (JSON with Padding)
                                  #Client creates globalThis.FUNC
                                  #Response is "FUNC(VAL)", i.e. executes globalThis.FUNC
                                  #I.e. bypassed SOP to pass VAL
                                  #Client should validate that response returns FUNC(OBJ) and not arbitrary JavaScript
                                  #Old alternative to CORS: prefer CORS

postMessage()                     #Bypasses SOP for communication between IFRAMEs
                                  #However, IFRAMEs must check MESSAGEEVENT.origin to prevent CSRF

chrome --disable-web-security
 --user-data-dir                  #Bypasses SOP, for development

                                  ┌──────────┐
                                  │   CORS   │
                                  └──────────┘

CORS ==>                          #Cross Origin Resource Sharing
                                  #Server requesting client to not enforce SOP for specific ORIGINs on specific resources

ORIGIN ==>                        #Relies on ORIGIN not being forgeable
Origin: ORIGIN ... [C]            #Cannot be forged in browsers
                                  #Always sent if not same origin

Access-Control-Allow-Origin:      #Request client not to enforce SOP
 ORIGIN [S]                       #Must match one of Origin [C]
                                  #Can be * but should avoid it

PREFLIGHT REQUEST ==>             #Pre-request that ask for CORS info from server
                                  #Uses OPTIONS method + Origin [C]
                                  #Can be skipped if all of:
                                  #  - GET|HEAD|POST
                                  #  - Content-Type [C] is 'application/x-www-urlencoded', 'multipart/form-data' or 'text/plain'
                                  #  - only HTTP headers: Accept, Accept-Language, Content-Language, Content-Type, Last-Event-ID, Downlink, client hints
Access-Control-Request-* [C]      #Inform server about the upcoming request
Access-Control-Request-Method:
 METHOD [C]                       #
Access-Control-Request-Headers:
 HEADER,... [C]                   #
REQ[Q].credentials
XHR.withCredentials               #Must be true if using Cookie [C], [Proxy-]Authentication [C] or client-side SSL certificates

PREFLIGH RESPONSE ==>             #If success, 204
Access-Control-Allow-* [S]        #Inform client about all allowed request
Access-Control-Allow-Origin:
 ORIGIN [S]                       #
Access-Control-Allow-Methods:
 METHOD,... [S]                   #
Access-Control-Allow-Headers:
 HEADER,... [S]                   #
Access-Control-Allow-Credentials:
 true [S]                         #Not allowed if Access-Control-Allow-Origin: *
Access-Control-Max-Age: NUM [S]   #How many seconds client should cache preflight response
Access-Control-Expose-Headers:    #Which HEADER to show to end user in final response
 HEADER,... [S]                   #By default (and always shown), only show:
                                  #Content-Type, Cache-Control, Content-Language, Expires, Pragma, Last-Modified

                                  ┌──────────────────┐
                                  │   CLICKJACKING   │
                                  └──────────────────┘

CLICKJACKING ==>                  #CSRF using an <iframe|frame|object|embed> with different ORIGIN
                                  #and make users click in it, believe it to be same ORIGIN

CSP ==>                           #'frame-ancestors' (see its doc) prevents clickjacking

X-Frame-Options: VAL [S]          #Prevents clickjacking
                                  #Ask client to allow putting response in an <iframe|frame|object|embed>:
                                  #  - DENY: never
                                  #  - sameorigin: only if parent has same origin
                                  #  - allow-from DOMAIN: only if top-level from DOMAIN (ignored by most browsers)
                                  #RFC 7034
                                  #Deprecated: prefer CSP 'frame-ancestors'

WINDOW.top === WINDOW             #Can be used for confirmation to prevent clickjacking
WINDOW.confirm()                  #Same, since popup cannot be framed

                                  ┌─────────┐
                                  │   URI   │
                                  └─────────┘

TRUST ==>                         #URI locates a resource, but it does not guarantee its security
                                  #E.g. URI's ownership can change

CONFIDENTALITY ==>                #URI can be logged, i.e. should not contain confidential information

HIDING ==>                        #Private URI can be guessed, i.e. should:
                                  #  - use random IDs in URI
                                  #  - not rely on URI remaining private

SPOOFING ==>                      #Making URI look like another
                                  #E.g. making USERINFO look like HOSTNAME|PATH

TYPOSQUATTING ==>                 #URI spoofing relying on typos, similar words (e.g. plural), different TLD, similar Unicode chars, etc.
                                  #Also called URL hijacking
                                  #Possible goals: selling URL, redirecting to competitor, phishing, getting traffic

URL SQUATTING ==>                 #Registering URL (including domain name) before legitimate owner
                                  #Similar goals as typosquatting

                                  ┌────────────┐
                                  │   OTHERS   │
                                  └────────────┘

HTTPS ==>                         #See HTTPS doc

Sniffing:
  - Can use X-Powered-By [S] so should not be used

IE-specific:
  - X-XSS-Protection: 1; mode=block [S]: same goal as CSP but browser-specific. Also for Chrome.
  - X-Download-Options: noopen [S]:
     - don't open automatically content on Content-Disposition [S]
     - could execute JavaScript code in current context otherwise
  - X-Content-Type-Options: nosniff [S]:
     - disables IE "MIME sniffing" feature, which would allow an attacker to inject JavaScript code in a file that looks like
       another type.

Flash-specific:
  - Adobe products like Flash asks for /crossdomain.xml (if exists) as a policy file.

Cache attack:
  - steps:
     - Alice write confidential information, then cached/stored
     - Mallory takes control of Alice's device
     - Mallory read cached confidential information
  - examples:
     - accessing someone else device then browsing to logged in websites
     - use authentication URL with cached authentication headers
  - solution:
     - do not cache/store confidential information, or for shorter time
        - e.g. use no-cache="HEADER" for confidential headers, no caching for confidential body

Cache poisoning:
  - setting a cache value to an arbitrary value
  - cache might be shared by several clients, in which case one client can affect others

Cookies:
  - cannot rely only on cookies for authorization, must also use anti-CSRF measures
  - content should be encrypted (for confidentiality) and signed (for authenticity) even over HTTPS
  - should use secure and HttpOnly
  - content should contain key (to server-side hash table, e.g. session id) not direct information
  - service on same URL but different port can access cookie
  - service on same domain or superdomain can set cookies

Open redirect:
  - redirection that depends on user-generated content in URLs
     - allowing user-generated URLs has same risk as well
  - if not validated, allows user to browse to different website without consent
     - can lead to phishing

Normalization:
  - when a VAL has different variants, which should be considered equal
  - if not normalized, comparison can fail
  - examples:
     - transtyping
     - charset, encoding
     - STR: case, Unicode normalization
     - NUM: radix, FLOAT representation, decimal digits, epsilon, i18n (e.g. separators)
     - OBJ: keys order
     - ARR: order
     - base64: padding, chars outside charset, newlines
     - paths: symlinks
     - path/URIs: . .., relative links, duplicate /
     - URIs: default parts, unused parts

Browser sandbox:
  - see about:sandbox (Chrome/Opera), about:support#sandbox (Firefox)

Tracking:
  - privacy concern: giving personal information without consent is akin to forced negotiation (i.e. weakens one side of the negotation)
  - can be:
     - sanctioned, i.e. user control: user consent, based on standards so easy to detect (e.g. cookies, localStorage)
     - unsanctioned: e.g. fingerprinting, supercookies
  - standard: W3C TAG "Unsanctioned tracking"

Device|machine fingerprinting:
  - identifying a device|machine by device|machine capabilities instead of usual state mechanisms (e.g. cookies)
  - should be:
     - diverse:
        - number of possible combinations (measured in bits of entropy)
        - combinations are evenly distributed
     - stable: does not change over time
     - more capabilities add diversity but might reduce stability
        - however can update new configuration if only parts of it changes, providing the other part has enough diversity entropy
  - capabilities:
     - passive (read-only):
        - browser:
           - active extensions, e.g. AdBlock
        - HTTP:
           - User-Agent [C]
           - Accept* [C]
           - Connection [C]
           - DNT [C]
        - JavaScript:
           - DATE.getTimezoneOffset()
           - supported features, e.g. ES6
        - DOM:
           - CANVAS: draw 2D|3D to see variations due to different GPU
           - NAVIGATOR: plugins, platform, cookieEnabled
           - SCREEN: height, width, colorDepth
           - supported features, e.g. localStorage|sessionStorage
        - Flash:
           - list of OS fonts
        - NTP:
           - clock skew: small sync difference (in ms)
        - TCP/IP:
           - configuration
              - initial packet size, initial TTL, window size, max segment size, window scaling value, flags (don't fragment, sackOK, nop)
              - 67 bits of entropy
              - eases OS fingerprinting
        - IEEE 802.11 (wireless)
        - OS
     - active (can write on machine)
        - MAC address
        - machine serial number
        - HTTP enrichment (network proxies adding HTTP headers)
  - protection:
     - not sending capabilities information
     - randomizing capabilities information

Referer: URI [C]:
  - current URI (without USERINFO nor #HASH)
     - about:blank means no current URI
  - problems:
     - privacy concern: might deduce identity from current URI
     - confidentiality: if capability URI
  - solutions:
     - for specific HTTP request: WINDOW.fetch() REQ.referrer
     - for any HTTP request: "Referrer Policy":
        - VAL (def: 'no-referrer-when-downgrade'):
           +---------------------------------+-----------------+--------------+-------------+
           | NAME                            | HTTPS->HTTP     | CROSS-ORIGIN | SAME-ORIGIN |
           |                                 | (HAS PRIO)      |              |             |
           +---------------------------------+-----------------+--------------+-------------+
           | no-referrer                     | does not matter | unset                      |
           +---------------------------------+-----------------+----------------------------+
           | strict-origin                   | unset           | ORIGIN                     |
           +---------------------------------+-----------------+----------------------------+
           | origin                          | does not matter | ORIGIN                     |
           +---------------------------------+-----------------+--------------+-------------+
           | same-origin                     | does not matter | unset        | URI         |
           +---------------------------------+-----------------+--------------+-------------+
           | strict-origin-when-cross-origin | unset           | ORIGIN       | URI         |
           +---------------------------------+-----------------+--------------+-------------+
           | origin-when-cross-origin        | does not matter | ORIGIN       | URI         |
           +---------------------------------+-----------------+--------------+-------------+
           | no-referrer-when-downgrade      | unset           | URI                        |
           +---------------------------------+-----------------+----------------------------+
           | unsafe-url                      | does not matter | URI                        |
           +---------------------------------+-----------------+----------------------------+
        - can specify using:
           - Referrer-Policy: VAL [S]
           - <meta name="referrer" content="VAL">
           - <a|area|iframe|img|link referrerpolicy="VAL">
           - WINDOW.fetch() REQ.referrerPolicy
           - CSP referrer
        - Link: noreferrer [S] or <... rel="noreferrer"> can also be used
     - browser support:
        - not IE11, except for Link: noreferrer [S] or <... rel="noreferrer">, but degrades gracefully
