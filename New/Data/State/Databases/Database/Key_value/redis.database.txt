
           
   REDIS   
           


VERSION ==>                   #Version: 3.0 beta8

PACKAGES ==>                  #  - redis-server: redis-server, redis-sentinel
                              #  - redis-tools: redis-cli, redis-benchmark, redis-check-dump|aof

SHORT SUMMARY ==>             #Use case:
                              #  - key-value store
                              #  - eleviates application logic with:
                              #     - structured data types: strings, int, floats, binary, objects, list/array, sets, zsets (sets with weights), hyperloglog (sets for counting unique elements)
                              #     - algorithms: sorting
                              #  - pubsub system
                              #  - good use as a cache:
                              #     - "maxmemory": limiting memory (e.g. LRU)
                              #     - expiration on keys
                              #Main properties:
                              #  - optimized for speed
                              #     - performance: cursors
                              #  - poor security on its own (by design)
                              #Other properties:
                              #  - ACID:
                              #     - atomicity/consistency/isolation:
                              #        - strong because single-threaded, every operation atomic
                              #        - can use transactions
                              #     - durability:
                              #        - RDB: compressed snapshot/backups saved on demand or automatically on change
                              #        - AOF: 
                              #           - log incoming commands, to reduce crash problems
                              #           - can control how durability/caching tradeoff (i.e. flushing to disk)
                              #  - Scaling: 
                              #     - replication: read-only slaves
                              #     - clusters: distribute data accross several read-write servers (using modulo of hash(KEY))
                              #  - High availability: sentinels: monitor for failover to replicated slaves. Can handle partitions.
                              #  - Monitoring: logging, debug info, performance (latency, slow operations)
                              #  - connection control (e.g. max clients)
                              #  - simple text-based protocol
                              #  - limits: 4 billions keys, objects with 4 billions elements

LONG SUMMARY ==>              #Database: 
                              #  - select NUM (switch to database)
                              #Server:
                              #  - redis-server (start server)
                              #  - CONFFILE redis.conf (init-style)
                              #     - also --CONFVAR VAL, config get "GLOB", config set CONFVAR VAL, config rewrite
                              #Connection: 
                              #  - CONFVAR bind, port, unixsocket
                              #  - redis://USER:PASSWORD@HOST:PORT/DATABASE_NUM
                              #  - CONFVAR maxclients, tcpbacklog
                              #  - CONFVAR client-output-buffer-limit, timeout, tcp-keepalive
                              #  - (server to client) client pause UINT, client kill UINT, client list, info clients
                              #  - (client itself) quit, shutdown
                              #Durability:
                              #  - RDB (snapshot/backup):
                              #     - [bg]save, lastsave
                              #     - CONFVAR dbfilename, dir
                              #     - CONFVAR rdbcompression, rdbchecksum
                              #     - CONFVAR save (automatically save)
                              #     - CONFVAR stop-writes-on-bgsave-error
                              #  - AOF (logs incoming commands):
                              #     - CONFVAR appendonly, appendfilename
                              #     - bgrewriteaof (compress)
                              #     - CONFVAR appendfsync, no-appendfsync-on-rewrite
                              #  - info persistence
                              #Replication:
                              #  - read-only replicating slaves, for scalability
                              #  - slaveof HOST PORT (or CONFVAR) (declaration)
                              #  - sync, CONFVAR slave-serve-stale-data (starts replication)
                              #  - psync, CONFVAR repl-backlog-size, CONFVAR repl-backlog-ttl (restarts replication)
                              #  - CONFVAR repl-ping-slave-timeout, repl-timeout (when master is considered down)
                              #  - CONFVAR slave-read-only, repl-disable-tcp-nodelay
                              #  - roles, info replication
                              #  - redis-cli --slave (simulation)
                              #Sentinels:
                              #  - replicating slaves, but for failovers. Each server should have one sentinel
                              #  - SENTCONF, SENTVAR (specific conf for sentinels)
                              #  - sentinel monitor MASTER IP PORT UINT, sentinel remove MASTER, sentinel set SENTVAR VAL
                              #  - redis-sentinel SENTCONF (launches sentinel)
                              #  - SENTVAR port, dir
                              #  - SENTVAR sentinel monitor, down-after-milliseconds (declaration)
                              #  - CONFVAR slave-priority (which is next master)
                              #  - SENTVAR sentinel parallel-sync, failover-timeout (failover timing)
                              #  - debug segfault (simulation)
                              #  - CONFVAR min-slaves-to-write, min-slaves-max-lag (avoid partitions)
                              #  - ping, sentinel master MASTER, sentinel masters, sentinel slaves MASTER, sentinel get-master-addr-by-name MASTR (debug)
                              #  - sentinel reset MASTER_GLOB_STR, sentinel failover MASTER (simulation)
                              #  - SENTVAR sentinel client-reconfig-script, sentinel notification-script (fires script on failovers)
                              #  - pubsub events on failovers
                              #Clusters:
                              #  - distribute data accross several servers, for scaling, using modulo of hash(KEY)
                              #Logs:
                              #  - CONFVAR loglevel, logfile
                              #  - CONFVAR syslog-enabled, syslog-ident, syslog-facility
                              #Monitoring:
                              #  - CONFVAR latency-monitor-threshold, latency latest|history|reset|graph|doctor (high-latency commands)
                              #  - time, ping, echo (debug)
                              #  - info all|redis_version|redis_mode|os|arch_bits|process_id|run_id|tcp_port|uptime_in_seconds|days|hz|config_file
                              #  - resetstat
                              #  - redis-cli --latency[-history], --intrisic-latency, redis-stat
                              #  - monitor (prints all commands received)
                              #Limits:
                              #  - CONFVAR databases (def: 16)
                              #  - 4 billions keys
                              #  - OBJ|LIST|SET|ZSET with 4 billions elements
                              #  - 512MB STR
                              #  - 64 bits [U]INT, double floats
                              #Performance:
                              #  - CONFVAR maxmemory, maxmemory-policy (e.g. LRU, random), maxmemory-samples (accuracy)
                              #  - dbsize, info keyspace, info memory (debug)
                              #  - slowlog get, slowlog len, slowlog reset, CONFVAR slow-log-slower-than, slowlog-max-len (slow commands)
                              #  - info total_connections_received, total_commands_processed, instantaneous_ops_per_sec, rejected_connections,
                              #    expired|evicted_keys, keyspace_hits|misses, pubsub_channels|patterns, latest_fork_usec, used_cpu_sys|user[_children],
                              #    cmdstat_COMMAND (debug)
                              #  - redis-benchmark
                              #Security:
                              #  - almost non-existing (optimized for speed instead)
                              #  - CONFVAR requirepass, masterauth (client password)
                              #  - CONFVAR rename-command (obfuscate command name)
                              #Protocols:
                              #  - simple text-based
                              #Transactions:
                              #  - single-threaded, operations always atomic, so two commands cannot happen at once
                              #  - multi ... exec|discard (transaction)
                              #  - watch VAR ... unwatch (make sure VAR is not modified)
                              #General:
                              #  - type VAR (typeof)
                              #  - object idletime VAR (atime)
                              #  - rename[nx] VAR VAR2 (nx: no overwrite)
                              #  - move VAR UINT (move to another database)
                              #  - dump VAR, restore VAR UINT STR, migrate HOST PORT VAR UINT UINT2 [copy] [replace] (serialization)
                              #  - keys GLOB_STR (return all keys)
                              #  - randomkey
                              #Remove:
                              #  - flush[db|all] (remove all)
                              #  - exists VAR
                              #  - del VAR...
                              #  - [p]expire[at] VAR UINT (set expiration time|date, "p" is milliseconds)
                              #  - [p]ttl VAR (get expiration)
                              #  - persist VAR (remove expiration)
                              #Strings:
                              #  - set STR STR2 [ex|px NUM] [nx|xx] (ex|px sets expiration) (nx|xx checks for [non-]existence)
                              #  - get STR
                              #  - getset STR STR2
                              #  - mset[nx] STR STR2 ..., mget STR... (batch)
                              #  - strlen STR (STR.length)
                              #  - setrange STR OFFSET STR2 (STR[OFFSET] = STR2)
                              #  - getrange STR INT INT2
                              #  - append STR STR2 (STR += STR2)
                              #Numbers:
                              #  - incrby|decrby INT NUM, incr|decr INT, incrbyfloat FLOAT FLOAT2
                              #Binary:
                              #  - getbit BITSTR UINT
                              #  - setbit BITSTR UINT 1|0
                              #  - bitpos BITSTR 1|0 [INT INT2] (first 1|0)
                              #  - bitcount BITSTR
                              #  - bitop and|or|xor|not BITSTR... (bitwise operations)
                              #Objects:
                              #  - hset[nx] OBJ VAR STR, hget OBJ VAR, hmget OBJ VAR ..., hmset OBJ VAR STR ..., hdel OBJ VAR..., hexists OBJ VAR, hincrby[float] OBJ VAR INT|FLOAT 
                              #    (like STR, but namespaced)
                              #  - hlen OBJ (number of keys)
                              #  - hgetall OBJ, hkeys OBJ, hvals OBJ (get keys|values)
                              #Lists:
                              #  - l|rpush[x] LIST STR... (insert at end|beginning)
                              #  - l|rpop LIST (remove)
                              #  - rpoplpush LIST LIST2 (move)
                              #  - llen LIST (length)
                              #  - lindex LIST INT (get single value)
                              #  - lset LIST INT STR (set single value)
                              #  - linsert LIST before|after STR STR2 (insert in middle)
                              #  - lrange LIST INT INT2 (get range)
                              #  - ltrim LIST INT INT2 (only keep specific range)
                              #  - lrem LIST INT STR (remove any|INT matching values)
                              #  - blpop|brpop LIST... UINT, brpoplpush LIST LIST2 UINT (queues, i.e. wait until list not empty)
                              #Sets:
                              #  - sadd SET STR... (add)
                              #  - srem SET STR... (remove)
                              #  - scard SET (length)
                              #  - smembers SET (get all)
                              #  - sismember SET STR
                              #  - sunion|sinter|sdiff[store] SET... (combinations)
                              #  - srandmember SET [INT] (get random elements)
                              #  - spop SET (pop random element)
                              #  - smove SET SET2 STR (move)
                              #ZSets:
                              #  - zadd ZSET SCOR_FLOAT STR ... (add)
                              #  - zincrby ZSET FLOAT STR (add to score)
                              #  - zscore ZSET STR (get score)
                              #  - z[rev]rank ZSET STR (get position)
                              #  - z[rev]range ZSET INT INT2 [withscores], z[rev]rangebyscore ZSET FLOAT FLOAT2 [withscores] [limit UINT UINT2], zrangebylex ZSET STR STR2 [limit UINT UINT2] (get range)
                              #  - zcard ZSET, zcount ZSET FLOAT FLOAT2, zlexcount ZSET STR STR2 (length)
                              #  - zrem ZSET STR..., zremrangebyrank ZST INT INT2, zremrangebyscore ZSET FLOAT FLOAT2, zremrangebylex ZSET STR STR2 (remove)
                              #  - zunionstore|zinterstore ZSET UINT ZSET2... [weights FLOAT...] [aggregate sum|min|max] (combination, with weights and sum|min|max)
                              #Hyperloglog:
                              #  - pfadd HYPERLOGLOG STR... (add)
                              #  - pfcount HYPERLOGLOG... (length)
                              #  - pfmerge HYPERLOGLOG HYPERLOGLOG2... (merge)
                              #Sorts & scan:
                              #  - sort LIST|SET|ZSET [by STR] [limit UINT UINT2] [get STR ...] [asc|desc] [alpha] [store LIST|SET|ZSET]
                              #  - scan|hscan|sscan|zscan UINT|OBJ|LIST|ZSET [match GLOB_STR] [count UINT3] (cursor)
                              #Pubsub:
                              #  - subscribe CHANNEL_STR..., unsubscribe [CHANNEL_STR...] (subscription)
                              #  - psubscribe CHNEL_GLOB_STR..., punsubscribe [CHANNEL_GLOB_STR...] (subscription with globbing)
                              #  - publish CHANNEL_STR STR2 (emit)
                              #  - pubsub channels [CHANNEL_GLOB_STR] (get channels)
                              #  - pubsub numsub CHANNEL_STR... (get subcriptions length)
                              #  - pubsub numpat (get active psubcribe length)
                              #  - CONFVAR notify-keyspace-events (listen for any change on the database)
                              #Clients:
                              #  - redis-cli
                              #  - REDIS (Node.js)




                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           DATABASES           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


DATABASES ==>                 #Redis databases are named with a NUM.
select [NUM]                  #Client command to switch to database NUM (def: 0). Returns "OK"


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            SERVER             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


redis-server [CONFFILE]       #Starts a set of databases:
                              #  - called "cluster" for PostgreSQL, but cluster has special meaning in Redis (master-master replication)
                              #Should be run under redis SHELL_USER and redis SHELL_GROUP:
                              #  - server runtime directory is $HOME (/var/run/redis/ for redis SHELL_USER)
                              #  - should be owned by redis SHELL_USER and redis SHELL_GROUP
                              #CONFFILE:
                              #  - is redis.conf (def: /etc/redis/redis.conf)
                              #  - can be - for stdin
                              #If CONFVAR daemonize yes (def): 
                              #  - run in background
                              #  - creates a PID file at CONFVAR pidfile (def: /var/run/redis/redis-server.pid)
                              #Should setup /etc/init.d/ script to start redis-server at start time

CONFFILE                      #Values are CONFVAR:
                              #  - VAR VAL
                              #  - can use human readable size
                              #  - include FILE can be used
                              #Can also use:
                              #  - redis-server --CONFVAR VAL
                              #  - config get "GLOB": returns [ CONFVAR VAL [...] ]
                              #  - config set CONFVAR VAL: some differences with CONFFILE:
                              #     - cannot use human readable size
                              #     - not persisted
                              #     - save UINT UINT2; save UINT3 UINT4 -> save UINT UINT2 UINT3 UINT4
                              #  - config rewrite: 
                              #     - persisted, i.e. overwrite CONFFILE according to changes made with config set
                              #     - tries to conserve comments, etc. as much as possible


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          CONNECTIONS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CONNECTION ==>                #Server connection at CONFVAR:
                              #  - bind (def: 127.0.0.1, can be several): address
                              #  - port (def: 6379)
                              #  - unixsocket: optional
                              #  - unixsocketperm
REDIS_URL                     #redis://USER:PASSWORD@HOST:PORT/DATABASE_NUM

CONFVAR maxclients            #  - def: ulimit -Sn minus 32
                              #  - by def., tries to do ulimit -n 10032
                              #     - can use /etc/default/redis-server with ULIMIT = n to call ulimit when redis-server is 
                              #       called
                              #  - when reaching limit, close new connections with ERROR
CONFVAR tcp-backlog           #TCP backlog (def: 511), i.e. max number of pending incoming connections

CONFVAR                       #CLASS SIZE SIZE2 UINT:
  client-output-buffer-limit  #Output from server to client is buffered, but could grow infinitely if gets too much input
                              #  - should only happen for pubsub or slaves, since normal clients wait for answer to reply
                              #This CONFVAR:
                              #  - closes client connection if:
                              #     - buffer grows of SIZE2/UINT sec. (0 to disable)
                              #     - or buffer grows over SIZE (0 to disable)
                              #  - CLASS is the type of client: normal (def: 0 0 0), pubsub (def: 32MB, 8MB/min), 
                              #    slave (def: 256MB, 64MB/min)

CONFVAR timeout               #NUM (in sec., def: 0, i.e. none): closes client connection after idle time (approx. time) (not pubsub clients)
CONFVAR tcp-keepalive         #NUM (in sec., def: 0)


client pause UINT             #Stops all interaction clients-server (except slaves) for UINT ms, then resume them normally
                              #Returns "OK"
                              #Used for maintainance:
                              #  - instead of stopping the server alltogether
                              #  - e.g. during failover: waiting for slaves to get all streams (using info replication), 
                              #    then switching everyone to new master
client kill ...               #... can be:
                              #  - addr IP:PORT
                              #  - id UINT
                              #  - type "normal|pubsub|slave"
                              #  - skipme yes|no: if yes (def), client calling this command is not killed
                              #Returns number of clients killed
                              #Wait for ongoing client command to end
client list                   #Returns STR where each line is one client with VAR=VAL ...:
                              #  - id UINT
                              #  - addr IP:PORT
                              #  - fd NUM
                              #  - name STR (def: ""): must use command client setname|getname
                              #  - age UINT: how many sec. connected
                              #  - idle UINT
                              #  - flags STR:
                              #     - "N": no flag
                              #     - "M": master
                              #     - "O": slave in monitor mode
                              #     - "S": slave not in monitor mode
                              #     - "x": transaction ongoing
                              #     - "d": transaction that will fail due to watch ongoing
                              #     - "c|A": transaction to be closed [ASAP]
                              #     - "b|u": [stops to] wait in a blocking operation
                              #  - db UINT
                              #  - [p]sub UINT
                              #  - multi: -1 if not in transaction
                              #  - qbuf[-free] UINT: input buffer size used|allowed
                              #  - omem UINT: output buffer size
                              #  - obl UINT: output buffer length
                              #  - oll UINT: output list length
                              #  - events "r|w": client socket is readable|writable
                              #  - cmd STR: last command played
info clients                  #connected_clients, blocked_clients, client_longest_output_list, client_biggest_input_buf


quit                          #Single-client stop. Ask server to flushes pending replies, then quit. Returns "OK"
                              #If client loses connection, just return ERROR until connection is established again.
shutdown [save|nosave]        #All-clients stop. Fired by SIGTERM:
                              #  - wait for clients to stop
                              #  - sync. save RDB (if used, unless|if save|nosave is used)
                              #  - flush AOF (if used)
                              #  - kill Lua scripts with script kill
                              #  - removes pid file and (if used) Unix socket
                              #  - returns STR if error, e.g. can't save (nothing if success)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          DURABILITY           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


DURABILITY ==>                #Runtime is only in-memory.
                              #But can do persistence on-disk with (can do both) RDB or AOF
                              #Should:
                              #  - no RDB nor AOF if no care of durability
                              #  - RDB alone if several hours loss is ok
                              #  - RDB+AOF if only 1 minute to few secs. loss is ok

RDB ==>                       #Point-in-time snapshots/backups: when restarts, read state from RDB file
[bg]save                      #[a]sync. save (prefer bgsave) returning "OK"
                              #  - CPU-intensive, can stop the database for up to one second
                              #  - background save requires:
                              #     - /etc/sysctl.conf vm.overcommit_memory = 1
                              #        - then reboot or sysctl vm.overcommit_memory=1
                              #     - so fork doesn't multiply memory by 2 (share parent's memory)
lastsave                      #Returns Unix time UINT3 for last successful save 
                              #Can be used to check if bgsave succeeded
CONFVAR dbfilename            #Def: "dump.rdb"
CONFVAR dir                   #Def: "/var/lib/redis/". also for AOF
CONFVAR rdbcompression        #yes (def)
CONFVAR rdbchecksum           #yes (def)
                              #Can check file with redis-check-dump DUMPFILE
CONFVAR save                  #UINT UINT2
                              #Checks every UINT seconds if UINT2 keys were changed, then bgsave
                              #  - can be set up several times
                              #  - def: 10000keys/min, 10keys/5min, 1key/15min
CONFVAR                       #yes (def)
  stop-writes-on-bgsave-error #Returns ERROR on any write after a bgsave error, until a new bgsave succeeds

AOF ==>                       #"Append only file"
                              #Logs every write command received before being performed (similar to PostgreSQL WAL)
                              #  - if crash and restart, replay the AOF instead of reading the RDB file
                              #  - slower restart than RDB alone
                              #  - but stronger guarantee (do not lose anything if crash)
                              #If crash while writing AOF:
                              #  - make backup of AOF to OLD_AOF
                              #  - do command line redis-check-aof AOF --fix
                              #  - check diff OLD_AOF NEW_AOF
CONFVAR appendonly            #yes
CONFVAR appendfilename        #Def: "appendonly.aof"
bgrewriteaof                  #Refactor AOF (remove unnecessary commands)
                              #Returns "OK"
                              #Automatically done when AOF has grown more than:
                              #  - CONFVAR auto-aof-rewrite-min-size SIZE (def:64mb)
                              #  - and CONFVAR auto-aof-rewrite-percentage NUM (def: 100)
CONFVAR appendfsync           #Controls flushing to AOF:
                              #  - no: let OS flush, very fast
                              #  - everysec: flushes every sec., not too slow
                              #  - always: always flushes, very slow
CONFVAR                       #yes
  no-appendfsync-on-rewrite   #Put appendfsync to "no" if bgsave or bgrewriteaof is being performed, to avoid slowing down the database too much.
                              #Can last up to 30 secs, so should be avoided

info persistence              #Returns:
                              #  - loading: if loading RDB, also:
                              #     - loading_start_time
                              #     - loading_total_bytes
                              #     - loading_loaded_bytes|perc
                              #     - loading_eta_seconds
                              #  - rdb_bgsave_in_progress
                              #  - rdb_changes_since_last_save: number of operations since last save
                              #  - rdb_last|current_bgsave_status|time_sec
                              #  - aof_enabled: if enabled also:
                              #     - aof_base|current_size
                              #     - aof_pending_rewrite
                              #     - aof_[rewrite_]buffer_length
                              #     - aof_pending_bio_fsync
                              #     - aof_delayed_fsync
                              #  - aof_rewrite_in_progress|scheduled
                              #  - aof_last|current_rewrite_time_sec
                              #  - aof_last_[bgre]write_status


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          REPLICATION          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


REPLICATION ==>               #Principles:
                              #  - RDB shipping on first connection, async. log shipping after
                              #     - there is a loss window in the time to ship log
                              #  - goal: 
                              #     - scalability (read-only slaves)
                              #     - high availability (failover): see below

slaveof HOST PORT             #Declares replication:
                              #  - if master down, make slave a master
                              #     - turns down replication to former master, but do not discard it, so can rebecome a slave if former master is back
                              #  - can make a slave to another slave
CONFVAR slaveof HOST PORT     #Alternative

sync                          #Starts replication
                              #Master does bgsave then ships RDB to all slaves that apply it
                              #While applying, they block queries
CONFVAR slave-serve-stale-data#If yes (def), with "sync", while waiting for RDB or when connection is lost, slaves serve old version of RDB 
                              #If no, respond with ERROR
psync                         #Like "sync" but for more suited for slaves reconnecting:
                              #  - master accumulates log during connection lost, then apply it on slave reconnection
                              #  - faster (do not reload everything)
CONFVAR repl-backlog-size     #Max log SIZE (def: 1MB) accumulated by master. Beyond, do "sync" instead
CONFVAR repl-backlog-ttl      #Max time to keep accumulated lof if no more slaves (def: 3600)

CONFVAR repl-ping-slave-period#UINT (def: 10, in secs): pings from slaves to master, to consider connection broken.
CONFVAR repl-timeout          #UINT (def: 60): pings timeouts

CONFVAR slave-read-only       #yes is def: slaves are conceptually read-only, only master should get write operations, so it's propagated to all slaves
                              #If no, allow slave-specific write operations:
                              #  - like info about master reachability (to coordinate failover strategy)
                              #  - but not usual write operations (would not propagate)

CONFVAR 
  repl-disable-tcp-nodelay    #On clients (def: no, which should be good)

roles                         #Returns [ "master|slave|sentinel", OFFSET, [ HOST, PORT, OFFSET2 ]... ]
                              #  - difference OFFSET - OFFSET2 show difference slave-master
                              #  - HOST:PORT are slaves (when master)
info replication              #Returns: roles, master_host|port, master_link_status, master_last_io_seconds_ago, master_sync_in_progress, connected_slaves,
                              #  - master_sync_left_bytes and master_sync_last_io_seconds_ago: if sync
                              #  - master_link_down_since_seconds: if down
                              #  - slaveNUM: id, ip, address, port, state

redis-cli --slave             #Simulate slave, showing commands received from master


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          AVAILABLITY          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SENTINEL ==>                  #Goal: high availability (failover)
                              #Each redis-server should also launch a sentinel
                              #Similar to a redis-server, protocol-wise

SENTCONF|SENTVAR              #Like CONFFILE|CONFVAR, but for sentinels
redis-server SENTCONF         
 --sentinel                   #Start a sentinel
redis-sentinal SENTCONF       #Same

SENTVAR port                  #Def: 26379. All sentinels should use same port.
SENTVAR dir                   #Def: "/tmp"


SENTVAR sentinel monitor      #MASTER HOST PORT UINT
                              #Sets master (def HOST PORT: localhost). Only need to specify masters (slaves and failovers are auto-discover)
                              #Also sets how many sentinels need to think the master is down to start failover (UINT, def: 2)
SENTVR down-after-milliseconds#MASTER UINT (def: 30000)
                              #How many milliseconds until master is considered down

CONFVAR slave-priority        #UINT (def: 100, 0 to disable).
                              #Slave with lowest priority is next to be promoted master, during failover
SENTVAR sentinel parallel-sync#UINT (def: 1)
                              #How many slaves at a time can configure to new master, during failover
SENTVAR failover-timeout      #UINT
                              #How long other sentinels wait for the sentinel in charge to change SENTINELFILE to change theirs (one at a time)

debug segfault                #Similate master crash


CONFVAR min-slaves-to-write   #On master. UINT.
                              #Master do not allow write commands if <UINT slaves connected
                              #Goal:
                              #  - if partition (slaves lose connection to master, one is promoted):
                              #     - two partitions with masters. 
                              #     - when merge, write info of one master will be lost.
                              #  - can prevent small partitions with less than majority of the system to allow writes with this
CONFVAR min-slaves-max-lag    #UINT. Same for max lag in secs.


SENTINEL COMMNANDS ==>        #Following commands are when connected to a sentinel
ping                          #Returns "PONG"
sentinel master MASTER        #Returns info about MASTER
sentinel masters              #Same as ARR
sentinel slaves MASTER        #Returns list of slaves
sentinel 
 get-master-addr-by-name MASTR#Returns IP:PORT
sentinel reset MASTER_GLOB_STR#Restart discovery process
sentinel failover MASTER      #Forces a failover, good if need to reboot master

SENTINELFILE                  #File recording the CONFEPOCH, i.e. version of current slave/masters configuration
                              #Changed by the sentinel in charge during failover, i.e. the one which will be promoted
SENTINELFILE COMMANDS ==>     #Commands to update the SENTINELFILE (must be done on all sentinels):
sentinel monitor 
 MASTER IP PORT UINT          #Like sentinel monitor SENTVAR
sentinel remove MASTER        #
sentinel set SENTVAR VAL      #


SENTVAR sentinel              #MASTER FILE
 client-reconfig-script       #On failovers, will fire FILE (e.g. Bash) with arguments: MASTER "leader|observer" "failover" OLD_IP NEW_IP OLD_PORT NEW_PORT
                              #  - leader is whether the current sentinel is in charge of failover
                              #  - IP|PORT are of the master
SENTVAR sentinel              #MASTER FILE
 notification-script          #On any event (see below), will fire FILE EVENT_TYPE EVENT_DESC
                              #FILE:
                              #  - must run in 60s
                              #  - will be retried if exit code is 1

PUBSUB EVENTS ==>             #Emitted by sentinels:
                              #  - they all get as message "master|slave" NAME IP PORT [@ MASTER IP PORT]
                              #  - can see events on sentinel log
                              #  - events: +reset-master, +slave, +failover-state-reconf-slaves, +failover-detected, 
                              #    +slave-reconf-sent|inprog|done, -dup-sentinel, +sentinel, +|-sdown, +|-odown, +new-epoch,
                              #    +try-failover, +elected-leader, +failover-state-select-slave, no-good-slave, selected-slave,
                              #    failover-state-send-slaveof-none, failover-end-for-timeout, failover-end, switch-master, +|-tilt


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           CLUSTERS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


PARTITIONS ==>                #Goal is to scale memory and CPU.
                              #Can be:
                              #  - range partioning: according to NUM ranges
                              #  - hash partioning: modulo of hash(KEY)
                              #Choosing the right Redis instance/partition can be done:
                              #  - client-side (Redis client)
                              #  - proxy-assisted (done by a proxy)
                              #  - query-routing: client sends to random redis server instance, which resends to the right instance
                              #Problems:
                              #  - disable operations with several keys (e.g. unions|intersections, or transactions with several keys)
                              #  - make backups, etc. spread accross several files
                              #  - when not implemented correctly, hard to scale (add|remove partitions)

REDIS CLUSTER ==>             #Allow master-master replication (write operations scaled on several masters) using hash partioning with query-routing (with help from client-side)
                              #But still in alpha as of 3.0 beta8, should complete later (including info cluster, redis-cli -c)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             LOGS              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CONFVAR loglevel              #debug|verbose|notice (def)|warning
CONFVAR logfile               #FILE (def: /var/log/redis/redis-server.log) ("" for stdout)

CONFVAR syslog-enabled        #yes|no (def: no)
                              #Uses /etc/logrotate.d/
CONFVAR syslog-ident          #STR
CONFVAR syslog-facility       #STR


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          MONITORING           :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CONFVAR                       #UINT (def: 0, e.g. disable)
 latency-monitor-threshold    #Record (in-memory) up to 160 operations with latency >= UINTms
                              #Query with the following commands
latency latest                #[ EVENT_STR, TIMESTAMP, LATENCY, MAX_RECORDED_LATENCY ]
latency history EVENT_STR     #[ [ TIMESTAMP, LATENCY ]... ]
latency reset EVENT_STR...    #
latency graph EVENT_STR       #ASCII graph
latency doctor                #Human readable output

time                          #Show current time as [ EPOCH_SEC, MICROSECS ]
ping                          #Returns "PONG". To check connection or latency.
echo STR                      #Same with STR

info all                      #
info redis_version            #
info redis_mode               #
info os                       #
info arch_bits                #
info process_id               #
info run_id                   #
info tcp_port                 #
info uptime_in_seconds|days   #
info hz                       #
info config_file              #
resetstat                     #Reset all data collected for info *

redis-cli --latency[-history] 
 [-i INTERVAL]                #Show latency at regular intervals
redis-cli 
 --intrinsic-latency NUM      #NUM is how many seconds test last
redis-stat                    #Only monitoring tool I found that do not use command monitor (slow)

monitor                       #Print all commands received by server (for debugging)


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            LIMITS             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


LIMITS ==>                    #  - Databases: CONFVAR databases (def: 16)
                              #  - Set of databases: 2^32 keys (4 billions)
                              #  - Types:
                              #     - OBJ|LIST|SET|ZSET: 2^32 elements
                              #     - STR: 512MB
                              #     - INT: 64 bits signed
                              #     - UINT: 63 bits unsigned
                              #     - FLOAT: DOUBLE truncated to 17 decimals


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          PERFORMANCE          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CONFVAR maxmemory             #SIZE (def: none on 64 bits, 3GB on 32 bits)
                              #Goal is either to avoid crashes, or implement a LRU cache
                              #If there are slaves, should let enough RAM memory for output buffers to slaves (see CONFVAR client-output-buffer-limit slave)
CONFVAR maxmemory-policy      #What to do when over the limit, on write operation:
                              #  - volatile|all-lru (def: volatile-lru): removes last recently used VAR [with ttl], from a sample
                              #  - volatile|allkeys-random: removes any VAR [with ttl]
                              #  - volatile-ttl: removes VAR with lowest ttl, from a sample
                              #  - noeviction: returns an ERROR
                              #Still return ERROR with other than "noeviction" if there are no suitable key to erase
                              #All maxmemory-policy but noeviction allow using Redis as a cache:
                              #  - all-lru is good for LRU cache
                              #  - allkeys-random is good for evenly distributed keyspace
                              #  - volatile-lru|random are good when mixing persistent and volatile keys, but should prefer divide into two different Redis instances
                              #  - noeviction should be used if not used as a cache.
CONFVAR maxmemory-samples     #Sample size (number of keys) (def: 3) for volatile-ttl and *-lru


dbsize                        #Returns number of keys
info keyspace                 #Returns dbNUM: keys, expires, avg_ttl
info memory                   #Returns used_memory[_rss|peak][_human], used_memory_lua, mem_fragmentation_ratio
                              #If used_memory_rss > used_memory, means memory fragmentation (see also mem_fragmentation_ratio)

slowlog get [UINT]            #Returns slow commands [ UINT2, TIMESTAMP, TIME_MICROSECS, COMMAND ], according to followinf CONFVARs
                              #Slow commands are stored in memory
CONFVAR slow-log-slower-than  #UINT (microsecs, def: 10000, 0 for all, -1 for none) 
CONFVAR slowlog-max-len       #UINT (def: 128)
slowlog len                   #Returns CONFVAR slowlog-max-len
slowlog reset                 #

info 
 total_connections_received   #
info total_commands_processed #
info instantaneous_ops_per_sec#
info rejected_connections     #
info expired|evicted_keys     #
info keyspace_hits|misses     #
info pubsub_channels|patterns #
info latest_fork_usec         #
info 
  used_cpu_sys|user[_children]#
info cmdstat_COMMAND          #With COMMAND: calls, usec_per_call


HOW TO USE LESS SPACE/MEMORY  #  - use 32 bits CPU (but memory will be limited to 4GB)
  ==>                         #  - using BITSTR
                              #  - uses OBJ instead of namespaced STR

TIPS ==>                      #  - Use pipelining
                              #  - when writing big chunks, should use protocol: write commands in a .txt file, and send it 
                              #    with ncap or (better) with redis-cli --pipe (will parse "inline version" of the protocol)
                              #  - most important factors: latency&bandwith > CPU > Mem speed
                              #  - Unix sockets faster that loopback
                              #  - Single threaded, so must launch 1 redis-server per CPU core (see Redis Cluster)
                              #  - put log files, RDB and AOF on same device
                              #  - don't use monitor in production, but info is fine
                              #  - CONFVAR hz (def: 10): raising will increase CPU usage but lower latency


redis-benchmark [...]         #Perform lot of operations, then report timing.
                              #Test are ping_inline|bulk, set, get, incr, lpush, lpop, sadd, spop, lrange_100|300|500|600, mset. 
                              #Can also have custom operations with ..., e.g. redis-benchmark script load ARG
-h HOST
-p PORT
-s SOCKET
-c NUM                        #Number of clients at same time (def: 50)
-n NUM                        #Number of requests per test (def: 10000)
-P NUM                        #Pipeline NUM requests (def: 1, meaning no pipelining)
-d SIZE                       #Data size for get and set
-k 1|0                        #TCP keepalive (def: 1)
-r NUM                        #Uses random keys for get/set/incr, and values for sadd, accross NUM random possibilities.

-t TEST,...                   #Only run specific tests
-q                            #Short output
--csv                         #CSV output
-l                            #Run forever


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           SECURITY            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


SECURITY ==>                  #Clients can do anything on a set of databases, so must be trusted. 
                              #So there should be an ACL layer between end-clients and Redis server.
                              #Goal of Redis is performance, not security.
                              #By def., does not use SSL because impact perf, needs to do it on top of it or (better) communicate using the loopback (same machine).

CONFVAR requirepass           #PASSWORD
                              #Clients gets ERROR "NOAUTH" for all commands until they use auth PASSWORD (return ERROR or "OK")
                              #Should be very strong PASSWORD, since can bruteforce up to 150000/sec.
CONFVAR masterauth            #PASSWORD
SENTVAR sentinel auth-pass    #MASTER PASSWORD

CONFVAR rename-command        #COMMAND NEW_COMMAND
                              #Change command name (e.g. "config") to a random string, so it is still available for admin but hidden from clients
                              #Change to "" to make it not available to everyone
                              #Might cause problem if already existing AOF


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:           PROTOCOL            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


PROTOCOL ==>                  #Is human-readable (client implement it, so should not need to know it) and case-insensitive.
                              #Structure:
                              #  - all lines terminated by \r\n
                              #Types:
                              #  +STR: cannot contain \r or \n
                              #
                              #  -ERROR MESSAGE: cannot contain \r or \n
                              #
                              #  :INT: use as BOOL (0|1) often
                              #
                              #  $LENGTH
                              #  STR: "bulk strings", can contain \r or \n. Good also for big sized data.
                              #
                              #  *LENGTH
                              #  ...: arrays of any type above
                              #
                              #Special:
                              #  - null is either:
                              #     - (preferred) STR with LENGTH -1, i.e. $-1
                              #     - ARR with LENGTH -1, i.e *-1
                              #Clients:
                              #  - sends commands and arguments as STR_ARR ("bulk strings")
                              #  - can also just send command and args as is with newline ("inline version" of the protocol): slower but easier (is same as redis-cli)
                              #Can pipeline:
                              #  - client sends several commands, and server will respond with several responses in same order
                              #  - good to minimize network roundtrips

TYPES ==>                     #Input|output types: see protocol
                              #Input types are sent as STR_ARR (see above), but redis-server reinterpret STR according to those higher-level types:
                              #  - STR: 
                              #     - STR_LIT are "..." or (escape everything then) '...'
                              #     - According to clients (case of redis-cli):
                              #        - Can contain slash escaped sequences (protocol uses binary)
                              #        - Uses UTF8 (protocol does not care about encoding)
                              #  - BITSTR: actually STR (can BITSTR->STR and STR->BITSTR)
                              #  - INT|FLOAT: actually STR (can INT->FLOAT, but not FLOAT->INT)
                              #  - OBJ: keys and values are STR ("hashes")
                              #  - LIST: STR_ARR
                              #  - SET: STR_ARR with unique values
                              #  - ZSET: STR_ARR with unique values and sorted according to individual NUM scores
                              #  - HYPERLOGLOG: like SET, but specialized for counting number of unique elements:
                              #     - must faster
                              #     - but only 99% approximation
                              #     - and can only add elements and retrieve number of elements
                              #Often keys use namespaces separated with ":"
                              #Usual types:
                              #  - ERROR is usually returned if wrong type.
                              #  - Unless specified otherwise:
                              #     - first argument is always a VAR
                              #     - others LIT if native type, VAR otherwise

TIME COMPLEXITY ==>           #Of commands are written like this:
                              #O(1)
                             l#O(log(n))
                            1n#O(1) for STR, O(n) for others
                             n#O(n)
                             m#O(n*log(n))


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ACID              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


CONSISTENCY/ISOLATION ==>     #Strong since Redis is single-threaded, and each command is atomic (because simple), two commands cannot happen at once.
ATOMICITY ==>                 #Each command is atomic, and can also use transactions for multi-commands atomicity
DURABILITY ==>                #See above


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:         TRANSACTIONS          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


multi                         #Make several commands ... atomic. Single commands are always atomic.
...                           #Discard means ... is not performed.
exec|discard                  #Return values:
                              #  - multi and discard returns "OK".
                              #  - ... commands returns "QUEUED"
                              #  - exec returns ... commands results as ARR (if some results are ARR2, returns ARR_ARR2)
                              #Blocking: 
                              #  - ... is only performed once exec is sent.
                              #  - it blocks the whole database (like an atomic operation)
                              #  - If only one operation, does not block more than a normal atomic operation
watch VAR...                  #Make exec fail (returns null) if any VAR... are modified between watch and exec.
                              #Returns "OK"
                              #Goal:
                              #  - to provide garentee VAR... are read-only, without blocking the whole database.
                              #  - means that multi ... exec can be kept smaller
                              #Should watch before multi, and keep multi ... exec as small as possible.
unwatch VAR...                #Returns "OK". Automatically called by exec|discard.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            GENERAL            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


type VAR                      #Returns TYPE "string|list|set|zset|hash" or "none" if does not exist.
object idletime VAR           #Number of seconds (resolution of 10 sec) since VAR has been read|write (except by object idletime)

rename VAR VAR2               #Like mv VAR VAR2
                              #Returns "OK" or ERROR if VAR not existing or VAR == VAR2
renamenx VAR VAR2             #Same but:
                              #  - do not overwrite if VAR2 exists
                              #  - returns false if VAR2 existed

move VAR UINT                 #Moves VAR to database numero UINT.
                              #Returns false if problem, e.g. key already exist in database UINT, or VAR does not exist.

dump VAR                    1n#Returns serialized VAR as STR:
                              #  - is RDB format with a checksum
                              #  - does not contain ttl info
restore VAR UINT STR        1n#Deserialize STR to VAR, with ttl UINT (in ms, 0 for no ttl)
                              #Returns "OK", or ERROR if checksum not validated.
migrate HOST PORT VAR UINT  1n#Moves VAR to another set of databases at HOST:PORT, database number UINT:
UINT2 [copy] [replace]        #  - dump VAR, then restore VAR, then del original VAR
                              #  - UINT2 is idle time timeout (in ms) (not total transfer time timeout)
                              #  - returns "OK" if success or ERROR:
                              #     - if "IOERR", original VAR still exist, but dest VAR may or may not exist
                              #     - any other ERROR: dest VAR do not exist
                              #     - do not overwrite dest VAR
                              #Options:
                              #  - "copy": do not del original VAR
                              #  - "replace": let overwrite dest VAR

keys GLOB_STR                n#Returns keys from current database matching GLOB, as STR_ARR
                              #Very slow, should be used in dev. only (use SET for production)
randomkey                     #Returns random VAR key from current database.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            REMOVE             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


flush[db|all]                 #Remove all keys from current|all databases

exists VAR                    #Returns true if VAR exists
del VAR...                  1n#Erases keys, if it exists. Returns number of keys removed
[p]expire VAR UINT            #Fire del VAR in UINT [milli]seconds
                              #Only operations that removes countdown: persist [get]set (not incr, lpush, rename nor hset)
                              #Returns false if VAR does not exist or ttl could not be set.
[p]expireat VAR UINT          #Same but with a Unix timestamp.
[p]ttl VAR                    #Returns VAR expire countdown in [milli]seconds and:
                              #  -1 if no ttl
                              #  -2 if not existing
persist VAR                   #Removes ttl
                              #Returns false if VAR does not exist or have no ttl


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:              STR              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


set STR STR2 [ex|px NUM]      #Like STR = STR2.
[nx|xx]                       #  - ex|px NUM: calls [p]expire STR NUM
                              #  - nx|xx: only if STR [does not] exist
                              #If VAR is from another TYPE, still makes it a STR.
                              #Returns "OK" or, if problem (e.g. with nx|xx), null.
get STR                       #Returns STR value or, if not existing, null.
getset STR STR2               #Like set, but returns old value STR. No ex|px|nx|xx arguments
mset[nx] STR STR2 ...        n#Do several set ...
                              #If nx: only if all STR don't exist
                              #Returns "OK"
mget STR...                  n#Do several get ..., returned as STR_ARR

incrby|decrby INT NUM         #Like INT += NUM or -= NUM
                              #If INT does not exist, set to 0.
                              #Returns new INT value
incr|decr INT                 #Same as incrby|decrby INT 1
incrbyfloat FLOAT FLOAT2      #Same but with FLOAT

strlen STR                    #Return byte size INT (0 when does not exist)
setrange STR OFFSET STR2      #Sets part of STR, i.e. STR[OFFSET] = STR2
                              #  - if OFFSET too big, fills STR with \0
                              #  - works on non-existing STR
                              #Returns new strlen STR
                              #Simple LIST using setrange|getrange|append|strlen (with fixed size element) is faster (but less functionality)
getrange STR INT INT2        n#Returns part of STR from INT included to INT2 excluded
                              #INT[2] can be negative (from end)
append STR STR2               #Like STR += STR2
                              #If any not existing -> ""
                              #Returns new length.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            BITSTR             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


getbit BITSTR UINT            #Return bit number UINT.
                              #If out of range, or not existing, returns 0.
setbit BITSTR UINT 1|0        #Sets bit number UINT.
                              #If out of range, or not existing, fills with 0 before.
                              #Returns original bit.
bitpos BITSTR 1|0            n#Returns bit position of first 1|0 bit, from byte INT included to INT2 excluded (def: all).
[INT INT2]                    #Position is always relative to beginning of BITSTR, not INT.
                              #If 1 and there are no 1, returns -1
                              #If 0 and there are no 0:
                              #  - if INT INT2, returns -1
                              #  - otherwise, returns BITSTR bit size + 1
bitcount BITSTR [INT INT2]   n#Returns number of 1 bits in BITSTR, from byte INT included to INT2 excluded (def: all)
                              #INT[2] can be negative (from end)
                              #Returns 0 if not existing
bitop and|or|xor BITSTR      n#Assigns to BITSTR (creates if not existing)
BITSTR2...                    #If not same length or not existing, zero padds.
bitop not BITSTR BITSTR2     n#Returns new BITSTR length


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:              OBJ              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


hset[nx] OBJ VAR STR          #Like OBJ.VAR = STR
                              #Returns false if OBJ.VAR already existed so has [not] been overwritten
hget OBJ VAR                  #
hmget OBJ VAR ...            n#
hmset OBJ VAR STR ...        n#
hdel OBJ VAR...              n#
hexists OBJ VAR               #
hincrby[float] OBJ VAR 
INT|FLOAT                     #Similar than version without h but for OBJ.VAR

hlen OBJ                      #Returns number of keys (0 if OBJ does not exist) (an OBJ with no member does not exist)
hgetall OBJ                  n#Returns all keys and values as STR_ARR: [ KEY1, VALUE1, KEY2, VALUE2 ... ]
hkeys OBJ                    n#Returns all keys as STR_ARR
hvals OBJ                    n#Returns all values as STR_ARR


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             LIST              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


l|rpush[x] LIST STR...        #Insert values.
                              #If LIST does not exist if no x, -> [], if x, do not do anything.
                              #Returns new length.
l|rpop LIST                   #Removes and return value STR (null if empty or not exists)
rpoplpush LIST LIST2          #Does lpush(LIST2, rpop(LIST))
                              #LIST can == LIST2, doing rotation on the LIST.
                              #If LIST does not exist, does not do anything.
                              #Returns element being popped|pushed

llen LIST                     #Returns length (0 if not exists)
lindex LIST INT              n#Returns LIST[INT] (null if not existing or out of range)
                              #INT can be negative (from end)
                              #Slower to access the middle.
lset LIST INT STR            n#Like lindex(LIST, INT) = STR
                              #Returns "OK" or ERROR if out of range.
                              #Slower to access the middle.
linsert LIST before|after    n#Look for first STR in LIST from beginning to end, and insert STR2 before|after
STR STR2                      #Returns new length, or -1 if STR not found.
lrange LIST INT INT2         n#Returns part of LIST as STR_ARR, from INT included to INT2 included.
                              #INT[2] can be negative (from end)
                              #Out of range is just rest to end of LIST.
ltrim LIST INT INT2          n#Like LIST = lrange(...)
lrem LIST INT STR            n#Removes elements == STR:
                              #  - if +INT, INT first elements
                              #  - if -INT, INT last elements
                              #  - if 0, all elements
                              #Returns number of removed elements.
                              #If not existing, do not do anything.

blpop|brpop LIST... UINT      #Do lpop|rpop from the first LIST... that is existing and not empty.
                              #Returns [ LIST_STR, VAL_STR ]
                              #If no LIST... are existing and not empty, blocks until one does, or until timeout UINT seconds (0 for no timeout) (in which case it returns null). 
                              #If several clients were blocked, the first that asked for it gets it, the other remain blocked.
                              #Used to implement queues
brpoplpush LIST LIST2 UINT    #Like blpop, but for rpoplpush.
                              #As opposed to blpop, if client dies, notification (pushing to LIST2) is still performed, which makes it more suitable for reliable notification queues.
                              #Returns element being popped|pushed or null if timeout.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:              SET              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


sadd SET STR...              n#Adds to SET if not duplicate.
                              #Returns number of new elements
srem SET STR...              n#Removes to SET if in there.
                              #Returns number of removed elements
scard SET                     #Returns length
smembers SET                 n#Returns all elements as STR_ARR
sismember SET STR             #Returns true if is part of SET

sunion|sinter|sdiff SET...   n#Returns combination as SET2
sunion|sinter|sdiffstore 
SET2 SET...                  n#Same but store result in SET2 instead, and return SET2 length.

srandmember SET [INT]        n#Returns INT random elements from SET as STR_ARR:
                              #  - if positive, can't return duplicates, if negative, can.
                              #  - if no INT, return single one as STR
                              #Returns null or [] if SET has no members.
spop SET                      #Same as srandmember SET, but remove element then.
smove SET SET2 STR            #Moves member STR of SET to SET2.
                              #Returns false if problem, including if STR is not in SET.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:             ZSET              :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


zadd ZSET SCOR_FLOAT STR ... l#Adds STR to ZSET, with SCORE. FLOAT can be "+|-inf"
                              #SCORE orders from -inf to +inf. If same SCORE, orders according to STR key, byte-wise ("lexicographical ordering")
                              #If STR already exist in ZSET, update SCORE.
                              #Returns number of new elements.
zincrby ZSET FLOAT STR       l#Adds FLOAT to the SCORE of STR in ZSET.
                              #Returns new SCORE.

zscore ZSET STR               #Returns member SCORE (null if not existing).
z[rev]rank ZSET STR          l#Returns member [reverse] sorted position (null if not existing)

z[rev]range ZSET INT INT2    l#Like srange but for a ZSET, [inverse] sorted
[withscores]                  #If "withscores", returns [ VAL, SCORE ... ] instead of [ VAL... ]
z[rev]rangebyscore ZSET       #Same but using scores, not position.
FLOAT FLOAT2 [withscores]     #FLOAT[2]:
[limit UINT UINT2]            #  - are min|max scores
                              #  - are inclusive, or if "(FLOAT", exclusive
                              #  - can be +|-inf
                              #Can add then an offset UINT (can be 0) then only take UINT2 max elements.
zrangebylex ZSET STR STR2     #Like zrangebyscore, but using lexicographical ordering instead.
[limit UINT UINT2]            #Only works if all elements in ZSET must have same SCORE.
                              #STR[2]:
                              #  - are min|max
                              #  - are inclusive if [STR, exclusive if (STR
                              #  - can be - + (like -inf|+inf)

zcard ZSET                    #Returns number of elements
zcount ZSET FLOAT FLOAT2     l#Returns length of zrangebyscore ... result
zlexcount ZSET STR STR2      l#Returns length of zrangebylex ... result

zrem ZSET STR...             m#Removes element. Returns number of removed elements.
zremrangebyrank ZST INT INT2 l#
zremrangebyscore ZSET 
FLOAT FLOAT2                 l#
zremrangebylex ZSET STR STR2 l#Same but according to range returned by zrange[byscore|bylex] ...

zunionstore|zinterstore      m#Stores in ZSET the union|intersection of ZSET2... (UINT if number of ZSET2...)
ZSET UINT ZSET2...            #Each ZSET2 gets its SCORE multiplied with a FLOAT (def: 1), then take the sum|min|max with 
[weights FLOAT...]            #other ZSET2 (def: sum)
[aggregate sum|min|max]       #Returns number of elements in ZSET.


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          HYPERLOGLOG          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


pfadd HYPERLOGLOG STR...      #Add STR element. Returns false if duplicate.
pfcount HYPERLOGLOG...        #Returns number of elements in union of HYPERLOGLOG...
                              #Using several HYPERLOGLOG.. or pfmerge are much slower.
pfmerge HYPERLOGLOG
HYPERLOGLOG2...              n#Store union of HYPERLOGLOG2... in HYPERLOGLOG. Returns "OK"


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:          SORT & SCAN          :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


sort LIST|SET|ZSET           m#Sort:
[by STR]                      #  - if:
[limit UINT UINT2]            #     - no "by STR", by the values
[get STR ...]                 #     - by STR with glob *, replace * with each value, and use this to sort
[asc|desc] [alpha]            #       (e.g. weight_* -> weight_VALUE for each value)
[store LIST|SET|ZSET]         #     - by STR with no glob *, do not sort
                              #  - in numerical ordering or if "alpha" lexicographical ordering.
                              #  - result is:
                              #     - if no get STR, LIST|SET|ZSET, after sorting
                              #     - if get STR with glob *:
                              #        - replace * with each value, and use this as result value instead
                              #        - if several get STR, returns ARR with n times more values
                              #        - can use "#" to mean LIST|SET|ZSET
                              #  - return result or if "store" put in destination.
                              #  - with glob *, can use ->VAR for an OBJ, e.g. weight_*->VAR, if weight_* returns an OBJ
                              #Can add then an offset UINT (can be 0) then only take UINT2 max elements.

scan UINT [match GLOB_STR]    #Iterates over keys of current database, matching GLOB_STR
[count UINT3]                 #Needs to call it several times to return all elements:
                              #  - better performance than long-blocking functions like keys or smembers 
                              #  - but don't provide consistent snapshot (because spread over time):
                              #     - might return duplicates
                              #     - elements that disappear at some point might not appear
                              #  - UINT is the current cursor (start at 0, and returns UINT2 to use for next iteration)
                              #    When iteration if finished, returnes 0 as UINT2
                              #Returns [ UINT2, ARR ], where ARR are the keys of current database.
                              #Number of elements returned:
                              #  - can be hinted by UINT3 (def: 10), but just a hint: might be less, more (especially if small) or even 0
hscan OBJ ...                 #
sscan LIST ...                #Same as scan ... but over the elements of an OBJ|LIST|ZSET
zscan ZSET ...                #OBJ returned ARR is [ VAR VAL ... ], ZSET [ VAL SCORE ... ], SET [ VAL ... ]


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            PUBSUB             :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


subscribe CHANNEL_STR...     n#Waits for another client to do publish ...
unsubscribe [CHANNEL_STR...] n#Hangs and returns for each event:
publish CHANNEL_STR STR2     n#  - [un]subscribe (for each CHANNEL): [ "[un]subscribe", CHANNEL_STR, UINT ], where UINT is number of subscribed channels
                              #  - message: [ "message", CHANNEL_STR, STR2 ]
psubscribe CHNEL_GLOB_STR... n#Same but:
punsubscribe                  #  - CHANNEL_GLOB_STR can use globbing (good for events namespaces)
[CHANNEL_GLOB_STR...]         #  - events are:
                              #     - [un]subscribe (for each CHANNEL): [ "p[un]subscribe", CHANNEL_GLOB_STR, UINT ], 
                              #     - message: [ "pmessage", CHANNEL_GLOB_STR, CHANNEL_STR, STR2 ]
pubsub channels 
[CHANNEL_GLOB_STR]           n#Returns current channels as STR_ARR
pubsub numsub CHANNEL_STR... n#Returns number of subscription for those channels as [ CHANNEL_STR UINT ... ]
pubsub numpat                 #Returns number of active psubscribe

CONFVAR notify-keyspace-events#Allows listening for some builtins messages.
                              #Are letters (def: ""):
                              #  - "K": __keyspace@NUM__:VAR events, with message COMMAND at database NUM
                              #  - "E": __keyevent@NUM__:COMMAND events, with message VAR
                              #Then letters:
                              #  - "A": all commands
                              #  - "$": STR commands
                              #  - "l": LIST commands
                              #  - "s": SET commands
                              #  - "h": OBJ commands
                              #  - "z": ZSET commands
                              #  - "x": expired event
                              #  - "e": evicted event
                              #  - "g": other commands (del, rename, etc.)
                              #All COMMAND that modifies KEY (only if modified) generate COMMAND events. Exceptions:
                              #  - del event: anything that erases|overwrites a key
                              #  - hdel event: when erasing OBJ.VAR
                              #  - set event: set, getset, mset
                              #  - hset event: hset, hmset
                              #  - [h]incrby event: [h]incr|decr[by]
                              #  - rename_from|to events: rename
                              #  - r|lpush event: r|lpush[x]
                              #  - [b]rpoplpush -> lpush then rpop events
                              #  - smove -> sadd then srem events
                              #  - expire event: [p]expire
                              #  - expired event: when a key is deleted because of expiration. It is not an end of countdown
                              #    but either:
                              #     - when expired key is being accessed
                              #     - when expired key is being garbage collected
                              #  - evicted event: when key erased because of maxmemory
                              #  - no events: move, restore, migrate


                                             /=+===============================+=\ 
                                            /  :                               :  \  
                                            )==:            CLIENTS            :==(   
                                            \  :_______________________________:  /    
                                             \=+===============================+=/


redis-cli [...]               #Command line client (connects to a set of databases)
                              #Can send command ... or use CLI
-h HOSTNAME                   #Def: 127.0.0.1
-p PORT                       #Def: 6379
-s UNIXSOCKET                 #Optional

--pipe                        #Read from stdin, and stdout (not stderr) to /dev/null
-x                            #Read last arg from stdin
-r NUM                        #Repeats command, with -i INTERVAL_DOUBLE (def: 0)

-a PASSWORD                   #Do auth PASSWORD
-n NUM                        #Do select NUM (def: 0)
--scan                        #Do a serie of scan. Can use --pattern GLOB

--raw                         #Raw output (def)
--csv                         #CSV output


REDIS                         #Node.js client (0.10.3)
                              #Should also install HIREDIS, to make it faster.
REDIS.createClient            #Returns CLIENT
([PORT[, HOST[, PARAM_OBJ]]]) #Def HOST:PORT is 127.0.0.1:6379. Can use SOCKET_PATH instead of PORT, HOST
                              #PARAM_OBJ:
                              #  - auth_pass PASSWORD: can also use CLIENT.auth(PASSWORD)
                              #  - socket_nodelay BOOL (def: true)
                              #  - socket_keepalive BOOL (def: true)
                              #  - enable_offline_queue BOOL (def: true): 
                              #     - if disconnected, buffer commands until reconnected
                              #     - can check CLIENT.offline_queue.length NUM
                              #  - connect_timeout UINT (def: false) and max_attemps UINT (def: false): 
                              #     - by def., will retry reconnecting forever. 
                              #     - The next try will be multiplied by CLIENT.retry_backoff (def: 1.7), up until 
                              #       retry_max_delay (def: null)
                              #     - Can check current CLIENT.retry_delay NUM
                              #  - family (def: "IPv4")
                              #All commands are async, meaning automatically pipelined (do not wait for answer to keep going)
CLIENT.COMMAND                #ARGS can be ARG_ARR or ARG...
(ARGS[, FUNC(ERROR, VAL)])    #Types:
                              #  - STR -> STR. 
                              #    If PARAM_OBJ.detect_buffers true (def: false), reply with BUFFER if ARGS used BUFFER
                              #  - INT -> INT
                              #  - null -> null
                              #  - LIST|SET|ZSET -> ARR
                              #  - BOOL -> 1|0
                              #Syntax exceptions:
                              #  - COMMAND SUBCOMMAND -> CLIENT.COMMAND(SUBCOMMAND_STR, ...)
                              #  - hgetall|hmset use OBJ
                              #  - pubsub: CLIENT.on(EVENT_STR, FUNC(CHANNEL_STR, VAL)) and CLIENT.publish(...)
                              #  - transaction: 
                              #     - CLIENT.multi() and CLIENT.exec(FUNC(ERROR, ARR))
                              #     - Must use the CLIENT returned by CLIENT.multi(), and finish the chain with exec()
                              #  - CLIENT.on("monitor", FUNC(TIME, ...)): fired after CLIENT.monitor()
                              #Uses command chaining.
CLIENT.send_command
(COMMAND_STR, ARGS, FUNC(...))#Only if CLIENT.COMMAND() is not implemented yet

REDIS.print                   #Redis-specific alternative to console.log.bind( console )

CLIENT.on("ready", FUNC())    #Every CLIENT.* should be inside this.
CLIENT.on("connection",FUNC())#Like ready event but if PARAM_OBJ.no_ready_check false (def), checks if server is loading 
                              #RDB and waits then to emit.
CLIENT.on("error",FUNC(ERROR))#On connection error (otherwise crash Node)
CLIENT.on("end", FUNC())      #When connection ends
CLIENT.on("idle", FUNC())     #When no outstanding client commands waiting for answers
                              #Can also check CLIENT.command_queue.length NUM
CLIENT.on("drain", FUNC())    #Emitted when it is ok to stream commands???

CLIENT.end()                  #Like CLIENT.quit() but forces to quit (avoid).
CLIENT.unref()                #Unref underlying socket, allowing program to quit (automatically done by CLIENT.quit())

CLIENT.connected              #BOOL
CLIENT.server_info            #Result of command info all
