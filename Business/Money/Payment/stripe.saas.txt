
                                  ┏━━━━━━━━━━━━┓
                                  ┃   STRIPE   ┃
                                  ┗━━━━━━━━━━━━┛

TODO:
  - update with latest API changes (last checked on 8 April 2020) in https://github.com/stripe/openapi and https://github.com/stripe/stripe-node
  - https://stripe.com/docs/api/subscription_schedules
     - https://stripe.com/docs/billing/subscriptions/subscription-schedules
  - https://stripe.com/docs/payments/cards/reusing-cards
  - https://stripe.com/docs/payments/cards/saving-cards#saving-card-without-payment
  - https://stripe.com/docs/billing/subscriptions/payment#using-setupintents
  - https://github.com/stripe/stripe-cli
  - Stripe.js:
     - https://stripe.com/docs/stripe-js
     - https://stripe.com/docs/amex-express-checkout#integrating
     - https://stripe.com/docs/masterpass#integrating
     - https://stripe.com/docs/visa-checkout#integrating
     - https://stripe.com/docs/payments/payment-intents/quickstart#viewport-meta-requirements
     - https://stripe.com/docs/payments/3d-secure-iframe
     - GET /apple_pay/domains[/ID], POST /apple_pay/domains, DELETE /apple_pay/domains/ID
     - https://github.com/stripe/react-stripe-js
  - Checkout:
     - https://stripe.com/docs/payments/checkout
     - https://dashboard.stripe.com/account/checkout/settings
     - including the Checkout section on https://stripe.com/docs/receipts
  - compare with other providers like PayPal, authorize.net and Klarna
  - check Stripe on GitHub
  - https://stripe.com/works-with
  - https://stripe.com/en-US/guides/general-data-protection-regulation
  - remove myself from Stripe Cardero

VERSION ==>                       #2020-03-02
                                  #Last checked on 8 April 2020
                                  #See:
                                  #  - https://stripe.com/en-US/blog/changelog
                                  #  - https://stripe.com/docs/upgrades
Stripe-Version: VERSION [C|S]     #Defaults to latest.

FEATURES ==>                      #Payment types:
                                  #  - single payments
                                  #  - recurring payments (including trials, complex plans, automation, prorating, high consumption limits, tiered pricing, metered pricing, discounts)
                                  #  - many payment methods
                                  #  - automatic payment method renewal on expiration
                                  #  - including on-site payment
                                  #  - user-created cards (spending limits, authorizations)
                                  #  - virtual ACH credit transfer
                                  #  - delayed payments (capturing)
                                  #Payment documents:
                                  #  - invoices (including PDF, hosted payment page, credit notes)
                                  #  - automatic receipts, emails
                                  #Payment issues:
                                  #  - refunds
                                  #  - fraud dispute resolution
                                  #  - automatic fraud detection (machine learning)
                                  #Platform/Connect:
                                  #  - platform payments (Connect) (including complex money flow, restricting accounts)
                                  #  - OAuth
                                  #  - Stripe account balance (including automatic payouts)
                                  #Shipping (costs, taxes, custom logic)
                                  #Large amount of currencies and countries (but not all)
                                  #Legal:
                                  #  - PCI compliance, SCA compliance
                                  #  - verification of Connect ACCOUNTs, VAT IDs
                                  #  - bank account verification
                                  #Developer UX:
                                  #  - very developer-friendly
                                  #  - clients: Node.js, Web UI, JavaScript (each UI element or full payment page)
                                  #  - export data as CSV or SQL

                                  ┌─────────────┐
                                  │   SUMMARY   │
                                  └─────────────┘

PRICING ==>                       #Percentage of money volume. Extra if different currency/country.
                                  #Connect standard: free, Connect express|custom: smaller percentage of money volume
                                  #Ongoing disputes have cost.
PARTNERS ==>                      #Apps that use Stripe OAuth. For extra fee and process, get marketing + support.
LEGAL ==>                         #PCI compliant if using Stripe clients. Easy to submit compliance documents.
                                  #SCA compiiant.

API REQUESTS ==>                  #REST API, urlencoded request, JSON response
AUTHENTICATION ==>                #Two keys: server-side, client-side. Can revoke|scope|time-limit new keys.
OAUTH ==>                         #Allow using another ACCOUNT, for Connect or for extensions.
SINGLE-USE LOGIN ==>              #Single-use login URL (Connect express only)

COMMON ATTRIBUTES ==>             #Custom metadata and created timestamp on any resource. Population.
PAGINATION ==>                    #
IDEMPOTENCY ==>                   #Idempotency-Key [C] to avoid doing twice side-effects because of retry (e.g. new PINTENT|CHARGE|USAGE_RECORD)

ERRORS ==>                        #Human-friendly message. Lots of type/subtypes on CHARGE failure. Request-Id [S]
TESTING ==>                       #Test mode.
                                  #Can use built-in fake SOURCE (and related), DISPUTE, Connect ACCOUNT, TAX_ID, READER, CHARGE.outcome.risk_level

EVENT ==>                         #Async operation or generic API event (create|update|delete). Include most request information.
WEBHOOK ==>                       #Webhook triggered on EVENT.

FILES ==>                         #Static files.
ADDRESS ==>                       #Used in many models.
CURRENCY ==>                      #Three stages of currency: customer -> CHARGE -> destination (customer pay for first, we pay for second)
                                  #Available currencies are limited by ACCOUNT.country and payment methods.
COUNTRY ==>                       #Customer can be any country, but our country must be among possible ones.
                                  #TRANSFER|PAYOUT|TOPUP must be within same country (or Eurozone)
                                  #Fee to both us and customer if different country.
                                  #Several features are US only.

PAYMENT INTENT ==>                #SOURCE authentication flow + CHARGE. Only for credit cards.
SETUP INTENT ==>                  #Like PINTENT but done in advance.
CHARGE ==>                        #Single payment. Can send receipts.
CAPTURING ==>                     #Delayed payment, for easy withdrawal or fraud suspicion. Can be partial.
REFUND ==>                        #Reverting CHARGE. Can send email.
STATEMENT DESCRIPTOR ==>          #Shown in bank statements.

SOURCE TYPES ==>                  #Differences: customer UX, sync|async, flow, re-use, timeframe, REFUND, DISPUTE, country, currency, pricing
                                  #Available:
                                  #  - card: common fast. Should use 3D secure. Should check bank response on CVC/ZIP match (can automate it).
                                  #  - digital wallets (Visa Checkout, Masterpass, Amex Express Checkout): lower amount, has personal info, NFC
                                  #  - terminal READER: in-person
                                  #  - ACH credit|debit: US-only, cheap, common in B2B, slow, re-use-friendly
                                  #     - credit: more effort for customer
                                  #     - debit: must first verify bank account (extra steps)
                                  #  - SEPA debit: like ACH debit but for EU
                                  #  - country-specific: Sofort (Germany), Giropay (Germany), EPS (Austria), iDEAL (Netherlands), Bancontact (Belgium),
                                  #    p24 (Poland), multibanco (Portugal), Klarna (mostly Scandinavia)
                                  #  - Stripe account
                                  #  - Alipay, WeChat: China, restrictive terms of service
                                  #  - Apple Pay, Google Pay, Microsoft Pay, Samsung Paya
                                  #Not available: wire transfers, Western Union
SOURCE ==>                        #Payment method (old API). Some can be re-used. Different authorization flows. Can be automatically updated on renewal.
PAYMENT METHOD ==>                #Payment method (new API, credit cards only)
CARD ==>                          #'card' payment method (old API)
BANK ACCOUNT ==>                  #'ach_debit' payment method (old API)
EXTERNAL ACCOUNT ==>              #CARD|BANK_ACCOUNT of an ACCOUNT (for PAYOUTs and Connect)
SOURCE TRANSACTION ==>            #CHARGEs of a specific SOURCE
CUSTOMER ==>                      #Person paying. Allow re-using payment method, email, address, INVOICE info.
TOKEN ==>                         #Encapsulate SOURCE|ACCOUNT|PERSON, for security reason.

SUBSCRIPTION ==>                  #Recurring CHARGE for a specific CUSTOMER. Can use trials. Either automatically charge or send emails. Can set periods.
                                  #Can send several invoices per period if high consumption. Automatic adjustment ("prorate") on changes.
SUBSCRIPTION ITEM ==>             #Allow several PLANs per SUBSCRIPTION
PLAN ==>                          #Pricing scheme. Tied to a PRODUCT. Can set frequency. Either flat or tiered. Can be metered. Can use modulo.
USAGE RECORD ==>                  #Metered usage single consumption.
USAGE RECORD SUMMARY ==>          #Metered usage summary consumption.
PRODUCT ==>                       #Generic info about service|product sold.

COUPON ==>                        #DISCOUNTs to many CUSTOMERs (SUBSCRIPTION only). Absolute or relative. Can be count|time limited. Can be repeated.
DISCOUNT ==>                      #Discount to one CUSTOMER
CREDIT NOTE ==>                   #Adjustment on open|paid INVOICE. Reduce INVOICE amount, REFUND, reduce CUSTOMER balance or settle outside Stripe. Can PDF.
CREDIT NOTE ITEM ==>              #CREDIT_NOTE's item

INVOICE ==>                       #Incoming SUBSCRIPTION CHARGE. Automatic (send emails, change state, payment retry) or manual. Can set due date.
                                  #Can PDF. Hosted URL to pay. Can customize look and content.
LINE ITEM ==>                     #Automatic INVOICE single item
INVOICE ITEM ==>                  #INVOICE single item
UPCOMING INVOICE ==>              #Preview an INVOICE
AUTOMATED RECONCILIATION ==>      #Virtual ACH credit transfer, with automatic emails.
TAX ID ==>                        #CUSTOMER tax identifiers. Verified by Stripe (EU only).
TAX RATE ==>                      #Tax on a SUBSCRIPTION[_ITEM]|INVOICE|LINE_ITEM. Relative. Inclusive or exclusive.

ACCOUNT ==>                       #Stripe account. Current one or through Connect. General company|person info. Branding (color|logo). Dashboard settings. Payment settings.
PERSON ==>                        #Stripe user. Info verified by Stripe.
RESTRICTION ==>                   #On ACCOUNT creation, must provide generic info. After 1 month, must upload ID. Only for business owners.
                                  #If issue, Stripe or us (for Connect) can forbid CHARGE|PAYOUT.
CAPABILITY ==>                    #US-specific restrictions
BALANCE ==>                       #ACCOUNT virtual bank account. Currency-wise. Some money can be reserved|pending.
BALANCE TRANSACTION ==>           #ACCOUNT's BALANCE single transaction.
CUSTOMER BALANCE TRANSACTION ==>  #CUSTOMER's balance single transaction.
PAYOUT ==>                        #Money from|to ACCOUNT to|from bank account / credit card. Can be faster for an extra fee. Minimal amount. Can be automated.
TOPUP ==>                         #Money from bank account / credit to ACCOUNT.

CONNECT ==>                       #When platform facilitating CHARGE|SUBSCRIPTIONs between payers (CUSTOMER) and seller (Stripe ACCOUNT2), for a FEE.
                                  #Types:
                                  #  - standard: normal Dashboard, does not handle ACCOUNT.*, OAuth, no DISPUTE|REFUND|BALANCE responsability, no fee
                                  #  - express: simple Dashboard, handle few ACCOUNT.*, OAuth, extra fee, US only
                                  #  - custom: custom Dashboard, handle all ACCOUNT.*, no OAuth, extra fee
                                  #Charges routing:
                                  #  - direct charges: only forward payment, usually standard
                                  #  - destination charges: more than forward payment, usually express|custom
                                  #  - separate: complex routing (including 1-n|n-1|n-n, or defered payment), usually express|custom, more work, must be both in US|Europe
                                  #Can decide to be shown on bank statements, or not.
                                  #Account debit: CHARGE|TRANSFER from Connect ACCOUNT2 towards our ACCOUNT. Must be both in US|Europe.
TRANSFER ==>                      #Money from ACCOUNT to ACCOUNT2
TRANSFER REVERSAL ==>             #REFUND of a TRANSFER
APPLICATION FEE ==>               #Our fee between Connect users. Absolute or (for SUBSCRIPTION) also relative.
APPLICATION FEE REFUND ==>        #REFUND of a FEE

FRAUD ==>                         #Causes: fraud (most common), product|service issue, wrong billing, bug.
                                  #Inquiries/retrievals: pre-dispute.
                                  #Typical frauds, signs of fraud, how to avoid.
                                  #>1% dispute rate creates issues with Stripe and credit card companies.
                                  #Should REFUND before DISPUTE.
DISPUTE ==>                       #Stripe takes money until solved. Must submit evidences.
                                  #Timeframe, process and possibility are payment method-specific.
CHARGE OUTCOME ==>                #CHARGE failure reason information. Radar risk score (machine learning) and rule.
RADAR RULE ==>                    #Automatically flag suspicious CHARGE: require 3D secure, create REVIEW or block.
                                  #Built-in or custom rules (using declarative syntax).
RADAR VALUE LIST ==>              #ENUM for use in Radar rules.
RADAR VALUE LIST ITEM ==>         #
REVIEW ==>                        #Suspicious CHARGE, but already processed.
FRAUD WARNING ==>                 #Similar but outside REVIEW system

ORDER ==>                         #CHARGE for 1|n SKUs to a CUSTOMER. Shipping logic: cost, taxes, custom logic (shippment, delivery estimation).
ORDER ITEM ==>                    #
ORDER RETURN ==>                  #REFUND or an ORDER
SKU ==>                           #Variation of a GOOD_PRODUCT (quantity, price, size, etc.). Can disable. Can set inventory. Can set attributes and dimensions.

ISSUING CARD ==>                  #User-created credit cards. Physical (shipped by Stripe) or virtual. Can set spending limits, including purchase category-wise. Can be replaced.
ISSUING CARD DETAILS ==>          #Same with extra security-sensitive fields.
ISSUING CARDHOLDER ==>            #User of ISSUING_CARD. Can be individual or business. Can disable.
ISSUING AUTHORIZATION ==>         #Pending transaction that must be approved first (through fast webhook). Can be partial.
ISSUING TRANSACTION ==>           #Transaction of ISSUING_CARD
ISSUING DISPUTE ==>               #DISPUTE of ISSUING_CARD

TERMINAL READER ==>               #Physical card reader. Ordered|shipped from Stripe. Client runs on mobile device, with JavaScript/iOS/Android SDK.
                                  #Pre-certified by Stripe.
                                  #Either Verifone (more expensive, not mobile, screen, keys) or BBPOS (cheaper, mobile, harder to integrate)
                                  #Receipts by email or manual. Must use charges capturing.
TERMINAL LOCATION ==>             #Several READERs in same place.
TERMINAL CONNECTION TOKEN ==>     #Token to authenticate client to READER

MONTHLY REPORT ==>                #CSV summary of ACCOUNT data, downloaded from Dashboard
SIGMA ==>                         #SQL query of ACCOUNT data. Can be shared. Data is 3 days old.
SIGMA SCHEDULED QUERY ==>         #Repeated Sigma query. Can automatically email results.

STRIPE-NODE ==>                   #Node.js client
DASHBOARD ==>                     #Web UI client. Some features only available in Dashboard.
                                  #Nice search. Can show all requests logs. Can export data as CSV. Team management roles. Email notifications.
FRONT-END ==>                     #JavaScript client, for each UI element
CHECKOUT ==>                      #JavaScript client, for whole page

                                  ┌─────────────┐
                                  │   PRICING   │
                                  └─────────────┘

COUNTRIES ==>                     #Pricing is ACCOUNT.country-specific. Those are US prices.

CHARGE ==>                        #2.9% + $0.30
                                  #Additional 1%-1.5% if customer's bank different country
                                  #Payment-method specific:
                                  #  - 'ach_debit':
                                  #     - 0.8%, max $5
                                  #     - $4 if failed (not disputed)
                                  #  - 'ach_credit_transfer':
                                  #     - $1
                                  #     - if must reconcile, $7 for <$1000, $15 for <$100,000, $25 otherwise

SUBSCRIPTION ==>                  #Either:
                                  #  - 0.4% per CHARGE (on top of normal price)
                                  #    - free for first $1,000,000/month
                                  #  - 0.7% per CHARGE, but include Sigma and Salesforce|Netsuite integrations

PAYOUT ==>                        #Either:
                                  #  - 'standard': $0.25
                                  #  - 'instant': 1.5% (or minimum $0.5)
                                  #Additional 1% if currency change

CONNECT ==>                       #standard: none
                                  #express|custom:
                                  #  - 0.25% of TRANSFERs in US/Canada, 0.5% otherwise
                                  #  - 1.5% of account debits
                                  #  - $2 per ACCOUNT
                                  #     - except ones with 0 CHARGEs during the month
                                  #     - except first 5000 ones each month
                                  #FEE: none

DISPUTE ==>                       #CHARGE is provisionally refunded
                                  #15 USD fee (refunded if won)

RADAR FOR FRAUD TEAMS ==>         #$0.02 per CHARGE

SCHEDULED_QUERY ==>               #  - <500: $0.02 per CHARGE + $10
                                  #  - <1000: $0.018 per CHARGE + $25
                                  #  - <5000: $0.016 per CHARGE + $50
                                  #  - <50000: $0.014 per CHARGE + $100

TERMINAL ==>                      #CHARGE: 2.7% + $0.05
                                  #TERMINAL itself ($59 or $299)

STRIPE VERIFIED PARTNER ==>       #$250/year

PREMIUM SUPPORT ==>               #$1000/month

                                  ┌──────────────┐
                                  │   PARTNERS   │
                                  └──────────────┘

PARTNERS ==>                      #Apps that use Stripe OAuth.
                                  #Must be registered online.
                                  #For free, only offers marketing materials.
                                  #Types:
                                  #  - extensions
                                  #  - plugins: e.g. for CMS
                                  #  - platforms: for whole website / PaaS
                                  #  - services: offering support|consulting (no OAuth)

STRIPE VERIFIED PARTNER ==>       #Requires:
                                  #  - extra fee
                                  #  - code quality submission (https://stripe.com/docs/partners/requirements)
                                  #Offers:
                                  #  - can shift customer questions to Stripe support
                                  #  - can use Stripe logo
                                  #  - featured in https://stripe.com/works-with
                                  #  - access to betas

                                  ┌───────────┐
                                  │   LEGAL   │
                                  └───────────┘

PCI COMPLIANCE ==>                #See PCI docs.
                                  #How Stripe helps:
                                  #  - stores sensitive information
                                  #     - i.e. never returned in response, only in request payloads
                                  #  - front-end code (checkout, Elements, mobile SDK, Terminal, Connect) handles it,
                                  #    i.e. never handled by our front-end or server code
                                  #     - i.e. needs to use those to be PCI compliant
                                  #  - validation: just need to click it every 3 month in dashboard, providing:
                                  #     - not creating charges manually via HTTP or via Dashboard (instead of Elements, etc.)
                                  #     - not level 1
                                  #        - for level 1, can also offer help (must contact them), reducing audit time from 3 months to 1 week
                                  #There is a section in Dashboard about current status, and documents to upload.

SCA COMPLIANCE ==>                #Must use 3D secure for 'card' payments. I.e. must use PINTENT.
                                  #See PSD2 docs.

MIGRATING ==>                     #Check online doc how to migrate from|to Stripe from|to another provider:
                                  #  - it's not easy and might be impossible if new provider is not PCI compliant
                                  #  - from one Stripe account to another: can contact support

                                  ┌──────────────┐
                                  │   NOTATION   │
                                  └──────────────┘

NOTATION ==>                    CU#Updatable on create|update
                                 R#Only on create|update, not in responses
                                 *#Required on create|update
                                 ?#Optional field (null or undefined if not present). I have not documented all optional fields as such yet.

MONEY                             #INT. In the currency's smallest unit (e.g. cents for USD).
                                  #Can be negative.
PMONEY                            #Like MONEY but >= 0
                                  #When *_decimal, is 'BIGINT' string (12 decimals precision) instead

DATE_NUM                          #Unix timestamp in seconds.

CMP_FILTER                        #OBJ: gt[e]|lt[e] NUM|DATE_NUM

                                  ┌──────────────────┐
                                  │   API REQUESTS   │
                                  └──────────────────┘

ENDPOINT ==>                      #https://api.stripe.com/v1/

Content-Type: application/
 x-www-form-urlencoded [C]        #Request body: x-www-form-urlencoded (but must keep [] not encoded)
?PARAM                            #Are actually request body parameters, not URL variables (except for OAuth)
Accept: application/json [C]      #Response body: JSON

                                  ┌────────────────────┐
                                  │   AUTHENTICATION   │
                                  └────────────────────┘

Authorization: Bearer API_KEY [C] #Authentication
API_KEY                           #2 keys:
                                  #  - server-side / secret
                                  #  - client-side / public / "publishable"

ADDITIONAL KEY ==>                #Can create|delete more keys:
                                  #  - can be revoked
                                  #     - including with a timeout of 12 hours
                                  #  - can be scoped to:
                                  #     - specific endpoints
                                  #     - read_write, read_only, none

POST /ephemeral_keys
DELETE /ephemeral_keys/ID
STRIPE.ephemeralKeys.create|del() #
EPHEMERAL_KEY                     #API_KEY time-limited and scoped to a specific CUSTOMER
EPHEMERAL_KEY.customer          RC#CUSTOMER.id
EPHEMERAL_KEY.issuing_card      RC#ISSUING_CARD.id
EPHEMERAL_KEY.secret              #API_KEY
EPHEMERAL_KEY.expires             #DATE_NUM

                                  ┌───────────┐
                                  │   OAUTH   │
                                  └───────────┘

OAUTH ==>                         #Allow apps to do things on behalf of user's ACCOUNT.
                                  #Endpoint connect.stripe.com
                                  #Not possible with ACCOUNT.type 'custom'

Stripe-Account: ACCOUNT.id [C]    #Log in using another ACCOUNT after granted through OAuth (ACCESS_TOKEN was obtained).
                                  #Not needed for /accounts/ID endpoints.
Authorization: ACCESS_TOKEN [C]   #Alternative|legacy way, less secure.
                                  #ACCESS_TOKEN is OAuth's

STRIPE.setClientId('CLIENT_ID')
STRIPE.getClientId()->'CLIENT_ID' #CLIENT_ID is found in Connect Dashboard, and identifies current ACCOUNT.

GET /oauth/[express/]authorize    #Redirects to OAuth authorization page.
STRIPE.oauth.authorizeUrl         #Returns '/oauth/authorize' full URL.
 ([URL_PARAMS, ][OPTS])->'URL'    #OPTS: express BOOL
?client_id=CLIENT_ID             *#
?response_type=code              *#
?redirect_uri=URI                 #Where to redirect.
?scope=STR                        #Either 'read_only' (def) or 'read_write' (recommended for Connect standard)
                                  #For 'express', can only be 'express' (def)
?state=STR                        #Arbitrary STR, passed to redirect as a CSRF token. Should be checked after redirection.
?stripe_landing=STR               #Whether should show a page to:
                                  #  - 'login' to Stripe
                                  #     - prefer if expect user to already have Stripe ACCOUNT.
                                  #     - def if ?scope=read_only
                                  #  - 'register' to Stripe
                                  #     - def if ?scope=read_write
?always_prompt=BOOL               #If true (def: false), prompt even if OAuth already connected.
?stripe_user[VAR]                 #Pre-fills ACCOUNT creation fields among:
                                  #  - email (ACCOUNT.*)
                                  #  - business_name|phone_number|business_type (ACCOUNT.business_profile.*)
                                  #  - first_name|last_name (PERSON.*)
                                  #  - suggested_capabilities|accept_capabilities STR_ARR among 'card_payments' or 'transfers' (REQUIREMENTS.*)
                                  #If ACCOUNT.type 'standard', can also pre-fill:
                                  #  - country|currency (ACCOUNT.*)
                                  #  - url (ACCOUNT.business_profile.*)
                                  #  - street_address|city|state|zip|dob_*|gender (PERSON.*)
                                  #  - physical_product|product_description (PRODUCT.*)

OAUTH REDIRECTION ==>             #Redirect URI:
                                  #  - must specify allowed ones in Dashboard.
                                  #     - defaults to first one
                                  #  - must be HTTPS
                                  #Passes the following query variables:
                                  #  - ?code=OAUTH_CODE
                                  #  - ?scope|state: same as input
                                  #EVENT 'account.application.authorized'
ERROR_RESPONSE                    #Does not redirect, except for 'access_denied'
ERROR_RESPONSE.error              #STR:
                                  #  - 'access_denied': user clicked the Deny button
                                  #  - 'invalid_scope': invalid ?scope
                                  #  - 'invalid_redirect_uri': invalid ?redirect_uri
                                  #  - 'invalid_request': missing ?response_type
                                  #  - 'unsupported_response_type' invalid ?response_type
ERROR_RESPONSE.error_description  #STR that can be shown to user
ERROR_RESPONSE.state              #STR. Same as ?state

POST /oauth/token
STRIPE.oauth.token()              #Turn OAUTH_CODE|REFRESH_TOKEN into ACCESS_TOKEN
?grant_type=STR                  *#Either:
                                  #  - 'authorization_code': use ?code
                                  #  - 'refresh_token': use ?refresh_token
?code=OAUTH_CODE                 *#
?refresh_token=REFRESH_TOKEN     *#
?scope=STR                        #Must be equal (def) or lower than original ?scope
RESPONSE.access_token             #ACCESS_TOKEN.
RESPONSE.refresh_token            #REFRESH_TOKEN
RESPONSE.stripe_user_id           #ACCOUNT.id
RESPONSE.stripe_publishable_key   #ACCOUNT's publishable API_KEY
RESPONSE.scope                    #STR
RESPONSE.token_type               #Always 'bearer'
ERROR_RESPONSE.error              #STR:
                                  #  - 'invalid_request': no ?grant_type|code|refrsh_token
                                  #  - 'invalid_grant': invalid|expired ?code|refresh_token
                                  #  - 'unsupported_grant_type': invalid ?grant_type
                                  #  - 'invalid_scope': invalid ?scope
                                  #  - 'unsupported_response_type': invalid ?response_type
ERROR_RESPONSE.error_description  #STR that can be shown to user

POST /oauth/deauthorize           #Invalidate an ACCESS_TOKEN.
STRIPE.oauth.deauthorize()        #EVENT 'account.application.deauthorized'
?stripe_user_id=ACCOUNT.id       *#For the ACCOUNT that granted the ACCESS_TOKEN
?client_id=CLIENT_ID             *#For the ACCOUNT that was granted the ACCESS_TOKEN
RESPONSE.stripe_user_id           #Same as input
ERROR_RESPONSE.error              #STR:
                                  #  - 'invalid_request': no ?client_id|stripe_user_id
                                  #  - 'invalid_client': invalid ?client_id|stripe_user_id
ERROR_RESPONSE.error_description  #STR that can be shown to user

                                  ┌──────────────────────┐
                                  │   SINGLE-USE LOGIN   │
                                  └──────────────────────┘

LOGIN_LINK                        #Single-use login URL for this ACCOUNT. Express only.

POST /accounts/ID/login_links     #
STRIPE.loginLinks.create()        #

LOGIN_LINK.url                    #'URL'

POST /accounts/ID/logout          #Invalidate all LOGIN_LINK

                                  ┌───────────────────────┐
                                  │   COMMON ATTRIBUTES   │
                                  └───────────────────────┘

RESOURCE.id                       #STR
RESOURCE.object                   #Either:
                                  #  - 'list': for list endpoints
                                  #  - 'RESOURCE_NAME' (e.g. 'balance_transaction')

RESOURCE.metadata               CU#Custom OBJ
                                  #Max 50 properties, max KEY length 40 bytes, max value length 500 bytes.
                                  #Should not contain personal or confidential information.

RESOURCE.created                  #DATE_NUM
GET /RESOURCES?created=CMP_FILTER #

?expand=VARR,...                  #Populate attribute
                                  #Max depth 4

                                  ┌────────────────┐
                                  │   PAGINATION   │
                                  └────────────────┘

GET /RESOURCES?limit=NUM          #Pagination size (def: 10). Min 1, max 100.
GET /RESOURCES
 ?starting_after|ending_before
 =RESOURCE.id                     #Cursor pagination

LIST                              #Paginated response
LIST.data                         #OBJ_ARR
LIST.has_more                     #BOOL
LIST.total_count                  #NUM
LIST.url                          #'/v1/...'

SRES.list(...)->PROMISE           #PROMISE is also an ASYNC_ITERATOR (with each OBJ model).
SRES.autoPagingEach               #Iterates over all, in streaming mode.
 ([FUNC(OBJ)][, FUNC2([ERROR])])  #PROMISE resolved with undefined once iteration done.
 ->PROMISE                        #FUNC() is called with each model OBJ:
                                  #  - can return false to stop iteration
                                  #  - can be async
                                  #FUNC2() is called at end
SRES.autoPagingToArray            #Iterates over all at once.
 (OPTS)->PROMISE_OBJ_ARR          #OPTS:
                                  #  - limit NUM (required) (max 10000): stops if more than that (but no errors)

                                  ┌─────────────────┐
                                  │   IDEMPOTENCY   │
                                  └─────────────────┘

Idempotency-Key: RANDOM [C]       #Memoize using:
                                  #  - RANDOM
                                  #  - request parameters (including body)
                                  #  - response's status code (including 4**|5**)
                                  #Error is same RANDOM but others two are different.
                                  #Allows for safe retries.
                                  #Only:
                                  #  - for `POST`
                                  #  - for requests that passed input validation layer.
                                  #  - for 24 hours.
                                  #Recommended for:
                                  #  - POST /charges|payment_intents
                                  #     - using the order ID, or the SOURCE.id (unless reusable), etc.
                                  #     - to avoid DISPUTEs on duplicated charges
                                  #  - POST /subscription_items/ID/usage_records

                                  ┌────────────┐
                                  │   ERRORS   │
                                  └────────────┘

{ error: ERROR }                  #Error response for any endpoint

ERROR.message
CHARGE.failure_message            #STR. Can be shown to users for card errors.
ERROR.param                       #'PROP' that failed input validation.
ERROR.charge                      #CHARGE.id
ERROR.payment_intent              #PINTENT
ERROR.setup_intent                #SETUP_INTENT
ERROR.payment_method              #PAYMENT_METHOD
ERROR.source                      #SOURCE.id

NODE_ERROR.raw                    #ERROR
NODE_ERROR.message|code|param     #Same as ERROR.*
NODE_ERROR.rawType                #Same as ERROR.type
NODE_ERROR.type                   #Same as ERROR.type except:
                                  #  - PascalCase and prepended with 'Stripe'
                                  #  - e.g. 'StripeConnectionError' or 'StripeAPIError'
NODE_ERROR.detail                 #NODE_ERROR2. When there is a sub-error
NODE_ERROR.headers                #HEADERS_OBJ
                                  #Only set when a 4**|5** response was received
NODE_ERROR.statusCode NUM         #Only set when a 4**|5** response was received
NODE_ERROR.doc_url                #'URL'

ERROR.type                        #Can be:
                                  #  - 'invalid_request_error' (400|404): input validation server-side
                                  #  - 'authentication_error' (401)
                                  #  - 'api_connection_error': cannot connect to API (network failure, timeout)
                                  #  - 'card_error' (402): credit card could not be charged
                                  #  - 'permission_error' (403)
                                  #  - 'idempotency_error' (409): wrong usage of `Idempotency-Key`
                                  #  - 'rate_limit_error' (429)
                                  #  - 'api_error' (500|502|503|504): server-side errors
                                  #  (stripe.js only)
                                  #  - 'validation_error': input validation
                                  #  (stripe-node only)
                                  #  - 'signature_response_error': webhooks verification error
                                  #  - 'stream_processing_error': when creating files using STREAMs
                                  #  - 'invalid_grant_error': OAuth error
                                  #  - 'generic_error': generic error

ERROR.code                        #One of:
CHARGE.failure_code               #  - 'account_already_exists': The email address provided for the creation of a deferred account already has an account associated with it.
                                  #    Use the OAuth flow to connect the existing account to your platform.
                                  #  - 'account_country_invalid_address': The country of the business address provided does not match the country of the account.
                                  #    Businesses must be located in the same country as the account.
                                  #  - 'account_invalid': The account ID provided as a value for the Stripe-Account header is invalid. Check that your requests are specifying a valid account ID.
                                  #  - 'account_number_invalid': The bank account number provided is invalid (e.g., missing digits).
                                  #    Bank account information varies from country to country. We recommend creating validations in your entry forms based on the bank account formats we provide.
                                  #  - 'alipay_upgrade_required': This method for creating Alipay payments is not supported anymore. Please upgrade your integration to use Sources instead.
                                  #  - 'amount_too_large': The specified amount is greater than the maximum amount allowed. Use a lower amount and try again.
                                  #  - 'amount_too_small': The specified amount is less than the minimum amount allowed. Use a higher amount and try again.
                                  #  - 'api_key_expired': The API key provided has expired. Obtain your current API keys from the Dashboard and update your integration to use them.
                                  #  - 'balance_insufficient': The transfer or payout could not be completed because the associated account does not have a sufficient balance available.
                                  #    Create a new transfer or payout using an amount less than or equal to the account's available balance.
                                  #  - 'bank_account_exists': The bank account provided already exists on the specified Customer object.
                                  #    If the bank account should also be attached to a different customer, include the correct customer ID when making the request again.
                                  #  - 'bank_account_unusable': The bank account provided cannot be used for payouts. A different bank account must be used.
                                  #  - 'bank_account_unverified': Your Connect platform is attempting to share an unverified bank account with a connected account.
                                  #  - 'bitcoin_upgrade_required': This method for creating Bitcoin payments is not supported anymore. Please upgrade your integration to use Sources instead.
                                  #  - 'card_declined': The card has been declined.
                                  #    When a card is declined, the error returned also includes the decline_code attribute with the reason why the card was declined.
                                  #  - 'charge_already_captured': The charge you're attempting to capture has already been captured. Update the request with an uncaptured charge ID.
                                  #  - 'charge_already_refunded': The charge you're attempting to refund has already been refunded. Update the request to use the ID of a charge that has not been refunded.
                                  #  - 'charge_disputed': The charge you're attempting to refund has been charged back. Check the disputes documentation to learn how to respond to the dispute.
                                  #  - 'charge_exceeds_source_limit': This charge would cause you to exceed your rolling-window processing limit for this source type.
                                  #    Please retry the charge later, or contact us to request a higher processing limit.
                                  #  - 'charge_expired_for_capture': The charge cannot be captured as the authorization has expired. Auth and capture charges must be captured within seven days.
                                  #  - 'country_unsupported': Your platform attempted to create a custom account in a country that is not yet supported.
                                  #    Make sure that users can only sign up in countries supported by custom accounts.
                                  #  - 'coupon_expired': The coupon provided for a subscription or order has expired. Either create a new coupon, or use an existing one that is valid.
                                  #  - 'customer_max_subscriptions': The maximum number of subscriptions for a customer has been reached. Contact us if you are receiving this error.
                                  #  - 'email_invalid': The email address is invalid (e.g., not properly formatted).
                                  #    Check that the email address is properly formatted and only includes allowed characters.
                                  #  - 'expired_card': The card has expired. Check the expiration date or use a different card.
                                  #  - 'idempotency_key_in_use': The idempotency key provided is currently being used in another request.
                                  #    This occurs if your integration is making duplicate requests simultaneously.
                                  #  - 'incorrect_address': The card's address is incorrect. Check the card's address or use a different card.
                                  #  - 'incorrect_cvc': The card's security code is incorrect. Check the card's security code or use a different card.
                                  #  - 'incorrect_number': The card number is incorrect. Check the card's number or use a different card.
                                  #  - 'incorrect_zip': The card's ZIP code is incorrect. Check the card's ZIP code or use a different card.
                                  #  - 'instant_payouts_unsupported': The debit card provided as an external account does not support instant payouts.
                                  #    Provide another debit card or use a bank account instead.
                                  #  - 'invalid_card_type': The card provided as an external account is not a debit card. Provide a debit card or use a bank account instead.
                                  #  - 'invalid_charge_amount': The specified amount is invalid.
                                  #    The charge amount must be a positive integer in the smallest currency unit, and not exceed the minimum or maximum amount.
                                  #  - 'invalid_cvc': The card's security code is invalid. Check the card's security code or use a different card.
                                  #  - 'invalid_expiry_month': The card's expiration month is incorrect. Check the expiration date or use a different card.
                                  #  - 'invalid_expiry_year': The card's expiration year is incorrect. Check the expiration date or use a different card.
                                  #  - 'invalid_number': The card number is invalid. Check the card details or use a different card.
                                  #  - 'invalid_source_usage': The source cannot be used because it is not in the correct state (e.g., a charge request is trying to use a source with a pending,
                                  #    failed, or consumed source). Check the status of the source you are attempting to use.
                                  #  - 'invoice_no_customer_line_items': An invoice cannot be generated for the specified customer as there are no pending invoice items.
                                  #    Check that the correct customer is being specified or create any necessary invoice items first.
                                  #  - 'invoice_no_subscription_line_items': An invoice cannot be generated for the specified subscription as there are no pending invoice items.
                                  #    Check that the correct subscription is being specified or create any necessary invoice items first.
                                  #  - 'invoice_not_editable': The specified invoice can no longer be edited.
                                  #    Instead, consider creating additional invoice items that will be applied to the next invoice.
                                  #    You can either manually generate the next invoice or wait for it to be automatically generated at the end of the billing cycle.
                                  #  - 'invoice_upcoming_none': There is no upcoming invoice on the specified customer to preview.
                                  #    Only customers with active subscriptions or pending invoice items have invoices that can be previewed.
                                  #  - 'livemode_mismatch': Test and live mode API keys, requests, and objects are only available within the mode they are in.
                                  #  - 'missing': Both a customer and source ID have been provided, but the source has not been saved to the customer.
                                  #    To create a charge for a customer with a specified source, you must first save the card details.
                                  #  - 'not_allowed_on_standard_account': Transfers and payouts on behalf of a Standard connected account are not allowed.
                                  #  - 'order_creation_failed': The order could not be created. Check the order details and then try again.
                                  #  - 'order_required_settings': The order could not be processed as it is missing required information. Check the information provided and try again.
                                  #  - 'order_status_invalid': The order cannot be updated because the status provided is either invalid or does not follow the order lifecycle (e.g., an order cannot
                                  #    transition from created to fulfilled without first transitioning to paid).
                                  #  - 'order_upstream_timeout': The request timed out. Try again later.
                                  #  - 'out_of_inventory': The SKU is out of stock. If more stock is available, update the SKU's inventory quantity and try again.
                                  #  - 'parameter_invalid_empty': One or more required values were not provided. Make sure requests include all required parameters.
                                  #  - 'parameter_invalid_integer': One or more of the parameters requires an integer, but the values provided were a different type.
                                  #    Make sure that only supported values are provided for each attribute.
                                  #  - 'parameter_invalid_string_blank': One or more values provided only included whitespace. Check the values in your request and update any that contain only whitespace.
                                  #  - 'parameter_invalid_string_empty': One or more required string values is empty. Make sure that string values contain at least one character.
                                  #  - 'parameter_missing': One or more required values are missing.
                                  #  - 'parameter_unknown': The request contains one or more unexpected parameters. Remove these and try again.
                                  #  - 'parameters_exclusive': Two or more mutually exclusive parameters were provided.
                                  #  - 'payment_intent_authentication_failure': The provided payment method has failed authentication.
                                  #    Provide a new payment method to attempt to fulfill this PaymentIntent again.
                                  #  - 'payment_intent_incompatible_payment_method': The PaymentIntent expected a payment method with different properties than what was provided.
                                  #  - 'payment_intent_invalid_parameter': One or more provided parameters was not allowed for the given operation on the PaymentIntent.
                                  #  - 'payment_intent_payment_attempt_failed': The latest payment attempt for the PaymentIntent has failed.
                                  #    Check the last_payment_error property on the PaymentIntent for more details, and provide source_data or a new source to attempt to fulfill this PaymentIntent again.
                                  #  - 'payment_intent_unexpected_state': The PaymentIntent's state was incompatible with the operation you were trying to perform.
                                  #  - 'payment_method_unactivated': The charge cannot be created as the payment method used has not been activated.
                                  #    Activate the payment method in the Dashboard, then try again.
                                  #  - 'payment_method_unexpected_state': The provided payment method's state was incompatible with the operation you were trying to perform.
                                  #    Confirm that the payment method is in an allowed state for the given operation before attempting to perform it.
                                  #  - 'payouts_not_allowed': Payouts have been disabled on the connected account.
                                  #    Check the connected account's status to see if any additional information needs to be provided, or if payouts have been disabled for another reason.
                                  #  - 'platform_api_key_expired': The API key provided by your Connect platform has expired.
                                  #    This occurs if your platform has either generated a new key or the connected account has been disconnected from the platform.
                                  #    Obtain your current API keys from the Dashboard and update your integration, or reach out to the user and reconnect the account.
                                  #  - 'postal_code_invalid': The ZIP code provided was incorrect.
                                  #  - 'processing_error': An error occurred while processing the card. Check the card details are correct or use a different card.
                                  #  - 'product_inactive': The product this SKU belongs to is no longer available for purchase.
                                  #  - 'rate_limit': Too many requests hit the API too quickly. We recommend an exponential backoff of your requests.
                                  #  - 'resource_already_exists': A resource with a user-specified ID (e.g., plan or coupon) already exists. Use a different, unique value for id and try again.
                                  #  - 'resource_missing': The ID provided is not valid. Either the resource does not exist, or an ID for a different resource has been provided.
                                  #  - 'routing_number_invalid': The bank routing number provided is invalid.
                                  #  - 'secret_key_required': The API key provided is a publishable key, but a secret key is required.
                                  #    Obtain your current API keys from the Dashboard and update your integration to use them.
                                  #  - 'sepa_unsupported_account': Your account does not support SEPA payments.
                                  #  - 'shipping_calculation_failed': Shipping calculation failed as the information provided was either incorrect or could not be verified.
                                  #  - 'sku_inactive': The SKU is inactive and no longer available for purchase. Use a different SKU, or make the current SKU active again.
                                  #  - 'state_unsupported': Occurs when providing the legal_entity information for a U.S. custom account, if the provided state is not supported.
                                  #    This is mostly associated states and territories.
                                  #  - 'tax_id_invalid': The tax ID number provided is invalid (e.g., missing digits). Tax ID information varies from country to country, but must be at least nine digits.
                                  #  - 'taxes_calculation_failed': Tax calculation for the order failed.
                                  #  - 'testmode_charges_only': Your account has not been activated and can only make test charges. Activate your account in the Dashboard to begin processing live charges.
                                  #  - 'tls_version_unsupported': Your integration is using an older version of TLS that is unsupported. You must be using TLS 1.2 or above.
                                  #  - 'token_already_used': The token provided has already been used. You must create a new token before you can retry this request.
                                  #  - 'token_in_use': The token provided is currently being used in another request. This occurs if your integration is making duplicate requests simultaneously.
                                  #  - 'transfers_not_allowed': The requested transfer cannot be created. Contact us if you are receiving this error.
                                  #  - 'upstream_order_creation_failed': The order could not be created. Check the order details and then try again.
                                  #  - 'url_invalid': The URL provided is invalid.
ERROR.doc_url                     #'URL' of the ERROR.code

ERROR.decline_code                #When ERROR.code is `card_declined`, can be:
                                  #  - invalid card numbers:
                                  #     - 'incorrect_number'
                                  #     - 'invalid_number'
                                  #     - 'invalid_expiry_year'
                                  #     - 'incorrect_cvc'
                                  #     - 'invalid_cvc'
                                  #     - 'incorrect_pin'
                                  #     - 'invalid_pin'
                                  #     - 'pin_try_exceeded'
                                  #     - 'incorrect_zip': The ZIP/postal code is incorrect.
                                  #     - 'approve_with_id': authorization error.
                                  #  - unknown reason:
                                  #     - 'call_issuer'
                                  #     - 'do_not_honor'
                                  #     - 'do_not_try_again'
                                  #     - 'generic_decline'
                                  #     - 'no_action_taken'
                                  #     - 'not_permitted'
                                  #     - 'revocation_of_all_authorizations'
                                  #     - 'revocation_of_authorization'
                                  #     - 'security_violation'
                                  #     - 'service_not_allowed'
                                  #     - 'stop_payment_order'
                                  #     - 'try_again_later'
                                  #     - 'transaction_not_allowed'
                                  #  - fraud:
                                  #     - 'fraudulent': Stripe suspects it is fraudulent.
                                  #     - 'lost_card': reported lost.
                                  #     - 'stolen_card': reported stolen.
                                  #     - 'pickup_card': reported lost or stolen.
                                  #     - 'restricted_card': reported lost or stolen.
                                  #     - 'merchant_blacklist': merchant is blacklisted by Stripe.
                                  #  - not enough money:
                                  #     - 'card_velocity_exceeded': exceeded the balance or credit limit available.
                                  #     - 'withdrawal_count_limit_exceeded': exceeded the balance or credit limit available on their card.
                                  #     - 'insufficient_funds'
                                  #     - 'invalid_amount': payment amount is invalid, or exceeds the amount that is allowed.
                                  #  - invalid purchase:
                                  #     - 'card_not_supported': does not support this type of purchase.
                                  #     - 'currency_not_supported': does not support the specified currency.
                                  #  - invalid card/bank:
                                  #     - 'expired_card'
                                  #     - 'invalid_account': The card, or account the card is connected to, is invalid.
                                  #     - 'new_account_information_available': The card, or account the card is connected to, is invalid.
                                  #  - server-side:
                                  #     - 'issuer_not_available': provider could not be reached.
                                  #     - 'processing_error': An error occurred while processing the card.
                                  #     - 'reenter_transaction': The payment should be attempted again.
                                  #  - 'duplicate_transaction'
                                  #  - 'testmode_decline': A Stripe test card number was used. A genuine card must be used to make a payment.

Request-Id: UUID [S]              #Request/response ID, for debugging
NODE_ERROR.requestId STR          #Request-Id [S]
                                  #Only set when a 4**|5** response was received

                                  ┌─────────────┐
                                  │   TESTING   │
                                  └─────────────┘

TEST MODE ==>                     #Each key has either a production or a test version
                                  #  - sandbox / separate data
                                  #  - payments not processed by providers
                                  #  - simpler steps for some flows
                                  #  - fewer retries
                                  #Forbidden by terms of service to use production key for testing.
                                  #Dashboard can toggle between each mode.
RESOURCE.livemode                 #BOOL on all RESOURCEs
                                  #Test transactions fire both test and production webhooks if WEBHOOK.connect true
                                  #  - i.e. those webhook handlers should check RESOURCE.livemode

FAKE DATA ==>                     #Can use test|fake SOURCE|TOKEN with following data. See list at:
                                  #  - https://stripe.com/docs/testing
                                  #  - each of the payment method doc pages
                                  #  - https://stripe.com/docs/connect/testing
                                  #  - https://stripe.com/docs/billing/testing
                                  #  - https://stripe.com/docs/radar/testing
                                  #SOURCE for CHARGE|PINTENT:
                                  #  - 'card':
                                  #      - use SOURCE.TYPE.number
                                  #      - different ones:
                                  #         - SOURCE.TYPE.brand
                                  #         - type of payment (credit|debit|etc.)
                                  #         - SOURCE.country
                                  #  - 'card' with 3D secure:
                                  #      - use SOURCE.TYPE.number
                                  #      - different ones:
                                  #         - version 1 vs version 2
                                  #         - requiredAndPerformed, notRequiredButPerformed, requiredButNotSupportedByBank, notSupported
                                  #         - *_check states
                                  #         - failure types
                                  #         - radar risk levels
                                  #         - country split pricing
                                  #  - 'sepa_debit':
                                  #      - use SOURCE.TYPE.iban
                                  #      - different ones: success vs fail
                                  #  - 'ach_credit_transfer':
                                  #      - SOURCE.owner.email 'amount_AMOUNT@example.com'
                                  #  - 'multibanco':
                                  #      - SOURCE.owner.email 'ANYTHING+fill_never|now@ANY_DOMAIN' (user never initiate, or does it right away)
                                  #  - 'sofort':
                                  #      - SOURCE.owner.name: 'succeeding_charge|failing_charge'
                                  #  - 'ach_debit':
                                  #      - SOURCE.type.routing_number: 110000000
                                  #      - SOURCE.type.account_number:
                                  #         - different failure types
                                  #      - PAYLOAD.amounts (verify endpoint):
                                  #         - [32, 45]: success
                                  #         - [any other]: failure
                                  #  - 'amex_express_checkout':
                                  #      - username: test_user
                                  #      - password: password
                                  #      - access code: 123456
                                  #  - 'masterpass': https://developer.mastercard.com/page/masterpass-sandbox-testing-guidelines#new-web-experience
                                  #  - 'visa checkout': https://developer.visa.com/capabilities/visa_checkout/docs#adding_visa_checkout_to_your_web_page
                                  #  - 'klarna': https://stripe.com/docs/sources/klarna#testing-klarna-payments
                                  #TOKEN|PAYMENT_METHOD:
                                  #  - use TOKEN|PAYMENT_METHOD.id
                                  #  - same differences as 'card' SOURCE
                                  #CARD|BANK_ACCOUNT for PAYOUT:
                                  #  - different ones:
                                  #     - country
                                  #     - failure code
                                  #     - CARD.brand
                                  #BANK_ACCOUNT for TOPUP:
                                  #  - different ones: failure code
                                  #DISPUTE:
                                  #  - through 'card' and 'sepa_debit' SOURCEs testing
                                  #  - different ones:
                                  #     - inquiry or normal DISPUTEs
                                  #     - won|lost
                                  #ACCOUNT for Connect:
                                  #  - PERSON.phone 0000000000 (express only)
                                  #  - PERSON.dob|id_number|verification.document, COMPANY.tax_id:
                                  #     - different ones: failure|success
                                  #  - OAuth:
                                  #     - should create separate test ACCOUNT (not OAuth to self)
                                  #     - ?redirect_uri can be HTTP, and can be localhost
                                  #TAX_ID:
                                  #  - different ones: success|failure|pending
                                  #READER:
                                  #  - SDK can mock a READER ("simulator")
                                  #CHARGE with READER:
                                  #  - must use a physical test card sent by Stripe
                                  #  - use CHARGE.amount
                                  #  - different ones: failure codes
                                  #CARD|TOKEN for CHARGE.outcome.risk_level

                                  ┌───────────┐
                                  │   EVENT   │
                                  └───────────┘

EVENT                             #Either:
                                  #  - asynchronous operation results
                                  #     - can use webhooks to handle them
                                  #  - generic API events, e.g. resource creation|update|deletion
                                  #     - webhooks not needed there

'EVENT_TYPE'                      #Common types are 'RESOURCE.created|updated|deleted' for:
                                  #  (created|updated|deleted)
                                  #  - account.external_account
                                  #  - coupon
                                  #  - customer[.discount|source|subscription|tax_id]
                                  #  - invoice
                                  #  - invoiceitem
                                  #  - person
                                  #  - plan
                                  #  - product
                                  #  - recipient
                                  #  - sku
                                  #  (created|updated)
                                  #  - charge.dispute
                                  #  - credit_note
                                  #  - early_fraud_warning
                                  #  - issuing_authorization
                                  #  - issuing_card
                                  #  - issuing_cardholder
                                  #  - issuing_dispute
                                  #  - issuing_settlement
                                  #  - issuing_transaction
                                  #  - order
                                  #  - payout
                                  #  - source.transaction
                                  #  - tax_rate
                                  #  - transfer
                                  #  (created)
                                  #  - application_fee
                                  #  - file
                                  #  - order_return
                                  #  - payment_intent
                                  #  - setup_intent
                                  #  - sigma.scheduled_query_run
                                  #  - topup
                                  #  (updated)
                                  #  - account
                                  #  - application_fee.refund
                                  #  - capability
                                  #  - charge
                                  #  - charge.refund
                                  #  - mandate
                                  #  - payment_method
                                  #  - reporting.report_type
                                  #  (none)
                                  #  - reporting.report_run
                                  #  - review
                                  #  - source
                                  #Other types are documented in each related resource.

GET /events[/ID]                  #
STRIPE.events.retrieve|list()     #

EVENT.api_version                 #'VERSION'
                                  #EVENTs are not migrated on new API versions, i.e. they keep old shape.
EVENT.type                        #'EVENT_TYPE'.
?type=STR                         #Can contain * for subtypes
?types=STR_ARR                    #
EVENT.data                        #EVENT_DATA
EVENT_DATA.object                 #RESOURCE that has changed (all new values)
EVENT_DATA.previous_attributes   ?#RESOURCE that has changed (only old values)
EVENT.request                     #EVENT_REQUEST. API request that started the event.
                                  #Fields are null if event was triggered by Stripe itself.
                                  #Request logs are available in the dashboard, but not in the API.
EVENT_REQUEST.id                 ?#Request-Id [S]
EVENT_REQUEST.idempotency_key    ?#Idempotency-Key [C]
EVENT.account                     #ACCOUNT.
EVENT.application                ?#ACCOUNT. Only within webhook payloads, when WEBHOOK.connect true.
EVENT.pending_webhooks            #INT. Number of webhooks still ongoing.
?delivery_success=BOOL            #

                                  ┌─────────────┐
                                  │   WEBHOOK   │
                                  └─────────────┘

WEBHOOK                           #Webhook firing request on EVENT creation.
                                  #Does a POST request with EVENT as JSON payload.
                                  #Should respond with 200 right away, before even processing the event.
                                  #  - otherwise tries for up to 3 days, with an exponential backoff
                                  #Webhooks might sometimes be triggered twice for same EVENT, i.e. handlers should be idempotent.
                                  #Order of webhooks (when several events are related) is not guaranteed.

GET /webhook_endpoints[/ID]
POST /webhook_endpoints[/ID]
DELETE /webhook_endpoints/ID      #
STRIPE.webhookEndpoints.
 list|retrieve|create|update|del()#

WEBHOOK.url                    *CU#'URL'
WEBHOOK.enabled_events         *CU#'EVENT_TYPE'_ARR that should trigger a request. Can be '*'
WEBHOOK.api_version              C#'VERSION'
WEBHOOK.secret                    #Webhook-specific 'SECRET' only returned at creation. Used to sign the request.
                                  #Can also be found in dashboard.
WEBHOOK.connect                 RC#BOOL. For 'account|person.*' EVENTs, whether this is for current ACCOUNT or OAuth connected ACCOUNT.
WEBHOOK.application              ?#ACCOUNT.id if WEBHOOK.connect true
WEBHOOK.disabled                RU#BOOL
WEBHOOK.status                    #'enabled' or 'disabled'

SIGNATURE ==>                     #Webhooks requests must be verified to make sure they are sent by Stripe.
                                  #Using SECRET and Stripe-Signature: 't=DATE_NUM,v1=HASH' [S]:
                                  #  - HASH is SHA256('DATE_NUM.REQUEST_PAYLOAD', SECRET) in hex
                                  #  - DATE_NUM is set sometime during response sending
                                  #     - should verify that it's not too far from current time to prevent replay attacks
                                  #       (intercepting a webhook request then resending it later)
                                  #     - library use a default tolerance of 5 minutes

STRIPE[-NODE].webhooks.signature. #Throw error if webhook request is invalid.
 verifyHeader(REQUEST_PAYLOAD,    #HEADER is Stripe-Signature [S]
 HEADER, SECRET, NUM)             #SECRET is webhook secret.
                                  #NUM is tolerance (def: does not check) (see above).
STRIPE[-NODE].webhooks.           #Like verifyHeader() except:
 constructEvent(REQUEST_PAYLOAD,  #  - returns JSON.parse(REQUEST_PAYLOAD)
 HEADER, SECRET, NUM)->OBJ        #  - def tolerance is 5 minutes
STRIPE[-NODE].webhooks.           #Get HEADER, for testing purposes.
 generateWebhookHeaderString      #OPTS:
 (OPTS)->HEADER                   #  - timestamp DATE_NUM
                                  #  - payload 'JSON'
                                  #  - secret SECRET
                                  #  - signature HASH (def: based on OPTS.timestamp|payload|secret)
                                  #  - scheme STR (def: 'v1')

                                  ┌───────────┐
                                  │   FILES   │
                                  └───────────┘

FILE                              #Static file, for the models|attributes that need it.

GET /files[/ID]                   #For POST:
POST /files                       #  - endpoint is https://files.stripe.com
                                  #  - Content-Type is multipart/form-data
STRIPE.files.
 retrieve|list|create()           #
STRIPE.files.create(OBJ|STREAM)   #OBJ:
                                  #  - key is filename
                                  #  - value is BUFFER|STR or { [type: 'MIME', ]data BUFFER|STR }
                                  #STREAM: filename will be 'file'
                                  #Def files MIME is 'application/octet-stream'

FILE.url                          #Private 'URL'
FILE.file_link_data             RC#FILE_LINK: expires_at, metadata, create true (required)
                                  #Not possible when FILE.purpose is 'finance_report_run|identity_document|sigma_scheduled_query'
FILE.links                        #FILE_LINK_LIST
FILE.filename                     #'FILENAME'
FILE.title                        #STR.
FILE.type                         #'EXT'
FILE.size                         #NUM (in bytes)
FILE.purpose                    *C#STR among:
                                  #  - 'business_icon|logo': ACCOUNT.settings.branding.icon|logo
                                  #  - 'identity_document': PERSON.verification.document.front|back
                                  #  - 'dispute_evidence': [ISSUING_]DISPUTE.evidence.*
                                  #  - 'customer_signature': DISPUTE.evidence.customer_signature
                                  #  - 'sigma_scheduled_query': SCHEDULED_QUERY.file
                                  #  - 'finance_report_run': REPORT_RUN.result
                                  #  - 'pci_document': PCI compliance file uploaded through Dashboard
                                  #  - 'tax_document_user_upload': uploaded through Dashboard
                                  #  - 'additional_verification'
?purpose=STR                      #

FILE_LINK                         #Link sharing a FILE publicly.

GET /file_links[/ID]
POST /file_links[/ID]             #
STRIPE.fileLinks.
 retrieve|list|create|update()    #

FILE_LINK.file                  *C#FILE.id
?file=FILE.id                     #
FILE_LINK.url                     #Public 'URL'
FILE_LINK.expires_at            CU#DATE_NUM
FILE_LINK.expired                 #BOOL
?expired=BOOL                     #

                                  ┌─────────────┐
                                  │   ADDRESS   │
                                  └─────────────┘

ADDRESS                           #
ADDRESS.country                   #COUNTRY
ADDRESS.state                     #STR
ADDRESS.city                      #STR
ADDRESS.postal_code               #STR
ADDRESS.line1                     #STR (e.g. street)
ADDRESS.line2                     #STR (e.g. appt)

BILL_DETAILS.address              #ADDRESS
BILL_DETAILS.name                 #STR. Recipient name.
BILL_DETAILS.email                #STR.
BILL_DETAILS.phone                #STR. Includes country extension

SHIPPING                          #Like ADDRESS with extra fields:
SHIPPING.carrier                  #STR. Delivery service like 'Fedex', 'UPS', 'USPS', etc.
SHIPPING.tracking_number          #'STR,...'.

                                  ┌──────────────┐
                                  │   CURRENCY   │
                                  └──────────────┘

RESOURCE.currency                 #STR (ISO 4217) (e.g. 'usd')
                                  #Available:
                                  #  - as sibling on any RESOURCE with MONEY properties.
                                  #  - on CUSTOMER|CARD|BANK_ACCOUNT|SKU|REPORT_RUN_PARAMS

COUNTRY_SPEC.default_currency     #STR
ACCOUNT.default_currency        CU#STR
                                  #Defaults to COUNTRY_SPEC.default_currency
CUSTOMER.currency                 #STR. Default for SUBSCRIPTIONs
                                  #Set by Stripe on first SUBSCRIPTION|INVOICE|COUPON|CREDIT_NOTE
                                  #Set only once. To change it, create new CUSTOMER
SOURCE|EXTERNAL_ACCOUNT.        CU#BOOL (def: false).
 default_for_currency             #When making payout to multiple SOURCE|EXTERNAL_ACCOUNTs:
                                  #  - use the one with same currency
                                  #  - if multiple ones, use the one with BOOL true

CURRENCY CONVERSION ==>           #Conversion is automatic and has three stages:
                                  #  - customer's currency (specified by SOURCE, i.e. customer input)
                                  #     - used during CHARGE
                                  #  - CHARGE.currency ("presentment" currency) (specified by our code)
                                  #     - stored in BALANCE, currency-wise
                                  #  - destination's currency (our bank account)
                                  #     - used during PAYOUT|TOPUP
                                  #        - not when money is re-used with a REFUND or a Connect transaction

AVAILABLE CURRENCIES ==>          #Customer's currency:
                                  #  - see full list at https://stripe.com/docs/currencies
                                  #CHARGE.currency is payment method-specific:
                                  #  - 'card*': any.
                                  #  - 'usd' only for card with JCB, Discover, Diners Club, and for 'ach*'
                                  #  - 'eur' for 'bancontact', 'eps', 'giropay', 'ideal', 'multibanco', 'sepa_debit', 'sofort', 'klarna'
                                  #  - 'pln' for 'p24'
                                  #  - 'usd', 'eur', 'gbp', 'cad', 'aud', 'sgd', 'hkd', 'jpy', 'nzd' for 'alipay'
                                  #     - and must be same as destination currency
                                  #  - 'usd', 'gbp', 'eur', 'aud', 'chf', 'hkd', 'sgd' for 'apple_pay'
                                  #  - 'usd', 'gbp', 'eur', 'aud', 'nzd', 'hkd', 'sgd' for 'google_pay'
                                  #  - 'usd', 'gbp', 'eur', 'aud', 'cad', 'hkd', 'sgd' for 'wechat'
                                  #Destination currency:
                                  #  - must match main currency of ACCOUNT.country
COUNTRY_SPEC.                     #Supported currencies as STR_ARR.
 supported_payment_currencies     #All countries support all currencies, so not useful.

EXCHANGE FEE ==>                  #Conversion exchange fee (if conversion needed):
                                  #  - customer to presentment: paid by customer (bank fee)
                                  #  - presentment to destination: 1% Stripe fee
                                  #I.e. CHARGE.currency should either use:
                                  #  - customer's currency (preferred): fee is paid by us, if PAYOUT|TOPUP
                                  #  - destination's currency: fee is paid by customer, always
                                  #There is also an unrelated fee when customer's bank's country is different from destination's:
                                  #  - paid by customer (bank fee)
                                  #  - we also pay 1-1.5% Stripe fee (depending on country)
                                  #Can set several bank accounts with different currencies|countries to avoid those fees.
                                  #Conversion happens at rate when CHARGE|REFUND is created:
                                  #  - the difference between REFUND and its CHARGE is paid by destination not customer
                                  #     - i.e. customer always get back exactly what they paid
                                  #Currency rates are shown in dashboard.
BALANCE_TRANSACTION.exchange_rate #NUM. Customer's currency to CHARGE.currency exchange rate.

                                  ┌─────────────┐
                                  │   COUNTRY   │
                                  └─────────────┘

COUNTRY                           #STR (2-letters ISO code)

AVAILABLE COUNTRIES ==>           #Only in Western countries (except Eastern Europe), Hong Kong, Singapore and Japan.
                                  #  - soon: Greece, Baltic countries, Poland, Brazil, India, Mexico, Malaysia
                                  #  - but can accept payments from any country
                                  #TRANSFER|PAYOUT|TOPUP must be within country with same default currency (e.g. Eurozone)
                                  #TERMINAL and ISSUING* available in US only

ACCOUNT.country                  C#COUNTRY. Cannot be changed.
                                  #Must match the bank account / credit card's country.
                                  #Impacts pricing and features (see COUNTRY_SPEC)
INVOICE.account_country           #

COUNTRY_SPEC                      #Country-specific information (currency, TRANSFER|PAYOUT|TOPUP, payment methods, required ACCOUNT|PERSON.* fields)

GET /country_specs[/ID]           #
STRIPE.countrySpecs.
 retrieve|list()                  #

COUNTRY_SPEC.id                   #COUNTRY
COUNTRY_SPEC.                     #{ CURRENCY: COUNTRY_ARR, ... }
 supported_bank_account_currencies#Currencies|countries accepted for TRANSFER|PAYOUT|TOPUP
COUNTRY_SPEC.
 supported_transfer_countries     #Same as single COUNTRY_ARR

                                  ┌────────────────────┐
                                  │   PAYMENT INTENT   │
                                  └────────────────────┘

PINTENT                           #SOURCE authentication + CHARGE creation
                                  #Can re-use SOURCE|PAYMENT_METHOD (CUSTOMER.sources|payment_method), but must re-authenticate for each CHARGE.
                                  #Meant to be used with PAYMENT_METHOD and replace SOURCE over time:
                                  #  - PINTENT.status|next_action is similar to SOURCE.flow
                                  #  - only support types supported by PAYMENT_METHOD (i.e. 'card*|sepa_debit|fpx')

GET /payment_intents[/ID]
POST /payment_intents[/ID]        #
POST /payment_intents/ID/confirm  #Like PINTENT.confirm true
                                  #Payload attributes: client_secret, payment_method, receipt_email, return_url, shipping,
                                  #source, off_session, error_on_requires_action
POST /payment_intents/ID/cancel   #Set PINTENT.status 'canceled'.
                                  #Payload attributes: cancellation_reason
STRIPE.paymentIntents.
 retrieve|list|create|update|
 confirm|cancel()                 #

PINTENT.amount                 *CU#
PINTENT.application_fee_amount  CU#
PINTENT.payment_method          CU#
PINTENT.customer                CU#
PINTENT.shipping                CU#
PINTENT.application               #
PINTENT.on_behalf_of             C#
PINTENT.description             CU#
PINTENT.receipt_email          ?CU#
?receipt_email=STR                #
PINTENT.invoice                   #
PINTENT.review                    #Like CHARGE.*
PINTENT.charges                   #CHARGE_LIST
                                  #Contains all failed CHARGEs + an final successful CHARGE (if any).
                                  #Sorted in reverse order.

PINTENT.payment_method_types    CU#STR_ARR of allowed SOURCE.type
PINTENT.payment_method_options  CU#OBJ:
                                  #  - card:
                                  #     - request_three_d_secure 'automatic' (def), 'challenge_only' or 'any'
                                  #     - installments OBJ:
                                  #        - Mexico only
                                  #        - https://stripe.com/docs/payments/installments: only document if needed
PINTENT.setup_future_usage      CU#'off_session' or 'off_session' (def)
                                  #Indicates that either:
                                  #  - payment will be done while user is not on the website.
                                  #  - payment method will be re-used by attaching to a CUSTOMER
                                  #This changes what SCA regulation requires, e.g. 3D secure confirmation.
PINTENT.off_session              C#Like PINTENT.setup_future_usage
                                  #Either 'recurring'|false or 'one_off'|true.

PINTENT.status                    #STR among:
                                  #  - 'requires_payment_method':
                                  #      - initial state
                                  #      - must add PINTENT.source|payment_method
                                  #  - 'requires_confirmation': must PINTENT.confirm true
                                  #  - 'requires_action':
                                  #      - ask for customer to authenticate using PINTENT.next_action (abstraction of SOURCE.flow)
                                  #      - if not needed, directly goes to 'requires_capture|succeeded'
                                  #  - 'processing': on-going PINTENT.next_action
                                  #     - EVENT 'payment_intent.processing'
                                  #  - 'requires_capture': must STRIPE.capture() (with PINTENT.capture_method 'manual')
                                  #  - 'succeeded': success
                                  #     - EVENT 'payment_intent.succeeded'
                                  #  - 'canceled':
                                  #     - cannot be done when status is 'processing' or 'succeeded'
                                  #     - refunded if partial captured (see amount_to_capture)
                                  #     - EVENT 'payment_intent.canceled'
                                  #On failure:
                                  #  - goes back to 'requires_payment_method'
                                  #  - EVENT 'payment_intent.payment_failed'
                                  #  - can try again
                                  #PINTENT should be:
                                  #  - created as soon as possible, i.e. when CUSTOMER start adding products/services
                                  #  - re-used if CUSTOMER does not finish, then comes back later
PINTENT.confirm                 RC#BOOL (def: false).
                                  #Set status to 'requires_action'
PINTENT.                        RC#BOOL (def: false). Does not allow status status 'requires_action'
 error_on_requires_action         #To use when user confirmation is not possible.
PINTENT.confirmation_method      C#Either:
                                  #  - 'manual':
                                  #     - manually set PINTENT.payment_method|confirm in the server
                                  #     - manually perform PINTENT.next_action in the client
                                  #     - sync|async SOURCEs: like CHARGEs
                                  #  - 'automatic' (def) (preferred):
                                  #     - let Stripe.js handle PINTENT.payment_method|confirm|next_action automatically
                                  #     - must pass PINTENT.client_secret to Stripe.js before it asks for payment method
                                  #     - must use webhooks even for sync SOURCEs
                                  #     - does not require passing TOKENs to server (since PINTENT.payment_method is set by Stripe.js)

PINTENT.next_action              ?#NEXT_ACTION
NEXT_ACTION.type                  #Either:
                                  #  - 'redirect_to_url': with confirmation_method 'manual'
                                  #  - 'use_stripe_sdk': with confirmation_method 'automatic'
NEXT_ACTION.redirect_to_url       #REDIRECT_TO_URL
REDIRECT_TO_URL.url               #'URL' to redirect CUSTOMER to, for payment authentication
REDIRECT_TO_URL.return_url        #'URL' CUSTOMER will be redirected to, after payment authentication
                                  #Will pass the following query variables:
                                  #  - ?payment_intent ID
                                  #  - ?payment_intent_client_secret STR: should be same as PINTENT.client_secret
PINTENT.return_url              RC#Can only be set if PINTENT.confirm true, PINTENT.confirmation_method 'manual' and SOURCE.type is 'card*'
PINTENT.client_secret             #PINTENT-specific STR.
                                  #?payment_intent_client_secret is added to REDIRECT_TO_URL.return_url redirection.
                                  #Should match PINTENT.client_secret to ensure this is the same customer.

PINTENT.use_stripe_sdk          RC#BOOL
NEXT_ACTION.use_stripe_sdk        #Internal OBJ used by Stripe.js

PINTENT.last_payment_error       ?#Confirmation ERROR
PINTENT.canceled_at              ?#DATE_NUM
PINTENT.cancellation_reason      ?#STR among:
                                 ?#  - by user|us: 'duplicate', 'fraudulent', 'requested_by_customer', 'abandoned'
                                 ?#  - by Stripe: 'failed_invoice', 'void_invoice', 'automatic'

                                  ┌──────────────────┐
                                  │   SETUP INTENT   │
                                  └──────────────────┘

SETUP_INTENT                      #Like PINTENT but save payment information without charging (instead of after charging)
                                  #To do when want to reuse it for several payments.

GET /setup_intents[/ID]
POST /setup_intents[/ID]
POST /setup_intents/ID/confirm    #Like POST /payment_intents/ID/confirm, except PAYLOAD attributes only: client_secret, payment_method, return_url
POST /setup_intents/ID/cancel     #Like POST /payment_intent/ID/cancel (same PAYLOAD)
STRIPE.setupIntents.retrieve|list|
 create|update|confirm|cancel()

SETUP_INTENT.payment_method     CU#
?payment_method=PAYMENT_METHOD.id #
SETUP_INTENT.
 payment_method_options         CU#
SETUP_INTENT.customer           CU#
?customer=CUSTOMER.id
SETUP_INTENT.application          #
SETUP_INTENT.on_behalf_of        C#
SETUP_INTENT.description        CU#
SETUP_INTENT.
 payment_method_types           CU#
SETUP_INTENT.status               #EVENT 'setup_intent.setup_failed|succeeded|canceled'
SETUP_INTENT.confirm            RC#
SETUP_INTENT.next_action          #
SETUP_INTENT.client_secret
SETUP_INTENT.cancellation_reason  #Like PINTENT
SETUP_INTENT.last_setup_error     #Like PINTENT.last_payment_error
SETUP_INTENT.usage              CU#'on_session|off_session', like PINTENT.off_session

                                  ┌────────────┐
                                  │   CHARGE   │
                                  └────────────┘

CHARGE                            #Single payment

GET /charges[/ID]
POST /charges[/ID]                #
STRIPE.charges.retrieve|list|
 create|update()                  #

CHARGE.payment_intent             #PINTENT.id
?payment_intent=PINTENT.id        #

CHARGE.amount                   *C#PMONEY
                                  #Have a currency-specific minimum (around $0.5).
                                  #  - see https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts
CHARGE.balance_transaction        #BALANCE_TRANSACTION.id

CHARGE.status                     #First 'pending' then either 'succeeded' or 'failed'.
                                  #EVENTS 'charge.pending|succeeded|failed' fired:
                                  #  - most SOURCEs are sync:
                                  #     - response status is never 'pending'
                                  #     - no need to use webhooks
                                  #  - some SOURCEs are async
                                  #     - must use webhooks
                                  #     - only SOURCE.type 'klarna' (1 day), 'ach_*' (2-5 days), 'sepa_debit' (6 days) and 'sofort' (2-14 days)
CHARGE.paid                       #BOOL for success

CHARGE.refunds                    #REFUND_LIST
CHARGE.refunded                   #BOOL. False if only partially refunded.
CHARGE.amount_refunded            #PMONEY. 0 if none.

CHARGE.source                   *C#Can be:
                                  #  - TOKEN
                                  #  - SOURCE|CARD|BANK_ACCOUNT:
                                  #     - must be reusable
                                  #     - requires CHARGE.customer
                                  #  - ACCOUNT
                                  #On create, must be ID
                                  #Prefer STRIPE.paymentMethod.create() + CHARGE.payment_method*
CHARGE.payment_method             #PAYMENT_METHOD.id
CHARGE.payment_method_details     #Like SOURCE.type + SOURCE.TYPE.*

CHARGE.customer                 CU#CUSTOMER.id
?customer=CUSTOMER.id             #
CHARGE.shipping                 CU#SHIPPING.
CHARGE.billing_details            #BILL_DETAILS
CHARGE.description              CU#STR. Shown in receipts.

CHARGE.receipt_email           ?CU#'EMAIL' to send a receipt to.
                                  #Can be resent|previewed from the dashboard.
                                  #Defaults to CHARGE.customer.email, providing it is enabled in Dashboard settings.
?receipt_email=STR                #
CHARGE.receipt_url                #'URI'. Kept up-to-date.
CHARGE.receipt_number             #STR. Unique number appearing on receipts.

                                  ┌───────────────┐
                                  │   CAPTURING   │
                                  └───────────────┘

CAPTURING ==>                     #Delayed payment:
                                  #  - first authorize CHARGE|PINTENT by bank
                                  #     - can be done several times or partially by specifying CHARGE.amount or PINTENT.amount_to_capture|application_fee_amount
                                  #  - then process payment (make money move)
                                  #     - EVENT 'charge.captured'
                                  #If more than 7 days, CHARGE|PINTENT fails
                                  #  - EVENT 'charge.expired'
                                  #To cancel it, should create a REFUND

GOALS ==>                         #Lightweight refund by holding money (cannot be spent by customer) without withdrawing it
                                  #  - e.g. when merchant must do some work before customer pays, and wants to avoid wasting
                                  #    this is customer cancels, while still allowing easy refunds
                                  #Delaying payment when it might look fraudulent
                                  #  - e.g. first check if it creates a REVIEW

LIMITS ==>                        #Only works with card* and klarna SOURCEs
                                  #Some banks show not-processed yet (but authorized) payments as if it was processed, which
                                  #can confuse some customers.

PINTENT CAPTURING ==>             #Steps:
                                  #  - POST /payment_intents with PINTENT.capture_method 'manual'
                                  #  - bank authorization -> PINTENT.status 'required_capture'
                                  #  - POST /payment_intents/ID/capture
                                  #  - fully processed -> PINTENT.status 'succeeded'
POST /payment_intents/ID/capture  #Payload: amount_to_capture, application_fee_amount
STRIPE.capture()                  #
PAYLOAD.amount_to_capture         #MONEY (def: full)
PAYLOAD.application_fee_amount    #MONEY (def: full)
PINTENT.amount_capturable         #How much can be withdrawn. When changes, EVENT 'payment_intent.amount_capturable_updated'
                                  #Eventually reaches PINTENT.amount
PINTENT.amount_received           #Sums of all PAYLOAD.amount_to_capture so far.
PINTENT.capture_method           C#Either:
                                  #  - 'automatic' (def): no capturing
                                  #  - 'manual': capturing

CHARGE CAPTURING ==>              #Steps:
                                  #  - POST /charges/ID with CHARGE.capture false
                                  #  - bank authorization
                                  #  - POST /charges/ID/capture or POST /charges/ID with CHARGE.capture true
                                  #  - fully processed -> CHARGE.status 'succeeded'
POST /charges/ID/capture
STRIPE.capture()                  #
CHARGE.capture                  RC#BOOL
CHARGE.captured                   #BOOL

                                  ┌────────────┐
                                  │   REFUND   │
                                  └────────────┘

REFUND                            #Reverting a CHARGE.
                                  #As opposed to CHARGE, do not incur a fee
                                  #  - but original CHARGE's Stripe fee is not reversed
                                  #Takes 5-10 days for customer to see credit.
                                  #Stripe send email to customer providing:
                                  #  - dashboard setting is enabled for this
                                  #  - CHARGE.customer.email is defined.
                                  #Reuses same SOURCE as CHARGE's.
                                  #Can fail:
                                  #  - e.g. if customer's SOURCE is not valid anymore.
                                  #  - refund is reversed under 30 days.
                                  #Payment-method specifics:
                                  #  - alipay, au_becs_debit: within 90 days
                                  #  - all others: within 180 days

GET /refunds[/ID]
POST /refunds[/ID]                #
STRIPE.refunds.
 list|retrieve|create|update()    #

REFUND.charge                   *C#CHARGE.id that was refunded.
?charge=CHARGE.id                 #
REFUND.payment_intent           *C#PINTENT.id that was refunded.
?payment_intent=PINTENT.id        #
REFUND.receipt_number             #Like CHARGE.*

REFUND.amount                    C#MONEY.
                                  #Can be partial:
                                  #  - in that case, refund_application_fee|reverse_transfer will be proportional.
                                  #  - can do several REFUNDs per CHARGE, but sum cannot exceed total CHARGE amount
REFUND.balance_transaction        #BALANCE_TRANSACTION.id of the refund

REFUND.status                     #STR among:
                                  #  - 'pending'
                                  #  - 'canceled', 'succeeded' or 'failed'
                                  #     - EVENT 'charge.refunded'
                                  #Card refunds are synchronous, i.e. never 'pending' nor 'canceled'.
REFUND.failure_balance_transaction#If refund failed, BALANCE_TRANSACTION.id reversing refund itself.
REFUND.failure_reason             #If refund failed, STR among 'lost_or_stolen_card', 'expired_or_canceled_card', 'unknown'.

REFUND.reason                   ?C#STR among 'duplicate', 'fraudulent', 'requested_by_customer', 'expired_uncaptured_charge'
REFUND.description                #STR. Shown to users. Only for non-card payments.

                                  ┌──────────────────────────┐
                                  │   STATEMENT DESCRIPTOR   │
                                  └──────────────────────────┘

RESOURCE.statement_descriptor     #STR. Description in CUSTOMER's bank transaction statement.
                                  #Only ASCII. Cannot contain <>"'*. Must contain a letter.
                                  #Three parts:
                                  #  - prefix among:
                                  #     - PAYOUT: ACCOUNT.settings.payouts.statement_descriptor
                                  #     - specific SOURCE: SOURCE.statement_descriptor
                                  #     - 'card' SOURCE: ACCOUNT.settings.card_payments.statement_descriptor_prefix
                                  #     - otherwise: ACCOUNT.settings.payments.statement_descriptor
                                  #  - delimiter '* '
                                  #  - suffix among: CHARGE|PINTENT|PAYOUT|TOPUP|INVOICE|SERVICE_PRODUCT.statement_descriptor
                                  #     - for SERVICE_PRODUCT, if multiple at once, use the first one
                                  #Total max length 22.
RESOURCE.
 statement_descriptor_suffix      #STR. Preferred to RESOURCE.statement_descriptor. For CHARGE|PINTENT only
ACCOUNT.settings.payouts.
 statement_descriptor           CU#
ACCOUNT.settings.
 card_payments.
 statement_descriptor_prefix    CU#
ACCOUNT.settings.payments.
 statement_descriptor           CU#
SOURCE.statement_descriptor      C#
CHARGE.
 statement_descriptor[_suffix]   C#
PINTENT.
 statement_descriptor[_suffix]  CU#
PAYOUT.statement_descriptor      C#
TOPUP.statement_descriptor       C#
INVOICE.statement_descriptor    CU#
SERVICE_PRODUCT.
 statement_descriptor           CU#

CHARGE.
 calculated_statement_descriptor  #After adding prefix|suffix

                                  ┌──────────────────┐
                                  │   SOURCE TYPES   │
                                  └──────────────────┘

DIFFERENCES ==>                   #Differences between source types:
                                  #  - how customer inputs the information (SOURCE.TYPE)
                                  #     - including client-side integration
                                  #  - customers habits:
                                  #     - country-specific
                                  #     - businesses prefer bank accounts, consumers prefer credit cards or digital wallets
                                  #  - sync vs async CHARGEs (see CHARGE webhooks above)
                                  #  - SOURCE.flow (how customer add payment method)
                                  #  - SOURCE.usage (whether can be re-used)
                                  #  - how long payment takes
                                  #  - how refunds are done (see above)
                                  #  - how disputes are done (see above)
                                  #  - country availability (see below)
                                  #  - currencies availability (see above)
                                  #  - how testing is done
                                  #  - whether capturing is supported (see above)
                                  #  - pricing (see above)

AVAILABLE SOURCE TYPES ==>        #Credit card companies controlled (banks are clients):
                                  #  - 'card':
                                  #      - credit card
                                  #      - fast
                                  #      - can use CARD entity
                                  #  - 'card' with 3D secure:
                                  #      - extra authorization:
                                  #         - redirects to bank website
                                  #         - banks asks for online password, on-device code or biometric
                                  #      - also called 'Visa Secure' or 'Mastercard Identity Check'
                                  #      - automatically triggered when using 'card' PAYMENT_METHOD with PINTENT
                                  #      - version 2: allow for PSD2 exemptions (see its doc)
                                  #         - Stripe automatically try to ask for exemptions if possible
                                  #      - can send email with instructions on how to proceed:
                                  #         - on every payment, or on payments that don't complete
                                  #         - must be configured through Dashboard settings
                                  #  - 'card' with CARD.wallet.type:
                                  #      - digital wallets
                                  #      - put money on it usually with credit card
                                  #      - includes personal information and address, i.e. more convenient (no need to ask for them)
                                  #      - some allow using with smartphone NFC
                                  #      - includes (CARD.wallet.type) 'visa_checkout', 'masterpass', 'amex_express_checkout'
                                  #  - 'card_present': READER
                                  #Bank-consortium controlled:
                                  #  - 'bank_account':
                                  #      - generic TYPE for all bank accounts payments
                                  #      - create|update only
                                  #  - 'ach_debit', 'ach_credit_transfer':
                                  #      - US
                                  #      - common in B2B
                                  #      - with bank account number and routing number
                                  #      - can take 2-5 days
                                  #      - more automated than credit card, because do not need to re-authorize
                                  #         - i.e. more convenient but needs more trust
                                  #      - charge amount can be paid in separate/several payments
                                  #      - 'debit' vs 'credit':
                                  #         - 'debit': we pull money from customer's account
                                  #            - more automated, less effort from customer but more risk of dispute
                                  #            - much cheaper Stripe fee than other payment methods
                                  #         - 'credit': customer puts money to our account
                                  #            - absolute Stripe fee instead of relative, i.e. cheaper for big amounts
                                  #      - 'debit' requires bank account to be verified:
                                  #         - done either through:
                                  #            - using another paid tool Plaid: https://stripe.com/docs/ach#using-plaid
                                  #               - instant
                                  #            - otherwise, 2 microdeposits are made by Stripe to account
                                  #               - bank statement is "AMTS:" followed by a secret number
                                  #               - customer needs to tell us those two numbers
                                  #               - we then call POST /customers/ID/sources/ID/verify
                                  #         - can use BANK_ACCOUNT entity
                                  #  - 'sepa_debit':
                                  #     - similar to 'ach_debit' but for EU
                                  #     - uses IBAN (bank account number)
                                  #        - can be collected from a previous purchase with a different method (e.g. 'bancontact')
                                  #     - user must fill and electronically sign a form with their information (MANDATE)
                                  #     - can take up to 14 days
                                  #  - 'au_becs_debit':
                                  #     - similar to 'ach_debit' but for Australia
                                  #  - 'gbp_credit_transfer': similar to 'ach_debit' but for UK
                                  #  - 'sofort': Germany
                                  #     - can take up to 14 days
                                  #  - 'giropay': Germany (10% market share)
                                  #  - 'eps': Austria (20% market share)
                                  #  - 'ideal': Netherlands (>50% market share)
                                  #  - 'bancontact': Belgium (>30% market share)
                                  #  - 'p24': Poland
                                  #  - 'multibanco': Portugal
                                  #     - requires action by customer (entering amount and details on their bank website), i.e. might take up to 7 days
                                  #  - 'klarna': mostly Scandinavia (10% market share)
                                  #  - 'fpx': Malaysia
                                  #Payment provider companies controlled:
                                  #  - 'stripe_account': Connect
                                  #  - 'alipay' (called 'alipay_account' on create|update): Alibab, China (>50% market share)
                                  #     - terms of service are too restrictive, should not use
                                  #  - 'wechat': China
                                  #Tech companies controlled:
                                  #  - 'card' with CARD.wallet.type:
                                  #     - 'apple_pay': holds balance, iPhone|iPad|Mac only
                                  #     - 'google_pay': does not hold balance (only store other payment methods)
                                  #     - 'microsoft_pay'
                                  #     - 'samsung_pay'
                                  #Not supported:
                                  #  - wire transfer:
                                  #     - directly use bank underlying system (SWIFT)
                                  #     - instant
                                  #     - can only send payments, not receive
                                  #     - less requirements on authentication, i.e. might more anonymous, more fraud-friendly
                                  #     - no possible refunds
                                  #     - high fees
                                  #  - Western Union (and similar companies):
                                  #     - use own underlying systems, not banks
                                  #     - fast
                                  #     - withdraw at physical locations
                                  #     - more anonymous, more fraud-friendly
                                  #     - no possible refunds
                                  #     - high fees

AVAILABILITY ==>                  #Right away: 'card', 'stripe_account', 'apple_pay', 'google_pay', 'microsoft_pay', 'samsung_pay'
                                  #Must have processed payments for 30 days: 'sepa_debit'
                                  #Behind feature toggles in dashboard settings, and agree to additional terms of service:
                                  #  - 'ach*'
                                  #  - 'visa_checkout', 'masterpass', 'amex_express_checkout'
                                  #  - 'sofort', 'giropay', 'eps', 'ideal', 'bancontact', 'multibanco', 'p24', 'klarna'
                                  #  - 'alipay', 'wechat'

COUNTRIES ==>                     #Countries availability:
                                  #  - US (destination): 'ach*'
                                  #  - Germany|Austria|Netherlands|Belgium|Italy|Spain (customer), US/EU (destination): 'sofort'
                                  #  - France|Germany|Austria|Netherlands|Belgium|Italy|Spain|Portugal|Luxembourg|Ireland (customer), US/EU (destination): 'sepa_debit'
                                  #  - Sweden|Norway|Denmark|Finland|Austria|Germany|Netherlands|UK (customer), US/EU (destination): 'klarna'
                                  #  - Germany (customer), US/EU (destination): 'giropay'
                                  #  - Netherlands (customer), US/EU (destination): 'ideal'
                                  #  - Austria (customer), US/EU (destination): 'eps'
                                  #  - Belgium (customer), US/EU (destination): 'bancontact'
                                  #  - Poland (customer), US/EU (destination): 'p24'
                                  #  - Portugal (customer), EU (destination): 'multibanco'
                                  #  - China (customer): 'alipay'
COUNTRY_SPEC.                     #ARR of SOURCE.type
 supported_payment_methods        #Initially always ['card', 'stripe']
                                  #But can add new payment methods by enabling them in dashboard.

SOURCE.type 'TYPE'              *C#Specific payment method (see values above)
SOURCE.TYPE                       #SOURCE_DETAILS. Each TYPE has its own attributes, but some are shared.
                                  #On update, should use SOURCE.* not SOURCE.TYPE.*

SOURCE.card*.number            *RC#STR. Credit card number.
SOURCE.card*.name              RCU#STR. Cardholder name.
SOURCE.card*.exp_month         *CU#INT. Card's expiration month (1-12)
SOURCE.card*.exp_year          *CU#INT. Card's expiration year.
SOURCE.card*.cvc                RC#INT. Card's CVC (back number)
SOURCE.card*.address_*         RCU#STR. Like ADDRESS.*
SOURCE.card*.address_zip       RCU#STR. ZIP or postal code.
SOURCE.card*.brand                #STR. Card brand among:
                                  #  - 'visa', 'mastercard': main two ones (75% market share)
                                  #  - 'unionpay': any Chinese credit card (15% market share)
                                  #  - 'amex' (5-10% market share)
                                  #  - 'jcb', 'diners', 'discover' (few % market share)
                                  #  - 'unknown'
SOURCE.card*.network              #STR. Same as *.brand but for the network actually processing the payment.
SOURCE.card*.funding              #STR. Card funding type among:
                                  #  - 'debit': money is withdrawn from account
                                  #  - 'credit': money is borrowed
                                  #  - 'prepaid': money has already been prepaid. Does not require bank account.
                                  #  - 'unknown'
SOURCE.card.CHECK_TYPE_check      #Checks performed by the bank.
                                  #Even when 'failed', bank still sometimes allows payment.
                                  #  - however this might indicate fraud, so we should not use this SOURCE
                                  #Can be:
                                  #  - 'unchecked' (pending)
                                  #  - 'pass' or 'fail'
                                  #  - 'unavailable' (not supported by bank)
                                  #  - 'not_provided' (could not check)
                                  #CHECK_TYPE are:
                                  #  - cvc: CVC. Guarantees customer physically possesses the card.
                                  #  - expiry: expiry date
                                  #  - address_line1 and address_postal_code ("AVS check"):
                                  #     - address matches the credit card owner's
                                  #     - does not work in every country
                                  #     - might not necessarily be an issue, e.g. when making a gift, billing address might differ. Or people might have moved.
                                  #Requires SOURCE.card*.cvc|address_line1|address_postal_code to be provided.
ACCOUNT.settings.
 card_payments.decline_on       CU#DECLINE_ON. Automatically declines CHARGES when SOURCE.card.*_check is 'failed'.
DECLINE_ON.avs_failure          CU#BOOL. For SOURCE.card.address_*_check
DECLINE_ON.cvc_failure          CU#BOOL. For SOURCE.card.cvc_check
SOURCE.card.three_d_secure       ?#If not attempted, undefined.
                                  #OBJ: succeeded BOOL, authenticated BOOL, version STR
SOURCE.card*|ach_debit|sepa_debit|
 au_becs_debit|
 gbp_credit_transfer.last4        #STR. Last four digits of the bank account or card number.
SOURCE.card*|ach*|sepa_debit|
 au_becs_debit|
 gbp_credit_transfer|alipay.
 fingerprint                      #STR. Checksum|fingerprint of the bank account or card number.
SOURCE.bank_account|card*|
 ach_debit|sofort|sepa_debit.
 country                        *C#Bank account or credit card's COUNTRY.

SOURCE.card.wallet               ?#WALLET. Digital wallet.
WALLET.type                       #STR. 'amex_express_checkout', 'apple_pay', 'google_pay', 'microsoft_pay', 'masterpass', 'samsung_pay', 'visa_checkout'
WALLET.dynamic_last4              #STR. Last four digits of the device account number.
WALLET.TYPE.name                  #STR. Owner's name. For 'masterpass', 'visa_checkout' only
WALLET.TYPE.email                 #STR. For 'masterpass', 'visa_checkout' only
WALLET.TYPE.billing_address       #ADDRESS. For 'masterpass', 'visa_checkout' only.
WALLET.TYPE.shipping_address      #ADDRESS. For 'masterpass', 'visa_checkout' only.

SOURCE.card_present.read_method   #STR. How card was read among:
                                  #  - 'contact_emv'
                                  #  - 'contactless_emv'
                                  #  - 'magnetic_stripe_fallback'
                                  #  - 'magnetic_stripe_track2'
                                  #  - 'contactless_magstripe_mode'
SOURCE.card_present.emv_auth_data #STR. Authorization response cryptogram.
SOURCE.card_present.receipt       #CARD_RECEIPT. Fields to print on receipts. Only required for EMV transactions.
CARD_RECEIPT.
 application_cryptogram           #STR. EMV tag 9F26, cryptogram generated by the integrated circuit
CARD_RECEIPT.
 application_preferred_name       #STR. Mnenomic of the Application Identifier.
CARD_RECEIPT.authorization_code   #STR. Identifier for this transaction.
CARD_RECEIPT.
 authorization_response_code      #STR. EMV tag 8A. A code returned by the card issuer.
CARD_RECEIPT.
 cardholder_verification_method   #STR among 'email' or 'sms'. How the cardholder verified ownership of the card.
CARD_RECEIPT.
 dedicated_file_name              #STR. EMV tag 84. Similar to the application identifier stored on the integrated circuit chip.
CARD_RECEIPT.
 terminal_verification_results    #STR. The outcome of a series of EMV functions performed by the card reader.
CARD_RECEIPT.
 transaction_status_information   #STR. An indication of various EMV functions performed during the transaction.
SOURC.card_present.generated_card?#CARD.id. Can be attached to CUSTOMER for re-use.

SOURCE.bank_account.
 account_holder_name           RCU#STR. Name of the owner (person/business).
SOURCE.bank_account|ach*.
 routing_number                  C#STR. Bank account's routing transit number.
SOURCE.bank_account|ach_debit.
 account_holder_type            CU#STR. Whether bank account holder is 'individual' or 'company'.
SOURCE.bank_account|
 ach_credit_transfer.
 account_number                *RC#STR. Account number to transfer funds to.
SOURCE.ach_credit_transfer.
 swift_code                       #STR. Bank's SWIFT code.
SOURCE.
 ach*|bancontact|giropay|sofort.
 bank_name                        #STR. E.g. 'WELLS FARGO'

SOURCE.bancontact|eps|giropay|
 p24|sofort|ideal.verified_name   #STR. Owner's full name according to provider.
SOURCE.bancontact|sofort|ideal.
 iban_last4                       #STR. Last four characters of the IBAN.
SOURCE.
 bancontact|giropay|sofort|ideal.
 bic                              #STR. Bank Identifier Code.
SOURCE.bancontact|giropay|sofort|
 sepa_debit.bank_code             #STR. Code of the bank.

SOURCE.multibanco|p24.reference   #STR. Unique reference for this payment.
                                  #For multibanco, should be communicated to user as they will need it to initiate payment.
                                  #For p24, should be communicated to user as they help them finding the payment transaction.
SOURCE.multibanco.entity          #STR. Entity number.
                                  #Should be communicated to user as they will need it to initiate payment.

SOURCE.ideal.bank                C#STR. Bank name among 'abn_amro', 'asn_bank', 'bunq', 'handelsbanken', 'ing', 'knab',
                                  #'moneyou', 'rabobank', 'regiobank', 'sns_bank', 'triodos_bank', 'van_lanschot'.
                                  #If not provided, user is redirected to a page asking for it.

SOURCE.bancontact|sofort.        C#STR. Customer's preferred language among 'en', 'de', 'fr', 'nl' or (sofort only) 'es', 'it', 'pl'.
 preferred_language               #Used to redirect user to correct language.

SOURCE.sepa_debit.sofort         C#Reuse a 'sofort' SOURCE2.id
SOURCE.sepa_debit.mandate_url     #'URL' to download copy of MANDATE
SOURCE.sepa_debit.mandate         #MANDATE.id
SOURCE.sepa_debit.
 mandate_reference                #STR. MANDATE reference to communicate to customer.

SOURCE.au_becs_debit.bsb_number  C#STR. Bank number

SOURCE.gbp_credit_transfer.
 sender_name                     C#STR.
SOURCE.gbp_credit_transfer.
 sender_account_number           C#STR.
SOURCE.gbp_credit_transfer.
 sender_sort_code                C#STR. Bank code.
SOURCE.gbp_credit_transfer.
 reference                       C#STR. Arbitrary identifier.
SOURCE.gbp_credit_transfer.
 funding_method                  C#STR. Among 'Faster Payments', 'BACS', 'CHAPS'

SOURCE.fpx.bank                  C#STR. One of 'affin_bank', 'alliance_bank', 'ambank', 'bank_islam', 'bank_muamalat',
                                  #'bank_rakyat', 'bsn', 'cimb', 'deutsche_bank', 'hong_leong_bank', 'hsbc', 'kfh',
                                  #'maybank2e', 'maybank2u', 'ocbc', 'pb_enterprise', 'public_bank', 'rhb',
                                  #'standard_chartered', 'uob'.
SOURCE.fpx.transaction_id         #STR

SOURCE.alipay_account           RC#STR. A token returned by Stripe representing the user’s Alipay account details.
SOURCE.alipay.username            #STR.
SOURCE.alipay.reusable            #BOOL. False if it's one-time payment method.
SOURCE.alipay.used                #BOOL. True if it's one-time payment method and has been used.
SOURCE.alipay.payment_amount      #PMONEY if one-time payment.

SOURCE.wechat.qr_code_url         #QR code as 'URL' with weixin:// protocol, to redirect users to.

SOURCE.masterpass.cart_id       *C#Unique STR of the current purchase session
SOURC.masterpass.transaction_id *C#Passed after redirect as query variable ?oauth_verifier

SOURC.card.visa_checkout.callid *C#Passed by Visa Checkout library as FUNC callback

SOURCE.source_order             *C#For Klarna
                                *C#Like ORDER but only with amount|email|shipping|items
SOURCE.klarna.product           *C#'payment'
SOURCE.klarna.purchase_country  *C#COUNTRY
SOURCE.klarna.
 first_name|last_name           CU#STR
SOURCE.klarna.
 shipping_first_name|last_name  CU#STR
SOURCE.klarna.
 [pay_later|now|over_time_]
 redirect_url                     #'URL'. Must redirect to it with the client token.
SOURCE.klarna.client_token        #STR
SOURCE.klarna.locale              #'LANG'. For payment page
SOURCE.klarna.page_title          #STR. For payment page
SOURCE.klarna.logo_url            #'URL'. For payment page
SOURCE.klarna.background_image_url#'URL'. For payment page
SOURCE.klarna.purchase_type       #STR. For payment page's buy button. Among: buy, rent, book, subscribe, download, order, continue.
SOURCE.klarna.
 pay_later|now|over_time_*        #Different options of payment
SOURCE.klarna.
 payment_method_categories        #'PAYMENT_OPTION,...'
SOURCE.klarna.
 pay_later|now|over_time_
 name                             #'PAYMENT_OPTION'
SOURCE.klarna.
 pay_later|now|over_time_
 asset_urls_standard              #'URI'. Short icon of option of payment
SOURCE.klarna.
 pay_later|now|over_time_
 asset_urls_descriptive           #'URI'. Long icon of option of payment

                                  ┌────────────┐
                                  │   SOURCE   │
                                  └────────────┘

SOURCE                            #Payment method of a CUSTOMER.

GET /sources/ID
POST /sources[/ID]
STRIPE.sources.
 retrieve|create|update()         #

SOURCE.usage                     C#Either:
                                  #  - must be 'reusable': for SOURCE.type 'card*', 'ach*', 'au_becs_debit'
                                  #  - must be 'single_use': for all others SOURCE.type
                                  #  - can be either: 'alipay', 'google_pay', 'apply_pay', 'samsung_pay', 'microsoft_pay', 'sepa_debit'
                                  #For 'reusable', must attach SOURCE to CUSTOMER before first usage, to be able to re-use it.
SOURCE.amount                    C#PMONEY if SOURCE.usage 'single_use'
SOURCE.owner                   RCU#BILL_DETAILS:
                                  #  - also include BILL_DETAILS.verified_*: like BILL_DETAILS.*, but verified by provider
                                  #Strongly recommended to decrease DISPUTEs and faciliate payment UX flow.

SOURCE.status                     #STR among:
                                  #  - 'pending': SOURCE not ready for payment yet
                                  #  - 'chargeable': can charge SOURCE (EVENT 'source.chargeable')
                                  #  - 'failed': cannot charge SOURCE anymore (EVENT 'source.failed')
                                  #  - 'canceled':
                                  #      - if SOURCE.usage 'single_use' (EVENT 'source.canceled')
                                  #      - cannot charge SOURCE anymore
                                  #      - done if:
                                  #         - SOURCE.status takes more than 6 hours to become 'chargeable'
                                  #         - CHARGE is not created within 1 hour after being 'chargeable'
                                  #  - 'consumed': already charged, either:
                                  #      - with SOURCE.usage 'single_use'
                                  #      - with SOURCE.usage 'reusable' if not attached to a CUSTOMER
                                  #Should always use those EVENTs except for SOURCE.type 'card*'
SOURCE.flow                      C#How the SOURCE is authenticated among:
                                  #  - 'none':
                                  #      - for SOURCE.type:
                                  #         - 'card*' (no 3D secure): nothing required
                                  #         - 'sepa_debit', 'au_becs_debit': through a MANDATE
                                  #         - 'card' with 'amex_express_checkout': SMS code
                                  #         - 'card' with 'masterpass', 'visa_checkout': redirect
                                  #         - 'card' with 'apple_pay', 'google_pay', 'microsoft_pay', 'samsung_pay':
                                  #           either through mobile SDK or using W3C Payment Request API on web
                                  #         - 'klarna': in addition to 'redirect', can also use Klarna SDK (https://stripe.com/docs/sources/klarna#customer-action)
                                  #  - 'redirect':
                                  #      - redirected to payment provider's URL, then payment provider redirects back
                                  #      - for SOURCE.type 'card*' (3D secure), 'ach_debit', 'alipay', 'bancontact', 'eps',
                                  #        'giropay', 'ideal', 'p24', 'wechat', 'sofort', 'multibanco', 'klarna'
                                  #  - 'code_verification': a code is sent (e.g. by SMS)
                                  #      - for SOURCE.type 'ach_debit'
                                  #  - 'receiver': requires other separate action from customer, such as logging in to their account and initiate the payment
                                  #      - for SOURCE.type:
                                  #         - 'ach_credit_transfer'
                                  #         - 'multibanco' (can also use 'redirect instead')
W3C PAYMENT REQUEST API ==>       #Users save payment information in browser:
                                  #  - can be synced cross-device
                                  #Supported by all browsers but IE, Android browser.

SOURCE.redirect                  C#REDIRECT. If SOURCE.flow 'redirect'
                                  #For 'wechat', uses SOURCE.wechat.qr_code_url instead
REDIRECT.url                      #'URL' of payment provider to redirect user to.
REDIRECT.return_url              C#'URL' to redirect after successful authentication.
                                  #Will pass the following query variables:
                                  #  - client_secret STR: should be same as SOURCE.client_secret
                                  #  - source SOURCE.id
                                  #  - livemode BOOL
REDIRECT.status                   #STR among:
                                  #  - 'not_required'
                                  #  - 'pending'
                                  #  - 'succeeded' or 'failed'
REDIRECT.failure_reason           #If REDIRECT.status 'failed', STR among:
                                  #  - 'user_abort': customer aborted
                                  #  - 'declined': authentication failed
                                  #  - 'processing_error': technical error
SOURCE.client_secret              #STR. ?client_secret is added to REDIRECT.return_url redirection.
                                  #Should match SOURCE.client_secret to ensure this is the same customer.

SOURCE.code_verification          #CODE_VERIF. If SOURCE.flow 'code_verification'.
CODE_VERIF.attempts_remaining     #NUM of attempts left to authenticate SOURCE.
CODE_VERIF.status                 #STR among:
                                  #  - 'pending': code sent
                                  #  - 'succeeded' or 'failed'

SOURCE.receiver                  C#RECEIVER. If SOURCE.flow 'receiver'.
RECEIVER.address                  #STR. Destination to send funds to. Should communicate to customer.
RECEIVER.amount_*                 #Updated by Stripe using CHARGE.*
RECEIVER.amount_charged           #CHARGE.amount
RECEIVER.amount_returned          #MONEY (negative) left to be paid by CUSTOMER.
                                  #Once 0, SOURCE.status goes from 'chargeable' to 'pending' (ready for re-use)
RECEIVER.amount_received          #amount_charged + amount_returned
RECEIVR.refund_attributes_method C#How to notify CUSTOMER of refunds among:
                                  #  - 'email': sent by Stripe
                                  #  - 'manual': EVENT 'source.refund_attributes_required' then must communicate ourselves
                                  #  - 'none' (def): no EVENT and we must communicate ourselves
RECEIVER.refund_attributes_status #Refund status among:
                                  #  - 'missing': none requested
                                  #  - 'requested'
                                  #  - 'available': ready for CUSTOMER to withdraw

SOURCE RENEWAL ==>                #For some countries, Stripe automatically updates SOURCE.* when information is updated (e.g. new card).
                                  #EVENTs:
                                  #  - 'customer.source.updated' and 'payment_method.card_automatically_updated': emitted on change
                                  #  - 'customer.source.expiring': SOURCE will expire at end of month
                                  #     - automatically sent email to CUSTOMER
                                  #        - must be enabled in Dashboard settings
                                  #        - can change link in email in Dashboard settings

                                  ┌─────────────┐
                                  │   MANDATE   │
                                  └─────────────┘

MANDATE                           #Form filled and signed by CUSTOMER with their information and consent. For 'sepa_debit' and 'au_bets_debit'
                                  #Also a standard text must be shown to CUSTOMER (seen here: https://stripe.com/docs/sources/sepa-debit#prerequisite)

GET /mandates/ID                  #
STRIPE.mandates.retrieve()        #

MANDATE.status                   *#'active', 'pending', 'inactive'
MANDATE.type                     *#'single_use|multi_use'
MANDATE.single_use                #SINGLE_USE
SINGLE_USE.amount                 #PMONEY
MANDATE.multi_use                 #OBJ
MANDATE.payment_method           *#PAYMENT_METHOD.id
MANDATE.payment_method_details   *#Like SOURCE.type + SOURCE.TYPE.* for card|sepa_debit
MANDATE.customer_acceptance      *#ACCEPTANCE
ACCEPTANCE.accepted_at            #DATE_NUM
ACCEPTANCE.type                  *#Whether this is done 'online' or 'offline'.
ACCEPTANCE.online|offline         #ACCEPTANCE_ONLINE|OFFLINE. Depends on ACCEPTANCE.type
ACCEPTANCE_ONLINE.ip              #'IP'
ACCEPTANCE_ONLINE.user_agent      #'USER_AGENT'

PINTENT|SETUP_INTENT.
 [single_use_]mandate            C#MANDATE.id
PINTENT|SETUP_INTET.mandate_data U#MANDATE (only customer_acceptance)

SOURCE.mandate                 RCU#SMANDATE
SMANDATE.amount                 CU#PMONEY. Defaults to full amount.
SMANDATE.interval               CU#Payment recurrence among:
                                  #  - 'one_time'
                                  #  - 'scheduled' (regular interval)
                                  #  - 'variable' (variable interval)
SMANDATE.notification_method    CU#How to notify CUSTOMER of payment (including recurring one):
                                  #  - 'email': email sent to CUSTOMER
                                  #  - 'manual': emit an EVENT 'source.mandate_notification' and we must communicate to CUSTOMER ourselves
                                  #  - 'none' (def): no EVENT and we must communicate ourselves
                                  #When doing 'manual'|'none':
                                  #  - should be sent within 14 days.
                                  #  - must include:
                                  #     - SOURCE.TYPE.last4|mandate_reference
                                  #     - SMANDATE.amount
                                  #     - SEPA creditor identifier (must ask our own bank online for it)
                                  #     - contact information
SMANDATE.acceptance             CU#SACCEPTANCE
SACCEPTANCE.status             *CU#Either 'accepted' or 'refused'
SACCEPTANCE.type                CU#Whether this is done 'online' or 'offline'.
SACCEPTANCE.online|offline      CU#SACCEPTANCE_ONLINE|OFFLINE. Depends on SACCEPTANCE.type
SACCEPTANCE[_ONLINE].date      *CU#DATE_NUM
SACCEPTANCE[_ONLINE].ip        *CU#'IP'
SACCEPTANCE[_ONLINE].user_agent*CU#'USER_AGENT'
SACCEPTANCE_OFFLN.contact_email*CU#'EMAIL' to contact us if a copy is requested.

                                  ┌────────────────────┐
                                  │   PAYMENT METHOD   │
                                  └────────────────────┘

PAYMENT_METHOD                    #Similar to SOURCE.
                                  #Prefer using PINTENT + PAYMENT_METHOD (new APIs) instead of SOURCE (older API).
                                  #  - including CHARGE.source vs CHARGE.payment_method[_details]
                                  #SOURCE.TYPEs support:
                                  #  - 'card' without 3D secure: both
                                  #  - 'card_present' and 'card' with 3D secure: only PINTENT + PAYMENT_METHOD
                                  #  - 'ideal'
                                  #  - 'sepa_debit'
                                  #  - 'au_becs_debit'
                                  #  - 'fpx'
                                  #  - all others: SOURCE
                                  #More SOURCE.TYPEs will be added in future.

GET /payment_methods/ID
GET /payment_methods?
 customer=CUSTOMER.id&type=STR
POST /payment_methods[/ID]        #
STRIPE.paymentMethods.
 retrieve|list|create|update()    #

PAYMENT_METHOD.type             *C#Like SOURCE.*
PAYMENT_METHOD.card[_present]|
 ideal|sepa_debit|au_becs_debit|
 fpx                            CU#Like SOURCE.*
PAYMENT_METHOD.TYPE.generated_from#GENERATED
GENERATED.charge                  #CHARGE.id
GENERATED.payment_method_details  #Like SOURCE.*
PAYMENT_METHOD.billing_details   U#BILL_DETAILS
PAYMENT_METHOD.customer           #CUSTOMER.id

                                  ┌──────────┐
                                  │   CARD   │
                                  └──────────┘

CARD                              #Similar to PAYMENT_METHOD for type 'card'

GET /customers/ID/sources/ID
GET /customers/ID/sources?object=
 card&customer=ID
POST /customers/ID/sources[/ID]
DELETE /customers/ID/sources/ID   #
STRIPE.sources.list|retrieve|
 create|update|deleteSource()     #

CARD.*                            #Same properties as SOURCE.card
CARD.*_check                      #Same as CARD.*
CARD.tokenization_method          #Same as WALLET.type
CARD.dynamic_last4                #Same as WALLET.dynamic_last4
CARD.customer                     #CUSTOMER.id (not Connect) (not if CARD.recipent)
CARD.recipient                    #CUSTOMER.id (not Connect) (not if CARD.customer)
CARD.available_payout_methods     #Available PAYOUT.method as STR_ARR of 'standard', 'instant'

                                  ┌──────────────────┐
                                  │   BANK ACCOUNT   │
                                  └──────────────────┘

BANK_ACCOUNT                      #Similar to PAYMENT_METHOD for type 'ach_debit'

GET /customers/ID/sources/ID
GET /customers/ID/sources?object=
 bank_account&customer=ID
POST /customers/ID/sources[/ID]
DELETE /customers/ID/sources/ID   #
POST
 /customers/ID/sources/ID/verify  #Set BANK_ACCOUNT.status to 'verified'
                                  #PAYLOAD is { amounts NUM_ARR } where NUM_ARR are the two secrets from customers (see above)
STRIPE.sources.list|retrieve|
 create|update|delete|
 verifySource()                   #

BANK_ACCOUNT.*                    #Same properties as SOURCE.ach_debit|bank_account
BANK_ACCOUNT.customer             #CUSTOMER.id (not Connect)
BANK_ACCOUNT.status               #STR among:
                                  #  - 'new': just created
                                  #  - 'validated': Stripe validates it exists. Next step is to verify.
                                  #  - 'verified': either Plaid validates it exists, or we manually use POST /customers/ID/sources/ID/verify
                                  #  - 'verification_failed': bank denies it exists. Will not be usable until updated.
                                  #  - 'errored': a previous transfer failed. Will not be usable until updated.
                                  #EVENT 'customer.source.updated' is emitted when 'verified' or 'verification_failed'

                                  ┌──────────────────────┐
                                  │   EXTERNAL ACCOUNT   │
                                  └──────────────────────┘

EXTERNAL_ACCOUNT                  #Same as CARD|BANK_ACCOUNT, but for ACCOUNT (PAYOUTs and Connect).
                                  #BANK_ACCOUNT verification not run, i.e. BANK_ACCOUNT.status either 'new' or 'errored'.
                                  #Also differences below.

GET /accounts/ID/external_accounts
 /ID
GET /accounts/ID/external_accounts
 ?object=bank_account|card
POST /accounts/ID/
 external_accounts[/ID]
DELETE /accounts/ID/
 external_accounts/ID
STRIPE.accounts.retrieve|list|
 create|update|
 deleteExternalAccount()          #

EXTERNAL_ACCOUNT.object           #'card|bank_account'
EXTERNAL_ACCOUNT.
 external_account               *C#EXTERNAL_ACCOUNT payload on create
ACCOUNT.external_accounts         #EXTERNAL_ACCOUNT_LIST
ACCOUNT.external_account       RCU#EXTERNAL_ACCOUNT
                                  #Required field

                                  ┌────────────────────────┐
                                  │   SOURCE TRANSACTION   │
                                  └────────────────────────┘

SOURCE_TRANSACTION                #CHARGEs of a specific SOURCE

GET /sources/ID/
 source_transactions[/ID]
STRIPE.
 list|retrieveSourceTransactions()#

SOURCE_TRANSACTION.amount
SOURCE_TRANSACTION.status         #Like CHARGE.*
SOURCE_TRANSACTION.source         #SOURCE.id
SOURCE_TRANSACTION.type           #Like SOURCE.*
SOURCE_TRANSACTION.TYPE.*         #Like SOURCE.TYPE.*

                                  ┌──────────────┐
                                  │   CUSTOMER   │
                                  └──────────────┘

CUSTOMER                          #Entity/person paying.
                                  #Can be used to re-use information accross payments:
                                  #  - SOURCE (only if SOURCE.usage 'reusable')
                                  #  - email
                                  #  - addresses
                                  #  - invoice info
                                  #To re-use between several Connect destination ACCOUNT2:
                                  #  - using platform ACCOUNT:
                                  #     - create CUSTOMER
                                  #  - then using destination ACCOUNT2:
                                  #     - create TOKEN of CUSTOMER
                                  #     - either:
                                  #        - create CHARGE with that TOKEN
                                  #        - create CUSTOMER, then create CHARGE with that CUSTOMER
GET /customers[/ID]
POST /customers[/ID]
DELETE /customers/ID              #
STRIPE.customers.
 retrieve|list|create|update|del()#
POST /payment_methods/ID/attach
POST /payment_methods/ID/detach   #Set|unset CUSTOMER.sources and PAYMENT_METHOD.customer. No payload
STRIPE.paymentMethods.
 attach|detach()

CUSTOMER.sources                  #TOKEN|SOURCE|BANK_ACCOUNT|CARD_LIST
                                  #Emits EVENTs 'payment_method.attached|detached' on change.
                                  #Should only use for reusable SOURCEs. Should avoid TOKENs.
CUSTOMER.default_source          U#TOKEN|SOURCE|BANK_ACCOUNT|CARD
CUSTOMER.source                RCU#Change default_source.
                                  #Also creates the TOKEN|SOURCE|BANK_ACCOUNT|CARD.
CUSTOMER.payment_method         RC#PAYMENT_METHOD.id
                                  #Like CUSTOMER.source but for already created PAYMENT_METHOD
SOURCE.customer                  ?#CUSTOMER.id. Only if attached

CUSTOMER.name                   CU#STR
CUSTOMER.email                  CU#'EMAIL'.
?email=STR                        #
CUSTOMER.phone                  CU#STR
CUSTOMER.address                CU#ADDRESS
CUSTOMER.shipping               CU#BILL_DETAILS
CUSTOMER.description            CU#STR.
CUSTOMER.preferred_locales      CU#'LANG'_ARR, used for invoices, emails, etc.

                                  ┌───────────┐
                                  │   TOKEN   │
                                  └───────────┘

TOKEN                             #Representation of:
                                  #  - a payment method (SOURCE|CARD|BANK_ACCOUNT)
                                  #  - privacy-sensitive information (ACCOUNT|PERSON)
                                  #Goal is to avoid leaking those information by using a TOKEN instead.

GET /tokens/ID
POST /tokens
STRIPE.tokens.retrieve|create()   #

TOKEN.type                        #One of:
                                  #  - 'card': TOKEN.card + TOKEN.customer
                                  #  - 'bank_account': TOKEN.bank_account + TOKEN.customer
                                  #  - 'account': TOKEN.account (see below)
                                  #  - 'pii': TOKEN.pii (see below)
TOKEN.card                       C#Same as SOURCE.card. Can be omitted if specified in CUSTOMER.
TOKEN.bank_account               C#Same as SOURCE.bank_account. Can be omitted if specified in CUSTOMER.
TOKEN.customer                  RC#CUSTOMER.id
TOKEN.person                     C#PERSON

TOKEN.used                        #BOOL. One-time usage. Expires after few minutes.
TOKEN.client_ip                   #'IP'

SOURCE.token                    RC#TOKEN.id. Use TOKEN to populate properties.

                                  ┌──────────────────┐
                                  │   SUBSCRIPTION   │
                                  └──────────────────┘

SUBSCRIPTION                      #Recurring CHARGE, either as a single PLAN, or several (using SUBSCRIPTION_ITEMs) for a specific CUSTOMER

GET /subscriptions[/ID]
POST /subscriptions[/ID]
STRIPE.subscriptions.
 list|retrieve|create|update()    #
DELETE /subscriptions/ID
STRIPE.subscriptions.del()        #Set status to 'canceled'
                                  #Payload: invoice_now, proration_behavior
PAYLOAD.invoice_now               #BOOL (def: false). Create a final INVOICE for pending metered usage or proration.
PAYLOAD.proration_behavior        #STR. Create a INVOICE_ITEM that give credits for remaining unused time.

SUBSCRIPTION.customer           *C#CUSTOMER.id
?customer=CUSTOMER.id             #
CUSTOMER.subscriptions            #SUBSCRIPTION_LIST
SUBSCRIPTION.default_source     CU#SOURCE|BANK_ACCOUNT|CARD.id
                                  #Def: CUSTOMER.default_source
SUBSCRIPTION.                   CU#PAYMENT_METHOD.id
 default_payment_method           #Def: CUSTOMER.default_payment_method
SUBSCRIPTION.pending_setup_intent #SETUP_INTENT

SUBSCRIPTION.items              CU#SUBSCRIPTION_ITEM_LIST
                                  #Max length 20
SUBSCRIPTION.plan                ?#PLAN. Only defined if SUBSCRIPTION.items.length === 1
?plan=PLAN.id                     #
SUBSCRIPTION.quantity             #NUM to multiply PLAN.amount with.
                                  #Only if PLAN.usage_type 'licensed'.
                                  #Only if SUBSCRIPTION.plan defined. Otherwise, should check SUBSCRIPTION_ITEM.quantity.

SUBSCRIPTION.status               #STR among:
                                  #  - 'trialing': no CHARGEs|PAYMENT_METHOD|SOURCE needed for a specific amount of time
                                  #  - 'active': last CHARGE succeeded
                                  #  (fixable errors)
                                  #  - 'incomplete':
                                  #     - either:
                                  #        - initial state
                                  #        - PINTENT.status 'requires_action'
                                  #        - first CHARGE (not after trial) failed (other PINTENT.status)
                                  #           - should retry with POST /invoices/ID/pay
                                  #     - SUBSCRIPTION read-only except for default_source
                                  #  - 'past_due':
                                  #     - either:
                                  #        - non-first CHARGE not paid
                                  #        - first CHARGE after trial not paid
                                  #  (terminal errors)
                                  #  - 'incomplete_expired':
                                  #     - first CHARGE not paid within 23 hours
                                  #     - INVOICE is voided
                                  #  - 'unpaid':
                                  #     - several attempts or deadline after 'past_due'
                                  #     - INVOICEs are still created but closed directly, and can be re-opened
                                  #  - 'canceled'
                                  #     - INVOICEs are not created anymore.
                                  #     - on-going INVOICEs still valid, unless deleted. However CHARGE must be manually created.
?status=STR                       #
SUBSCRIPTION.cancel_at          CU#DATE_NUM. Set status to 'canceled' at that time.
?cancel_at=DATE_NUM               #
SUBSCRIPTION.
 cancel_at_period_end           CU#BOOL (def: false). Set status to 'canceled' at end of period.
SUBSCRIPTION.canceled_at         ?#DATE_NUM
                                  #If SUBSCRIPTION.cancel_at_period_end was used, date where this was set. Otherwise, date status set to 'canceled'.
SUBSCRIPTION.payment_behavior   CU#What to do when first CHARGE failed:
                                  #  - 'allow_incomplete' (def, better): status 'incomplete'
                                  #  - 'pending_if_incomplete': status 'trialing'
                                  #  - 'error_if_incomplete': ERROR

SUBSCRIPTION.collection_method  CU#Either:
                                  #  - 'charge_automatically' (def): automatically create CHARGEs
                                  #  - 'send_invoice': send emails with INVOICE and payment instructions
?collection_method=STR            #
SUBSCRIPTION.latest_invoice       #Last INVOICE.id
SUBSCRIPTION.days_until_due     CU#NUM of days to pay INVOICEs. Only if SUBSCRIPTION.collection_method 'send_invoice'
                                  #Default can be configured in Dashboard settings

SUBSCRIPTION.                   CU#DATE_NUM (def: 'now') used to define on which day of the week|month|year to INVOICE each period.
 billing_cycle_anchor             #Reset when:
                                  #  - changing PLAN or period settings
                                  #  - status goes from 'trial' to 'active'
                                  #  - BILLING_THRESHOLDS.reset_billing_cycle_anchor true
                                  #When reset to 'now', new INVOICE will be created right away.
SUBSCRIPTION.start_date           #DATE_NUM. Create timestamp. Might differ from `created` in some cases.
SUBSCRIPTION.backdate_start_date C#Same as start_date but can be set (in past only). If set in past, add a proration.
SUBSCRIPTION.ended_at            ?#DATE_NUM
SUBSCRIPTION.                     #DATE_NUM. Periods are decided by PLAN.interval[_count]
 current_period_start|end         #INVOICEs are created at end of each period.
?current_period_start|end=
 CMP_FILTER                       #

SUBSCRIPTION.trial_from_plan   RCU#BOOL (def: false). Whether to use SUBSCRIPTION.trial_period_days.
SUBSCRIPTION.trial_period_days  RC#NUM. Def: PLAN.trial_period_days
SUBSCRIPTION.trial_start          #DATE_NUM
SUBSCRIPTION.trial_end          CU#DATE_NUM or 'now'. Either:
                                  #  - automatically set using SUBSCRIPTION.trial_period_days if SUBSCRIPTION.trial_from_plan
                                  #  - manually set. At most two years from billing_cycle_anchor
                                  #EVENT 'customer.subscription.trial_will_end' three days before trial end, or when using 'now'

SUBSCRIPTION                   RCU#BOOL. Whether partial period are charged|credited:
 .proration_behavior              #  - 'create_prorations' (def): proportionally, invoice as late as possible
                                  #  - 'always_invoice': proportionally, invoice as soon as possible
                                  #  - 'none': not at all
                                  #Partial periods happen when changing:
                                  #  - quantity or unit price
                                  #  - period settings
                                  #  - SUBSCRIPTION.billing_cycle_anchor
                                  #This includes changing PLANs as a whole.
                                  #Applied on next INVOICE.
                                  #Only if PLAN.usage_type 'licensed'
SUBSCRIPTION.proration_date     RU#DATE_NUM. When change happened.
SUBSCRIPTION.pending_update       #PENDING_UPDATE. Pending SUBCRIPTION update due to trial|proration
PENDING_UPDATE.subscription_items|
 billing_cycle_anchor|
 trial_from_plan|trial_end|       #New SUBSCRIPTION.*
PENDING_UPDATE.expires_at         #DATE_NUM of end of update

SUBSCRIPTION.billing_thresholds CU#BILLING_THRESHOLDS|''.
                                  #Create INVOICE each time quantity (modulo'd) passes some threshold for a given period.
                                  #Goal: ensuring big quantity are paid by splitting them into several INVOICEs
                                  #Only with PLAN.usage_type 'metered'
                                  #Not if:
                                  #  - status 'trialing'
                                  #  - 24 hours before period end (to avoid confusion with 2 INVOICEs)
BILLING_THRESHOLDS.amount_gte   CU#PMONEY, excluding taxes
BILLING_THRESHOLDS.             CU#BOOL (def: false). Reset SUBSCRIPTION.billing_cycle_anchor.
 reset_billing_cycle_anchor       #Not allowed if PLAN.aggregate_usage 'last_ever'.

SUBCRIPTION.pause_collection    CU#PAUSE_COLLECTION
                                  #Temporarily disables SUBSCRIPTION
                                  #Event 'pause_collection'
PAUSE_COLLECTION.resumes_at     CU#DATE_NUM
PAUSE_COLLECTION.behavior       CU#One of 'keep_as_draft', 'mark_uncollectible', 'void'

                                  ┌───────────────────────┐
                                  │   SUBSCRIPTION ITEM   │
                                  └───────────────────────┘

SUBSCRIPTION_ITEM                 #Abstraction of one or several PLANs, used by a complex SUBSCRIPTION.
                                  #If same SUBSCRIPTION, must have PLAN.interval|currency

GET /subscription_items[/ID]
POST /subscription_items[/ID]
DELETE /subscription_items/ID     #
STRIPE.subscriptionItems.
 list|retrieve|create|update|del()#

SUBSCRIPTION_ITEM.subscription  *C#SUBSCRIPTION.id
?subscription=SUBSCRIPTION.id     #
SUBSCRIPTION_ITEM.plan|quantity|
 billing_thresholds             CU#Like SUBSCRIPTION.*
SUBSCRIPTION_ITEM.
 payment_behavior|
 proration_behavior|
 proration_date                RCU#Like SUBSCRIPTION.*
SUBSCRIPTION_ITEM.deleted        U#BOOL. Delete the SUBSCRIPTION_ITEM.
                                  #Only when updated through SUBSCRIPTION.items
SUBSCRIPTION_ITEM.clear_usage    U#BOOL. Delete the SUBSCRIPTION_ITEM's USAGE_RECORDs
                                  #Only when updated through SUBSCRIPTION.items
                                  #Only when PLAN.usage_type 'metered' and SUBSCRIPTION_ITEM.deleted true

                                  ┌──────────┐
                                  │   PLAN   │
                                  └──────────┘

PLAN                              #Pricing scheme.

GET /plans[/ID]
POST /plans[/ID]
DELETE /plans/ID                  #
STRIPE.plans.
 list|retrieve|create|update|del()#

PLAN.nickname                   CU#STR, not shown to customers.
PLAN.product                   *CU#PRODUCT.id
?product=PRODUCT.id               #
PLAN.active                     CU#BOOL. Available for new SUBSCRIPTIONs
?active=BOOL                      #

PLAN.interval                   *C#Frequency among 'day', 'week', 'month', 'year'.
PLAN.interval_count              C#NUM of PLAN.interval (def: 1)
PLAN.trial_period_days          CU#NUM of free|trial days

PLAN.billing_scheme              C#Either:
                                  #  - 'per_unit' (def): unit price is fixed (PLAN.amount)
                                  #  - 'tiered': unit price is variable, based on quantity (PLAN.tiers[_mode])
                                  #Both can use any PLAN.usage_type
PLAN.amount[_decimal]            C#PMONEY|'BIGINT'. Unit price, to multiply with quantity.
PLAN.tiers                       C#TIER_ARR. Different unit price depending on quantity.
TIER.up_to                        #'NUM' or 'inf'. Quantity max threshold to be using this TIER.
TIER.flat_amount[_decimal]        #PMONEY|'BIGINT'. Absolute price (for whole TIER)
TIER.unit_amount[_decimal]        #PMONEY|'BIGINT'. Relative price (per unit)
PLAN.tiers_mode                  C#Either:
                                  #  - 'volume': use unit price of the matching TIER for the whole quantiy
                                  #  - 'graduated': use unit price of each matching TIER for each part of the quantity
                                  #E.g. if 2$/unit for 1-100 and 1$ for >100, 150 units will cost:
                                  #  - 'volume': $1x150
                                  #  - 'graduated': $2x100 + $1x50

PLAN.usage_type                  C#Either:
                                  #  - 'licensed' (def):
                                  #     - quantity is fixed: SUBSCRIPTION[_ITEM].quantity
                                  #     - e.g. price per number of users
                                  #     - INVOICE at period start
                                  #  - 'metered':
                                  #     - quantity is variable: USAGE_RECORD[_SUMMARY] + PLAN.aggregate_usage
                                  #     - e.g. price per ms
                                  #     - INVOICE at period end
PLAN.aggregate_usage             C#Can be:
                                  #  - 'sum' (def): adds all USAGE_RECORDs of the period
                                  #  - 'max': only use highest USAGE_RECORD of that period
                                  #  - 'last_during_period': use last USAGE_RECORD of that period
                                  #  - 'last_ever': use last USAGE_RECORD of that period + previous unpaid periods
                                  #     - goal: to charge trials

PLAN.transform_usage             C#TRANSFORM_USAGE. Divide the price.
                                  #Useful to apply a modulo on the quantity:
                                  #  - e.g. track consumption per millisecond, but charge per 100ms
                                  #Only if PLAN.billing_scheme 'per_unit'
TRANSFORM_USAGE.divide_by         #INT
TRANSFORM_USAGE.round             #'up' (def) or 'down'

                                  ┌──────────────────┐
                                  │   USAGE RECORD   │
                                  └──────────────────┘

USAGE_RECORD                      #CUSTOMER's single consumption for PLAN.usage_type 'metered' or PLAN.tiers

POST /subscription_items/ID/
 usage_records                    #
STRIPE.subcriptionItems.
 createUsageRecord()              #

USAGE_RECORD.subscription_item  *C#SUBSCRIPTION_ITEM.id
USAGE_RECORD.quantity           *C#INT (>=0)
USAGE_RECORD.timestamp          *C#DATE_NUM.
                                  #Must be within current period (+|- 5 minutes, for clock drift)
USAGE_RECORD.action              C#If USAGE_RECORD with same subscription_item|timestamp, either:
                                  #  - 'increment' (default): do not overwrite it
                                  #  - 'set': overwrite it. Not allowed if SUBSCRIPTION.billing_thresholds defined

                                  ┌──────────────────────────┐
                                  │   USAGE RECORD SUMMARY   │
                                  └──────────────────────────┘

USAGE_RECORD_SUMMARY              #Aggregate of USAGE_RECORD for a specific SUBSCRIPTION_ITEM and INVOICE

GET /subscription_items/ID/
 usage_records_summaries          #
STRIPE.subcriptionItems.
 listUsageRecordSummaries()       #

USAGE_RECORD_SUMMARY.
 subscription_item                #SUBSCRIPTION_ITEM.id
?subscription_item=ID             #
USAGE_RECORD_SUMMARY.invoice      #INVOICE.id
USAGE_RECORD_SUMMARY.total_usage  #NUM
USAGE_RECORD_SUMMARY.
 period.start|end                 #DATE_NUM

                                  ┌─────────────┐
                                  │   PRODUCT   │
                                  └─────────────┘

PRODUCT                           #Products being sold
                                  #Can be populated from a feed (Google Product Feed) from the Dashboard.
                                  #Either:
                                  #  - 'service': for SUBSCRIPTION|PLAN
                                  #  - 'good': for ORDER|SKU

GET /products[/ID]
POST /products[/ID]
DELETE /products/ID               #
STRIPE.products.
 list|retrieve|create|update|del()#
?ids=STR_ARR                      #

PRODUCT.type                    *C#'service' or 'good'
?type=STR                         #
PRODUCT.name                   *CU#STR. Shown to CUSTOMER.
PRODUCT.active                  CU#BOOL. Currently available for purchase.
                                  #If false, cannot create ORDER|SKU|SUBSCRIPTION|PLAN with it.
?active=BOOL                      #
PRODUCT.updated                   #DATE_NUM

PRODUCT.attributes              CU#STR_ARR (e.g. 'color', 'size', etc.) that can be used by SKU.attributes

SERVICE_PRODUCT.unit_label       U#STR. Unit shown in receipts|INVOICE. E.g. 'seat'.

GOOD_PRODUCT.url                CU#'URL'
?url=STR                          #
GOOD_PRODUCT.caption            CU#Short STR to be shown to CUSTOMER.
GOOD_PRODUCT.description        CU#Long STR to be shown to CUSTOMER.
GOOD_PRODUCT.images             CU#'URL'_ARR to be shown to CUSTOMER.
GOOD_PRODUCT.shippable          CU#BOOL
?shippable=BOOL                   #
GOOD_PRODUCT.package_dimensions CU#PACKAGE_DIMENSIONS. For shipping.
PACKAGE_DIMENSIONS.
 height|length|weight|width       #NUM (inches)
GOOD_PRODUCT.deactivate_on      CU#ARR of CONNECT_ACCOUNT.id that cannot purchase this.

                                  ┌────────────┐
                                  │   COUPON   │
                                  └────────────┘

COUPON                            #DISCOUNTs given to many CUSTOMERs. Only for SUBSCRIPTIONs.

GET /coupons[/ID]
POST /coupons[/ID]
DELETE /coupons/ID                #
STRIPE.coupons.
 retrieve|list|create|update|del()#

COUPON.name                     CU#STR shown in INVOICEs and receipts

COUPON.amount_off                C#PMONEY to substract to all INVOICEs
COUPON.percent_off               C#0-100. Percentage to substract to all INVOICEs

COUPON.duration                 *C#How long DISCOUNT will work among 'once' (one period), 'repeating' or 'forever'
COUPON.duration_in_months        C#NUM. If duration 'repeating'.
COUPON.times_redeemed             #NUM of DISCOUNTs created
COUPON.max_redemptions           C#NUM. Max COUPON.times_redeemed
COUPON.redeem_by                 C#DATE_NUM after which can no longer create DISCOUNTs
COUPON.valid                      #BOOL.
                                  #Can be invalid if beyond COUPON.duration|max_redemptions|redeem_by
                                  #If false, cannot apply to CUSTOMER, but already created DISCOUNTs still work.
COUPON.deleted                    #BOOL.
                                  #When true, other COUPON.* are undefined

SUBSCRIPTION.coupon            RCU#Creates a DISCOUNT
SUBSCRIPTION|INVOICE.discount     #DISCOUNT
CUSTOMER.coupon                RCU#Creates a DISCOUNT on future SUBSCRIPTION|INVOICE
CUSTOMER.discount                 #DISCOUNT
ORDER.coupon                   RCU#Creates a DISCOUNT
                                  #Must be COUPON.duration 'once' and same currency as ORDER.
                                  #Create a 'discount' ORDER_ITEM
ORDER.external_coupon_code        #Same

                                  ┌──────────────┐
                                  │   DISCOUNT   │
                                  └──────────────┘

DISCOUNT                          #COUPON given to one CUSTOMER.

DELETE /customers|subscriptions/
 ID/discount                      #
STRIPE.customers|subscriptions.
 deleteDiscount()                 #

DISCOUNT.coupon                   #COUPON.id
DISCOUNT.customer                 #CUSTOMER.id
DISCOUNT.subscription             #SUBSCRIPTION.id

DISCOUNT.start                    #DATE_NUM
DISCOUNT.end                     ?#DATE_NUM if COUPON.duration_in_months
?created=CMP_FILTER               #

                                  ┌─────────────────┐
                                  │   CREDIT NOTE   │
                                  └─────────────────┘

CREDIT_NOTE                       #Adjustment on an 'open|paid' INVOICE (wrong quantity|price, cannot deliver, etc.)
                                  #Can have several per INVOICE.
                                  #If:
                                  #  - type 'pre_payment': reduces INVOICE.amount_due
                                  #  - type 'post_payment' + refund[_amount]: REFUND
                                  #  - type 'post_payment' + credit_amount: reduces CUSTOMER.balance
                                  #  - out_of_band_amount: any thing left after there is considered settled outside of Stripe

GET /credit_notes[/ID]
POST /credit_notes[/ID]           #
POST /credit_notes/ID/void        #Set status to 'void'
GET /credit_notes/preview         #Like POST /credit_notes except dry run
                                  #Same request payload.
STRIPE.creditNotes.retrieve|list|
 create|update|voidCreditNote|
 preview()                        #

CREDIT_NOTE.invoice             *C#INVOICE.id
?invoice=INVOICE.id               #
CREDIT_NOTE.customer              #CUSTOMER.id
?customer=CUSTOMER.id             #
CREDIT_NOTE.
 customer_balance_transaction     #CBALANCE_TRANSACTION.id

CREDIT_NOTE.type                  #One of:
                                  #  - 'pre_payment': INVOICE.status 'open'
                                  #  - 'post_payment': INVOICE.status 'paid'

CREDIT_NOTE.status                #STR among:
                                  #  - 'issued'
                                  #  - 'void': reverted (EVENT 'credit_note.voided')
CREDIT_NOTE.voided_at            ?#DATE_NUM

CREDIT_NOTE.total                 #PMONEY in total. Including tax and discount.
CREDIT_NOTE.amount               C#PMONEY in total. Including tax.
CREDIT_NOTE.subtotal              #PMONEY. Excluding tax and discount.
CREDIT_NOTE.credit_amount       RC#PMONEY
CREDIT_NOTE.discount_amount       #PMONEY
INVOICE.pre|post_payment_
 credit_notes_amount              #PMONEY received through CREDIT_NOTEs

CREDIT_NOTE.refund_amount       RC#PMONEY
CREDIT_NOTE.refund               C#REFUND.id

CREDIT_NOTE.out_of_band_amount  RC#PMONEY

CREDIT_NOTE.reason               C#STR among 'duplicate', 'fraudulent', 'order_change', 'product_unsatisfactory'
CREDIT_NOTE.memo                CU#STR shows to CUSTOMER

CREDIT_NOTE.number                #Unique STR shown on receipts and INVOICE
CREDIT_NOTE.pdf                   #'URL' to PDF

                                  ┌────────────────────────┐
                                  │   CREDIT NOTES LINES   │
                                  └────────────────────────┘

CREDIT_NOTE_LINE                  #CREDIT_NOTE's item

GET /credit_notes/ID/lines        #
GET /credit_notes/preview/lines   #Like GET /credit_notes/preview (including request payload) but return CREDIT_NOTE.lines instead.
STRIPE.creditNotes.
 list[Preview]LineItems()         #

CREDIT_NOTE.lines                C#CREDIT_NOTE_LINE_ARR
?credit_note=ID                   #

CREDIT_NOTE_LINE.amount          C#
CREDIT_NOTE_LINE.discount_amount  #Like CREDIT_NOTE.*

CREDIT_NOTE_LINE.quantity        C#NUM
CREDIT_NOTE_LINE.
 unit_amount[_decimal]           C#PMONEY|'BIGINT'. Cost of each unit

CREDIT_NOTE_LINE.type            C#Can be:
                                  #  - 'invoice_line_item': has invoice_line_item
                                  #  - 'custom_line_item': has no invoice_line_item

CREDIT_NOTE_LINE.
 invoice_line_item               C#LINE_ITEM

CREDIT_NOTE_LINE.description     C#STR

                                  ┌─────────────┐
                                  │   INVOICE   │
                                  └─────────────┘

INVOICE                           #Invoice, i.e. incoming CHARGE. Can be:
                                  #  - automatic: created by each period in a SUBSCRIPTION
                                  #  - manual

GET /invoices[/ID]
POST /invoices[/ID]
DELETE /invoices/ID               #
POST /invoices/ID/finalize        #From INVOICE.status 'draft' to 'open'.
                                  #Payload: invoice, auto_advance.
POST /invoices/ID/
 mark_uncollectible               #Set INVOICE.status from 'open' to 'uncollectible'
POST /invoices/ID/void            #Set INVOICE.status to 'void'
POST /invoices/ID/send            #Manually send INVOICE by email. Noop in test mode.
                                  #Only if state 'open'
                                  #EVENT 'invoice.sent'
POST /invoices/ID/pay             #Set INVOICE.paid true
                                  #Only if state 'open|uncollectible'
                                  #Payload: payment_method|source, paid_out_of_band, forgive
PAYLOAD.payment_method|source     #Will attempt PINTENT|CHARGE again.
                                  #If not set, manually set INVOICE.paid true.
PAYLOAD.paid_out_of_band          #BOOL. Not paid within Stripe. No CHARGE will be automatically created.
PAYLOAD.forgive                   #BOOL. Allow CHARGE.amount to be less than INVOICE.amount_due.
STRIPE.invoices.retrieve|list|
 create|update|del|
 finalizeInvoice|
 markUncollectible|void|send|pay()#

INVOICE.subscription             C#SUBSCRIPTION.id
?subscription=SUBSCRIPTION.id     #

INVOICE.collection_method       CU#Def: SUBSCRIPTION.collection_method
?collection_method=STR            #
INVOICE.
 subscription_proration_date     ?#SUBSCRIPTION.proration_date
INVOICE.days_until_due         RCU#Def: SUBSCRIPTION.days_until_due
INVOICE.due_date                CU#DATE_NUM depending on INVOICE.days_until_due
?due_date=CMP_FILTER              #
INVOICE.period_start|end          #DATE_NUM

CUSTOMER.balance                CU#MONEY to add|substract to next INVOICE.
                                  #Negative means we owe CUSTOMER, positive CUSTOMER owes us.
CUSTOMER.delinquent               #BOOL. True if last INVOICE unpaid by due date, or failed (if recurring).
INVOICE.starting_balance          #CUSTOMER.balance before this INVOICE
INVOICE.ending_balance           ?#CUSTOMER.balance after this INVOICE
                                  #Only once status 'open'
INVOICE.subtotal                  #PMONEY. Order:
INVOICE.total                     #  INVOICE.subtotal: original amount
INVOICE.amount_due                #  - DISCOUNT
                                  #  INVOICE.total
                                  #  - exclusive TAX_RATE
                                  #  - starting_balance
                                  #  - proration_behavior
                                  #  - CREDIT_NOTE
                                  #  INVOICE.amount_due: final amount, used as CHARGE.amount
INVOICE.amount_paid|remaining     #PMONEY. Their sum === INVOICE.amount_due

INVOICE.status                    #STR among:
?status=STR                       #  - 'draft'
                                  #     - does not have following fields yet: invoice_pdf|hosted_invoice_url|receipt_number|number|customer_*
                                  #     - only state where can update LINE_ITEMs or amount
                                  #  - 'open'
                                  #     - EVENT 'invoice.finalized'
                                  #  - 'paid'
                                  #     - EVENTs 'invoice.payment_succeeded|payment_failed|payment_action_required'
                                  #  - 'uncollectible'
                                  #     - canceled because CUSTOMER cannot pay
                                  #     - accounted as bad debt
                                  #     - status can still change to 'paid' or 'void'
                                  #     - EVENT 'invoice.marked_uncollectible'
                                  #  - 'void'
                                  #     - canceled because INVOICE was wrong
                                  #     - accounted as $0 invoice
                                  #     - status cannot change anymore
                                  #     - EVENT 'invoice.voided'
INVOICE.paid                      #BOOL
INVOICE.auto_advance            CU#BOOL for all the following actions.
                                  #Def true unless:
                                  #  - manual INVOICE
                                  #  - INVOICE.billing_reason 'subscription_update|upcoming|manual'
                                  #  - INVOICE.billing_reason 'subscription_create' and first payment attempt failed
                                  #  - SUBSCRIPTION.state 'canceled'
                                  #Most of this can|must be configured|enabled|disabled in Dashboard setttings
                                  #Change state:
                                  #  - from 'draft' to 'open' after one hour
                                  #  - from 'open' to 'paid' after successful CHARGE (amount_due)
                                  #  - from 'open' to 'void|uncollectible':
                                  #     - if all retries fail
                                  #     - after 15 days since first attempt
                                  #     - after 60 days since due_date
                                  #Charges payments:
                                  #  - using SUBSCRIPTION.default_source|payment_method|hosted_invoice_url
                                  #  - including sending emails if PINTENT.status 'requires_action' (e.g. 3D secure)
                                  #  - if SUBSCRIPTION.collection_method 'charge_automatically'
                                  #Retries failed payments:
                                  #  - default 4 times within 3 weeks
                                  #  - use machine learning to determine best time to retry
                                  #  - if SUBSCRIPTION.collection_method 'charge_automatically'
                                  #Send email:
                                  #  - few days (def: 7) before INVOICE creation:
                                  #     - if SUBSCRIPTION.collection_method 'charge_automatically'
                                  #     - also EVENT 'invoice.upcoming'
                                  #  - on INVOICE 'open':
                                  #     - contains INVOICE.invoice_pdf and INVOICE.hosted_invoice_url
                                  #     - if SUBSCRIPTION.collection_method 'send_invoice'
                                  #     - can be manually send with POST /invoices/ID/send
                                  #  - on payment success
                                  #  - on payment failure
                                  #  - few days before|after due_date
INVOICE.status_transitions.
 finalized_at|paid_at|
 marked_uncollectible_at|voided_at#DATE_NUM
INVOICE.webhooks_delivered_at     #DATE_NUM where EVENT 'invoice.finalized' was successfully delivered (if there are any WEBHOOKs).

INVOICE.billing_reason            #STR among:
                                  #  - 'subscription_create': SUBSCRIPTION first period
                                  #  - 'subscription_cycle': SUBSCRIPTION non-first periods
                                  #  - 'subscription_update': SUBSCRIPTION change
                                  #  - 'subscription_threshold': SUBSCRIPTION.billing_thresholds
                                  #  - 'upcoming': GET /invoices/upcoming
                                  #  - 'manual': created through API|Dashboard
INVOICE.threshold_reason          #THRESHOLD_REASON. Only if triggered because of SUBSCRIPTION.billing_thresholds.
THRESHOLD_REASON.amount_gte       #Total PMONEY that triggered threshold.
THRESHOLD_REASON.item_reasons     #ITEM_REASON_ARR. Which LINE_ITEM triggered threshold.
ITEM_REASON.line_item_ids         #LINE_ITEM_ID_ARR
ITEM_REASON.usage_gte             #PMONEY

SUBSCRIPTION.
 next_pending_invoice_item_invoice#DATE_NUM
SUBSCRIPTION.
 pending_invoice_item_interval   C#INVOICE_INTERVAL
INVOICE_INTERVAL.interval         #'day|week|month|year'
INVOICE_INTERVAL.interval_count   #NUM

INVOICE.customer                  #CUSTOMER.id
?customer=CUSTOMER.id             #
INVOICE.customer_address|email|
 name|phone|shipping|tax*         #CUSTOMER.*

INVOICE.
 default_payment_method|source  CU#Def: SUBSCRIPTION.default_payment_method|source
INVOICE.charge                    #CHARGE.id
CHARGE.invoice                    #INVOICE.id
INVOICE.payment_intent            #PINTENT.id

INVOICE.next_payment_attempt      #DATE_NUM for next CHARGE. Only if SUBSCRIPTION.collection_method 'charge_automatically'
INVOICE.attempt_count             #NUM. How many times CHARGE was tried (including successfully).
INVOICE.attempted                 #BOOL. Whether attemp_count !== 0

INVOICE.invoice_pdf              ?#'URL' to PDF. Can view.
INVOICE.hosted_invoice_url        #'URL' to web version. Can:
                                  #  - view
                                  #  - specify PAYMENT_METHOD and pay
                                  #  - download PDF and receipts
                                  #Can be disabled though Dashboard settings
                                  #Shown in invoices footers. Also sent by email.
INVOICE.receipt_number            #Unique STR shown in receipts (payment transaction).
INVOICE.number                    #Unique STR shown in receipts (invoice + customer).
                                  #Prefixed by CUSTOMER.invoice_prefix followed by '-INCREMENT'
CUSTOMER.next_invoice_sequence  CU#STR. Next invoice suffix
CUSTOMER.invoice_prefix         CU#STR. Def: random 4 bytes hex

INVOICE.lines                     #LINE_ITEM_LIST
                                  #Sorted by LINE_ITEM.subscription then LINE_ITEM.period.end

CUSTOMER.invoice_settings       CU#INVOICE_SETTINGS
INVOICE.description             CU#STR shown to CUSTOMER
                                  #Example: thanking the customer
                                  #Can set default value through Dashboard settings, per-SUBSCRIPTION or for all.
INVOICE[_SETINGS].custom_fields CU#CUSTOM_FIELD_ARR|''. Displayed on top-right corner.
                                  #By default that corner also shows: invoice number, date of issue, date due.
                                  #Example: contact info, unique numbers.
CUSTOM_FIELD.name                C#STR
CUSTOM_FIELD.value               C#STR
INVOICE[_SETTINGS].footer       CU#STR displayed on the invoice.
                                  #Can set default value through Dashboard settings
                                  #Example: legal text
INVOICE.account_name              #ACCOUNT.business_profile.name

                                  ┌───────────────┐
                                  │   LINE ITEM   │
                                  └───────────────┘

LINE_ITEM                         #Single item in an automatic INVOICE

GET /invoices/ID/lines            #
STRIPE.invoices.listLineItems()   #

LINE_ITEM.type                    #'subscription' or 'invoiceitem'
LINE_ITEM.subscription          ?C#SUBSCRIPTION.id
LINE_ITEM.subscription_item      ?#SUBSCRIPTION_ITEM.id
LINE_ITEM.plan                   ?#PLAN.id
LINE_ITEM.invoice_item           ?#INVOICE_ITEM.id
LINE_ITEM.amount                CU#MONEY. Unit price. Can be negative to give money to CUSTOMER
LINE_ITEM.quantity              CU#NUM. Quantity
LINE_ITEM.discountable          CU#BOOL. Whether DISCOUNT should be used.
LINE_ITEM.proration               #BOOL
LINE_ITEM.period.start|end      CU#DATE_NUM
LINE_ITEM.description           CU#STR shown to CUSTOMER

                                  ┌──────────────────┐
                                  │   INVOICE ITEM   │
                                  └──────────────────┘

INVOICE_ITEM                      #Single item in:
                                  #  - a specific INVOICE, manual or automatic: INVOICE_ITEM.invoice
                                  #  - the next automatic INVOICE: INVOICE_ITEM.customer|subscription
                                  #Same properties as LINE_ITEM, with extra fields:

GET /invoiceitems[/ID]
POST /invoiceitems[/ID]
DELETE /invoiceitems/ID           #
STRIPE.invoiceItems.
 retrieve|list|create|update|del()#

INVOICE_ITEM.
 unit_amount[_decimal]          CU#PMONEY|'BIGINT'
INVOICE_ITEM.invoice            ?C#INVOICE.id
?invoice=INVOICE.id               #
?pending=BOOL                     #Filter by INVOICE undefined
INVOICE_ITEM.customer             #CUSTOMER.id
?customer=CUSTOMER.id             #
INVOICE_ITEM.date                 #DATE_NUM

                                  ┌──────────────────────┐
                                  │   UPCOMING INVOICE   │
                                  └──────────────────────┘

GET /invoices/upcoming            #See INVOICEs not created yet.
STRIPE.invoices.retrieveUpcoming()#
GET /invoices/upcoming/lines      #See LINE_ITEMs of INVOICEs not created yet.
STRIPE.invoices.
 listUpcomingLineItems()          #

?coupon=COUPON.id                 #
?customer=CUSTOMER.id             #
?subscription=ID                  #
?subscription_billing_cycle_anchor
 =STR                             #
?subscription_cancel_at=DATE_NUM  #
?subscription_cancel_at_period_end
 =BOOL                            #
?subscription_cancel_now=BOOL     #
?subscription_default_tax_rates=
 OBJ_ARR                          #
?subscription_proration_behavior=
 STR                              #
?subscription_proration_date=
 DATE_NUM                         #
?subscription_stard_date=DATE_NUM #
?subscription_trial_end=BOOL      #
?subscription_trial_from_plan=BOOL#
?subscription_items=OBJ_ARR       #
?subscription_items.*.id=ID       #
?subscription_items.*.
 billing_thresholds.usage_gte=NUM #
?subscription_items.*.clear_usage=
 BOOL                             #
?subscription_items.*.deleted=BOOL#
?subscription_items.*.metadata=OBJ#
?subscription_items.*.plan=ID     #
?subscription_items.*.quantity=NUM#
?subscription_items.*.tax_rates=
 OBJ_ARR                          #
?invoice_items=OBJ_ARR            #
?invoice_items.*.
 amount[_decimal]=NUM|'BIGINT'    #
?invoice_items.*.currency=STR     #
?invoice_items.*.description=STR  #
?invoice_items.*.discountable=BOOL#
?invoice_items.*.invoiceitem=ID   #
?invoice_items.*.metadata=OBJ     #
?invoice_items.*.period.start|end
 =DATE_NUM                        #
?invoice_items.*.quantity=NUM     #
?invoice_items.*.tax_rates=OBJ_ARR#
?invoice_items.*.
 unit_amount[_decimal]=NUM|'BIGNT'#

                                  ┌──────────────────────────────┐
                                  │   AUTOMATED RECONCILIATION   │
                                  └──────────────────────────────┘

AUTOMATED RECONCILIATION ==>      #If:
                                  #  - no SUBSCRIPTION.default_payment_method|source
                                  #  - SUBSCRIPTION.collection_method 'send_invoice'
                                  #  - ACCOUNT.country US
                                  #  - currency USD
                                  #Then:
                                  #  - create a 'ach_credit_transfer' SOURCE and attach it to CUSTOMER.source
                                  #  - create INVOICE-wise virtual bank account
                                  #     - more secure because do not expose our bank account information.
                                  #  - send payment instructions in email on how to make ACH or wire transfer
                                  #  - on payment, set INVOICE.status 'paid'

                                  ┌────────────┐
                                  │   TAX ID   │
                                  └────────────┘

TAX_IDS                           #CUSTOMER's tax identifiers, e.g. company VAT ID.
                                  #Should verify that:
                                  #  - ID exists:
                                  #     - (EU only) done by Stripe
                                  #  - tax name and address match CUSTOMER's:
                                  #     - (EU only) Stripe fills TAX_VERIF_verified_name|address, but we still need to check
                                  #        - need to wait for EVENT 'customer.tax_id.updated'
                                  #Shown on INVOICEs.
                                  #Collected taxes can be exported as CSV in Dashboard.

GET /customers/ID/tax_ids[/ID]
POST /customers/ID/tax_ids
DELETE /customers/ID/tax_ids/ID   #
STRIPE.taxIds.
 retrieve|list|create|del()       #

TAX_IDS.customer                *C#CUSTOMER.id
?customer=CUSTOMER.id             #
TAX_IDS.country                   #COUNTRY

TAX_IDS.type                    *C#One of 'us_ein' (US), 'eu_vat' (EU), 'nz_gst' (New Zealand), 'au_abn' (Australia), 'ca_bn|ca_qst' (Canada), 'in_gst' (India),
                                *C#'ch_vat' (Switzerland), 'mx_rfc' (Mexico), 'sg_uen' (Singapore), 'za_var' (South Africa),
                                *C#'no_vat' (Norway), 'hk_br' (Hong Kong), 'ru_inn' (Russia), 'es_cif' (Spain), 'jp_cn' (Japan),
                                *C#'th_vat' (Thailand), 'tw_vat' (Taiwan), 'kr_brn' (Korea), 'li_uid' (Liechtenstein),
                                *C#'my_itn|my_sst' (Malaysia), 'unknown'
TAX_IDS.value                   *C#STR

TAX_IDS.verification              #TAX_VERIF
TAX_VERIF.status                  #From 'pending' to 'available' (success), 'unavailable' (failure) or 'unverified' (cannot check)
TAX_VERIF.verified_name           #STR
TAX_VERIF.verified_address        #STR
CUSTOMER.tax_ids                  #TAX_IDS_LIST
CUSTOMER.tax_id_data            RC#TAX_IDS_ARR
CUSTOMER.tax_exempt             CU#One of:
                                  #  - 'none' (def): pay TAX_RATE
                                  #  - 'exempt': does not pay TAX_RATEs
                                  #  - 'reverse': does not pay TAX_RATEs, but customer must report the tax and pay it outside Stripe

COMPANY.tax_id                 RCU#STR. Country-specific company ID.
                                  #Required field
COMPANY.tax_id_provided           #BOOL
COMPANY.tax_id_registrar        CU#STR. Country-specific (Germany only) company jurisdiction.
COMPANY.vat_id                 RCU#STR. Country-specific company VAT number.
COMPANY.vat_id_provided           #BOOL

                                  ┌──────────────┐
                                  │   TAX RATE   │
                                  └──────────────┘

TAX_RATE                          #Specific tax rate for a given SUBSCRIPTION[_ITEM]|INVOICE|LINE_ITEM

GET /tax_rates[/ID]
POST /tax_rates[/ID]              #
STRIPE.taxRates.
 retrieve|list|create|update()    #

TAX_RATE.percentage             *C#FLOAT (0-1)
TAX_RATE.inclusive              *C#BOOL. Whether inclusive (included in amount) or exclusive (added to amount).
?inclusive=BOOL                   #

TAX_RATE.active                 CU#BOOL (def: true). Whether can be applied to new SUBSCRIPTION|INVOICE (old ones will still work)
?active=BOOL                      #

TAX_RATE.jurisdiction           CU#STR
TAX_RATE.display_name          *CU#STR shown to receipts and INVOICEs
TAX_RATE.description            CU#STR not shown to CUSTOMER

SUBSCRIPTION|INVOICE.
 default_tax_rates              CU#TAX_RATE_LIST|''. Max length 5.
SUBSCRIPTION_ITEM|LINE_ITEM|
 CREDIT_NOTE_LINE.tax_rates     CU#TAX_RATE_ARR|''. Max length 5.

INVOICE.tax                       #PMONEY. Amount of tax.
INVOICE|LINE_ITEM.
 total_tax_amounts
CREDIT_NOTE[_LINE].tax_amounts    #TAX_AMOUNT_ARR. Breakdown of taxes
TAX_AMOUNT.amount                 #PMONEY
TAX_AMOUNT.inclusive              #BOOL
TAX_AMOUNT.tax_rate               #TAX_RATE

                                  ┌─────────────┐
                                  │   ACCOUNT   │
                                  └─────────────┘

ACCOUNT                           #Stripe account.
                                  #Also used for other accounts authorized through OAuth with Connect:
                                  #  - express|custom requires updating ACCOUNT.* (see below)

GET /accounts[/ID]
POST /accounts[/ID]
DELETE /accounts/ID               #
STRIPE.accounts.retrieve|list|
 create|update|del()              #

JAPAN KANJI/KANA ==>              #The following fields are suffixed with _kanji|_kana in Japan: address, *name, statement_descriptor

ACCOUNT.email                   CU#STR.
ACCOUNT.business_type           CU#Can be 'individual', 'company', 'government_entity' or 'non_profit'
                                  #Required field
ACCOUNT.structure               CU#STR.
                                  #Can be:
                                  #  - government_instrumentality
                                  #  - governmental_unit
                                  #  - multi_member_llc
                                  #  - private|public_corporation|partnership
                                  #  - tax_exempt_government_instrumentality
                                  #  - [un]incorporated_non_profit
                                  #  - unincorporated_association
                                  #Required field
ACCOUNT.individual              CU#PERSON. Only if business_type 'individual'.
                                  #Required field
ACCOUNT.company                 CU#COMPANY. Only if business_type 'company'. Used for verification by Stripe.
                                  #Required field
COMPANY.name                    CU#STR. Legal name.
                                  #Required field
COMPANY.address                 CU#ADDRESS.
                                  #Required fields:
                                  #  - state (except EU, Singapore, Hong Kong)
                                  #  - city|line1 (except Singapore)
                                  #  - town (Japan)
                                  #  - postal_code
COMPANY.phone                   CU#STR.
                                  #Required field (Japan)
COMPANY.executives_provided     CU#BOOL. Must be set to true once all PERSONs with RELATIONSHIP.executive true have been created.
COMPANY.directors_provided      CU#BOOL. Must be set to true once all PERSONs with RELATIONSHIP.director true have been created.
COMPANY.owners_provided         CU#BOOL. Must be set to true once all PERSONs with RELATIONSHIP.owner true have been created.
                                  #Automatically set by Stripe if total RELATIONSHIP.percent_ownership amounts to 1.
COMPANY.verification              #COMPANY_VERIF
COMPANY_VERIF.document          CU#VERIF_DOC (see below)

ACCOUNT.business_profile        CU#BUSINESS_PROFILE. Information shown to customers.
BUSINESS_PROFILE.name           CU#STR.
BUSINESS_PROFILE.url            CU#'URL'. Must be HTTP[S] and be URL-encoded.
BUSINESS_PROFILE.support_addressCU#ADDRESS.
BUSINESS_PROFILE.support_email  CU#STR.
BUSINESS_PROFILE.support_phone  CU#STR.
BUSINESS_PROFILE.support_url    CU#'URL'
BUSINESS_PROFILE.mcc            CU#STR. Four-digits ISO 18245 describing industry.
                                  #Can be used by payment providers to enforce specific rules or taxes.
                                  #Automatically set by Stripe for standard|express, but not for custom
                                  #See list at https://stripe.com/docs/connect/setting-mcc#list
BUSINESS_PROFILE.
 product_description            CU#STR. Internal-only description of the product sold. Used by Stripe for risk and underwriting purposes.

ACCOUNT.tos_acceptance          CU#TOS_ACCEPTANCE. Stripe Terms Of Service.
                                  #For custom Connect account.
                                  #We are responsible for showing link and text of Stripe Terms of Service (see online doc).
                                  #Required field
TOS_ACCEPTANCE.date             CU#DATE_NUM
TOS_ACCEPTANCE.ip               CU#'IP'
TOS_ACCEPTANCE.user_agent       CU#STR
                                  #Must be filled, but can be emptied out afterwards.

ACCOUNT.settings                CU#SETTINGS
SETTINGS.branding               CU#BRANDING. Customize colors/logos in emails, receipts, invoices and Checkout.
BRANDING.icon                   CU#FILE.id. Icon logo. Square and min 128x128. JPG/PNG/GIF.
BRANDING.logo                   CU#FILE.id. Full logo. Min 128x128. Max 512KB. JPG/PNG/GIF.
                                  #Can decide whether to show icon (def) or logo using Dashboard setttings
BRANDING.primary_color          CU#'#CSS_HEX_COLOR'

SETTINGS.dashboard                #DASHBOARD_SETTINGS. Settings for Dashboard UI.
DASHBOARD_SETTINGS.display_name   #STR
DASHBOARD_SETTINGS.timezone       #STR

SETTINGS.payments               CU#PAYMENTS_SETTINGS (see above).
SETTINGS.card_payments          CU#CARD_SETTINGS
CARD_SETTINGS.decline_on        CU#DECLINE_ON (see above).
SETTINGS.payouts                CU#PAYOUTS_SETTINGS (see above).

TOKEN.type                        #Can be 'account'
                                  #Goal: like payment TOKENs (PCI compliance, security) but for ACCOUNT.*
TOKEN.account                   RC#ACCOUNT, but only privacy-sensitive fields:
                                  #  - business_type, company|individual
                                  #  - also tos_shown_and_accepted BOOL
ACCOUNT.account_token          RCU#TOKEN.id

                                  ┌────────────┐
                                  │   PERSON   │
                                  └────────────┘

PERSON                            #Persons associated with a ACCOUNT.
                                  #Fields verified by Stripe cannot be updated anymore.

GET /accounts/ID/persons[/ID]
POST /accounts/ID/persons[/ID]
DELETE /accounts/ID/persons/ID    #
STRIPE.persons.
 list|retrieve|create|udpate|del()#

PERSON.account                  CU#ACCOUNT.id

PERSON.address                  CU#ADDRESS
                                  #Required fields (for companies):
                                  #  - state (Ireland, Japan)
                                  #  - city (EU, Hong Kong, Japan)
                                  #  - town (Japan)
                                  #  - postal_code (EU, Singapore, Japan, New Zealand)
                                  #  - line1 (EU, Singapore, Hong Kong, Japan, Australia)
                                  #Required fields (for individuals):
                                  #  - state (US, Canada, Japan, Australia)
                                  #  - city (non-EU except Singapore)
                                  #  - postal_code (non-EU except Hong Kong)
                                  #  - line1 (non-EU)
PERSON.dob                      CU#DOB|''
                                  #Required field
DOB.day                           #1-31
DOB.month                         #1-12
DOB.year                          #4 digits
PERSON.first_name               CU#STR
                                  #Required field
PERSON.maiden_name              CU#STR
PERSON.last_name                CU#STR
                                  #Required field
PERSON.gender                   CU#'male' or 'female'
                                  #Required field (Japan)
PERSON.email                    CU#STR
PERSON.phone                    CU#STR

PERSON.id_number               RCU#Country-specific ID number. For example social security number in US.
                                  #Can also be a PII TOKEN.id
                                  #Eventually required field (US, Canada, Hong Kong, Singapore)
PERSON.id_number_provided         #BOOL
PERSON.ssn_last_4              RCU#Social security number last 4 digits.
                                  #Required field (US)
PERSON.ssn_last_4_provided        #BOOL

PERSON.relationship             CU#RELATIONSHIP to the account.
RELATIONSHIP.title              CU#STR. Job title.
RELATIONSHIP.representative     CU#BOOL. Whether the person is the primary representative
?relationship.representative=BOOL #
RELATIONSHIP.owner              CU#BOOL. Whether the person is an owner of the company
?relationship.owner=BOOL          #
RELATIONSHIP.director           CU#BOOL. Whether the person is a director of the company.
                                  #Only if ACCOUNT.business_type is 'company'.
                                  #Required for accounts in the EU.
?relationship.director=BOOL       #
RELATIONSHIP.executive          CU#BOOL. Same for managers|executives.
?relationship.executive=BOOL      #
RELATIONSHIP.percent_ownership  CU#FLOAT (0-1). Company's ownership percentage.

PERSON.verification             CU#PERSON_VERIF
PERSON_VERIF.status               #Stripe verification of PERSON.* fields. From 'pending' to 'verified' or 'unverified'.
PERSON_VERIF.details              #STR. Human-friendly failure status like 'Provided identity information could not be verified'.
PERSON_VERIF.details_code         #STR. Machine-friendly failure status:
                                  #  - scan_corrupt: cannot open file
                                  #  - scan_not_uploaded: wrong format
                                  #  - scan_not_readable: hard to read
                                  #  - scan_failed_greyscale: should be in color
                                  #  - scan_id_country_not_supported: wrong country
                                  #  - scan_id_type_not_supported: wrong ID type (e.g. not passport)
                                  #  - scan|document_name_mismatch: does not match PERSON.*_name
                                  #  - failed_keyed_identity: cannot get full PERSON.*_name
                                  #  - [scan_]failed_other
PERSON_VERIF.document           CU#VERIF_DOC.
                                  #Can be:
                                  #  - passport (preferred)
                                  #  - ID card (all but New Zealand)
                                  #  - Driver license (all but Hong Kong)
                                  #Should be:
                                  #  - <8000x8000px
                                  #  - <5MB
                                  #  - JPG|PNG
                                  #  - in colors
                                  #Should not submit FILE previously rejected.
                                  #Eventually required field
PERSON_VERIF.
 additional_document            CU#Additional VERIF_DOC.
VERIF_DOC.front|back            CU#FILE.id
                                  #Only front needed for:
                                  #  - passports
                                  #  - ID card (Hong Kong)
                                  #  - Driver license (Belgium, Denmark, Finland, Germany, Ireland, Luxembourg, Norway, Portugal, Spain, Sweden, Switzerland, UK)
VERIF_DOC.details                 #STR. Human-friendly failure status like 'Identity document is too unclear to read'.
VERIF_DOC.details_code            #STR. Machine-friendly failure status:
                                  #  - document_corrupt: cannot open file
                                  #  - document_not_uploaded: wrong format
                                  #  - document_not_readable: hard to read
                                  #  - document_failed_greyscale: should be in color
                                  #  - document_too_large: >8000x8000px
                                  #  - document_country_not_supported: wrong country
                                  #  - document_type_not_supported: wrong ID type (e.g. not passport)
                                  #  - document_photo_mismatch: wrong picture
                                  #  - document_expired: wrong date
                                  #  - document_incomplete
                                  #  - document_type_not_supported
                                  #  - document_missing_back|front
                                  #  - document_failed_copy
                                  #  - document_failed_other
                                  #  - document_fraudulent
                                  #  - document_invalid
                                  #  - document_manipulated
                                  #  - document_failed_test_mode

TOKEN.type                        #Can be 'pii'
                                  #Goal: like payment TOKENs (PCI compliance, security) but for PERSON.*
TOKEN.person                    RC#PERSON.
TOKEN.pii                       RC#OBJ: id_number TOKEN.id
PERSON.person_token            RCU#TOKEN.id

                                  ┌─────────────────┐
                                  │   RESTRICTION   │
                                  └─────────────────┘

RESTRICTIONS REASONS ==>          #ACCOUNT can be restricted:
                                  #  - on ACCOUNT creation, must provide minimum required fields
                                  #     - US needs to ask for ACCOUNT.requested_capabilities as well
                                  #  - after hitting a specific volume threshold, must provide additional required fields
                                  #  - can restrict OAuth connected ACCOUNTs using POST /accounts/ID/reject
ACCOUNT.charges_enabled           #BOOL. Enable CHARGEs.
ACCOUNT.payouts_enabled           #BOOL. Enable PAYOUTs.

COUNTRY_SPEC.verification_fields. #'VARR' of fields that must be filled on ACCOUNT|PERSON.*
 company|individual.              #  - otherwise ACCOUNT.payouts_enabled|charges_enabled false
 minimum|additional               #Should use this information to know which information to ask (instead of hard-coding it).
                                  #Should:
                                  #  - check ACCOUNT|PERSON.requirements on 'account|person.updated' EVENT
                                  #  - ask users those information accordingly
                                  #Field names do not always exactly match actual field names.
                                  #company|individual depends on ACCOUNT.business_type
                                  #PERSON.* fields are for:
                                  #  - ACCOUNT creator
                                  #  - EU/Singapore, company only:
                                  #     - every "beneficial owner", i.e. >25% shares
                                  #     - other owner|directories: first_name|last_name only
                                  #Can be either:
                                  #  - 'minimum':
                                  #     - set ACCOUNT.charges_enabled true
                                  #     - required right away
                                  #     - marked as "required field"
                                  #  - 'additional':
                                  #     - set ACCOUNT.payouts_enabled true
                                  #     - only required after hitting a specific threshold:
                                  #        - e.g. in US: either 30 days since first CHARGE, or more than $1500 CHARGEs
                                  #     - marked as "eventually required field"
                                  #     - only passport/ID card and ID numbers
                                  #     - can do it upfront or not (since it's quite a big requirement)
                                  #Are automatically verified by Stripe.
ACCOUNT|PERSON.requirements      ?#REQUIREMENTS to fill in required fields.
REQUIREMENTS.                     #'VARR'_ARR to fill on ACCOUNT
 eventually|currently|past_due|   #  - 'eventually_due': "additional" required fields not required yet. Also includes 'pending_verification|currently_due|past_due' fields
 pending_verification             #  - 'pending_verification': Stripe is verifying informaiton. Also includes 'currently_due|past_due' fields
                                  #  - 'currently_due': required before 'current_deadline'. Also includes 'past_due' fields.
                                  #  - 'past_due': past 'current_deadline'.
REQUIREMENTS.current_deadline     #DATE_NUM
                                  #If miss the deadline, ACCOUNT is restricted, but can still be fixed.
ACCOUNT.details_submitted         #BOOL. Whether account details have been submitted.
REQUIREMENTS.disabled_reason     ?#STR among:
                                  #  - 'requirements.pending_verification|past_due': ACCOUNT creation
                                  #  - 'rejected.REASON': POST /accounts/ID/reject
                                  #  - 'listed': matches a blacklist
                                  #  - 'under_review': Stripe triggered it internally
                                  #  - 'other'
REQUIREMENTS.errors               #REQUIREMENTS_ERROR_ARR
REQUIREMENT_ERROR.requirement     #'VARR'
REQUIREMENT_ERROR.reason          #STR. Informative message
REQUIREMENT_ERROR.code            #STR among:
                                  #  - invalid_address_city_state_postal_code
                                  #  - invalid_street_address
                                  #  - invalid_value_other
                                  #  - verification_document_address_mismatch
                                  #  - verification_document_address_missing
                                  #  - verification_document_corrupt
                                  #  - verification_document_country_not_supported
                                  #  - verification_document_dob_mismatch
                                  #  - verification_document_duplicate_type
                                  #  - verification_document_expired
                                  #  - verification_document_failed_copy
                                  #  - verification_document_failed_greyscale
                                  #  - verification_document_failed_other
                                  #  - verification_document_failed_test_mode
                                  #  - verification_document_fraudulent
                                  #  - verification_document_id_number_mismatch
                                  #  - verification_document_id_number_missing
                                  #  - verification_document_incomplete
                                  #  - verification_document_invalid
                                  #  - verification_document_manipulated
                                  #  - verification_document_missing_back
                                  #  - verification_document_missing_front
                                  #  - verification_document_name_mismatch
                                  #  - verification_document_name_missing
                                  #  - verification_document_nationality_mismatch
                                  #  - verification_document_not_readable
                                  #  - verification_document_not_uploaded
                                  #  - verification_document_photo_mismatch
                                  #  - verification_document_too_large
                                  #  - verification_document_type_not_supported
                                  #  - verification_failed_address_match
                                  #  - verification_failed_business_iec_number
                                  #  - verification_failed_document_match
                                  #  - verification_failed_id_number_match
                                  #  - verification_failed_keyed_identity
                                  #  - verification_failed_keyed_match
                                  #  - verification_failed_name_match
                                  #  - verification_failed_other

POST /accounts/ID/reject          #Restrict an ACCOUNT connected through OAuth
                                  #Payload: reason
PAYLOAD.reason                    #STR among 'fraud', 'terms_of_service', 'listed', 'other'.
STRIPE.account.reject()           #

                                  ┌────────────────┐
                                  │   CAPABILITY   │
                                  └────────────────┘

CAPABILITY                        #Disable some features on ACCOUNT pending required fields verification.
                                  #Only required for US ACCOUNT.
                                  #Should only request the ones needed, so less verification is done.

GET
 /accounts/[ID/]capabilities[/ID]
POST
 /accounts/[ID/]capabilities/ID   #
STRIPE.accounts.
 list|retrieve|updateCapability() #

CAPABILITY.account                #ACCOUNT.id
CAPABILITY.requirements           #REQUIREMENTS
CAPABILITY.status                 #Can be:
                                  #  - 'unrequested'
                                  #  - 'pending': requested but pending
                                  #  - 'active': requested and approved
                                  #  - 'inactive', 'disabled': requested and declined
CAPABILITY.requested             U#BOOL
CAPABILITY.requested_at          ?#DATE_NUM

ACCOUNT.requested_capabilities  CU#TYPE_ARR
ACCOUNT.capabilities              #CAPABILITIES
CAPABILITIES.TYPE                 #TYPE can be:
                                  #  - 'card_payments': direct charges (see above)
                                  #  - 'transfers': destination|separate charges (see above)
                                  #  - 'card_issuing'
                                  #  - 'au_becs_debit_payments': can use 'au_becs_debit' payment type
                                  #  - 'tax_reporting_us_1099_k', 'tax_reporting_us_1099_misc': US tax reporting
                                  #Value is CAPABILITY.status

                                  ┌─────────────┐
                                  │   BALANCE   │
                                  └─────────────┘

BALANCE                           #ACCOUNT "Stripe bank account".

GET /balance                      #
STRIPE.balance.retrieve()         #

BALANCE.available                 #BALANCE_SUB_ARR. Money available.
                                  #EVENT 'balance.available' when updated.
                                  #If negative, cannot create TRANSFER nor positive PAYOUT.
BALANCE.pending                   #BALANCE_SUB_ARR.
                                  #Any money added to BALANCE is pending for few days (country-specific).
                                  #Cannot be used while pending.
BALANCE.connect_reserved          #BALANCE_SUB_ARR.
                                  #Money reserved with Connect when a destination's ACCOUNT's BALANCE is negative:
                                  #  - when platform is responsible to cover cost, i.e. with DESC|SEPC
                                  #  - a TRANSFER is automatically created after 6 months
                                  #  - if for too long, should use POST /accounts/ID/reject
BALANCE_SUB                       #Subdivision of BALANCE for each currency and SOURCE
BALANCE_SUB.amount                #MONEY
BALANCE_SUB.source_types.TYPE     #INT. How amount is divided between account TYPE 'bank_account|card|fpx'.

                                  ┌─────────────────────────┐
                                  │   BALANCE TRANSACTION   │
                                  └─────────────────────────┘

BALANCE_TRANSACTION               #BALANCE's single transaction

GET /balance_transactions[/ID]    #
STRIPE.balanceTransactions.
 list|retrieve()                  #

BALANCE_TRANSACTION.amount        #PMONEY paid by sender
?currency=STR                     #

BALANCE_TRANSACTION.net           #amount - fee
BALANCE_TRANSACTION.fee           #PMONEY. Fee paid to another ACCOUNT, Stripe or taxes
BALANCE_TRANSACTION.fee_details   #FEE_DETAILS
FEE_DETAILS.type                  #Can be: 'application_fee', 'stripe_fee' or 'tax'
FEE_DETAILS.application           #ACCOUNT.id
FEE_DETAILS.amount                #PMONEY
FEE_DETAILS.description           #STR

BALANCE_TRANSACTION.status        #'pending' or 'available'
BALANCE_TRANSACTION.available_on  #DATE_NUM. When will be 'available' in BALANCE. Until then is 'pending'
?available_on=CMP_FILTER          #

BALANCE_TRANSACTION.type          #Can be:
                                  #  - stripe_fee: Stripe pricing fee
                                  #  - stripe_fx_fee: Stripe pricing fee, for currency conversion
                                  #  - tax_fee: tax on Stripe pricing fee
                                  #  - tax_deducted_at_source
                                  #  - charge: credit-card CHARGE
                                  #  - payment: non-credit-card CHARGE
                                  #  - [payment_]refund, refund_failure: same for REFUND
                                  #  - payment_failure_refund: REFUND due to async CHARGE that failed
                                  #  - payout[_cancel|failure]: PAYOUT
                                  #  - advance[_funding]: instant PAYOUTs > BALANCE (Stripe advances money)
                                  #  - topup[_reversal]: TOPUP
                                  #  - adjustment: DISPUTE fee and REFUND failures
                                  #  - application_fee: FEE
                                  #  - application_fee_refund: FEE_REFUND
                                  #  - transfer[_cancel|failure]: TRANSFER
                                  #  - transfer_refund: TRANSFER_REVERSAL
                                  #  - connect_collection_transfer, reserve_transaction: BALANCE.connect_reserved
                                  #  - reserved_funds: money reserved by Stripe because of Risk
                                  #  - issuing_transaction: remove money on AUTHORIZATION, after capturing
                                  #  - issuing_authorization_hold|release: [un]hold reserved money on AUTHORIZATION, before|after capturing
?type=STR                         #

BALANCE_TRANSACTION.              #Similar to type but more useful for reporting.
 reporting_category               #Value is a little different (put in parentheses):
                                  #  - fee (stripe_fee, stripe_fx_fee)
                                  #  - tax (tax_fee)
                                  #  - charge_failure (payment_failure_refund)
                                  #  - payout
                                  #  - payout_reversal (payout_cancel|failure)
                                  #  - advance, advance_funding
                                  #  - topup, topup_reversal
                                  #  - dispute, dispute_reversal, refund_failure (adjustment)
                                  #  - platform_earning (application_fee)
                                  #  - platform_earning_refund (application_fee_refund)
                                  #  - transfer
                                  #  - transfer_reversal (transfer_refund)
                                  #  - connect_collection_transfer
                                  #  - connect_reserved_funds (reserve_transactions)
                                  #  - risk_reserved_funds (reserved_funds)
                                  #  - issuing_transaction
                                  #  - issuing_authorization_hold|release
                                  #  - network_cost
                                  #  - other_adjustment
                                  #  - partial_capture_reversal
                                  #  - financing_paydown
                                  #  - financing_paydown_reversal
                                  #  - financing_payout
                                  #  - financing_payout_reversal

BALANCE_TRANSACTION.source        #Related RESOURCE.id
?source=SOURCE.id                 #
?payout=PAYOUT.id                 #

BALANCE_TRANSACTION.description   #STR

                                  ┌──────────────────────────────────┐
                                  │   CUSTOMER BALANCE TRANSACTION   │
                                  └──────────────────────────────────┘

CUSTOMER BALANCE TRANSACTION ==>  #Like BALANCE_TRANSACTION for a CUSTOMER

GET /customers/ID/
 balance_transactions[/ID]
POST /customers/ID/
 balance_transactions[/ID]        #
STRIPE.customers.
 retrieve|list|create|
 updateBalanceTransactions()      #

CBALANCE_TRANSACTION.amount     *C#PMONEY paid by CUSTOMER
CBALANCE_TRANSACTION.
 description                   ?CU#Shown to CUSTOMER
CBALANCE_TRANSACTION.customer     #CUSTOMER.id
CBALANCE_TRANSACTION.type         #STR among:
                                  #  - adjustment
                                  #  - applied_to_invoice|unapplied_from_invoice
                                  #  - credit_note
                                  #  - initial
                                  #  - invoice_too_small|large
                                  #  - unspent_receiver_credit
CBALANCE_TRANSACTION.
 ending_balance                   #PMONEY left on BALANCE after transaction
CBALANCE_TRANSACTION.invoice     ?#INVOICE.id
CBALANCE_TRANSACTION.credit_note ?#CREDIT_NOTE.id

                                  ┌────────────┐
                                  │   PAYOUT   │
                                  └────────────┘

PAYOUT                            #Transfer money from ACCOUNT to bank account / credit card

GET /payouts[/ID]
POST /payouts[/ID]                #
POST /payouts/ID/cancel           #Set PAYOUT.status to 'canceled'
STRIPE.payouts.list|retrieve|
 create|update|cancel()           #

PAYOUT.amount                   *C#MONEY
                                  #Minimum of around €1-2 (currency-specific) (only for EU countries).
                                  #Can be negative, in which case bank account / credit card is debited instead.
                                  #  - done to put negative BALANCE back to normal
                                  #Restrictions for debit 'card':
                                  #  - must be US
                                  #  - must be visa|mastercard|discover
                                  #  - maximum $3000 for 'standard', $9999 for 'instant'.

PAYOUT.source_type               C#'bank_account' or 'card' (source)
                                  #Decides which BALANCE_SUB to pick.
PAYOUT.type                       #'bank_account' or 'card' (destination)
PAYOUT.destination               C#CARD|BANK_ACCOUNT.id. Where to send.
?destination=CARD|BANK_ACCOUNT.id #

PAYOUT.method                    C#Either:
                                  #  - 'standard':
                                  #     - takes several days (country-specific)
                                  #        - 7-10 days the first time it's done
                                  #  - 'instant':
                                  #     - less than 30 minutes
                                  #     - only for Connect, for debit cards and not for all banks (but most)
                                  #     - higher Stripe fee
                                  #     - US only
                                  #     - max $5000 per day
PAYOUT.status                     #STR among:
                                  #  - 'pending': not submitted to bank yet
                                  #  - 'in_transit'
                                  #  - 'paid', 'failed' or 'canceled'
                                  #     - EVENT 'payout.paid|failed|canceled'
?status=STR                       #
PAYOUT.arrival_date               #Expected|actual DATE_NUM
?arrival_date=CMP_FILTER          #
PAYOUT.failure_message           ?#STR
PAYOUT.failure_code              ?#STR among:
                                  #  - 'insufficient_funds': not enough money to make payout
                                  #  - 'unsupported_card': invalid card
                                  #  - 'invalid_account_number'
                                  #  - 'incorrect_account_holder_name'
                                  #  - 'no_account': invalid bank account details.
                                  #  - 'account_closed|frozen': bank account has been closed|frozen
                                  #  - 'bank_ownership_changed': bank account no longer valid because of ownership change.
                                  #  - 'invalid_currency': bank does not handle this currency.
                                  #  - 'bank_account_restricted':
                                  #      - bank account does not handle payout type|amount.
                                  #      - usually because it's a savings account.
                                  #  - 'debit_not_authorized': bank account does not handle debit transactions.
                                  #  - 'could_not_process': generic problem with bank
                                  #  - 'declined': declined by bank.

PAYOUT.description               C#Like CHARGE.*

PAYOUT.balance_transaction        #BALANCE_TRANSACTION.id
PAYOUT.                          ?#If failed|canceled, BALANCE_TRANSACTION.id reversing it.
 failure_balance_transaction      #Takes up to 5 days to receive money back.

PAYOUT.automatic                  #BOOL. True if created by an automated payout SCHEDULE.
ACCOUNT.settings.payouts        CU#PAYOUTS_SETTINGS.
PAYOUTS_SETTINGS.schedule       CU#SCHEDULE. Automatically create PAYOUTs.
SCHEDULE.interval               CU#Automatic PAYOUTs frequency among 'daily', 'weekly', 'monthly' or 'manual' (never, but actually 90 days)
SCHEDULE.weekly_anchor          CU#STR ('monday', etc.). Day of the week if SCHEDULE.interval 'weekly'.
SCHEDULE.monthly_anchor         CU#NUM. Days of the month if SCHEDULE.interval 'monthly'.
                                  #If 29-31 and month has fewer days, send on last day.
SCHEDULE.delay_days             CU#Wait for INT days before any CHARGE is included in automatic PAYOUTs.
PAYOUTS_SETTINGS.               CU#BOOL (def: true for Express, false for Custom accounts).
 debit_negative_balances          #Automatically create negative PAYOUT if BALANCE is negative.
                                  #Only for ACCOUNT in US|Canada|Australia.

                                  ┌───────────┐
                                  │   TOPUP   │
                                  └───────────┘

TOPUP                             #Inverse of PAYOUT. Money added to ACCOUNT
                                  #Only for US ACCOUNTs (at the moment)
                                  #ACCOUNT.settings.payouts.schedule.interval must be 'manual'
                                  #Take 5-6 business days.

GET /topups[/ID]
POST /topups[/ID]                 #
POST /topups/ID/cancel            #From TOPUP.status 'pending' to 'canceled'.
STRIPE.topups.list|retrieve|
 create|update|cancel()           #

TOPUP.amount                    *C#PMONEY
?amount=CMP_FILTER                #

TOPUP.source                     C#SOURCE
                                  #Must be verified BANK_ACCOUNT

TOPUP.status                      #Can be:
                                  #  - 'pending'
                                  #  - 'succeeded' (EVENT 'topup.succeeded')
                                  #  - 'failed' (EVENT 'topup.failed')
                                  #  - 'canceled' (EVENT 'topup.canceled')
                                  #  - 'reversed' (EVENT 'topup.reversed')
?status=STR                       #
TOPUP.expected_availability_date ?#DATE_NUM.
TOPUP.failure_message            ?#STR
TOPUP.failure_code               ?#STR

TOPUP.balance_transaction        ?#BALANCE_TRANSACTION.id

TOPUP.description               CU#STR shown to users.

                                  ┌─────────────┐
                                  │   CONNECT   │
                                  └─────────────┘

ACCOUNT.type                    *C#Can be:
                                  #  - 'standard':
                                  #     - users use normal Stripe Dashboard (more features but more complex)
                                  #     - ACCOUNT:
                                  #        - we cannot create|update ACCOUNT (Stripe+user handle it)
                                  #        - we cannot access ACCOUNT.external_accounts|created|requirements|company|individual nor CARD|BANK_ACCOUNT.account|currency
                                  #     - Stripe handles auth (OAuth)
                                  #     - responsibility for DISPUTE|REFUND|BALANCE: Stripe (if DIRC), us (if DESC|SEPC)
                                  #     - fee: none
                                  #  - 'express':
                                  #     - users use simpler Stripe Dashboard (fewer features but better UX)
                                  #     - ACCOUNT:
                                  #        - we cannot create ACCOUNT but must update ACCOUNT (only business_profile|requested_capabilities|settings|metadata)
                                  #          (Stripe handles most of it)
                                  #        - we cannot access ACCOUNT.company|individual nor CARD|BANK_ACCOUNT.account|currency
                                  #     - Stripe handles auth (OAuth)
                                  #     - responsibility for DISPUTE|REFUND|BALANCE: us
                                  #     - fee: more (see above)
                                  #     - US only (for the moment)
                                  #     - users must have 2FA with SMS on a US phone number
                                  #  - 'custom':
                                  #     - users use our own Dashboard (UX tailored by us)
                                  #     - ACCOUNT:
                                  #        - we must create|update all ACCOUNT.* including:
                                  #           - tos_acceptance
                                  #           - payment information (external_accounts)
                                  #           - settings
                                  #           - "required fields" (company|individual information)
                                  #        - we can access all ACCOUNT.*
                                  #     - we handle auth (no OAuth)
                                  #     - responsibility for DISPUTE|REFUND|BALANCE: us
                                  #     - fee: more (see above)
                                  #For all:
                                  #  - Stripe handles ACCOUNT verification

CHARGES ROUTING ==>               #There are three way to route Connect charges: 'direct charges' (DIRC), 'destination charges' (DESC) and 'separate' (SEPC)
                                  #For all:
                                  #  - source: customer. Can use any payment method
                                  #  - platform: our ACCOUNT in the middle
                                  #  - destination: another ACCOUNT2, authorized to us through OAuth
                                  #Use cases:
                                  #  - DIRC: platform only forwards payments
                                  #  - DESC: platform does more than only forwarding payments
                                  #  - SEPC: more complex routing such as:
                                  #     - TRANSFER done later than CHARGE
                                  #     - 1-n, n-1 or n-n payments
                                  #Recommended ACCOUNT.type:
                                  #  - DIRC: standard
                                  #  - DESC|SEPC: express|custom
                                  #Stripe fees:
                                  #  - DIRC: source for all fees
                                  #  - DESC|SEPC: platform for all fees + additional ones (see above)
                                  #Responsibility for DISPUTE, REFUND and negative BALANCE:
                                  #  - DIRC + ACCOUNT.type 'standard': source
                                  #  - otherwise: platform
                                  #Routing summary:
                                  #  - DIRC:
                                  #     - 1 CHARGE source -> destination
                                  #     - platform not involved except for FEE
                                  #  - DESC:
                                  #     - 1 CHARGE source -> platform
                                  #     - 1 TRANSFER platform -> destination (automatic)
                                  #  - SEPC:
                                  #     - 1-n CHARGE source -> platform
                                  #     - 1-n TRANSFER platform -> destination (manual)
                                  #CHARGE routing:
                                  #  - DIRC: create CHARGE|PINTENT using destination's ACCOUNT2 (OAuth)
                                  #  - DESC: create CHARGE|PINTENT using our ACCOUNT, with transfer_data towards ACCOUNT2
                                  #  - SEPC:
                                  #     - create CHARGE|PINTENT using our ACCOUNT
                                  #     - create TRANSFER from out ACCOUNT to destination's ACCOUNT2
                                  #     - all CHARGEs|PINTENTs|TRANSFERs must specify transfer_group, and use the same one
                                  #     - should create TRANSFERs as fast as possible, and not more than 90 days (for compliance reasons)
                                  #REFUND:
                                  #  - DIRC: create REFUND using destination's ACCOUNT2 (OAuth), with REFUND.refund_application_fee
                                  #  - DESC: create REFUND using our ACCOUNT, with REFUND.refund_application_fee|reverse_transfer
                                  #  - SEPC: create REFUND using our ACCOUNT, with REFUND.reverse_transfer or REVERSAL
                                  #FEE:
                                  #  - all: Stripe fee calculated based on original CHARGE, before application FEE
                                  #  - DIRC: CHARGE|PINTENT.application_fee_amount (creates a FEE)
                                  #  - DESC: either (same financial result):
                                  #     - CHARGE|PINTENT.application_fee_amount: fee is taken by creating a FEE after TRANSFER
                                  #     - TRANSFER_DATA.amount: fee is taken by making TRANSFER amount smaller (with TRANSFER_DATA.amount), no FEE is created
                                  #  - SEPC: fee is taken by making TRANSFER amount smaller, no FEE is created
                                  #CHARGE.on_behalf_of:
                                  #  - DIRC: cannot be defined. Always destination's
                                  #  - DESC|SEPC: can be defined. Defaults to platform's
                                  #CAPABILITY:
                                  #  - DIRC: 'card'
                                  #  - DESC|SEPC: 'platform'
                                  #Restrictions:
                                  #  - SEPC: only when platform's ACCOUNT and destination's ACCOUNT2 are both in US or both in Europe
                                  #Publishable key for Stripe.js:
                                  #  - all: changes which account is used client-side (e.g. when looking up CUSTOMERs)
                                  #  - DIRC: platform|destination
                                  #  - DESC|SEPC: platform

CHARGE.application                #ACCOUNT.id that created the charge. When using DIRC|DESC|SEPC charges
CARD|BANK_ACCOUNT.account         #ACCOUNT.id

CHARGE|PINTENT.transfer_data    CU#TRANSFER_DATA. When using DESC charges
TRANSFER_DATA.amount            CU#PMONEY
TRANSFER_DATA.destination        C#ACCOUNT.id

CHARGE.on_behalf_of              C#ACCOUNT.id
                                  #When using Connect, which ACCOUNT should be used for information like statement_descriptor and currency
                                  #Either platform's or destination's
                                  #Default value depends on whether using DIRC|DESC|SEPC charges routing (see below)

ACCOUNT DEBIT ==>                 #Transferring money from a destination's ACCOUNT2 towards our ACCOUNT.
                                  #Two methods:
                                  #  - CHARGE.source ACCOUNT:
                                  #     - to use for actual service|charge
                                  #     - properly accounted in tax form
                                  #  - TRANSFER using destination's ACCOUNT2 (OAuth) towards our ACCOUNT
                                  #     - to use for corrections
                                  #     - not accounted in tax form
                                  #Both methods are charged higher than normal CHARGE|TRANSFER (see above)
                                  #Restrictions:
                                  #  - only express|custom
                                  #  - ACCOUNTs must both be in US, or both in Europe
                                  #  - must use destination's ACCOUNT default currency

SUBSCRIPTIONS ==>                 #Can make sources pay for SUBSCRIPTIONs of destination's ACCOUNT2 (OAuth).
                                  #SUBSCRIPTION|PLAN|CUSTOMER must be handled while authenticated as ACCOUNT2 (not our ACCOUNT).
                                  #To take a FEE:
                                  #  - either:
                                  #     - SUBSCRIPTION.application_fee_percent: relative
                                  #     - INVOICE.application_fee_amount: absolute
                                  #  - all LINE_ITEMs but have been created with our ACCOUNT

                                  ┌──────────────┐
                                  │   TRANSFER   │
                                  └──────────────┘

TRANSFER                          #Transfer money from current ACCOUNT towards another ACCOUNT2.
                                  #Uses ACCOUNTs BALANCE.
                                  #EVENTs 'transfer.paid|failed'

GET /transfers[/ID]
POST /transfers[/ID]              #
STRIPE.transfers.
 retrieve|list|create|update()    #

TRANSFER.amount                 *C#

TRANSFER.balance_transaction     ?#BALANCE_TRANSACTION.id of source
CHARGE.transfer                   #TRANSFER.id (inverse)
TRANSFER.source_type             C#'card|bank_account'

TRANSFER.destination            *C#ACCOUNT.id
?destination=ACCOUNT.id           #
TRANSFER.destination_payment     ?#CHARGE.id of destination
CHARGE.source_transfer            #TRANSFER.id (inverse)

TRANSFER.transfer_group          C#Unique STR to group several TRANSFERs
?transfer_group=STR               #
CHARGE|PINTENT.transfer_group   CU#
?transfer_group=STR               #
TOPUP.transfer_group             C#

TRANSFER.source_transaction     ?C#CHARGE.id of source
                                  #When defined, both TRANSFER and ACCOUNT's BALANCE_TRANSACTION will be pending until CHARGE completes (success|failure)
                                  #  - otherwise, they are withdrawn right away
                                  #TRANSFER.amount (of all TRANSFERs with same source_transaction) must be <= CHARGE.amount
                                  #Automatically filled as transfer_group
                                  #If CHARGE fails, TRANSFER still happens
                                  #  - should create a TRAVERSAL then
                                  #Alternative is to wait for 'charge.paid' webhook to create TRANSFER:
                                  #  - should be done when payment method is async, since we need to create those webhooks to handle failure anyway

TRANSFER.description            CU#Like CHARGE.*

                                  ┌───────────────────────┐
                                  │   TRANSFER REVERSAL   │
                                  └───────────────────────┘

TRAVERSAL                         #REFUND of a TRANSFER.
                                  #If can do TRANSFER, can do TRAVERSAL (no permission needed from destination).

GET /transfers/ID/reversals[/ID]
POST /transfers/ID/reversals[/ID]
STRIPE.transferReversals.
 list|retrieve|create|update()    #

TRAVERSAL.transfer                #TRANSFER.id

TRAVERSAL.amount                 C#PMONEY (def: entire amount)

TRAVERSAL.source_refund           #REFUND.id
TRAVERSAL.
 destination_payment_refund       #REFUND.id
TRAVERSAL.balance_transaction     #BALANCE_TRANSACTION.id of the refund

TRANSFER.amount_reversed          #Like CHARGE.amount_refunded
TRANSFER.reversed                 #BOOL. Whether has been fully reversed.
                                  #EVENT 'transfer.reversed', even on partial TRAVERSAL.
TRANSFER.reversals                #TRAVERSAL_LIST

TRAVERSAL.description           RC#STR shown in Dashboard.

REFUND.reverse_transfer         RC#BOOL (def: false). Whether should create a TRAVERSAL.
                                  #Only when CHARGE.transfer_data was used.
REFUND.source_transfer_reversal  ?#TRAVERSAL.id if source was ACCOUNT
REFUND.transfer_reversal         ?#TRAVERSAL.id if destination was ACCOUNT

                                  ┌─────────────────────┐
                                  │   APPLICATION FEE   │
                                  └─────────────────────┘

FEE                               #Cut taken by platform ACCOUNT for a CHARGE|TRANSFER from source to destination ACCOUNT2.
                                  #Is in same currency as CHARGE|TRANSFER

GET /application_fees[/ID]        #
STRIPE.applicationFees.
 retrieve|list()                  #

CHARGE|PINTENT.
 application_fee_amount          C#PMONEY
ORDER.application_fee            C#PMONEY
SUBSCRIPTION.
 application_fee_percent        CU#0-100
INVOICE.application_fee_amount  CU#PMONEY
TRANSFER_DATA.amount             C#PMONEY (def: CHARGE.amount)
                                  #If lower than CHARGE.amount, difference is fee.
                                  #Does not create a FEE instance.
                                  #Not supported by PINTENT yet.
FEE.amount                        #PMONEY

CHARGE.application_fee            #FEE.id

FEE.account                       #ACCOUNT.id of destination (paid the fee)
FEE.application                   #ACCOUNT.id of platform (earned the fee)
FEE.originating_transaction       #CHARGE|TRANSFER.id that created the FEE
FEE.charge                        #CHARGE.id of the FEE itself
?charge=CHARGE.id                 #
FEE.balance_transaction           #BALANCE_TRANSACTION.id of the FEE itself

                                  ┌────────────────────────────┐
                                  │   APPLICATION FEE REFUND   │
                                  └────────────────────────────┘

FEE_REFUND                        #REFUND of a FEE.

GET /application_feeds/ID/
 refunds[/ID]
POST /application_feeds/ID/
 refunds[/ID]
STRIPE.applicationFee.retrieve|
 list|create|updateRefund[s]()    #

FEE_REFUND.amount                C#MONEY. Can be partial.

FEE_REFUND.fee                    #FEE.id
FEE_REFUND.balance_transaction    #BALANCE_TRANSACTION.id of the FEE_REFUND itself

TRAVERSAL|REFUND.
 refund_application_fee         RC#BOOL (def: false). Whether should create a FEE_REFUND.
FEE.amount_refunded               #PMONEY.
FEE.refunded                      #BOOL. True if fully refunded.
                                  #EVENT 'application_fee.refunded', even on partial REFUND.
FEE.refunds                       #FEE_REFUND_LIST

                                  ┌───────────┐
                                  │   FRAUD   │
                                  └───────────┘

DISPUTE ==>                       #When a CUSTOMER questions our CHARGE. Also called "chargebacks".
                                  #Possible causes:
                                  #  - they did not authorize it (e.g. done with a stolen card) (most common cause)
                                  #  - they did not receive the product/service
                                  #  - wrong billing (e.g. transaction sent twice to bank)
                                  #  - technical (e.g. expired authorization)

INQUIRIES/RETRIEVALS ==>          #  - DISPUTE early stage where money was not taken from ACCOUNT yet
                                  #  - only done by American Express and Discover, not Mastercard nor Visa
                                  #  - should handle like a normal DISPUTE
                                  #  - status 'warning_needs_response', 'warning_under_review' and either 'warning_closed' or 'charge_refunded'
                                  #     - equivalent of 'needs_response', 'under_review', 'won' or 'lost'

WITHDRAWAL ==>                    #Should always talk to customer, and try to fix the problem and make them withdraw the dispute.
                                  #If customer wants to withdraw, should consider approving dispute and charging them again instead
                                  #  - like this, faster process (no need to wait 10 weeks to settle the dispute)

TYPICAL FRAUDS ==>                #  - stolen cards
                                  #  - overpayment / payout scam:
                                  #     - using a stolen card, make a purchase
                                  #     - then ask seller to make a purchase back (e.g. pay for their favorite freight company)
                                  #     - then cancel first purchase
                                  #  - alternative refunds:
                                  #     - using a stolen card, make a purchase but pays too much
                                  #     - then ask seller to make a refund
                                  #     - then cancel first purchase
                                  #  - marketplace: when running a marketplace and one user pays another, but product/service is not delivered
                                  #  - card testing:
                                  #     - trying a stolen card on a website that allow very small purchases (e.g. donations)
                                  #     - should prevent with CAPTCHAs or rate limiting

SIGNS OF FRAUD ==>                #  - fake information (emails, phone numbers)
                                  #  - different information across purchases (emails, payment methods, shipping|billing addresses, IP)
                                  #  - scripted communication
                                  #     - should google sentences
                                  #  - expensive or very frequent purchases
                                  #  - splitting purchases (including refunds) over several payment methods
                                  #  - asking us to process payment manually (so that IP address / responsability is ours)
                                  #  - amount higher than required
                                  #  - wrong CVC
                                  #  - addresses mismatches
                                  #     - shipping vs billing vs card|bank account's owner (AVS check)
                                  #     - often legitimate (gift purchase), but raise warnings
                                  #  - change of address after purchase
                                  #  - ask for different shipping

AVOIDING DISPUTES ==>             #Billing:
                                  #  - using 3D secure makes us less liable to disputes.
                                  #  - provide a good *.statement_descriptor
                                  #  - send receipts
                                  #  - should always collect: name, email, card CVC, full billing address (including ZIP), shipping address (if different)
                                  #  - use ACCOUNT.settings.card_payments.decline_on.cvc_failure true
                                  #  - do not refund on a different credit card / bank account (to avoid frauds)
                                  #Fraudulent-looking payments:
                                  #  - should delay it:
                                  #     - delay payment by capturing it (CHARGE.capture)
                                  #     - delay shipping by 1-2 days
                                  #  - if already accepted, should refund it
                                  #Identification:
                                  #  - auth with social media accounts or bank services (e.g. BankID)
                                  #Communication:
                                  #  - good communication / customer service
                                  #  - clear refund and cancellation policies
                                  #     - should be agreed on (as part of terms of service)
                                  #     - should be presented in full text (not just link)
                                  #  - reach out to user through the contact information verified by bank
                                  #Shipping:
                                  #  - choose delivery service that:
                                  #     - requires signature on delivery
                                  #     - has good tracking
                                  #  - ship to the exact same address provided by customer
                                  #  - be fast to ship, and communicate delays
                                  #  - save shipping labels
                                  #  - protective packaging

HIGH DISPUTE RATE ==>             #If for one month, for >5000 USD, either:
                                  #  - dispute rate (won or lost) >1% per CHARGE count
                                  #  - dispute rate lost to fraud >8% per CHARGE money, for >10 transactions
                                  #Then:
                                  #  - Stripe (and competitors) might cancel account
                                  #  - Credit card companies might:
                                  #     - charge higher dispute fees
                                  #     - blacklist wth TMFs (Terminated Merchant Files)
                                  #        - MATCH is Mastercard's one and is commonly used
                                  #         - can happen too if:
                                  #            - failing to protect payment method data or comply to PCI
                                  #     - give hefty fines ($10,000 to $100,000)
                                  #Credit card companies have warning programs:
                                  #  - if about to hit threshold, give warnings
                                  #  - then must tell them how we want to fix it
                                  #  - give few months to fix it

                                  ┌─────────────┐
                                  │   DISPUTE   │
                                  └─────────────┘

DASHBOARD ==>                     #Should prefer using the Dashboard instead of API for this.

LIFECYCLE ==>                     #Created by Stripe on CUSTOMER's request
                                  #  - EVENT 'charge.dispute.created'
                                  #  - status 'needs_response'
                                  #Money is taken from ACCOUNT (see pricing):
                                  #  - EVENT 'charge.dispute.funds_withdrawn'
                                  #Should either:
                                  #  - submit DISPUTE.evidence
                                  #     - usually banks only allow one submission.
                                  #     - status 'under_review'
                                  #     - should still submit even if customer withdrew dispute
                                  #     - often takes around 10 weeks to get answer.
                                  #  - "accept" a DISPUTE
                                  #     - i.e. no submission
                                  #Either:
                                  #  - status 'lost'
                                  #  - status 'won'
                                  #     - both CHARGE refund and fee are reversed if bank resolves in favor
                                  #       (which happens only 20-40% of times)
                                  #        - fee is actually charged by credit card company, but reversed by Stripe
                                  #        - EVENT 'charge.dispute.funds_reinstated'
                                  #Email is sent with summary
                                  #  - EVENT 'charge.dispute.closed'

DISPUTE AND REFUNDS ==>           #  - cannot create a REFUND on a disputed CHARGE
                                  #  - cannot create a DISPUTE on a refunded CHARGE
                                  #  - should avoid refunding through a different way than Stripe:
                                  #     - it would allow disputing both the refund and the charge, and losing both

PAYMENT METHOD-SPECIFIC ==>       #  - card*:
                                  #     - provider-specific and reason-specific, but usually 120 days
                                  #     - if 3D secure, cannot be dispute for "not authorized" reasons (but other reasons still possible)
                                  #  - alipay, wechat, klarna: only for problem with quality of goods
                                  #  - 'ach_credit_transfer', 'bancontact', 'eps', 'giropay', 'ideal', 'multibanco', 'p24', 'sofort': no DISPUTE possible
                                  #  - 'sepa_debit':
                                  #     - within 13 weeks
                                  #        - after 8 weeks, only fo authorization/fraud reasons
                                  #     - includes customer-side issues like account frozen or not enough funds
                                  #     - fee a little lower (10 USD instead of 15 USD)
                                  #  - 'ach_debit':
                                  #     - cannot provide EVIDENCE
                                  #     - within 60 days
                                  #  - 'google_pay', 'apply_pay', 'microsoft_pay', 'samsung_pay', 'alipay': yes
                                  #  - 'au_becs_debit':
                                  #     - within 7 years
                                  #     - cannot dispute

GET /disputes[/ID]
POST /disputes/ID                 #
POST /disputes/ID/close           #Change DISPUTE.status from 'needs_response' to 'lost'
STRIPE.disputes.
 retrieve|list|update|close()     #

DISPUTE.charge                    #CHARGE.id
?charge=ID                        #
DISPUTE.payment_intent            #PINTENT.id
?payment_intent=ID                #
CHARGE.disputed                   #BOOL

DISPUTE.amount                    #PMONEY. Disputed amount.
                                  #Usually CHARGE.amount, but could be slightly different because of:
                                  #  - currency fluctuation
                                  #  - only part of charge is disputed
                                  #  - CHARGE was transmitted to bank several times (or similar)
DISPUTE.balance_transactions      #BALANCE_TRANSACTION_ARR of money taken (and potentially eventually reversed) from ACCOUNT.
DISPUTE.is_charge_refundable      #BOOL. True if inquiry/retrieval and can still refund.

DISPUTE.status                    #STR among:
                                  #  - '[warning_]needs_response'
                                  #  - '[warning_]under_review'
                                  #  - 'won', 'lost', 'warning_closed' or 'charge_refunded'
DISPUTE.reason                    #STR given by customer among:
                                  #  - credit_not_processed:
                                  #     - product/service was returned/canceled, but not refund was done
                                  #     - should show that refund was done, or that not eligible for refund
                                  #  - subscription_canceled:
                                  #     - same for subscription
                                  #  - duplicate:
                                  #     - charged multiple times for same product/service
                                  #     - should show that each charge was for different product/service
                                  #  - fraudulent:
                                  #     - did not authorize (e.g. card stolen)
                                  #     - should show customer was the real customer (e.g. IP address, shipping)
                                  #  - product_not_received
                                  #     - product/service was never received
                                  #     - should show product was shipped, or that service was used
                                  #  - product_unacceptable
                                  #     - product defective or not as described
                                  #     - should show product delivered as described at time of purchase
                                  #  - unrecognized: does not recognize payment on bank statement
                                  #  - general: others
                                  #  - bank_cannot_process
                                  #  - check_returned
                                  #  - customer_initiated
                                  #  - debit_not_authorized
                                  #  - incorrect_account_details
                                  #  - insufficient_funds

DISPUTE.submit                  RU#BOOL (def: true). Whether to submit DISPUTE.evidence to the bank.
DISPUTE.evidence_details          #EVIDENCE_DETAILS. Submission information.
EVIDENCE_DETAILS.submission_count #NUM of submissions.
EVIDENCE_DETAILS.has_evidence     #BOOL if DISPUTE.evidence exists.
EVIDENCE_DETAILS.due_by           #DATE_NUM. Deadline to submit. Usually 1-3 weeks.
                                  #null if bank does not allow submitting evidences at all.
EVIDENCE_DETAILS.past_due         #BOOL. True if evidence submission happened after EVIDENCE_DETAILS.due_by.

DISPUTE.evidence                 U#EVIDENCE. Evidence to solve dispute in our favor.
                                  #Best practices for evidences:
                                  #  - self-contained, i.e. no dynamic content nor external links.
                                  #     - include screenshots instead
                                  #  - contain all possible information, but not more.
                                  #     - avoid lengthy explanation.
                                  #     - only include email conversation if relevant, and redact it to only the relevant parts.
                                  #  - neutral tone.
                                  #  - highlight important info
                                  #     - e.g.  arrows, bold font
                                  #     - crop
                                  #  - should be big enough and printable in black/white because sometimes transmitted over fax
                                  #     - >=12 point font size
                                  #     - no colors highlighting
                                  #     - A4 portrait
EVIDENCE.customer_name            #STR
EVIDENCE.customer_email_address   #'EMAIL'
EVIDENCE.customer_purchase_ip     #'IP'
EVIDENCE.customer_signature       #FILE.id.
EVIDENCE.customer_communication   #FILE.id. Any relevant communication with the customer.
                                  #For example, proof customer received or liked the product/service.
EVIDENCE.access_activity_log      #STR. Server logs showing customer accessing the product/service.
                                  #Should include IP addresses, timestamps, and any activity.
EVIDENCE.receipt                  #FILE.id.
EVIDENCE.service_documentation    #FILE.id proving product/service was provided to customer, such as a contract.
EVIDENCE.service_date             #'DATE' (human-readable format) of product/service start.
EVIDENCE.product_description      #STR.
EVIDENCE.billing_address          #STR. The billing address provided by the customer.
EVIDENCE.shipping_address         #STR.
EVIDENCE.shipping_date            #'DATE' (human-readable format)
EVIDENCE.shipping_carrier         #'STR,...'. Delivery services such as 'Fedex' or 'UPS'.
EVIDENCE.shipping_documentation   #FILE.id proving product was shipped. Should show the full shipping address.
EVIDENCE.shipping_tracking_number #'STR,...'
EVIDENCE.refund_policy            #FILE.id. Our subscription refund policy, as shown to the customer.
EVIDENCE.refund_policy_disclosure #STR explaining how/when the refund policy was shown to the customer.
EVIDNCE.refund_refusal_explanation#STR explaning why customer is not entitled to a refund.
EVIDENCE.cancellation_policy      #Same as refund_policy, but for subcription cancellation.
EVIDENCE.
 cancellation_policy_disclosure   #Same as refund_* but for subscription cancellation.
EVIDENCE.cancellation_rebuttal    #STR explaining why the customer's subscription was not canceled.
EVIDENCE.duplicate_charge_id      #STR of previous CHARGE (for a charge disputed as duplicate)
EVIDENCE.
 duplicate_charge_explanation     #STR explaining why a charge is not a duplicate (for a charge disputed as duplicate)
EVIDENCE.                         #FILE.id uniquely identifying the charge, such as a receipt or shipping label.
 duplicate_charge_documentation   #Should be paired with a similar document from the disputed payment that proves the two payments are separate.
EVIDENCE.uncategorized_file       #Any other FILE.id
EVIDENCE.uncategorized_text       #Any other STR.

                                  ┌────────────────────┐
                                  │   CHARGE OUTCOME   │
                                  └────────────────────┘

CHARGE.outcome                    #OUTCOME. Whether payment was accepted.
OUTCOME.type                      #STR among:
                                  #  - 'authorized': success
                                  #  - 'invalid': invalid parameters
                                  #  - 'manual_review': REVIEW was created
                                  #  - 'blocked': Stripe blocked before sending to bank
                                  #  - 'issuer_declined': bank rejected
OUTCOME.network_status            #STR among:
                                  #  - 'approved_by_network': success
                                  #  - 'not_sent_to_network': Stripe blocked before sending to bank (Radar rule or invalid parameters)
                                  #  - 'declined_by_network': bank rejected
                                  #  - 'reversed_after_approval': bank authorized, but Stripe blocked (e.g. Radar rule based on *_check)
OUTCOME.reason                    #STR among:
                                  #  - ERROR.decline_code
                                  #  - 'elevated|highest_risk_level': OUTCOME.risk_level
                                  #  - 'rule': blocked by Radar rule

OUTCOME.risk_score                #'0-100'
                                  #Undefined for non-card payments
OUTCOME.risk_level                #STR among:
                                  #  - 'highest' (75-100)
                                  #  - 'elevated' (50-75)
                                  #  - 'normal' (0-50)
                                  #  - 'not_assessed': non-card payments
                                  #  - 'unknown'
                                  #0-50-75-100 can be customized in Dashboard
OUTCOME.seller_message            #STR. Explanation of OUTCOME.risk_level. Should not be shown to customers.
OUTCOME.rule                      #STR. Custom Radar rule when OUTCOME.reason 'rule'

CHARGE.fraud_details             U#FRAUD_DETAILS. Set either by Stripe (Radar) or us.
FRAUD_DETAILS.stripe_report       #Always 'fraudulent'.
FRAUD_DETAILS.user_report        U#Either 'fraudulent' or 'safe'.

                                  ┌────────────────┐
                                  │   RADAR RULE   │
                                  └────────────────┘

RADAR FROM FRAUD TEAMS ==>        #Additional cost.
                                  #Without it, can only use built-in rules.
                                  #With it, also:
                                  #  - custom rules
                                  #  - REVIEW
                                  #  - risk score
                                  #  - better dashboard

RADAR RULES ==>                   #Rules that automatically handle suspicious CHARGEs:
                                  #  - require 3D secure
                                  #  - allow but create warning (REVIEW)
                                  #  - reject
                                  #Either built-in or custom.
                                  #For Connect, must be set for each ACCOUNT.

RISK SCORE ==>                    #CHARGE.outcome.risk_score|risk_level is automatically set.
                                  #Can be used by Radar rules. Used by some of the built-in rules.
                                  #Uses machine learning:
                                  #  - data comes from:
                                  #     - client behavior:
                                  #        - must use Stripe clients (e.g. Checkout, Stripe elements, etc.)
                                  #        - should include Stripe.js on every page, to monitor whole client behavior
                                  #        - privacy policy should tell users about this data collection (https://stripe.com/docs/radar#requirements)
                                  #     - Stripe other users, i.e. we don't need to train models first
                                  #  - should specify CHARGE.customer for repeated payments
                                  #  - should collect CUSTOMER.name|email|shipping|billing_details

BUILT-IN RADAR RULES ==>          #Enabled by default:
                                  #  - Request 3DS if :risk_level: = 'highest'
                                  #  - Request 3DS if :card_3d_secure_support: = 'required'
                                  #  - Allow if :is_3d_secure_authenticated: and :has_liability_shift:
                                  #  - Block if :risk_level: = 'highest'
                                  #  - Block if :ATTR: in @VAR_blocklist
                                  #  - Block if not :cvc_check:
                                  #Disabled by default:
                                  #  - Request 3DS if :card_3d_secure_support: = 'optional|recommended'
                                  #  - Block if not :address_zip_check:
                                  #  - Review if :risk_level: = 'elevated'
@VAR_blocklist                    #Built-in VALUE_LIST, initially empty.
                                  #VAR is charge_description|card_country|card_bin|card_fingerprint|email|email_domain|client_ip_country|client_ip_address
                                  #Automatically updated:
                                  #  - on CHARGE.fraud_details.user_report 'fraudulent' or REFUND with reason 'fraudulent'
                                  #  - for card_fingerprint|email
                                  #  - including CUSTOMER's other CARDs
                                  #Can also be manually edited.

CUSTOM RADAR RULES ==>            #Must be set in Dashboard.
ACTION if CONDITIONS              #Custom rule syntax
ACTION                            #In priority order:
                                  #  - Request 3DS: require 3D secure
                                  #  - Allow: allow
                                  #  - Block: reject, do not create REVIEW
                                  #  - Review: allow, create REVIEW
CONDITIONS                        #[NOT] CONDITION [AND|OR CONDITON2...]
                                  #Operators are case-insensitive.
                                  #Can use parentheses.
CONDITION                         #Either:
                                  #  - ATTR [OP VALUE], where ATTR can be:
                                  #      :BOOL_ATTR: -> no OP VALUE
                                  #      :STR_ATTR: -> = != 'STR' or IN ('STR',...) or IN @VALUE_LIST
                                  #      :NUM_ATTR: -> = != < <= > >= NUM
                                  #      ::[customer|destination:]ATTR:: -> like STR|NUM_ATTR but using CHARGE|PINTENT|CUSTOMER|ACCOUNT.metadata.ATTR
                                  #  - is_missing(ATTR):
                                  #     - by default rules are false if ATTR value missing
ATTR                              #All STR_ATTR are case-insensitive except card_fingerprint and *_check.
                                  #Available ones:
                                  #  - risk_score NUM: OUTCOME.risk_score
                                  #  - risk_level STR: OUTCOME.risk_level
                                  #  - *_check STR: CARD.*_check
                                  #  - amount_in_CURRENCY PMONEY: CHARGE.amount
                                  #  - is_recurring BOOL: from SUBSCRIPTION
                                  #  - charge_description STR: CHARGE.descrition
                                  #  - STATUS_per_FILTER_number_FREQUENCY NUM: number of CHARGEs on current ACCOUNT for past hour|day for this CARD|CUSTOMER|IP
                                  #    that were successful, declined (by bank) or blocked (by Radar)
                                  #     - number of CHARGEs on current ACCOUNT
                                  #     - STATUS: 'charge_attempts' (started), 'auths' (successful), 'declines' (declined by bank), 'blocks' (by Radar)
                                  #     - FILTER 'card|customer|ip_address': for this CARD|CUSTOMER|IP
                                  #     - FREQUENCY: for past 'hour|day'
                                  #  - is_checkout  BOOL: used Checkout
                                  #  - card_3d_secure_support STR: CARD 3D support among 'required', 'recommended', 'optional', 'not_supported'
                                  #  - is_3d_secure BOOL: payment method can use 3D secure
                                  #  - is_3d_secure_authenticated BOOL: payment method completed 3D secure (including if the bank provided an exemption)
                                  #  - has_liability_shift  BOOL: whether fraud liability is not against us (e.g. after using 3D secure)
                                  #  - card_country COUNTRY: SOURCE.country
                                  #  - card_funding STR: CARD.funding
                                  #  - card_bin STR: Bank Identification Number (BIN), i.e. CARD.number first six digits
                                  #  - card_brand STR: CARD.brand
                                  #  - card_fingerprint STR: CARD.fingerprint
                                  #  - ip_address STR: REVIEW.ip_address
                                  #  - ip_country COUNTRY: REVIEW.ip_address's country
                                  #  - is_my_login_ip BOOL: is yourself
                                  #  - is_anonymous_ip  BOOL: no IP
                                  #  - destination  STR: TRANSFER_DATA.destination
                                  #  - email STR: CHARGE.receipt_email, CUSTOMER.email or inside CHARGE|CUSTOMER.description
                                  #  - email_domain STR: same but domain only
                                  #  - is_disposable_email  BOOL
                                  #  - billing|shipping_address STR: CHARGE.billing_details|shipping
                                  #  - billing|shipping_address_* STR: CHARGE.billing_details|shipping.*

                                  ┌──────────────────────┐
                                  │   RADAR VALUE LIST   │
                                  └──────────────────────┘

VALUE_LIST                        #ENUM constant that can be used in Radar rules (see above)

GET /radar/value_lists[/ID]
POST /radar/value_lists[/ID]
DELETE /radar/value_lists/ID      #
STRIPE.radar.valueLists.
 retrieve|list|create|update|del()#

VALUE_LIST.name                *CU#STR. For display.
VALUE_LIST.alias               *CU#STR. For rules writing.
?alias=STR                        #
VALUE_LIST.item_type             C#One of:
                                  #  - 'card_bin': credit card Bank Identification Number
                                  #  - 'card_fingerprint'
                                  #  - 'country'
                                  #  - 'email'
                                  #  - 'ip_address'
                                  #  - '[case_sensitive_]string': others
VALUE_LIST.list_items             #VALUE_LIST_ITEM_LIST
?contains=STR                     #Filters by VALUE_LIST_ITEM.value
VALUE_LIST.created_by             #STR. User name.

                                  ┌───────────────────────────┐
                                  │   RADAR VALUE LIST ITEM   │
                                  └───────────────────────────┘

VALUE_LIST_ITEM                   #Each VALUE_LIST item

GET /radar/value_list_items[/ID]?
 value_list=ID
POST /radar/value_list_items
DELETE /radar/value_list_items/ID #
STRIPE.radar.valueListItems.
 retrieve|list|create|del()       #

VALUE_LIST_ITEM.value_list      *C#VALUE_LIST.id
VALUE_LIST_ITEM.value           *C#STR
?value=STR                        #
VALUE_LIST_ITEM.created_by        #STR. User name

                                  ┌────────────┐
                                  │   REVIEW   │
                                  └────────────┘

REVIEW                            #CHARGE flagged as suspicious by Radar.
                                  #Those CHARGEs have not been blocked, i.e. they have been processed successfully.
                                  #  - however should REFUND if suspicious

GET /reviews[/ID]
POST /reviews/ID/approve          #Set REVIEW.open to false.
STRIPE.reviews.
 retrieve|list|approve()          #

REVIEW.open                       #BOOL
                                  #EVENT 'review.opened|closed'
REVIEW.reason                     #If REVIEW.open, same as opened_reason. Otherwise same as closed_reason
REVIEW.opened_reason              #Either:
                                  #  - 'rule'
                                  #  - 'manual': through Dashboard
REVIEW.closed_reason             ?#Which action was taken among:
                                  #  - 'approved': nothing
                                  #  - 'refunded': REFUND
                                  #  - 'refunded_as_fraud': REFUND + report to Stripe: only meant to improve their machine learning algorithm
                                  #  - 'disputed': a DISPUTE was created before we take any action
                                  #Only if REVIEW.open false
                                  #Must be updated in Dashboard

REVIEW.charge                     #CHARGE.id
CHARGE.review                     #REVIEW.id
REVIEW.payment_intent             #PINTENT.id
PINTENT.review                    #REVIEW.id

REVIEW.billing_zip               ?#STR. Payment method ZIP code.
REVIEW.ip_address                 #'IP'
REVIEW.ip_address_location        #IP_LOCATION
IP_LOCATION.country               #COUNTRY
IP_LOCATION.region                #STR. State|province|region
IP_LOCATION.city                  #STR
IP_LOCATION.latitude              #FLOAT
IP_LOCATION.longitude             #FLOAT
REVIEW.session                    #REVIEW_SESSION. Payment browser session.
REVIEW_SESSION.browser            #STR (e.g. 'Chrome')
REVIEW_SESSION.version            #STR. Browser version (e.g. '61.0.3163.100')
REVIEW_SESSION.platform           #STR (e.g. 'Macintosh')
REVIEW_SESSION.device             #STR (e.g. 'Samsung SM-G930T')

                                  ┌───────────────────┐
                                  │   FRAUD WARNING   │
                                  └───────────────────┘

FRAUD_WARNING                     #CHARGE flagged as suspiscious by Radar, but outside the rules/REVIEW system.
                                  #Those CHARGEs have not been blocked, i.e. they have been processed successfully.
                                  #  - however should REFUND if suspicious

GET
 /radar/early_fraud_warnings[/ID] #
STRIPE.radar.earlyFraudWarnings.
 list|retrieve()                  #

FRAUD_WARNING.charge              #CHARGE.id
?charge=CHARGE.id                 #
FRAUD_WARNING.fraud_type          #STR among:
                                  #  - 'made_with_stolen_card'
                                  #  - 'made_with_lost_card'
                                  #  - 'made_with_counterfeit_card'
                                  #  - 'unauthorized_use_of_card'
                                  #  - 'fraudulent_card_application'
                                  #  - 'card_never_received'
                                  #  - 'misc'
FRAUD_WARNING.actionable          #BOOL. No DISPUTE|REFUND yet. I.e. can do a REFUND.

                                  ┌───────────┐
                                  │   ORDER   │
                                  └───────────┘

ORDER                             #CHARGE for 1|several SKUs sold to a specific CUSTOMER
                                  #Shipping:
                                  #  - shipping costs to CHARGE
                                  #  - trigger events to notify shipping logic:
                                  #     - including integrations to providers
                                  #     - shipping logic itself is not done by Stripe
                                  #  - including taxes:
                                  #     - can be tricky because country-specific
                                  #     - including integrations to providers
                                  #Checks|updates SKU.inventory
                                  #Checks PRODUCT|SKU.active
                                  #Some attributes can only be updated through custom callback (see below).

GET /orders[/ID]
POST /orders[/ID]                 #
POST /orders/ID/pay               #Create the CHARGE, trying to change status to 'paid'
                                  #Payload: customer, application_fee, email, source
PAYLOAD.source                    #Like CHARGE.source
STRIPE.orders.
 retrieve|list|create|update|pay()#

?ids=ID_ARR                       #
ORDER.charge                     ?#CHARGE.id. Present if status 'paid|fulfilled|refunded'
CHARGE.order                     ?#ORDER.id
ORDER.amount
ORDER.application                 #Like CHARGE.*
ORDER.amount_returned             #Like CHARGE.amount_refunded
ORDER.customer                   C#Like CHARGE.*
?customer=CUSTOMER.id             #
ORDER.email                      C#'EMAIL' of CUSTOMER

ORDER.status                     U#STR among:
                                  #  - 'created'
                                  #  - 'paid' (EVENT 'order.payment_succeeded|failed')
                                  #  - 'canceled': REFUND before shipped
                                  #  - 'fulfilled': paid + shipped
                                  #  - 'returned': REFUND after shipped (RETURN)
?status=STR                       #
ORDER.status_transitions.
 paid|fulfilled|returned|canceled #DATE_NUM
?status_transitions=OBJ_ARR       #OBJ_ARR: canceled|fulfiled|paid|returned CMP_FILTER
ORDER.updated                     #DATE_NUM

ORDER.items                      C#ORDER_ITEM_ARR of type 'sku'

ORDER.returns                     #RETURN_LIST

ORDER.shipping                 ?CU#SHIPPING
ORDER.selected_shipping_method  ?U#Chosen SHIPPING_METHOD.id
                                  #Defaults to first ORDER.shipping_methods
ORDER.shipping_methods           ?#Available SHIPPING_METHOD_ARR
SHIPPING_METHOD.id                #STR
SHIPPING_METHOD.amount            #PMONEY. Shipping cost.
SHIPPING_METHOD.description       #STR to be shown to CUSTOMER
SHIPPING_METHOD.delivery_estimate #DELIVERY_ESTIMATE. Expected delivery time.
DELIVERY_ESTIMATE.type            #Either 'exact' or 'range'
DELIVERY_ESTIMATE.date            #'YYYY-MM-DD'. If type 'exact'.
DELIVERY_ESTIMATE.earliest|latest #'YYYY-MM-DD' If type 'range'.

SHIPPING_METHOD.tax_items         #ORDER_ITEM_ARR of type 'tax'

ORDER.upstream_id                 #STR. Real-life order ID (if different from Stripe's)
?upstream_ids=ID_ARR              #

CHARGE CAPTURING ==>              #Must be done through dashboard among:
                                  #  - no capturing (def)
                                  #  - capture when status 'fulfilled'
                                  #  - must capture manually (with POST /charges/ID/capture)

SHIPPING COSTS ==>                #How 'shipping' ORDER_ITEM are added.
                                  #Must be done through dashboard among:
                                  #  - 'free' (def)
                                  #  - 'flat_rate' with OBJ_ARR:
                                  #     - amount PMONEY
                                  #     - free_above PMONEY
                                  #     - description STR
                                  #  - 'callback' with OBJ: url 'URL' (see below)
                                  #  - 'provider' 'easypost|shippo':
                                  #     - see online doc for how to integrate
                                  #     - must still create an account and do whole logic with them

SHIPPING TAXES ==>                #How 'tax' ORDER_ITEM are added.
                                  #Must be done through dashboard among:
                                  #  - 'included' (def)
                                  #  - 'percentage' with OBJ:
                                  #     - percent 0-1 FLOAT
                                  #     - description STR
                                  #  - 'callback' with OBJ: url 'URL' (see below)
                                  #  - 'provider' 'avalara|taxjar|taxamo':
                                  #     - see online doc for how to integrate
                                  #     - must still create an account and do whole logic with them

SHIPPING CUSTOM LOGIC ==>         #When choosing 'callback', calls URL on ORDER creation.
                                  #PAYLOAD is ORDER
                                  #Need to respond with OBJ:
                                  #  - order_update OBJ:
                                  #     - order_id ORDER.id
                                  #     - ORDER attributes to update: items, shipping_methods, upstream_id, external_coupon_code
                                  #Can respond with 4**|5** with ERROR as payload:
                                  #  - type 'action_failed'
                                  #  - code STR among:
                                  #     - 'product_inactive': PRODUCT.active false
                                  #     - 'sku_inactive': SKU.active false
                                  #     - 'out_of_inventory': out of stock (SKU.inventory)
                                  #     - 'maximum_sku_quantity_exceeded': CUSTOMER ordered more than allowed quantity for this SKU
                                  #     - 'shipping_calculation_failed': could not compute shipping
                                  #     - 'taxes_calculation_failed': could not compute shipping's taxes
                                  #     - 'address_verification_failed': could not verify ORDER.shipping
                                  #     - 'upstream_order_creation_failed': generic error
                                  #  - message STR
                                  #  - param 'VARR':
                                  #     - must be 'items[NUM]' if code '*_inactive', 'out_of_inventory' or 'maximum_sku_quantity_exceeded'

                                  ┌────────────────┐
                                  │   ORDER ITEM   │
                                  └────────────────┘

ORDER_ITEM                        #Either:
                                  #  - 'sku': single SKU of an ORDER (ORDER.items). Max 25 items per ORDER.
                                  #  - 'discount': single DISCOUNT of an ORDER (ORDER.coupon|external_coupon_code)
                                  #  - 'shipping': shipping costs of an ORDER (ORDER.shipping_methods)
                                  #  - 'tax': taxes on SHIPPING_METHOD's of an ORDER (SHIPPING_METHOD.tax_items)

ORDER_ITEM.type                   #One of 'sku', 'discount', 'shipping', 'tax'
ORDER_ITEM.parent                ?#DISCOUNT|SKU|SHIPPING_METHOD.id

ORDER_ITEM.amount                 #PMONEY
ORDER_ITEM.quantity               #INT. Only if type 'sku'
ORDER_ITEM.description            #STR to be shown to CUSTOMER

                                  ┌──────────────────┐
                                  │   ORDER RETURN   │
                                  └──────────────────┘

RETURN                            #REFUND for an ORDER

POST /orders/ID/returns
STRIPE.orders.returnOrder()       #
GET /order_returns[/ID]           #
STRIPE.orderReturns.
 list|retrieve()                  #

RETURN.order                    *C#ORDER.id
?order=ORDER.id                   #
RETURN.items                     C#ORDER_ITEM_ARR (def: all)
RETURN.amount                     #PMONEY
RETURN.refund                     #REFUND.id

                                  ┌─────────┐
                                  │   SKU   │
                                  └─────────┘

SKU                               #Specific variation|packaging of a GOOD_PRODUCT:
                                  #  - fixed quantity, price
                                  #  - other attributes like size, colors, release number

GET /skus[/ID]
POST /skus[/ID]
DELETE /skus/ID                   #
STRIPE.skus.
 list|retrieve|create|update|del()#

?ids=ID_ARR                       #
SKU.product                    *CU#GOOD_PRODUCT.id
?product=PRODUCT.id               #

SKU.price                      *CU#PMONEY

SKU.active                      CU#Overrides GOOD_PRODUCT.*
?active=BOOL                      #

SKU.inventory                  *CU#INVENTORY. Whether SKU is in stock.
INVENTORY.type                  CU#STR among: 'finite' (quantified), 'bucket' (not quantified), 'infinite'.
INVENTORY.quantity              CU#INT. Number available in stock. Only if INVENTORY.type 'finite'
?in_stock=BOOL                    #
INVENTORY.value                 CU#STR among 'in_stock', 'limited', 'out_of_stock'. Only if INVENTORY.type 'bucket'

SKU.package_dimensions          CU#Overrides GOOD_PRODUCT.*
SKU.attributes                  CU#OBJ where:
                                  #  - keys are among GOOD_PRODUCT.attributes
                                  #  - values are STR
?attributes=OBJ                   #
SKU.image                       CU#'URL' to be shown to CUSTOMER

SKU.updated                       #Like GOOD_PRODUCT.*

                                  ┌──────────────────┐
                                  │   ISSUING CARD   │
                                  └──────────────────┘

ISSUING_CARD                      #User-created credit cards.
                                  #Examples: employees expense cards, gift cards.
                                  #Either physical or virtual.

GET /issuing/cards[/ID]
POST /issuing/cards[/ID]          #
STRIPE.issuing.cards.
 retrieve|list|create|update()    #

ISSUING_CARD.currency
ISSUING_CARD.brand
ISSUING_CARD.exp_month
ISSUING_CARD.exp_year
ISSUING_CARD.last4
ISSUING_CARD.name                 #Same as CARD.*
ISSUING_CARD.pin                  #OBJ: status 'blocked|active'
?exp_month=NUM                    #
?exp_year=NUM                     #
?last4=STR                        #
?name=STR                         #
?source=SOURCE.id                 #

ISSUING_CARD.type                C#Either:
                                  #  - 'physical'
                                  #     - shipped by Stripe
                                  #     - supports EMV, contactless payments
                                  #  - 'virtual': through mobile wallet or online payments
?type=STR                         #
ISSUING_CARD.shipping            C#ISSUING_CARD_SHIPPING if type 'physical'
ISSUING_CARD_SHIPPING.*           #Like SHIPPING.*
ISSUING_CARD_SHIPPING.type       C#Either 'individual' or 'bulk' (ship several together)
ISSUING_CARD_SHIPPING.status      #STR among:
                                  #  - 'pending'
                                  #  - 'shipped'
                                  #  - 'delivered'
                                  #  - 'returned', 'failure', 'canceled'
ISSUING_CARD_SHIPPING.tracking_url#'URL'
ISSUING_CARD_SHIPPING.service    C#Can be 'priority', 'express' or 'standard' (def)
ISSUING_CARD_SHIPPING.eta         #DATE_NUM

ISSUING_CARD.cardholder          C#Default CARD_HOLDER
?cardholder=CARD_HOLDER.id        #

ISSUING_CARD.status             CU#STR among:
                                  #  - 'inactive' (def)
                                  #  - 'active'
                                  #  - 'canceled': permanent
                                  #  - 'lost': permanent
                                  #  - 'stolen': permanent
?status=STR                       #

ISSUING_CARD.spending_controls  CU#SPENDING_CONTROLS. Rules to automatically decline AUTHORIZATIONs
SPENDING_CONTROLS.
 spending_limits               RCU#SPENDING_LIMIT_ARR. Max PMONEY per time interval.
SPENDING_LIMIT.amount          RCU#PMONEY
SPENDING_LIMIT.interval        RCU#Frequency among 'per_authorization', 'daily', 'weekly', 'monthly', 'yearly', 'all_time'
SPENDING_LIMIT.categories      RCU#STR_ARR. Whitelist categories.
AUTH_CONTROLS.                  CU#'CATEGORY'_ARR. Either whitelist or blacklist categories.
 allowed|blocked_categories       #'CATEGORY' is the type of industry (MCC). See list at https://stripe.com/docs/issuing/authorizations/categories

ISSUING_CARD.replacement_for    ?C#ISSUING_CARD2.id
                                  #Give same card number as previous one (when possible).
                                  #Should be set for better fraud tracking.
ISSUING_CARD.replaced_by          #ISSUING_CARD.id (inverse)
ISSUING_CARD.replacement_reason ?C#STR among 'damage', 'expiration', 'loss', 'theft'

                                  ┌──────────────────────────┐
                                  │   ISSUING CARD DETAILS   │
                                  └──────────────────────────┘

ISSUING_CARD_DETAILS              #Like ISSUING_CARD (same properties) but with some extra fields:

GET /issuing/cards/ID/details     #
STRIPE.issuing.cards.
 retrieveDetails()                #

ISSUING_CARD_DETAILS.card         #ISSUING_CARD
ISSUING_CARD_DETAILS.number       #'NUM'
ISSUING_CARD_DETAILS.
 cvc|exp_month|exp_year           #Like CARD.*

                                  ┌────────────────────────┐
                                  │   ISSUING CARDHOLDER   │
                                  └────────────────────────┘

CARD_HOLDER                       #User of a ISSUING_CARD
                                  #CARD_HOLDERs can share same ISSUING_CARD

GET /issuing/cardholders[/ID]
POST /issuing/cardholders[/ID]    #
STRIPE.cardholders.
 retrieve|list|create|update()    #

CARD_HOLDER.type                *C#Either 'individual' or 'company'
?type=STR                         #

CARD_HOLDER.email               CU#STR
CARD_HOLDER.phone_number        CU#STR
?phone_number=STR                 #
CARD_HOLDER.billing            *CU#BILL_DETAILS
?email=STR                        #
CARD_HOLDER.company             CU#COMPANY (only fields tax_id|tax_id_provided)
CARD_HOLDER.individual          CU#PERSON (only fields dob|first_name|last_name|verification)

CARD_HOLDER.status              CU#One of:
                                  #  - 'active' (def): can pay
                                  #  - 'inactive': cannot pay yet (e.g. requires extra step to activate)
                                  #  - 'blocked': blocked by Stripe
?status=STR                       #

CARD_HOLDER.requirements         ?#ISSUING_REQUIREMENTS to fill in required fields.
ISSUING_REQUIREMENTS.past_due     #'VARR'_ARR to fill on PERSON.*
ISSUING_REQUIREMENTS.            ?#STR among:
 disabled_reason                  #  - 'rejected.listed': POST /accounts/ID/reject
                                  #  - 'listed': matches a blacklist
                                  #  - 'under_review': Stripe triggered it internally

CARD_HOLDER.spending_controls   CU#SPENDING_CONTROLS, but without max_*

                                  ┌───────────────────────────┐
                                  │   ISSUING AUTHORIZATION   │
                                  └───────────────────────────┘

AUTHORIZATION                     #Pending ISSUING_TRANSACTIONs waiting for approval.
                                  #EVENT 'issuing_authorization.request' is emitted on create
                                  #  - i.e. when user is waiting for payment to be processed
                                  #  - must set AUTHORIZATION.approved within 2 seconds
                                  #  - if no webhook, automatically approved
                                  #     - unless timed out, using timeout specified as Dashboard settings
                                  #Additional 'issuing_authorization.request' EVENTs can then be made to add more money:
                                  #  - only possible for some 'CATEGORY'
                                  #     - e.g. hotels to extend someone's stay
                                  #  - will not go through ISSUING_CARD.spending_controls

GET /authorizations[/ID]
POST /authorizations/ID           #
POST /authorizations/ID/approve   #Set approved to true.
POST /authorizations/ID/decline   #Set approved to false.
STRIPE.issuing.authorizations.
 retrieve|list|update|approve|
 decline()                        #

AUTHORIZATION.card                #ISSUING_CARD
?card=ISSUING_CARD.id             #
AUTHORIZATION.cardholder          #CARD_HOLDER
?cardholder=CARDHOLDER.id         #

AUTHORIZATION.status              #STR among:
                                  #  - 'pending': approved, but not captured
                                  #  - 'closed': approved and captured, or declined
                                  #  - 'reversed': payment error
?status=STR                       #
AUTHORIZATION.approved            #BOOL

AUTHORIZATION.request_history     #REQUEST_HISTORY_ARR. Previous values of AUTHORIZATION.*
REQUEST_HISTORY.reason            #STR among:
                                  #  - 'card_active': worked
                                  #  - 'webhook_approved|declined|timeout': handled by webhook
                                  #  - 'spending_controls': declined by ISSUING_CARD.spending_controls
                                  #  - 'card_inactive': declined because ISSUING_CARD.status 'inactive'
                                  #  - 'insufficient_funds': declined because not enough money
                                  #  - 'account_disabled': declined because ACCOUNT blocked
                                  #  - 'suspected_fraud': declined because fraud
                                  #  - 'verification_failed'
                                  #  - 'cardholder_inactive'
                                  #  - 'cardholder_verification_required'
                                  #  - 'not_allowed'
VAC.entity                        #'account|card|cardholder'
VAC.name                          #'allowed_categories|blocked_categories|max_amount|max_approval|spending_limits'
REQUEST_HISTORY.
 approved|authorized|held*        #Same as AUTHORIZATION.*

AUTHORIZATION.pendingRequest      #PENDING_REQUEST
PENDING_REQUEST.
 is_amount_controllable           #BOOL
AUTHORIZATION|PENDING_REQUEST.
 amount                           #PMONEY
AUTHORIZATION|PENDING_REQUEST.
 merchant_amount                  #PMONEY

AUTHORIZATION.balance_transactions#BALANCE_TRANSACTION_ARR
AUTHORIZATION.transactions        #ISSUING_TRANSACTION_ARR

AUTHORIZATION.merchant_data       #MERCHANT_DATA selling to CARD_HOLDER
MERCHANT_DATA.name                #STR
MERCHANT_DATA.*                   #ADDRESS fields, except line1|line2
MERCHANT_DATA.category            #'CATEGORY'
MERCHANT_DATA.network_id          #'ID' assigned by card brand
MERCHANT_DATA.url                ?#'URL' of the purchase

AUTHORIZATION.merchant_amount     #PMONEY

AUTHORIZATION.authorization_method#STR. How card was used among:
                                  #  - 'online'
                                  #  - 'keyed_in': PIN
                                  #  - 'chip'
                                  #  - 'contactless': Bluetooth/NFC
                                  #  - 'swipe': magnetic stripe
AUTHORIZATION.wallet             ?#One of 'apple_pay', 'google_pay', 'samsung_pay'
AUTHORIZATION.verification_data   #Same as SOURCE.card.*_check, except:
                                  #  - values are 'match', 'mismatch' or 'not_provided'
                                  #  - address_zip_check -> address_postal_code_check
                                  #  - also includes three_d_secure OBJ: result 'attempt_acknowledged|authenticated|failed'
                                  #Should be checked

                                  ┌─────────────────────────┐
                                  │   ISSUING TRANSACTION   │
                                  └─────────────────────────┘

ISSUING_TRANSACTION               #BALANCE_TRANSACTION made with an ISSUING_CARD

GET /issuing/transactions[/ID]
POST /issuing/transactions/ID     #
STRIPE.issuing.transactions.
 retrieve|list|update()           #

ISSUING_TRANSACTION.card          #ISSUING_CARD.id
?card=ISSUING_CARD.id             #
ISSUING_TRANSACTION.cardholder    #CARDHOLDER.id
?cardholder=CARDHOLDER.id         #
ISSUING_TRANSACTION.
 balance_transaction              #BALANCE_TRANSACTION.id
ISSUING_TRANSACTION.authorization #AUTHORIZATION.id
ISSUING_TRANSACTION.merchant_data #Like AUTHORIZATION.merchant_data

ISSUING_TRANSACTION.amount        #MONEY
ISSUING_TRANSACTION.type          #One of:
                                  #  - 'capture': normal payment
                                  #  - 'cash_withdrawal': ATM withdrawal
                                  #  - 'refund[_reversal]'
                                  #  - 'dispute[_loss]'

ISSUING_TRANSACTION.dispute       #ISSUING_DISPUTE.id
?dispute=ISSUING_DISPUTE.id       #

                                  ┌─────────────────────┐
                                  │   ISSUING DISPUTE   │
                                  └─────────────────────┘

ISSUING_DISPUTE                   #Like DISPUTE but for an ISSUING_TRANSACTION
                                  #Made by us against a CARDHOLDER
                                  #Can only submit once.
                                  #Money is only reversed after dispute is won.

GET /issuing/disputes[/ID]
POST /issuing/disputes[/ID]       #
STRIPE.issuing.disputes.
 retrieve|list|create|update()    #

ISSUING_DISPUTE.amount           C#PMONEY
ISSUING_DISPUTE.
 disputed_transaction            C#ISSUING_TRANSACTION.id
?disputed_transaction=ID
ISSUING_DISPUTE.status            #'unsubmitted', 'under_review', 'won' or 'lost'

ISSUING_DISPUTE.reason           C#'duplicate', 'product_not_received', 'fraudulent' or 'other'
ISSUING_DISPUTE.evidence.REASON  C#ISSUING_EVIDENCE
ISSUING_EVIDENCE.
 dispute_explanation             C#STR
ISSUING_EVIDENCE.
 uncategorized_file              C#FILE.id
ISSUING_EVIDENCE.
 original_transaction            C#TRANSACTION.id (only for 'duplicate')

                                  ┌─────────────────────┐
                                  │   TERMINAL READER   │
                                  └─────────────────────┘

READER                            #Physical credit card reader.
                                  #Can be ordered and shipped from Dashboard
                                  #  - Connect ACCOUNTs can do it too
                                  #Client runs on a mobile device:
                                  #  - use JavaScript/iOS/Android SDK to communicate to it
                                  #Are pre-certified by Stripe (PCI, EMV), i.e. no need to do regulation process.

READER TYPES ==>                  #Must be either:
                                  #  - Verifone P400
                                  #     - $299
                                  #     - screen, keys
                                  #     - client must provide UI for operator
                                  #     - can set splash screen through Dashboard settings
                                  #     - size of a big phone
                                  #     - connect through internet
                                  #     - charged to wall, i.e. must be in same place
                                  #     - READER does requests to Stripe
                                  #        - i.e. must have internet connection, either with Ethernet or sharing through USB
                                  #     - updated automatically
                                  #  - BBPOS chipper 2x pt:
                                  #     - $59
                                  #     - no screen, no keys
                                  #     - client must provide UI for operator+customer
                                  #     - no JavaScript SDK (iOS/Android only)
                                  #     - size of 1/3 phone
                                  #     - connect through Bluetooth
                                  #     - charged through USB, i.e. can be moved
                                  #     - client does requests to Stripe
                                  #     - updated manually
                                  #Both allow EMV 1|2|3, swipe and contactless payments.

PAYMENTS ==>                      #Use SOURCE.type 'card_present'
                                  #PINTENT.capture_method must be 'manual', and captured within 24 hours
                                  #Receipts are either:
                                  #  - by email (normal CHARGE.receipt_email)
                                  #  - manually building using SOURCE.card_present.receipt, then printing or emailing ourselves

GET /terminal/readers[/ID]
POST /terminal/readers[/ID]
DELETE /terminal/readers/ID       #
STRIPE.terminal.readers.
 retrieve|list|create|update|del()#

READER.registration_code        *C#STR. Generated by reader to register an ACCOUNT

READER.location                  C#LOCATION.id
?location=LOCATION.id             #

READER.label                    CU#STR. Custom name

READER.device_type                #STR, e.g. 'verifone_P400' or 'bbpos_chipper2x'
?device_type=STR                  #
READER.device_sw_version          #Software 'VERSION'
READER.ip_address                 #'IP'
READER.serial_number              #STR
READER.status                     #STR
?status=STR                       #

                                  ┌───────────────────────┐
                                  │   TERMINAL LOCATION   │
                                  └───────────────────────┘

LOCATION                          #Group of READERS in same place.

GET /terminal/location[/ID]
POST /terminal/location[/ID]
DELETE /terminal/location/ID      #
STRIPE.terminal.locations.
 retrieve|list|create|update|del()#

LOCATION.address               *CU#ADDRESS.
LOCATION.display_name          *CU#STR

                                  ┌───────────────────────────────┐
                                  │   TERMINAL CONNECTION TOKEN   │
                                  └───────────────────────────────┘

CONNECTION_TOKEN                  #Token to authenticate client to READER

POST /terminal/connection_tokens
STRIPE.terminal.connectionTokens.
 create()                         #

CONNECTION_TOKEN.location         #LOCATION.id
CONNECTION_TOKEN.secret           #STR. Your application should pass this token to the Stripe Terminal SDK.

                                  ┌────────────────────┐
                                  │   MONTHLY REPORT   │
                                  └────────────────────┘

MONTHLY REPORT ==>                #Can be downloaded from Dashboard (Settings > Data)
                                  #Contains a summary of ACCOUNT data.
                                  #Either as CSV or as Quickbooks (US accounting software)

                                  ┌───────────┐
                                  │   SIGMA   │
                                  └───────────┘

SIGMA ==>                         #Runs SQL queries against ACCOUNT data.
                                  #Data is not from now but about 3 days ago.
                                  #Dashboard contains some pre-defined SQL queries ('templates')
                                  #Can be shared (from Dashboard).
                                  #Table names are endpoint names:
                                  #  - in plural
                                  #  - with `_metadata` suffix for metadata
                                  #Not all attributes are available.

                                  ┌───────────────────────────┐
                                  │   SIGMA SCHEDULED QUERY   │
                                  └───────────────────────────┘

SCHEDULED_QUERY                   #SQL query that is repeated.
                                  #Frequency must be updated in Dashboard: daily|weekly|monthly
                                  #Automatically emailed: can add|remove email addresses from Dashboard.
                                  #EVENT 'sigma.scheduled_query_run.created' fired on each repetition.

GET /sigma/scheduled_query_runs
 [/ID]                            #
STRIPE.sigma.scheduledQueryRuns.
 retrieve|list()                  #

SCHEDULED_QUERY.sql               #'SQL'

SCHEDULED_QUERY.status            #STR among:
                                  #  - 'completed'
                                  #  - 'canceled', 'failed', 'timed_out'
SCHEDULED_QUERY.error             #SCHEDULED_QUERY_ERROR
SCHEDULED_QUERY_ERROR.message     #STR

SCHEDULED_QUERY.file              #FILE.id. Results as CSV

SCHEDULED_QUERY.data_load_time    #DATE_NUM. When this data was taken (about 3 days ago).
                                  #Can be used inside SQL queries, if need data range.
SCHEDULED_QUERY.
 result_available_until           #DATE_NUM. After that, file cannot be downloaded anymore.

SCHEDULED_QUERY.title             #STR

                                  ┌─────────────────┐
                                  │   REPORT TYPE   │
                                  └─────────────────┘

REPORT_TYPE                       #Specific Sigma tables.
                                  #This is a beta feature, I am not sure how to use this.

GET /reporting/report_types[/ID]
STRIPE.reporting.reportTypes.
  retrieve|list()                 #

REPORT_TYPE.name                  #STR
REPORT_TYPE.version               #NUM
REPORT_TYPE.
 data_available_start|end         #DATE_NUM
REPORT_TYPE.updated               #DATE_NUM
REPORT_TYPE.default_columns       #STR_ARR. Default value for REPORT_RUN_PARAMS.columns

                                  ┌────────────────┐
                                  │   REPORT RUN   │
                                  └────────────────┘

REPORT_RUN                        #Run a REPORT_TYPE and export it as CSV.

GET /reporting/report_runs[/ID]
POST /reporting/report_runs
STRIPE.reporting.reportRuns.
 retrieve|list|create()           #

REPORT_RUN.report_type          *C#REPORT_TYPE.id
REPORT_RUN.status                 #STR among 'pending', 'succeeded', 'failed'
                                  #EVENT 'reporting.report_run.succeeded|failed'
REPORT_RUN.result                 #FILE.id as CSV. Only if status 'succeeded'
REPORT_RUN.succeeded_at           #DATE_NUM when status 'succeeded'
REPORT_RUN.error                 ?#ERROR. Only if status 'failed'
REPORT_RUN.parameters            C#REPORT_RUN_PARAMS
REPORT_RUN_PARAMS.
 interval_start|end              C#DATE_NUM of the data range
REPORT_RUN_PARAMS.
 reporting_category              C#Filter by BALANCE_TRANSACTION.reporting_category.
REPORT_RUN_PARAMS.columns        C#'PROP'_ARR. Add columnes for each of those BALANCE_TRANSACTION.*
REPORT_RUN_PARAMS.
 connected_account               C#ACCOUNT.id (with Connect)
REPORT_RUN_PARAMS.payout          #PAYOUT.id
REPORT_RUN_PARAMS.timezone       C#STR

                                  ┌─────────────────┐
                                  │   STRIPE-NODE   │
                                  └─────────────────┘

VERSION ==>                       #8.39.0

new STRIPE-NODE
 (['API_KEY'][, OPTS])->STRIPE    #

OPTS.apiKey                       #'API_KEY'. Def: none
OPTS.apiVersion                   #'VERSION'. Stripe-Version [C]. Def: none

STRIPE.RESOURCE                   #SRES
SRES.*([PATH_VAL,...]             #Call REST API endpoint.
 DATA_OBJ, OPTS|'API_KEY')        #RESOURCE:
 ->PROMISE                        #  - is camelCase, in plural
                                  #  - can be checkout|issuing|radar|reporting|sigma|terminal.*
                                  #  - e.g. 'radar.valueLists'
                                  #PATH_VAL are URL variables.
                                  #DATA_OBJ:
                                  #  - request payload (including ?PARAM)
                                  #  - DATE are serialized to DATE_NUM
                                  #OPTS:
                                  #  - apiKey|apiVersion
                                  #  - idempotencyKey Idempotency-Key [C]
                                  #  - stripeAccount Stripe-Account [C]
                                  #  - maxNetworkRetries|timeout: see below
                                  #PROMISE either:
                                  #  - resolved with response OBJ, with additional:
                                  #     - lastResponse RES
                                  #        - requestId STR
                                  #  - rejected with ERROR
                                  #Retries on network errors
SRES.create(...)                  #Common method for `POST /`
SRES.list(...)                    #Common method for `GET /`
SRES.retrieve(...)                #Common method for `GET /ID` (URL param 'id')
SRES.update(...)                  #Common method for `POST /ID` (URL param 'id')
SRES.del(...)                     #Common method for `DELETE /ID` (URL param 'id')

STRIPE.on('request', FUNC(OBJ))   #OBJ:
                                  #  - method 'METHOD'
                                  #  - path '/PATH'
                                  #  - account ACCOUNT.id
                                  #  - idempotencyKey STR
                                  #  - apiVersion 'VERSION'
                                  #  - request|response_start_time DATE_NUM
STRIPE.on('response', FUNC(OBJ))  #Like 'request' but also:
                                  #  - status NUM
                                  #  - request_id STR
                                  #  - elapsed NUM (in ms)
                                  #  - request|response_start_time DATE_NUM

OPTS.host                         #'HOST'. Def: 'api.stripe.com'
OPTS.port                         #'PORT'. Def: 443
OPTS.protocol                     #'SCHEME'. Def: 'https'

OPTS.maxNetworkRetries            #NUM (def: 0)
                                  #Retry on 409 (any method) or 5** (not POST)
                                  #If not 0, defaults Idempotency-Key [C] to a UUIDv4
                                  #Uses exponential backoff
OPTS.timeout                      #Def: 80 secs
OPTS.httpAgent                    #Def: AGENT with keepAlive true

User-Agent: Stripe/v1
 NodeBindings/{PACKAG.version} [C]#
X-Stripe-Client-User-Agent:       #Set with analytics. JSON of OBJ:
 JSON [C]                         #  - bindings_version PACKAGE.version
                                  #  - lang 'node'
                                  #  - lang_version: process.version
                                  #  - platform: process.platform
                                  #  - publisher 'stripe'
                                  #  - uname `uname -a`
                                  #  - application APPINFO
OPTS.appInfo                      #APPINFO: name, version, url, partner_id
                                  #Analytics info used in:
                                  #  - User-Agent [C] as 'NAME[/VERSION] [(URL)]' at end
                                  #  - X-Stripe-Client-User-Agent [C]
                                  #Meant for Stripe plugins.
OPTS.typescript                   #BOOL (def: false). Indicates in User-Agent [C] that typescript is used.
OPTS.telemetry                    #BOOL (def: true).
                                  #Send X-Stripe-Client-Telemetry: JSON [C] of OBJ:
                                  #  - last_request_metrics OBJ_ARR:
                                  #     - request_id STR: Request-Id [S]
                                  #     - request_duration_ms NUM

                                  ┌───────────────┐
                                  │   DASHBOARD   │
                                  └───────────────┘

DASHBOARD ==>                     #https://dashboard.stripe.com/dashboard
                                  #Web UI for API
                                  #Some features are only available through Dashboard, not API. They are documented in this doc.

REQUESTS LOGGING ==>              #Shows API requests and Webhooks requests:
                                  #  - count over time (including error rate)
                                  #  - each request's full request/response payload

DATA EXPORT ==>                   #Can export data as CSV.

TEAM MANAGEMENT ==>               #Can assign roles to users to restrict what they can do:
                                  #  - view only
                                  #  - support specialist
                                  #  - analyst: can also view PAYOUTs
                                  #  - developer: can also update ACCOUNT|RADAR settings and view API keys
                                  #  - administrator: can also do team management and update PAYOUT settings and sources

NOTIFICATIONS ==>                 #Can be notified by email on some events (CHARGE, FEE, DISPUTE, WEBHOOK failed, INVOICE incorrect amount, RADAR blocking)

SEARCH FILTERS ==>                #'[-]FILTER ...'
FILTER ==>                        #Either:
                                  #  - 'ATTR:[OP]VALUE'
                                  #     - OP is < or >
                                  #     - VALUE can be NUM..NUM2
                                  #  - other STR: keyword search
ATTR ==>                          #Among:
                                  #  - metadata: RESOURCE.metadata.VAR exists
                                  #  - created|amount|currency|country|email|status: RESOURCE.*
                                  #  - receipt: RESOURCE.receipt_number
                                  #  - risk_level:  CHARGE.outcome.risk_level
                                  #  - name: CUSTOMER|CARDHOLDER.name
                                  #  - postal: ADDRESS.postal_code
                                  #  - flow|type|usage: SOURCE.*
                                  #  - brand|exp|last4: CARD.*
                                  #  - zip: CARD.address_zip
                                  #  - number: INVOICE.number
                                  #Also special attributes:
                                  #  - is: possible VALUE:
                                  #     - charge|coupon|customer|invoice|invoiceitem|payout|plan|transfer: RESOURCE.object
                                  #     - captured: CHARGE.*
                                  #     - disputed: CHARGE with a DISPUTE
                                  #     - paid|refunded: CHARGE|INVOICE.*

                                  ┌───────────────┐
                                  │   FRONT-END   │
                                  └───────────────┘

CSP ==>                           #When used in front-end, must whitelist some *.stripe.com (see online doc).

STRIPE.JS ==>                     #Client-side library.
                                  #Should be loaded from Stripe CDN, not bundled, to remain PCI-compliant.
                                  #Should be on every page, for Radar (see above).

STRIPE ELEMENTS ==>               #Part of Stripe.js
                                  #UI inputs to:
                                  #  - retrieve payment information for several payment methods
                                  #  - translate it into a TOKEN|SOURCE|CARD|BANK_ACCOUNT (doing API calls under hood)
                                  #  - this TOKEN|SOURCE|CARD|BANK_ACCOUNT can then be used, e.g. with POST /charges
                                  #Available as React components too.
                                  #Localized.
                                  #Mobile-friendly.
                                  #Customizable UI.
                                  #Input validation and error handling.
                                  #a11y.
                                  #Browser autofill.
<card>                            #Credit card payment method
<iban>                            #bank_account or sepa_debit payment methods.
                                  #Only EU countries.
                                  #Stripe account must have processed card payments already.
<ideal>                           #iDEAL payment method.
<paymentRequestButton>            #Apple Pay + Google Pay + Microsoft Pay + Payment request API payment methods.
                                  #Hidden if none is supported by browser/device.

MOBILE SDK ==>                    #Like Stripe elements, but for native mobile

STRIPE TERMINAL SDK ==>           #Clients connecting to READERs.
                                  #JavaScript/iOS/Android
                                  #Not documented yet (only document when I need it)

INVOICE WEB PAGE ==>              #INVOICE.hosted_invoice_url is 'URL' where users can pay.
                                  #Send to them by email

STRIPE CHECKOUT ==>               #Full payment forms/flow (including Stripe elements).

                                  ┌──────────────┐
                                  │   CHECKOUT   │
                                  └──────────────┘

SESSION                           #Checkout session

GET /checkout/sessions/ID
POST /checkout/sessions           #
STRIPE.checkout.sessions.
 retrieve|create()                #

checkout.session.completed        #'EVENT_TYPE' when a Checkout Session has been successfully completed.
SESSION.success_url             *C#'URL' to redirect client after successful CHARGE
SESSION.cancel_url              *C#'URL' to redirect client if cancel SESSION
SESSION.client_reference_id      C#string A unique string to reference the Checkout Session.
                                  #This can be a customer ID, a cart ID, or similar.
                                  #It is included in the checkout.session.completed webhook and can be used to fulfill the purchase.
SESSION.customer                 C#CUSTOMER.id
SESSION.customer_email           C#string The email address used to create the customer object.
SESSION.display_items             #DISPLAY_ITEM_ARR The line items, plans, or SKUs that were purchased by the customer.
DISPLAY_ITEM.amount               #PMONEY
DISPLAY_ITEM.quantity             #NUM
DISPLAY_ITEM.type                 #STR, including 'custom'
DISPLAY_ITEM.custom               #OBJ metadata
SESSION.line_items              RC#LINE_ITEM_ARR:
                                  #  - only amount, quantity, description
                                  #  - also attributes: name STR, images 'URL'_ARR
SESSION.locale                   C#string The IETF language tag of the locale Checkout is displayed in. If blank or auto, the browser's locale is used.
SESSION.payment_intent            #PINTENT.id Only if SKUs or line items were provided.
SESSION.payment_intent_data      C#PINTENT with only: application_fee_amount, capture_method, description, on_behalf_of, receipt_email, shipping, statement_descriptor, transfer_data
SESSION.payment_method_types    *C#STR_ARR The list of payment method types (e.g. card) that this Checkout Session is allowed to use.
SESSION.subscription              #SUBSCRIPTION.id Only if one or more plans were provided.
SESSION.subscription_data        C#SUBSCRIPTION with only trial_end, trial_period_days, items SUBSCRIPTION_ITEM_ARR (with only plan|quantity)
SESSION.                        *C#Specify whether Checkout should collect the customer's billing address.
 billing_address_collection       #If set to required, Checkout will always collect the customer's billing address.
                                  #If left blank or set to auto Checkout will only collect the billing address when necessary.
